--[[
################################################################################
# 
# Copyright (c) 2014-2019 Ultraschall (http://ultraschall.fm)
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# 
################################################################################
]]

-------------------------------------
--- ULTRASCHALL - API - FUNCTIONS ---
-------------------------------------

if type(ultraschall)~="table" then 
  -- update buildnumber and add ultraschall as a table, when programming within this file
  local retval, string = reaper.BR_Win32_GetPrivateProfileString("Ultraschall-Api-Build", "Functions-Build", "", reaper.GetResourcePath().."/UserPlugins/ultraschall_api/IniFiles/ultraschall_api.ini")
  local retval, string2 = reaper.BR_Win32_GetPrivateProfileString("Ultraschall-Api-Build", "API-Build", "", reaper.GetResourcePath().."/UserPlugins/ultraschall_api/IniFiles/ultraschall_api.ini")
  if string=="" then string=10000 
  else 
    string=tonumber(string) 
    string=string+1
  end
  if string2=="" then string2=10000 
  else 
    string2=tonumber(string2)
    string2=string2+1
  end 
  reaper.BR_Win32_WritePrivateProfileString("Ultraschall-Api-Build", "Functions-Build", string, reaper.GetResourcePath().."/UserPlugins/ultraschall_api/IniFiles/ultraschall_api.ini")
  reaper.BR_Win32_WritePrivateProfileString("Ultraschall-Api-Build", "API-Build", string2, reaper.GetResourcePath().."/UserPlugins/ultraschall_api/IniFiles/ultraschall_api.ini")  
  ultraschall={} 
end

-- deprecated stuff
  runcommand = ultraschall.RunCommand
  Msg=ultraschall.Msg
---

ultraschall.ErrorCounter=0
ultraschall.StartTime=os.clock()
ultraschall.ErrorMessage={}

-- HoHoHo
ultraschall.snowB=os.date("*t")

ultraschall.snowtodaysdate=ultraschall.snowB.day.."."..ultraschall.snowB.month
ultraschall.snowoldgfx=gfx.update

ultraschall.temp,ultraschall.tempfilename=reaper.get_action_context()

ultraschall.Dump, ultraschall.ScriptFileName=reaper.get_action_context()

if ultraschall.tempfilename:match("ultraschall_startscreen.lua")~=nil and 
    (ultraschall.snowtodaysdate=="24.12" or 
     ultraschall.snowtodaysdate=="25.12" or 
     ultraschall.snowtodaysdate=="26.12") then
  ultraschall.snowoldgfx=gfx.update
  function gfx.update()
    if ultraschall.US_snowmain~=nil then ultraschall.US_snowmain() end
    ultraschall.snowoldgfx()
  end      
end
--gfx.init()

-- initial values
ultraschall.snowspeed=1.3       -- the falling speed of the snowflakes
ultraschall.snowsnowfactor=5000 -- the number of snowflakes
ultraschall.snowwindfactor=3    -- the amount the wind influences the snow; wind has an effect sideways and on the falling-speed. 
                                -- Don't set too high(>100), will look ugly otherwise. Rather experimental, than a real wind simulation...

-- let's create some basic shapes to blit as snowflakes for:
-- close snowflakes
gfx.setimgdim(200,1,1)
gfx.dest=200
gfx.set(0.5,0.5,0.5)
gfx.rect(0,0,1,1)
-- medium snowflakes
gfx.setimgdim(400,1,1)
gfx.dest=400
gfx.set(0.3,0.3,0.3)
gfx.rect(0,0,1,1)
-- small and far snowflakes
gfx.setimgdim(401,1,1)
gfx.dest=401
gfx.set(0.2,0.2,0.2)
gfx.rect(0,0,1,1)


-- set framebuffer to the shown one
gfx.dest=-1

-- Let's create an initial set of snowflakes
ultraschall.snowSnowflakes={}
for a=1, ultraschall.snowsnowfactor do
  -- random x-position
  -- random y-position
  -- speed(which I also use as size-factor) and
  -- another speed-factor(useful? Don't know...)
  if gfx.w==0 then ultraschall.snowwidth=1000 else ultraschall.snowwidth=gfx.w end
  if gfx.h==0 then ultraschall.snowheight=500 else ultraschall.snowheight=gfx.h end
  ultraschall.snowSnowflakes[a]={math.random(1,ultraschall.snowwidth),math.random(-1500,0),math.random()*2,(math.random()/4)*math.random(-1,1)}
  if ultraschall.snowSnowflakes[a][3]<0.4 then ultraschall.snowSnowflakes[a][3]=ultraschall.snowSnowflakes[a][3]*2 end
end
  

-- Let's create a table, that is meant to influence the fall of the snowflakes, as wind would do.
-- For laziness, I simply choose a sinus-wave to create it
-- this could be improved much much more...
  ultraschall.snowwind=-3.6  
  ultraschall.snowWindtable={}
  for windcounter=0, ultraschall.snowsnowfactor do
   ultraschall.snowwind=(ultraschall.snowwind+ultraschall.snowwindfactor*.001)--/(speed*2)
   if ultraschall.snowwind>3.6 then ultraschall.snowwind=-3.6 end
   ultraschall.snowWindtable[windcounter]=math.sin(windcounter)-(math.random()/2)*ultraschall.snowwindfactor
  end

ultraschall.snowwindoffset=1

--if GUI==nil then GUI={} end
function ultraschall.US_snowmain()
  -- set sky to gray  
  gfx.clear=0--reaper.ColorToNative(15,15,15)
  local RUN=0
  local RUN_STOP=0
  
  for i=1, ultraschall.snowsnowfactor do  
    -- let's do the calculation of the falling of the snow
    gfx.x=ultraschall.snowSnowflakes[i][1]
    gfx.y=ultraschall.snowSnowflakes[i][2]+1

    -- if a snowflake hasn't left the bottom of the window, do
    if ultraschall.snowSnowflakes[i][2]<gfx.h then
      local RUN=RUN+1
      ultraschall.snowwindoffset=ultraschall.snowwindoffset+1
      if ultraschall.snowwindoffset>ultraschall.snowsnowfactor then ultraschall.snowwindoffset=1 end
      
      -- calculate the movement toward the bottom, influenced by speed and wind
      ultraschall.snowTemp=ultraschall.snowSnowflakes[i][2]+(ultraschall.snowSnowflakes[i][3]*ultraschall.snowspeed)-(ultraschall.snowWindtable[ultraschall.snowwindoffset]/4*ultraschall.snowSnowflakes[i][4])
      if ultraschall.snowTemp>=ultraschall.snowSnowflakes[i][2] then ultraschall.snowSnowflakes[i][2]=ultraschall.snowTemp end -- prevent backwards flying snow
      -- calculate the movement toward left/right, influenced by wind
      ultraschall.snowSnowflakes[i][1]=ultraschall.snowSnowflakes[i][1]+(ultraschall.snowSnowflakes[i][4]+ultraschall.snowWindtable[ultraschall.snowwindoffset]/4*ultraschall.snowSnowflakes[i][4])
      
      
      -- let's blit the snowflakes with their different sizes and colors
      
      if ultraschall.snowSnowflakes[i][3]>0.4 then 
        -- big snowflakes, close and bright
        gfx.blit(200,1.1*ultraschall.snowSnowflakes[i][3],0)      
      elseif ultraschall.snowSnowflakes[i][3]<0.3 and ultraschall.snowSnowflakes[i][3]>0.1 then
        -- medium snowflakes, normal and darker
        gfx.blit(401,1.1,0)      
      else
        -- small snowflakes, dark
        gfx.blit(400,0.7,0)
      end

    elseif gfx.h~=0 then
      local RUN_STOP=RUN_STOP+1 -- just a debug-variable to see, how many are newly created

      -- When Snowflake has left the bottom of the window, create a new one
      -- this is like the initial creation of snowflakes, but unlike there, we make the y-position 0 here
      if gfx.w==0 then ultraschall.snowwidth=1000 else ultraschall.snowwidth=gfx.w end
      if gfx.h==0 then ultraschall.snowheight=3000 else ultraschall.snowheight=gfx.h end
      ultraschall.snowSnowflakes[i]={math.random(1,ultraschall.snowwidth),0,math.random()*2,(math.random()/2)*math.random(-1,1)}
    end
  end

  -- update gfx and start all over again
--  gfx.update()
--  if gfx.getchar()~=-1 then reaper.defer(ultraschall.US_snowmain) end
end

ultraschall.US_snowmain()
  if ultraschall.US_snowmain~=nil then ultraschall.US_snowmain() end
--end

gfx.x=0
gfx.y=0
gfx.r=1
gfx.g=1
gfx.b=1
--back2business
if reaper.GetOS() == "Win32" or reaper.GetOS() == "Win64" then
    -- user_folder = buf --"C:\\Users\\[username]" -- need to be test
    ultraschall.Separator = "\\"
  else
    -- user_folder = "/USERS/[username]" -- Mac OS. Not tested on Linux.
    ultraschall.Separator = "/"
  end
  --ultraschall.info = debug.getinfo(1,'S');
  ultraschall.Script_Path = reaper.GetResourcePath().."/Scripts/"-- ultraschall.info.source:match[[^@?(.*[\/])[^\/]-$]]
  local script_path = reaper.GetResourcePath().."/UserPlugins/ultraschall_api"..ultraschall.Separator
  ultraschall.Api_Path=script_path
  ultraschall.Api_Path=string.gsub(ultraschall.Api_Path,"\\","/")
  ultraschall.Api_InstallPath=reaper.GetResourcePath().."/UserPlugins/"
--]]  

function ultraschall.GetEnvelopeStateChunk(TrackEnvelope, str, isundo, usesws)
  return reaper.GetEnvelopeStateChunk(TrackEnvelope, "", false)
end

--A=reaper.GetTrackEnvelope(reaper.GetTrack(0,1),0)
--B,C,D=ultraschall.GetEnvelopeStateChunk(A, "", true, true)

function print2(...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>print2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>print2(parameter_1 to parameter_n)</functioncall>
  <description>
    replaces Lua's own print-function. 
    
    Converts all parametes given into string using tostring() and displays them as a MessageBox, separated by two spaces.
  </description>
  <parameters>
    parameter_1 to parameter_n - the parameters, that you want to have printed out
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, print, messagebox</tags>
</US_DocBloc>
]]

  local string=""
  local count=1
  local temp={...}
  while temp[count]~=nil do
    string=string.."  "..tostring(temp[count])
    count=count+1
  end
  reaper.MB(string:sub(3,-1),"Print",0)
end

--print("Hula","Hoop",reaper.GetTrack(0,0))
--print("tudel")

function print(...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>print</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>print(parameter_1 to parameter_n)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    replaces Lua's own print-function, that is quite useless in Reaper.
    
    Converts all parametes given into string using tostring() and displays them in the ReaScript-console, separated by two spaces, ending with a newline.
  </description>
  <parameters>
    parameter_1 to parameter_n - the parameters, that you want to have printed out
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, print, console</tags>
</US_DocBloc>
]]

  local string=""
  local count=1
  local temp={...}
  while temp[count]~=nil do
    string=string.."  "..tostring(temp[count])
    count=count+1
  end
  if string:sub(-1,-1)=="\n" then string=string:sub(1,-2) end
  reaper.ShowConsoleMsg(string:sub(3,-1).."\n","Print",0)
end

--print2("Hula","Hoop",reaper.GetTrack(0,0))
--print("tudel")


function ultraschall.AddErrorMessage(functionname, parametername, errormessage, errorcode)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer errorcount = ultraschall.AddErrorMessage(string functionname, string parametername, string errormessage, integer errorcode)</functioncall>
  <description>
    Adds a new errormessage to the Ultraschall-Api-Error-messagesystem. Returns the number of the errormessage.
    Intended for your own 3rd party-functions for the API, to give the user more feedback about errors than just a cryptic errorcode.
    
    returns false in case of failure
  </description>
  <parameters>
    string functionname - the function, where the error happened
    string parametername - the parameter, that caused the problem
    string errormessage - a longer description of what cause the problem and a hint to a possible solution
    integer errorcode - a number, that represents the error-message. Will be -1 by default, if not given.
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
    integer errorcount - the number of the errormessage within the Ultraschall-Api-Error-messagesystem
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, add, message</tags>
</US_DocBloc>
]]
  -- check parameters
  if functionname==nil or errormessage==nil then a=false functionname="ultraschall.AddErrorMessage" errormessage="functionname or errormessage is nil. Must contain valid value instead!" end
  ultraschall.ErrorCounter=ultraschall.ErrorCounter+1
  if parametername==nil then parametername="" end
  if type(errorcode)~="number" then errorcode=-1 end
  
  -- let's create the new errormessage
  local ErrorMessage={}
  ErrorMessage["funcname"]=functionname
  ErrorMessage["errmsg"]=errormessage
  ErrorMessage["readstate"]="unread"
  ErrorMessage["date"]=os.date()
  ErrorMessage["time"]=os.time()
  ErrorMessage["parmname"]=parametername
  ErrorMessage["errcode"]=errorcode
  
  -- add it to the error-message-system
  ultraschall.ErrorMessage[ultraschall.ErrorCounter]=ErrorMessage
  
  if ultraschall.ShowErrorInReaScriptConsole==true then print("Function: "..functionname.."\n   Parameter: "..parametername.."\n   Error: "..errorcode.." - \""..errormessage.."\"\n   Errortime: "..ErrorMessage["date"].."\n") end
  
  -- terminate script with Lua-errormessage
  if ultraschall.IDEerror==true then error(functionname..":"..errormessage,3) end
  if a==false then return false
  else return true, ultraschall.ErrorCounter
  end
end


function ultraschall.GetTrackStateChunk(MediaTrack, str, isundo, usesws)
  return reaper.GetTrackStateChunk(MediaTrack, "", false)
end

--A=reaper.GetTrack(0,0)
--L,M,N=ultraschall.GetTrackStateChunk(A,"", false, false)
--T=M:len()



function ultraschall.CountCharacterInString(checkstring, character)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountCharacterInString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array positions = ultraschall.CountCharacterInString(string checkstring, string character)</functioncall>
  <description>
    Counts, how often character appears in checkstring and returns the count, as well as a array an with the position-numbers.
    
    returns -1 in case of error
  </description>
  <parameters>
    string checkstring - the string to check search through
    string character - the character to search for. Only single characters are allowed. Controlcodes like \n \t count as single character. Case sensitive.
  </parameters>
  <retvals>
    integer count - the number of occurences of character in checkstring
    array positions - the positionnumbers of the character in checkstring
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, string, character, check, find, count, position, numbers</tags>
</US_DocBloc>
]]
  if type(checkstring)~="string" then ultraschall.AddErrorMessage("CountCharacterInString", "checkstring", "only strings allowed as parameter", -1) return -1 end
  if type(character)~="string" or character:len()>1 then ultraschall.AddErrorMessage("CountCharacterInString", "character", "only a string with one(!) character allowed", -2) return -1 end
  local count=0
  local countarray={}
  for i=1,checkstring:len() do
    if checkstring:sub(0+i,0+i)==character then count=count+1 countarray[count]=i end
  end
  return count, countarray
end

function ultraschall.malformedpatternhelper(patstring)
  local A="Tudelu"
  A:match(patstring)
end

--ultraschall.malformedpatternhelper("")

function ultraschall.IsValidMatchingPattern(patstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidMatchingPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidMatchingPattern(string patstring)</functioncall>
  <description>
    Returns, if patstring is a valid pattern-matching-string
  </description>
  <retvals>
    boolean retval - true, patstring is a valid pattern-matching-string; false, patstring isn't a valid pattern-matching-string
  </retvals>
  <parameters>
    string patstring - the string to check for, if it's a valid pattern-matching-string
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, pattern, string, check, valid, matching</tags>
</US_DocBloc>
]]
  local A=pcall(ultraschall.malformedpatternhelper,patstring)
  return A
end

--C=ultraschall.IsValidMatchPattern()

function ultraschall.GetTrackStateChunk_Tracknumber(tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackStateChunk_Tracknumber</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string trackstatechunk, boolean overflow = ultraschall.GetTrackStateChunk_Tracknumber(integer tracknumber)</functioncall>
  <description>
    returns the trackstatechunk for track tracknumber
    
    returns false in case of an error
  </description>
  <parameters>
    integer tracknumber - the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.    
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of error
    string trackstatechunk - the trackstatechunk for track tracknumber
  </retvals>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstatechunk, get</tags>
</US_DocBloc>
]]
  -- prepare variables
  local Track, A, AA, Overflow
  
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackStateChunk_Tracknumber","tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackStateChunk_Tracknumber","tracknumber", "only tracknumbers allowed between 0(master), 1(track1) and "..reaper.CountTracks(0).."(last track in this project)", -2) return false end
  
  -- Get Mastertrack, if tracknumber=0
  if tracknumber==0 then Track=reaper.GetMasterTrack(0)
  else Track=reaper.GetTrack(0,tracknumber-1)
  end

  return reaper.GetTrackStateChunk(Track, "", false)
end

--A,B,C=ultraschall.GetTrackStateChunk_Tracknumber(2,true)
--reaper.ShowConsoleMsg(B)


function ultraschall.IsValidMediaItemStateChunk(itemstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidMediaItemStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidMediaItemStateChunk(string MediaItemStateChunk)</functioncall>
  <description>
    Checks, whether MediaItemStateChunk is a valide MediaItemStateChunk.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, MediaItemStateChunk is valid; false, MediaItemStateChunk isn't a valid statechunk
  </retvals>
  <parameters>
    string MediaItemStateChunk - the string to check, if it's a valid MediaItemStateChunk
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, check, mediaitemstatechunk, valid</tags>
</US_DocBloc>
]]
  if type(itemstatechunk)~="string" then ultraschall.AddErrorMessage("IsValidMediaItemStateChunk", "itemstatechunk", "Must be a string.", -1) return false end  
  itemstatechunk=itemstatechunk:match("<ITEM.*%c>\n")
  if itemstatechunk==nil then return false end
  local count1=ultraschall.CountCharacterInString(itemstatechunk, "<")
  local count2=ultraschall.CountCharacterInString(itemstatechunk, ">")
  if count1~=count2 then return false end
  return true
end

--s,sc=reaper.GetItemStateChunk(reaper.GetMediaItem(0,0),"",false)
--reaper.MB(sc.."LOL","",0)
--A,B=ultraschall.IsValidMediaItemStateChunk("Tohuwabohu")

function ultraschall.CheckMediaItemArray(MediaItemArray)
--checks, if MediaItemArray is a valid array.
-- throws out all invalid table-entries
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, array retMediaItemArray = ultraschall.CheckMediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Checks, whether MediaItemArray is valid.
    It throws out all entries, that are not MediaItems and returns the altered array as result.
    
    returns false in case of error or if it is not a valid MediaItemArray
  </description>
  <parameters>
    array MediaItemArray - a MediaItemArray that shall be checked for validity
  </parameters>
  <retvals>
    boolean retval - returns true if MediaItemArray is valid, false if not
    integer count - the number of entries in the returned retMediaItemArray
    array retMediaItemArray - the, possibly, altered MediaItemArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, check</tags>
</US_DocBloc>
]]
  if type(MediaItemArray)~="table" then ultraschall.AddErrorMessage("CheckMediaItemArray", "MediaItemArray", "Only array with MediaItemObjects as entries is allowed.", -1) return false,0,{} end
  local count=1
  while MediaItemArray[count]~=nil do
    if reaper.ValidatePtr(MediaItemArray[count],"MediaItem*")==false then table.remove(MediaItemArray,count)
    else
      count=count+1
    end
  end
  if count==1 then return false, count-1, MediaItemArray
  else return true, count-1, MediaItemArray
  end
end

function ultraschall.IsValidMediaItemArray(MediaItemArray)
--checks, if MediaItemArray is a valid array.
-- throws out all invalid table-entries
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, array retMediaItemArray = ultraschall.IsValidMediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Checks, whether MediaItemArray is valid.
    It throws out all entries, that are not MediaItems and returns the altered array as result.
    
    returns false in case of error or if it is not a valid MediaItemArray
  </description>
  <parameters>
    array MediaItemArray - a MediaItemArray that shall be checked for validity
  </parameters>
  <retvals>
    boolean retval - returns true if MediaItemArray is valid, false if not
    integer count - the number of entries in the returned retMediaItemArray
    array retMediaItemArray - the, possibly, altered MediaItemArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, check</tags>
</US_DocBloc>
]]
  if type(MediaItemArray)~="table" then ultraschall.AddErrorMessage("IsValidMediaItemArray", "MediaItemArray", "Only array with MediaItemObjects as entries is allowed.", -1) return false,0,{} end
  local count=1
  while MediaItemArray[count]~=nil do
    if reaper.ValidatePtr(MediaItemArray[count],"MediaItem*")==false then table.remove(MediaItemArray,count)
    else
      count=count+1
    end
  end
  if count==1 then return false, count-1, MediaItemArray
  else return true, count-1, MediaItemArray
  end
end

function ultraschall.CheckMediaItemStateChunkArray(MediaItemStateChunkArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckMediaItemStateChunkArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, array retMediaItemStateChunkArray = ultraschall.CheckMediaItemStateChunkArray(array MediaItemStateChunkArray)</functioncall>
  <description>
    Checks, whether MediaItemStateChunkArray is valid.
    It throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.
    
    returns false in case of error or if it is not a valid MediaItemStateChunkArray
  </description>
  <parameters>
    array MediaItemStateChunkArray - a MediaItemStateChunkArray that shall be checked for validity
  </parameters>
  <retvals>
    boolean retval - returns true if MediaItemStateChunkArray is valid, false if not
    integer count - the number of entries in the returned retMediaItemStateChunkArray
    array retMediaItemStateChunkArray - the, possibly, altered MediaItemStateChunkArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, chunk, check</tags>
</US_DocBloc>
]]
--checks, if MediaItemStateChunkArray is a valid array.
-- throws out all invalid table-entries
  if type(MediaItemStateChunkArray)~="table" then ultraschall.AddErrorMessage("CheckMediaItemStateChunkArray", "MediaItemStateChunkArray", "Only array with MediaItemStateChunks as entries allowed.", -1) return false end
  local count=1
  while MediaItemStateChunkArray[count]~=nil do
    if type(MediaItemStateChunkArray[count])~="string" or MediaItemStateChunkArray[count]:match("<ITEM.*>")==nil then table.remove(MediaItemStateChunkArray,count)
    else
      count=count+1
    end
  end
  if count==1 then return false
  else return true, count-1, MediaItemStateChunkArray
  end
end

function ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidMediaItemStateChunkArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, array retMediaItemStateChunkArray = ultraschall.IsValidMediaItemStateChunkArray(array MediaItemStateChunkArray)</functioncall>
  <description>
    Checks, whether MediaItemStateChunkArray is valid.
    It throws out all entries, that are not MediaItemStateChunks and returns the altered array as result.
    
    returns false in case of error or if it is not a valid MediaItemStateChunkArray
  </description>
  <parameters>
    array MediaItemStateChunkArray - a MediaItemStateChunkArray that shall be checked for validity
  </parameters>
  <retvals>
    boolean retval - returns true if MediaItemStateChunkArray is valid, false if not
    integer count - the number of entries in the returned retMediaItemStateChunkArray
    array retMediaItemStateChunkArray - the, possibly, altered MediaItemStateChunkArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, chunk, check</tags>
</US_DocBloc>
]]
  local retval, errcode, functionname, parmname, errormessage, lastreadtime, err_creation_date, err_creation_timestamp, errorcounter0 = ultraschall.GetLastErrorMessage()
  local retval, count, retMediaItemStateChunkArray = ultraschall.CheckMediaItemStateChunkArray(MediaItemStateChunkArray)
  local retval, errcode, functionname, parmname, errormessage, lastreadtime, err_creation_date, err_creation_timestamp, errorcounter = ultraschall.GetLastErrorMessage() 
  if errorcounter0~=errorcounter and functionname=="CheckMediaItemStateChunkArray" then ultraschall.AddErrorMessage("IsValidMediaItemStateChunkArray",parmname, errormessage, errcode) return false end
  return retval, count, retMediaItemStateChunkArray
end


function ultraschall.CSV2IndividualLinesAsArray(csv_line,separator)
-- converts a csv to an array with all individual values without the ,-separators as well as
-- the number of entries in the array(beginning with 1)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CSV2IndividualLinesAsArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array individual_values = ultraschall.CSV2IndividualLinesAsArray(string csv_line, optional string separator)</functioncall>
  <description>
    convert a csv-string to an array of the individual values. If separator cannot be found, it'll return the original string
    
    returns nil in case or error
  </description>
  <retvals>
    integer count - the number of entries
    array individual_values  - all values, each in an individual array-position
  </retvals>
  <parameters>
    string csv_line - a string as a csv, with all values included and separated by parameter separator
    string separator - the separator, that separates the individual entries; use nil for commas; separators will be removed from the final strings!
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>notes,csv,converter,string,array</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(csv_line)~="string" then ultraschall.AddErrorMessage("CSV2IndividualLinesAsArray","csv_line", "only string is allowed", -1) return -1 end
  if separator==nil then separator="," end

  -- set variables
  local count=1
  local line_array={}

  -- small workaround
  csv_line=csv_line..separator

  -- do the patternmatching-magic
  for line in csv_line:gmatch("(.-)"..separator) do
    line_array[count]=line
    count=count+1
  end

  return count-1, line_array
end

--B,BB=ultraschall.CSV2IndividualLinesAsArray("wuddel,duddel", nil)

function ultraschall.IsValidTrackString(trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidTrackString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean valid, integer count, array individual_tracknumbers = ultraschall.IsValidTrackString(string trackstring)</functioncall>
  <description>
    checks, whether a given trackstring is a valid one. Will also return all valid numbers, from trackstring, that can be used as tracknumbers, as an array.
  </description>
  <retvals>
    boolean valid - true, is a valid trackstring; false, is not a valid trackstring
    integer count - the number of entries found in trackstring
    array individual_tracknumbers - an array that contains all available tracknumbers
  </retvals>
  <parameters>
    string trackstring - the trackstring to check, if it's a valid one
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, check, valid</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(trackstring)~="string" then ultraschall.AddErrorMessage("IsValidTrackString","trackstring", "Must be a string!", -1) return false end
  local count, individual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local found=true
  if individual_values==nil then ultraschall.AddErrorMessage("IsValidTrackString","trackstring", "Has no tracknumbers in it!", -1) return false end

  -- check the individual trackstring-entries and throw out all invalid-entries
  for i=count, 1, -1 do
    individual_values[i]=tonumber(individual_values[i])
    if individual_values[i]==nil then table.remove(individual_values,i) count=count-1 found=false end
  end
  
  -- sort it and return it
  table.sort(individual_values) 
  return found, count, individual_values
end

--A,B,C,D,E=ultraschall.IsValidTrackString("1,4,3")
--A,B,C,D,E=ultraschall.IsValidTrackString("1,1,2,99,l,8,4")

function ultraschall.CountProjectTabs()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountProjectTabs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_projecttabs = ultraschall.CountProjectTabs()</functioncall>
  <description>
    Counts the number of opened project tabs.
  </description>
  <retvals>
    integer number_of_projecttabs - the number of projecttabs currently opened
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, projectfiles, count, projecttab</tags>
</US_DocBloc>
]]
  local ProjCount=-1
  local Aretval="t"
  while Aretval~=nil do
    local Aretval, Aprojfn = reaper.EnumProjects(ProjCount+1, "")
    if Aretval~=nil then ProjCount=ProjCount+1
    else break
    end
  end
  return ProjCount+1
end


--A=ultraschall.CountProjectTabs()

function ultraschall.GetProject_Tabs()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Tabs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_projecttabs, array projecttablist = ultraschall.GetProject_Tabs()</functioncall>
  <description>
    Returns the ReaProject-objects, as well as the filenames of all opened project-tabs.
  </description>
  <retvals>
    integer number_of_projecttabs - the number of projecttabs currently opened
    array projecttablist - an array, that holds all ReaProjects as well as the projectfilenames
                         - projecttablist[idx][1] = ReaProject
                         - projecttablist[idx][2] = projectfilename with path
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, projectfiles, count, projecttab, project, filename</tags>
</US_DocBloc>
]]
  local ProjTabList={}
  local CountProj=ultraschall.CountProjectTabs()
  for i=1, CountProj do
    ProjTabList[i]={}
    ProjTabList[i][1], ProjTabList[i][2] = reaper.EnumProjects(i-1, "")
  end  
  return CountProj, ProjTabList
end

  ultraschall.tempCount, ultraschall.tempProjects = ultraschall.GetProject_Tabs()
  if ultraschall.ProjectList==nil then 
    ultraschall.ProjectList=Projects ultraschall.ProjectCount=ultraschall.tempCount
  end
  

--ultraschall.IDEerror=true


--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>StartTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.StartTime</functioncall>
  <description>
    Contains the correct starting time of the current instance of the Ultraschall-Framework, which probably means your script, that embeds the framework.
  </description>
  <chapter_context>
    API-Variables
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, variable, starttime</tags>
</US_DocBloc>
]]


--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Euro</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.Euro</functioncall>
  <description>
    Holds the Euro-currency-symbol, which is hard to type in Reaper's own IDE.
  </description>
  <chapter_context>
    API-Variables
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, variable, euro, currency, symbol</tags>
</US_DocBloc>
]]


-- Note for myself: the function ApiTest isn't defined in here, but rather in UserPlugins/ultraschall_api.lua
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApiTest</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.ApiTest()</functioncall>
  <description>
    Displays a message to show, which parts of the Ultraschall-API are turned on and which are turned off.
  </description>
  <chapter_context>
    Developer
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>help,api,test, developer</tags>
</US_DocBloc>
--]]


function ultraschall.IsValidTrackStateChunk(statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidTrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean valid = ultraschall.IsValidTrackStateChunk(string TrackStateChunk)</functioncall>
  <description>
    returns, if a TrackStateChunk is a valid statechunk
  </description>
  <parameters>
    string TrackStateChunk - a string to check, if it's a valid TrackStateChunk
  </parameters>
  <retvals>
    boolean valid - true, if the string is a valid statechunk; false, if not a valid statechunk
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, check, validity, track, statechunk, valid</tags>
</US_DocBloc>
--]]
  if type(statechunk)~="string" then ultraschall.AddErrorMessage("IsValidTrackStateChunk","statechunk", "must be a string", -1) return false end
  if statechunk:match("<TRACK.*>\n$")~=nil then return true end
  return false
end

function ultraschall.IsValidEnvStateChunk(statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidEnvStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean valid = ultraschall.IsValidEnvStateChunk(string EnvelopeStateChunk)</functioncall>
  <description>
    returns, if a EnvelopeStateChunk is a valid statechunk
  </description>
  <parameters>
    string EnvelopeStateChunk - a string to check, if it's a valid EnvelopeStateChunk
  </parameters>
  <retvals>
    boolean valid - true, if the string is a valid statechunk; false, if not a valid statechunk
  </retvals>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, check, validity, envelope, statechunk, valid</tags>
</US_DocBloc>
--]]
  if type(statechunk)~="string" then ultraschall.AddErrorMessage("IsValidEnvStateChunk","statechunk", "must be a string", -1) return false end
  if statechunk:match("<.-ENV.-\n.*>\n$")~=nil then return true end
  return false
end

function ultraschall.GetStringFromClipboard_SWS()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetStringFromClipboard_SWS</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>string clipboard_string = ultraschall.GetStringFromClipboard_SWS()</functioncall>
  <description>
    Returns the content of the clipboard as a string. Uses the SWS-function reaper.CF_GetClipboard, but does everything for you, that is needed for proper use of this function.
  </description>
  <retvals>
    string clipboard_string - the content of the clipboard as a string
  </retvals>
  <chapter_context>
    Clipboard Functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>copy and paste, clipboard, sws</tags>
</US_DocBloc>
]]
-- gets a big string from clipboard, using the 
-- CF_GetClipboardBig-function from SWS
-- and deals with all aspects necessary, that
-- surround using it.
  local buf = reaper.CF_GetClipboard(buf)
  local WDL_FastString=reaper.SNM_CreateFastString("HudelDudel")
  local clipboardstring=reaper.CF_GetClipboardBig(WDL_FastString)
  reaper.SNM_DeleteFastString(WDL_FastString)
  return clipboardstring
end


function ultraschall.IsValidItemStateChunk(itemstatechunk)
  if type(itemstatechunk)~="string" then ultraschall.AddErrorMessage("IsValidItemStateChunk", "itemstatechunk", "Must be a string.", -1) return false end  
  itemstatechunk=itemstatechunk:match("<ITEM.*%c>\n")
  if itemstatechunk==nil then return false end
  local count1=ultraschall.CountCharacterInString(itemstatechunk, "<")
  local count2=ultraschall.CountCharacterInString(itemstatechunk, ">")
  if count1~=count2 then return false end
  return true
end
--_l,sc=reaper.GetItemStateChunk(reaper.GetMediaItem(0,0),"",false)
--A=ultraschall.IsValidItemStateChunk(sc,"",false)


function ultraschall.ToggleIDE_Errormessages(togglevalue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleIDE_Errormessages</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ToggleIDE_Errormessages(optional boolean togglevalue)</functioncall>
  <description>
    Toggles or sets, if the error-messaging system shall output it's errors to Reaper's IDE(true) or not(false).
    When set true, it will show the errormessages at the bottom of the IDE, as you are used by Reaper's own functions.
  </description>
  <parameters>
    optional boolean togglevalue - true, if errormessages shall be shown at the bottom of the IDE, false if not. If omitted, it toggles what was set before.
  </parameters>
  <retvals>
    boolean retval - true, if errors will be shown at the bottom of the IDE; false, if not
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, toggle, message, ide</tags>
</US_DocBloc>
]]
  -- sets ultraschall.IDEerror to true or false(dependend on parameter togglevalue)  
  if togglevalue==true or togglevalue==false then ultraschall.IDEerror=togglevalue
  else
    if ultraschall.IDEerror==true then ultraschall.IDEerror=false
    else ultraschall.IDEerror=true
    end
  end
  -- return new ultraschall.IDEerror-setting
  return ultraschall.IDEerror
end


--L=ultraschall.ToggleIDE_Errormessages()
--A,B=ultraschall.AddErrorMessage("functionname","tudelu")
--M=ultraschall.ToggleIDE_Errormessages()
--A,B=ultraschall.AddErrorMessage("functionname","HeckMeck in ZeckMeck")
--A,B=ultraschall.AddErrorMessage("functionname","HeckMeck in ZeckMeck")
--A,B=ultraschall.AddErrorMessage("functionname","HeckMeck in ZeckMeck")
--reaper.MB(ultraschall.ErrorMessage[ultraschall.ErrorCounter][3],"",0)

function ultraschall.ReadErrorMessage(errornumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer errcode, string functionname, string parmname, string errormessage, string lastreadtime, string err_creation_date, string err_creation_timestamp = ultraschall.ReadErrorMessage(integer errornumber)</functioncall>
  <description>
    Reads an error-message within the Ultraschall-ErrorMessagesystem.
    Returns a boolean value, the functionname, the errormessage, the "you've already read this message"-status, the date and a timestamp of the creation of the errormessage.
    returns false in case of failure
  </description>
  <parameters>
    integer errornumber - the number of the error, beginning with 1. Use <a href="#CountErrorMessages">CountErrorMessages</a> to get the current number of error-messages.
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
    integer errcode - the errorcode of this message, as set by the function that created this errormessage; -1 is default value
    string functionname - the name of the function, where the problem happened
    string parmname - the parameter, that was used wrong by the programmer; "" if no parameter was involved in this error
    string errormessage - the message of the problem with a possible hint to a solution
    string readstatus - "unread" if the message hasn't been read yet or a date_time from when the message has been read already
    string err_creation_date - the date_time of when the error-message was created
    string err_creation_timestamp - the timestamp of when the error-message was created. Usually seconds, since system got started
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, get, message</tags>
</US_DocBloc>
]]
  -- check parameters
  
  if math.type(errornumber)~="integer" then ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value, must be an integer", -1) return false end
  if errornumber<1 or errornumber>ultraschall.ErrorCounter then ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "no such error-message. Use ultraschall.CountErrorMessages() to find out the number of messages available.", -2) return false end

  -- set readstate
  local readstate=ultraschall.ErrorMessage[errornumber]["readstate"] 
  ultraschall.ErrorMessage[errornumber]["readstate"]=os.date()
  
  --return values
  return true, ultraschall.ErrorMessage[errornumber]["errcode"],
               ultraschall.ErrorMessage[errornumber]["funcname"],
               ultraschall.ErrorMessage[errornumber]["parmname"],
               ultraschall.ErrorMessage[errornumber]["errmsg"],
               readstate,
               ultraschall.ErrorMessage[errornumber]["date"],
               ultraschall.ErrorMessage[errornumber]["time"]
end


function ultraschall.DeleteErrorMessage(errornumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteErrorMessage(integer errornumber)</functioncall>
  <description>
    Deletes an error-message within the Ultraschall-ErrorMessagesystem.

    returns false in case of failure
  </description>
  <parameters>
    integer errornumber - the number of the error to delete, beginning with 1. Use <a href="#CountErrorMessages">CountErrorMessages</a> to get the current number of error-messages.
  </parameters>
  <retvals>
    boolean retval - true, if such an error exists; false if it didn't
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, delete, message</tags>
</US_DocBloc>
]]
  if math.type(errornumber)~="integer" then ultraschall.AddErrorMessage("DeleteErrorMessage","errornumber", "not a valid value, must be an integer", -1) return false end
  if errornumber<1 or errornumber>ultraschall.ErrorCounter then ultraschall.AddErrorMessage("DeleteErrorMessage","errornumber", "no such error-message. Use ultraschall.CountErrorMessages() to find out the number of messages available.", -2) return false end
  ultraschall.ErrorMessage[errornumber]=nil
  ultraschall.ErrorCounter=ultraschall.ErrorCounter-1
  return true
end


--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -1)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -2)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -3)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -4)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -5)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -6)
--ultraschall.AddErrorMessage("ReadErrorMessage","errornumber", "not a valid value", -7)
--us=ultraschall.ErrorMessage
--C1,D1,E1,F1,G1,H1,I1,J1,K1=ultraschall.ReadErrorMessage(1)
--A=ultraschall.DeleteErrorMessage(0)
--A=ultraschall.DeleteErrorMessage(1)

function ultraschall.GetLastErrorMessage()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer errcode, string functionname, string parmname, string errormessage, string lastreadtime, string err_creation_date, string err_creation_timestamp, integer errorcounter = ultraschall.GetLastErrorMessage()</functioncall>
  <description>
    Reads the last error-message stored in the Ultraschall-ErrorMessagesystem.
    Returns a boolean value, the functionname, the errormessage, the date and a timestamp of the creation of the errormessage, the unread-status as well as the error-message-number.
    returns false in case of failure
  </description>
  <parameters>
    integer errornumber - the number of the error, beginning with 1. Use <a href="#CountErrorMessages">CountErrorMessages</a> to get the current number of error-messages.
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
    integer errcode - the errorcode of this message, as set by the function that created this errormessage; -1 is default value
    string functionname - the name of the function, where the problem happened
    string parmname - the parameter, that was used wrong by the programmer; "" if no parameter was involved in this error
    string errormessage - the message of the problem with a possible hint to a solution
    string readstatus - "unread" if the message hasn't been read yet or a date_time from when the message has been read already
    string err_creation_date - the date_time of when the error-message was created
    string err_creation_timestamp - the timestamp of when the error-message was created. Usually seconds, since system got started
    integer errorcounter - the error-message-number within the Ultraschall-Error-Message-System
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, get, message</tags>
</US_DocBloc>
]]
  if ultraschall.ErrorCounter==0 then return false end --ultraschall.AddErrorMessage("GetLastErrorMessage","","No Error Message available!",-1) return false end
  local errornumber=ultraschall.ErrorCounter
  local readstate=ultraschall.ErrorMessage[errornumber]["readstate"]
  ultraschall.ErrorMessage[ultraschall.ErrorCounter]["readstate"]=os.date()
  
  return true, ultraschall.ErrorMessage[errornumber]["errcode"],
                 ultraschall.ErrorMessage[errornumber]["funcname"],
                 ultraschall.ErrorMessage[errornumber]["parmname"],
                 ultraschall.ErrorMessage[errornumber]["errmsg"],
                 readstate,
                 ultraschall.ErrorMessage[errornumber]["date"],
                 ultraschall.ErrorMessage[errornumber]["time"],
                 ultraschall.ErrorCounter
end

--L=ultraschall.ToggleIDE_Errormessages(false)
--S,T,U,V,W,X,Y,Z,ZZ,ZZZ = ultraschall.GetLastErrorMessage()
--S,T,U,V,W,X = ultraschall.GetLastErrorMessage()
--S,T,U,V,W,X = ultraschall.GetLastErrorMessage()


function ultraschall.DeleteLastErrorMessage()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteLastErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteLastErrorMessage()</functioncall>
  <description>
    Deletes the last error-message and returns a boolean value.
    returns false in case of failure
  </description>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, delete, message</tags>
</US_DocBloc>
]]
  if ultraschall.ErrorCounter==0 then ultraschall.AddErrorMessage("DeleteLastErrorMessage","","No Error Message available!",-1) return false
  else
    ultraschall.ErrorMessage[ultraschall.ErrorCounter]=nil
    ultraschall.ErrorCounter=ultraschall.ErrorCounter-1
    return true
  end
end


--S,T,U,V,W,X = ultraschall.GetLastErrorMessage()
--S,T,U,V,W,X = ultraschall.GetLastErrorMessage()
--ultraschall.AddErrorMessage("Hula","Bula")
--A=ultraschall.DeleteLastErrorMessage()
--A=ultraschall.DeleteLastErrorMessage()
--ultraschall.AddErrorMessage("dings","dongs")
--S1,T1,U1,V1,W1,X1 = ultraschall.GetLastErrorMessage()
--

function ultraschall.DeleteAllErrorMessages()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteAllErrorMessages</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteAllErrorMessages()</functioncall>
  <description>
    Deletes all error-messages and returns a boolean value.
    returns false in case of failure
  </description>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, delete, message</tags>
</US_DocBloc>
]]
  if ultraschall.ErrorCounter==0 then ultraschall.AddErrorMessage("DeleteAllErrorMessages","","No Error Message available!",-1) return false
  else
    ultraschall.ErrorCounter=0
    ultraschall.ErrorMessage={}
    return true
  end
end

--ultraschall.AddErrorMessage("dings","dongs")
--ultraschall.AddErrorMessage("dings","dongs")
--ultraschall.AddErrorMessage("dings","dongs")
--reaper.MB(ultraschall.ErrorCounter,"",0)
--ultraschall.AddErrorMessage("dings","dongs")
--ultraschall.DeleteAllErrorMessages()
--reaper.MB(ultraschall.ErrorMessage[1][1],"",0)


-- Nacharbeiten der Fehlercodes und des Auseinanderklamsern des Parameters.
-- Warum hab ich das nicht schon vorher gemacht?

function ultraschall.GetLastErrorMessage2(count,setread)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastErrorMessage2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array ErrorMessages = ultraschall.GetLastErrorMessage2(integer count, boolean setread)</functioncall>
  <description>
    Returns an array with the last "count" errormessages. 1 for the last, 2 for the last 2, etc.
    Set setread to false, if you want to retain the unread status of the error-messages.
    returns false in case of failure
  </description>
  <parameters>
    integer count - the number of the last few errors, you want to get returned. Use <a href="#CountErrorMessages">CountErrorMessages</a> to get the current number of error-messages.
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
    array ErrorMessages - an array, that contains all values for the chosen number of errormessages.
    -The fields are ErrorMessages[errornumber][x], where x stands for
    -"errcode" - the errorcode of this function, default is -1 
    -"funcname" - functionname
    -"parmname" - name of the parameter, that caused the error
    -"errmsg" - errormessage
    -"readstate" - readstatus
    -"date" - errorcreation date_time
    -"time" - errorcreation timestamp in seconds, usually seconds since computer has been started
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, get, message</tags>
</US_DocBloc>
]]
  -- check parameters
  if math.type(count)~="integer" then ultraschall.AddErrorMessage("GetLastErrorMessage2","count", "not a valid value, must be an integer", -1) return false end
  if count<1 or count>ultraschall.ErrorCounter then ultraschall.AddErrorMessage("GetLastErrorMessage2","count", "higher than available errormessages or lower than 1. Use ultraschall.CountErrorMessages() to find out the number of messages available.", -2) return false end
  if setread~=true and setread~=false then ultraschall.AddErrorMessage("GetLastErrorMessage2","setread", "only true or false allowed", -3) return false end
  
  -- create table atable
  local atable={}
  
  -- get all requested errormessages and put them into the table atable
  for i=1, count do
    local ErrorMessage={}
    ErrorMessage["errcode"]=ultraschall.ErrorMessage[i]["errcode"]
    ErrorMessage["funcname"]=ultraschall.ErrorMessage[i]["funcname"]
    ErrorMessage["parmname"]=ultraschall.ErrorMessage[i]["parmname"]
    ErrorMessage["errmsg"]=ultraschall.ErrorMessage[i]["errmsg"]
    ErrorMessage["readstate"]=ultraschall.ErrorMessage[i]["readstate"]
    ErrorMessage["date"]=ultraschall.ErrorMessage[i]["date"]
    ErrorMessage["time"]=ultraschall.ErrorMessage[i]["time"]
    
    -- if setread is set to true, set the readstate to the readdate
    if setread==true then ultraschall.ErrorMessage[i]["readstate"]=os.date() end
    atable[i]=ErrorMessage
  end
  
  -- return the result
  return true, atable
end

--Y,YY,YYY=ultraschall.GetLastErrorMessage(-1,true)
--ultraschall.AddErrorMessage("tudelu","parmesan","faultyfawlty",-3)

--Y,YY,YYY=ultraschall.GetLastErrorMessage2(2,true)
--Y,YY,YYY=ultraschall.GetLastErrorMessage2(2,true)

--Y2,YY2,YYY2=ultraschall.GetLastErrorMessage(-1,true)

--reaper.MB(LL[1],"",0)

--  ultraschall.ToggleIDE_Errormessages(false)
--  S,T,U,V = ultraschall.GetLastErrorMessage2("1","lula")


function ultraschall.CountErrorMessages()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountErrorMessages</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer errorcounter = ultraschall.CountErrorMessages()</functioncall>
  <description>
    Returns the current count of errormessages in the system available.
  </description>
  <retvals>
    integer errorcounter - the number of errormessages currently available in the error-message-system. Includes read and unread ones.
  </retvals>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, count, message</tags>
</US_DocBloc>
]]
  return ultraschall.ErrorCounter
end

function ultraschall.ShowLastErrorMessage()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ShowLastErrorMessage</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.ShowLastErrorMessage()</functioncall>
  <description>
    Displays the last error message in a messagebox, if existing and unread.
  </description>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, show, message</tags>
</US_DocBloc>
--]]
  -- get the error-information
  local retval, errcode, functionname, parmname, errormessage, lastreadtime, err_creation_date, err_creation_timestamp, errorcounter = ultraschall.GetLastErrorMessage()
  
  -- if errormessage exists and message is unread
  if retval==true and lastreadtime=="unread" then 
    if parmname~="" then 
      -- if error-causing-parameter was given, display this message
      parmname="param: "..parmname 
      reaper.MB(functionname.."\n\n"..parmname.."\nerror  : "..errormessage.."\n\nerrcode: "..errcode,"Ultraschall Api Error Message",0) 
    else
      -- if no error-causing-parameter was given, display that message
      reaper.MB(functionname.."\n\nerror  : "..errormessage.."\n\nerrcode: "..errcode,"Ultraschall Api Error Message",0) 
    end
  end
end

--ultraschall.AddErrorMessage("Hallelujah","integer techtelmechtel","mag nur bekuschelt werden",-69)
--ultraschall.ShowLastErrorMessage()
--ultraschall.ShowLastErrorMessage()


--------------------------------------------------
------ ULTRASCHALL FRAMEWORK 4.00 BETA 1 ---------
--------------------------------------------------

---------------------------
---- US Little Helpers ----
---------------------------

function ultraschall.ConvertColor(r,g,b)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer colorvalue, boolean retval = ultraschall.ConvertColor(integer r, integer g, integer b)</functioncall>
  <description>
    converts r, g, b-values to native-system-color. Works like reaper's ColorToNative, but doesn't need |0x1000000 added.
    
    returns color-value 0, and retval=false in case of an error
  </description>
  <retvals>
    integer colorvalue - the native-system-color; 0 to 33554431
  </retvals>
  <parameters>
    integer r - the red colorvalue
    integer g - the green colorvalue
    integer b - the blue colorvalue
  </parameters>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, color, native, convert, red, gree, blue</tags>
</US_DocBloc>
]]
    if math.type(r)~="integer" then ultraschall.AddErrorMessage("ConvertColor","r", "only integer allowed", -1) return 0, false end
    if math.type(g)~="integer" then ultraschall.AddErrorMessage("ConvertColor","g", "only integer allowed", -2) return 0, false end
    if math.type(b)~="integer" then ultraschall.AddErrorMessage("ConvertColor","b", "only integer allowed", -3) return 0, false end
    return reaper.ColorToNative(r,g,b)|0x1000000, true
end

--ultraschall.ConvertColor(9,9,9.9)

function ultraschall.ConvertColorReverse(color)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorReverse</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer r, integer g, integer b, boolean retval = ultraschall.ConvertColorReverse(integer colorvalue)</functioncall>
  <description>
    converts a native-system-color to r, g, b-values.
    
    returns 0,0,0,false in case of an error
  </description>
  <retvals>
    integer r - the red colorvalue
    integer g - the green colorvalue
    integer b - the blue colorvalue
    boolean retval - true, color-conversion was successful; false, color-conversion was unsuccessful
  </retvals>
  <parameters>
    integer colorvalue - the native-system-color; 0 to 33554431
  </parameters>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, color, native, convert, red, gree, blue</tags>
</US_DocBloc>
]]
    if math.type(color)~="integer" then ultraschall.AddErrorMessage("ConvertColorReverse", "color", "only integer allowed", -1) return  0, 0, 0, false end
    if color<0 or color>33554431 then ultraschall.AddErrorMessage("ConvertColorReverse", "color", "must be between 0 and 33554431", -2) return  0, 0, 0, false end
    
    local a,b,c=reaper.ColorFromNative(color)
    return a,b,c, true
end
--O=reaper.ColorToNative(255,255,255)|0x1000000
--P=ultraschall.ConvertColor(255,255,255)
--reaper.CF_SetClipboard(O)
--L,LL,LLL,LLLL=ultraschall.ConvertColorReverse(999)


function ultraschall.RoundNumber(num)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RoundNumber</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.RoundNumber(number num)</functioncall>
  <description>
    returns a rounded value of the parameter number. %.5 and higher rounds up, lower than %.5 round down.
  </description>
  <retvals>
    integer retval  - the rounded number
  </retvals>
  <parameters>
    number num - the floatingpoint number, you'd like to have rounded.
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>number, rounding</tags>
</US_DocBloc>
--]]
    -- check parameters  
    if type(num)~="number" then ultraschall.AddErrorMessage("RoundNumber","number", "only a number allowed", -1) return nil end
    
    -- do the math
    return num % 1 >= 0.5 and math.ceil(num) or math.floor(num)
end

--A=ultraschall.RoundNumber("9.1")

function ultraschall.ApiFunctionTest()
  ultraschall.functions_works="on"
end





function ultraschall.GetPartialString(str,sep1,sep2)
-- returns the part of a string between sep1 and sep2
--
-- str-string to be processed
-- sep1 - separator on the "left" side of the string
-- sep2 - separator on the "right" side of the string
-- returns -1 if it doesn't work, no sep1 or sep2 exist
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPartialString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string partial_string = ultraschall.GetPartialString(string str, string sep1, string sep2)</functioncall>
  <description>
    returns the part of a filename-string between sep1 and sep2
    
    returns nil if it doesn't work, no sep1 or sep2 exist 
  </description>
  <retvals>
    string partial_string  - the partial string between sep1 and sep2
  </retvals>
  <parameters>
    string str - string to be processed
    string sep1 - separator on the "left" side of the partial string
    string sep2 - separator on the "right" side of the partial string
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>string,separator</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(str)~="string" then ultraschall.AddErrorMessage("GetPartialString","str", "only a string allowed", -1) return nil end
  if type(sep1)~="string" then ultraschall.AddErrorMessage("GetPartialString","sep1", "only a string allowed", -2) return nil end
  if type(sep2)~="string" then ultraschall.AddErrorMessage("GetPartialString","sep2", "only a string allowed", -3) return nil end

  -- escape some characters
  if sep1=="%" then sep1="%%" end
  if sep2=="%" then sep2="%%" end
  if sep1=="." then sep1="%." end
  if sep2=="." then sep2="%." end
  
  -- do the pattern matching  
  local result=str:match(sep1.."(.*)"..sep2)
    
  if result==nil then ultraschall.AddErrorMessage("GetPartialString","", "separator not found", -4) return nil end
  return result
end
  
--L,L2,L3,L4=ultraschall.GetPartialString("olapaloma blanca","lo","blo")


function ultraschall.RunCommand(actioncommand_id)
-- runs a command by its ActionCommandID(instead of the CommandID-number)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RunCommand</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.RunCommand(string actioncommand_id)  </functioncall>
  <description>
    runs a command by its ActionCommandID(instead of the CommandID-number)
    
    returns -1 in case of error
  </description>
  <retvals>
    integer retval - -1, in case of error
  </retvals>
  <parameters>
    string actioncommand_id - the ActionCommandID of the Command/Script/Action you want to run; must be either a number or the ActionCommandID beginning with an underscore _
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command,commandid,actioncommandid,action,run</tags>
</US_DocBloc>
--]]
  -- check parameter
  if ultraschall.CheckActionCommandIDFormat(actioncommand_id)==false then ultraschall.AddErrorMessage("RunCommand", "actioncommand_id", "must be a command-number or start with an _underscore", -1) return -1 end
  
  -- run the command
  local command_id = reaper.NamedCommandLookup(actioncommand_id)
  reaper.Main_OnCommand(command_id,0)
end

--ultraschall.RunCommand("l1007")

function ultraschall.Notes2CSV()
-- returns the project's notes as a CSV(retval)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Notes2CSV</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string csv_retval = ultraschall.Notes2CSV()</functioncall>
  <description>
    Gets the project's notes and returns it as a CSV.
  </description>
  <retvals>
    string csv_retval  - the project notes, returned as a csv-string; entries separated by a comma
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>notes,csv,converter,string</tags>
</US_DocBloc>
--]]
  local csv = ""
  local linenumber=1
  local notes = reaper.GetSetProjectNotes(0, false, "")
  for line in notes:gmatch"[^\n]*" do
    csv = csv .. "," .. line --escapeCSV(line)
  end
    
  local retval= string.sub(csv, 2) -- remove first ","
  return retval
end


function ultraschall.CSV2Line(csv_line)
-- converts a csv to a "clean" line without the ,-separators
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CSV2Line</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string values = ultraschall.CSV2Line(string csv_line)</functioncall>
  <description>
    converts a string of csv-values into a string with all values and without the ,-separators
    
    returns nil in case of error
  </description>
  <retvals>
    string values  - all values in one string
  </retvals>
string csv_line - the csv-line, values separated by commas
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>notes,csv,converter,string</tags>
</US_DocBloc>
--]]
  -- check parameter
  if type(csv_line)~="string" then ultraschall.AddErrorMessage("CSV2Line","csv_line", "only string is allowed", -1) return nil end
  
  -- do the magic
  if tonumber(csv_line)~=nil then return tostring(csv_line) end
  return string.gsub(csv_line, ",", "")
end


--ALABAMA=ultraschall.CSV2Line(",sss1,2,3,4,599999,sdfhiudfho,sdfu89u409e,9iu0,")



function ultraschall.RGB2Grayscale(red,green,blue)
--converts rgb to a grayscale value
-- Parameters: 
-- red - red-color-value 0-255
-- green - green-color-value 0-255
-- blue - blue-color-value 0-255
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RGB2Grayscale</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer graycolor = ultraschall.RGB2Grayscale(integer red, integer green, integer blue)</functioncall>
  <description>
    converts rgb to a grayscale value. Works native on Mac as well on Windows, no color conversion needed.
  </description>
  <parameters>
    integer red - red-value between 0 and 255.
    integer green - red-value between 0 and 255.
    integer blue - red-value between 0 and 255.
  </parameters>
  <retvals>
    integer graycolor  - the gray color-value, generated from red,blue and green.
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>colorvalues,rgb,gray,grayscale,grey,greyscale</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(red)~="integer" then ultraschall.AddErrorMessage("RGB2Grayscale","red".."only integer is allowed", -1) return nil end
  if math.type(green)~="integer" then ultraschall.AddErrorMessage("RGB2Grayscale","green".."only integer is allowed", -2) return nil end
  if math.type(blue)~="integer" then ultraschall.AddErrorMessage("RGB2Grayscale","blue".."only integer is allowed", -3) return nil end

  if red<0 or red>255 then ultraschall.AddErrorMessage("RGB2Grayscale","red", "must be between 0 and 255", -4) return -1 end
  if green<0 or green>255 then ultraschall.AddErrorMessage("RGB2Grayscale","green", "must be between 0 and 255", -5) return -1 end
  if blue<0 or blue>255 then ultraschall.AddErrorMessage("RGB2Grayscale","blue", "must be between 0 and 255", -6) return -1 end

  -- do the legend of the grayscale and return it's resulting colorvalue
  local gray=red+green+blue
  gray=ultraschall.RoundNumber(gray/3)
  local gray_color=reaper.ColorToNative(gray,gray,gray)
  return ultraschall.RoundNumber(gray_color)
end

--A=ultraschall.RGB2Grayscale(0,0,0)

function ultraschall.IsItemInTrack(tracknumber, itemIDX)
--returns true, if the itemIDX is part of track tracknumber, false if not, -1 if no such itemIDX or Tracknumber available
-- itemIDX - the number of the Item to check of
-- integer tracknumber - the number of the track to check in
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsItemInTrack</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsItemInTrack(integer tracknumber, integer itemIDX)</functioncall>
  <description>
    checks, whether a given item is part of the track tracknumber
    
    returns true, if the itemIDX is part of track tracknumber, false if not, -1 if no such itemIDX or Tracknumber available
  </description>
  <retvals>
    boolean retval - true, if item is in track, false if item isn't in track
  </retvals>
  <parameters>
    integer itemIDX - the number of the item to check of
    integer tracknumber - the number of the track to check in, with 1 for track 1, 2 for track 2, etc.
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>itemmanagement,item,track,existence</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("IsItemInTrack","tracknumber", "only integer is allowed", -1) return nil end
  if math.type(itemIDX)~="integer" then ultraschall.AddErrorMessage("IsItemInTrack","itemIDX", "only integer is allowed", -2) return nil end
  
  if tracknumber>reaper.CountTracks(0) or tracknumber<0 then ultraschall.AddErrorMessage("IsItemInTrack","tracknumber", "no such track in this project", -3) return -1 end
  if itemIDX>reaper.CountMediaItems(0)-1 or itemIDX<0 then ultraschall.AddErrorMessage("IsItemInTrack","itemIDX", "no such item in this project", -4) return -1 end
  
  -- Get the tracks and items
  local MediaTrack=reaper.GetTrack(0, tracknumber-1) 
  local MediaItem=reaper.GetMediaItem(0, itemIDX)
  local MediaTrack2=reaper.GetMediaItem_Track(MediaItem)
  
  -- check and return
  if MediaTrack==MediaTrack2 then return true 
  else return false
  end  
end

--AA=ultraschall.IsItemInTrack(1, 1)




--  content="%SystemRoot%\\syswow64\\chcp.com\ntestballon"
--  stringthing=string.format('%q', content)
  
--A=ultraschall.WriteValueToFile("c:\\Ultraschall3_1-portable - Api/UserPlugins/ultraschall_api/temp/temp hui.bat", "aboutyou")


function ultraschall.CreateTrackString(firstnumber, lastnumber, step)
-- returns a string with the all numbers from firstnumber to lastnumber, separated by a ,
-- e.g. firstnumber=4, lastnumber=8 -> 4,5,6,7,8
-- firstnumber - the number, with which the string starts
-- lastnumber - the number, with which the string ends
-- step - how many numbers shall be skipped inbetween. Can lead to a different lastnumber, if not 1 ! nil=1
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackString(integer firstnumber, integer lastnumber, optional integer step)</functioncall>
  <description>
    returns a string with the all numbers from firstnumber to lastnumber, separated by a ,
    e.g. firstnumber=4, lastnumber=8 -> 4,5,6,7,8
  </description>
  <parameters>
    integer firstnumber - the number, with which the string starts
    integer lastnumber - the number, with which the string ends
    integer step - how many numbers shall be skipped inbetween. Can lead to a different lastnumber, when step is not 1! nil or invalid value=1
  </parameters>
  <retvals>
    string trackstring - a string with all tracknumbers, separated by a ,
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackstring, track, create</tags>
</US_DocBloc>

--]]
  -- check parameters
  if math.type(firstnumber)~="integer" then ultraschall.AddErrorMessage("CreateTrackString","firstnumber", "only integer allowed", -1) return nil end
  if math.type(lastnumber)~="integer" then ultraschall.AddErrorMessage("CreateTrackString","lastnumber", "only integer allowed", -2) return nil end
  if tonumber(step)==nil then step=1 end
    
  -- prepare variables
  firstnumber=tonumber(firstnumber)
  lastnumber=tonumber(lastnumber)
  step=tonumber(step)
  local trackstring=""
  
  -- create trackstring
  for i=firstnumber, lastnumber, step do
    trackstring=trackstring..","..tostring(i)
  end
  return trackstring:sub(2,-1)
end

--L=ultraschall.CreateTrackString("1","b")

------------------------------------
---- Ultraschall.ini Management ----
------------------------------------

--reaper.MB(ultraschall.Separator,"",0)

function ultraschall.SetUSExternalState(section, key, value)
-- stores value into ultraschall.ini
-- returns true if successful, false if unsuccessful
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetUSExternalState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetUSExternalState(string section, string key, string value)</functioncall>
  <description>
    stores values into ultraschall.ini. Returns true if successful, false if unsuccessful.
    
    unlike other Ultraschall-API-functions, this converts the values, that you pass as parameters, into strings, regardless of their type
  </description>
  <retvals>
    boolean retval - true, if successful, false if unsuccessful.
  </retvals>
  <parameters>
    string section - section within the ini-file
    string key - key within the section
    string value - the value itself
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, value, insert, store</tags>
</US_DocBloc>
--]]
  -- check parameters
  section=tostring(section)
  key=tostring(key)
  value=tostring(value)  
  
  if section:match(".*(%=).*")=="=" then ultraschall.AddErrorMessage("SetUSExternalState","section", "no = allowed in section", -4) return false end

  -- set value
  return ultraschall.SetIniFileValue(section, key, value, reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini")
end

--A=ultraschall.SetUSExternalState("tes=10to","cowb[sfijdfd]oy bebop2","Howde[]eho")
--A=ultraschall.SetUSExternalState("tes10to","cowb[sfijdfd]oy bebop2","Howde[]eho")
--AA=ultraschall.SetUSExternalState("tes89to","cafdfaaowbsfijdfdoy bebop2","Howdeeho")

function ultraschall.GetUSExternalState(section, key)
-- gets a value from ultraschall.ini
-- returns length of entry(integer) and the entry itself(string)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetUSExternalState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string value = ultraschall.GetUSExternalState(string section, string key)</functioncall>
  <description>
    gets a value from ultraschall.ini. 
    
    returns an empty string in case of an error
  </description>
  <retvals>
    string value  - the value itself; empty string in case of an error or no such extstate
  </retvals>
  <parameters>
    string section - the section of the ultraschall.ini.
    string key - the key of which you want it's value.
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, value, get</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(section)~="string" then ultraschall.AddErrorMessage("GetUSExternalState","section", "only string allowed", -1) return "" end
  if type(key)~="string" then ultraschall.AddErrorMessage("GetUSExternalState","key", "only string allowed", -2) return "" end
 
  -- get value
  local A, B = ultraschall.GetIniFileValue(section, key, "", reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini")
  return B
end

--A,AA=ultraschall.GetUSExternalState("ultraschall_clock","docked")

function ultraschall.CountUSExternalState_sec()
--count number of sections in the ultraschall.ini
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountUSExternalState_sec</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer section_count = ultraschall.CountUSExternalState_sec()</functioncall>
  <description>
    returns the number of [sections] in the ultraschall.ini
  </description>
  <retvals>
    integer section_count  - the number of section in the ultraschall.ini
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, section</tags>
</US_DocBloc>

--]]
  -- check existence of ultraschall.ini
  if reaper.file_exists(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini")==false then ultraschall.AddErrorMessage("CountUSExternalState_sec","", "ultraschall.ini does not exist", -1) return -1 end
  
  -- count external-states
  local count=0
  for line in io.lines(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini") do
    local check=line:match(".*=.*")
    if check~=nil then check="" count=count+1 end
  end
  return count
end

--A=ultraschall.CountUSExternalState_sec()

function ultraschall.CountUSExternalState_key(section)
--count number of keys in the section in ultraschall.ini
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountUSExternalState_key</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer key_count = ultraschall.CountUSExternalState_key(string section)</functioncall>
  <description>
    returns the number of keys in the given [section] in ultraschall.ini
  </description>
  <retvals>
    integer key_count  - the number of keys within an ultraschall.ini-section
  </retvals>
  <parameters>
    string section - the section of the ultraschall.ini, of which you want the number of keys.
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, key</tags>
</US_DocBloc>
--]]
  -- check parameter and existence of ultraschall.ini
  if type(section)~="string" then ultraschall.AddErrorMessage("CountUSExternalState_key","section", "only string allowed", -1) return false end
  if reaper.file_exists(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini")==false then ultraschall.AddErrorMessage("CountUSExternalState_key","", "ultraschall.ini does not exist", -2) return -1 end

  -- prepare variables
  local count=0
  local startcount=0
  
  -- count keys
  for line in io.lines(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini") do
   local check=line:match("%[.*.%]")
    if startcount==1 and line:match(".*=.*") then
      count=count+1
    else
      startcount=0
    if "["..section.."]" == check then startcount=1 end
    if check==nil then check="" end
    end
  end
  
  return count
end

--A=ultraschall.CountUSExternalState_key("view")

function ultraschall.EnumerateUSExternalState_sec(number)
-- returns name of the numberth section in ultraschall.ini or nil, if invalid
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateUSExternalState_sec</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string section_name = ultraschall.EnumerateUSExternalState_sec(integer number)</functioncall>
  <description>
    returns name of the numberth section in ultraschall.ini or nil if invalid
  </description>
  <retvals>
    string section_name  - the name of the numberth section within ultraschall.ini
  </retvals>
  <parameters>
    integer number - the number of section, whose name you want to know
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, enumerate, section</tags>
</US_DocBloc>
--]]
  -- check parameter and existence of ultraschall.ini
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateUSExternalState_sec", "number", "only integer allowed", -1) return false end
  if reaper.file_exists(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini")==false then ultraschall.AddErrorMessage("EnumerateUSExternalState_sec", "", "ultraschall.ini does not exist", -2) return -1 end

  if number<=0 then ultraschall.AddErrorMessage("EnumerateUSExternalState_sec","number", "no negative number allowed", -3) return nil end
  if number>ultraschall.CountUSExternalState_sec() then ultraschall.AddErrorMessage("EnumerateUSExternalState_sec","number", "only "..ultraschall.CountUSExternalState_sec().." sections available", -4) return nil end

  -- look for and return the requested line
  local count=0
  for line in io.lines(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini") do
    check=line:match("%[.-%]")
    if check~=nil then count=count+1 end
    if count==number then return line end
  end
end

--A=ultraschall.EnumerateUSExternalState_sec(10)

function ultraschall.EnumerateUSExternalState_key(section, number)
-- returns name of a numberth key within a section in ultraschall.ini or nil if invalid or not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateUSExternalState_key</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string key_name = ultraschall.EnumerateUSExternalState_key(string section, integer number)</functioncall>
  <description>
    returns name of a numberth key within a section in ultraschall%.ini or nil if invalid or not existing
  </description>
  <retvals>
    string key_name  - the name ob the numberth key in ultraschall.ini.
  </retvals>
  <parameters>
    string section - the section within ultraschall.ini, where the key is stored.
    integer number - the number of the key, whose name you want to know; 1 for the first one
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ultraschall.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, enumerate, key</tags>
</US_DocBloc>
--]]
  -- check parameter
  if type(section)~="string" then ultraschall.AddErrorMessage("EnumerateUSExternalState_key", "section", "only string allowed", -1) return false end
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateUSExternalState_key", "number", "only integer allowed", -2) return false end

  -- prepare variables
  local count=0
  local startcount=0
  
  -- find and return the proper line
  for line in io.lines(reaper.GetResourcePath()..ultraschall.Separator.."ultraschall.ini") do
    local check=line:match("%[.*.%]")
    if startcount==1 and line:match(".*=.*") then
      count=count+1
      if count==number then local temp=line:match(".*=") return temp:sub(1,-2) end
    else
      startcount=0
      if "["..section.."]" == check then startcount=1 end
      if check==nil then check="" end
    end
  end
  return nil
end


--ALAMO=ultraschall.EnumerateUSExternalState_key("view",0)


--ALABAMSA=ultraschall.CountUSExternalState_key("tes6to")


--------------------------
---- Get Track States ----
--------------------------


function ultraschall.GetTrackName(tracknumber, str)
-- returns the trackname as a string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackName</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackname = ultraschall.GetTrackName(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns name of the track.
    
    It's the entry NAME
  </description>
  <retvals>
    string trackname  - the name of the track
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, name, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackName", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackName", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  
  -- get trackname
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackName", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  local Track_Name=str:match("NAME (.-)%c")
  return Track_Name
end

--A=ultraschall.GetTrackName(1, nil)

--MediaTrack=reaper.GetMasterTrack(0)
--retval, str = reaper.GetTrackStateChunk(MediaTrack, "test", false)
--reaper.ShowConsoleMsg(str)

function ultraschall.GetTrackPeakColorState(tracknumber, str)
-- returns a color-number as a string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackPeakColorState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer PeakColorState = ultraschall.GetTrackPeakColorState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns state of the PeakColor-number, which is the trackcolor. Will be returned as string, to avoid losing trailing or preceding zeros.
    
    It's the entry PEAKCOL
  </description>
  <retvals>
    string PeakColorState  - the color of the track
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackcolor, color, get, state, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackPeakColorState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
    --get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackPeakColorState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  -- get peakcolor-state
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackPeakColorState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  str=str:match("PEAKCOL(%s.-)%c").." "
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackPeakColorState(2)

function ultraschall.GetTrackBeatState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackBeatState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number BeatState = ultraschall.GetTrackBeatState(integer tracknumber,optional string TrackStateChunk)</functioncall>
  <description>
    returns Track-BeatState. 

    It's the entry BEAT
  </description>
  <retvals>
    number BeatState  - -1 - Project time base; 0 - Time; 1 - Beats position, length, rate; 2 - Beats position only
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, beat, get, state, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackBeatState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackBeatState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  
  -- get beatstate
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackBeatState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end        
  str=str:match("BEAT(%s.-)%c").." "
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackBeatState(1)

function ultraschall.GetTrackAutoRecArmState(tracknumber, str)
-- returns nil, if it's unset
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackAutoRecArmState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer AutoRecArmState = ultraschall.GetTrackAutoRecArmState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns if the track is in AutoRecArm, when selected. Returns nil if not.

    It's the entry AUTO_RECARM
  </description>
  <retvals>
    integer AutoRecArmState  - state of autorecarm; 1 for set; nil if unset
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, autorecarm, rec, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackAutoRecArmState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackAutoRecArmState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackAutoRecArmState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get recarm
  str=str:match("AUTO_RECARM(%s.-)%c")
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackAutoRecArmState(1)
  
function ultraschall.GetTrackMuteSoloState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMuteSoloState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer Mute, integer Solo, integer SoloDefeat = ultraschall.GetTrackMuteSoloState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns states of Mute and Solo-Buttons.
    
    It's the entry MUTESOLO
  </description>
  <retvals>
    integer Mute - Mute set to 0 - Mute off, 1 - Mute On
    integer Solo - Solo set to 0 - Solo off, 1 - Solo ignore routing, 2 - Solo on
    integer SoloDefeat  - SoloDefeat set to 0 - off, 1 - on
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, mute, solo, solodefeat, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMuteSoloState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMuteSoloState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMuteSoloState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get mutesolo-state
  str=str:match("MUTESOLO(%s.-)%c")
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s"))
end

--A1,A2,A3 = ultraschall.GetTrackMuteSoloState(1)
  
function ultraschall.GetTrackIPhaseState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackIPhaseState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number IPhase = ultraschall.GetTrackIPhaseState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns state of the IPhase. If the Phase-button is pressed, it will return 1, else it will return 0.
    
    It's the entry IPHASE
  </description>
  <retvals>
    number IPhase  - state of the phase-button; 0, normal phase; 1, inverted phase(180)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, iphase, phase, button, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackIPhaseState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
    
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackIPhaseState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackIPhaseState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end

  -- get iphase-state
  str=str:match("IPHASE(%s.-)%c")
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackIPhaseState(1)

function ultraschall.GetTrackIsBusState(tracknumber, str)
-- for folder-management
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackIsBusState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer busstate1, integer busstate2 = ultraschall.GetTrackIsBusState(integer tracknumber, optional string trackstatechunk)</functioncall>
  <description>
    returns busstate of the track, means: if it's a folder track
    
    It's the entry ISBUS
  </description>
  <retvals>
    integer busstate1=0, integer busstate2=0 - track is no folder
    - or
    integer busstate1=1, integer busstate2=1 - track is a folder
    - or
    integer busstate1=1, integer busstate2=2 - track is a folder but view of all subtracks not compactible
    - or
    integer busstate1=2, integer busstate2=-1 - track is last track in folder(no tracks of subfolders follow)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, busstate, folder, subfolders, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackIsBusState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then

    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackIsBusState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackIsBusState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get busstate
  str=str:match("ISBUS(%s.-)%c")
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s"))
end

--A1,A2=ultraschall.GetTrackIsBusState(1)

function ultraschall.GetTrackBusCompState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackBusCompState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number BusCompState1, number BusCompState2 = ultraschall.GetTrackBusCompState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns BusCompState, if the tracks in a folder are compacted or not.
    
    It's the entry BUSCOMP
  </description>
  <retvals>
    number BusCompState1 - 0 - no compacting, 1 - compacted tracks, 2 - minimized tracks
    number BusCompState2 - 0 - unknown,1 - unknown
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, busstate, folder, subfolders, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackBusCompState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack        
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackBusCompState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackBusCompState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get buscompstate
  str=str:match("BUSCOMP(%s.-)%c")
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s"))
end

--A,A2=ultraschall.GetTrackBusCompState(1)

function ultraschall.GetTrackShowInMixState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackShowInMixState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer MCPvisible, number MCP_FX_visible, number MCPTrackSendsVisible, integer TCPvisible, number ShowInMix5, number ShowInMix6, number ShowInMix7, number ShowInMix8 = ultraschall.GetTrackShowInMixState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns Show in Mix-state.
    
    It's the entry SHOWINMIX
  </description>
  <retvals>
     integer MCPvisible - 0 invisible, 1 visible
     number MCP_FX_visible - 0 visible, 1 FX-Parameters visible, 2 invisible
     number MCPTrackSendsVisible - 0 & 1.1 and higher TrackSends in MCP visible, every other number makes them invisible
     integer TCPvisible - 0 track is invisible in TCP, 1 track is visible in TCP
     number ShowInMix5 - unknown
     number ShowInMix6 - unknown
     number ShowInMix7 - unknown
     number ShowInMix8  - unknown
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, mixer, show, mcp, tcp, fx, visible, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackShowInMixState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackShowInMixState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackShowInMixState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get showinmix-state
  str=str:match("SHOWINMIX(%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s(.-)%s")),
         
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s"))
end  

--A1,A2,A3,A4,A5,A6,A7,A8=ultraschall.GetTrackShowInMixState(2)

function ultraschall.GetTrackFreeModeState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackFreeModeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer FreeModeState = ultraschall.GetTrackFreeModeState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns if the track has track free item positioning enabled(1) or not(0).
    
    It's the entry FREEMODE
  </description>
  <retvals>
    integer FreeModeState  - 1 - enabled, 0 - not enabled
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackfreemode, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackFreeModeState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackFreeModeState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackFreeModeState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get freemode-state
  str=str:match("FREEMODE(%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackFreeModeState(2)

function ultraschall.GetTrackRecState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackRecState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer ArmState, integer InputChannel, integer MonitorInput, integer RecInput, integer MonitorWhileRec, integer presPDCdelay, integer RecordingPath = ultraschall.GetTrackRecState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns Track Rec State.
    
    It's the entry REC
  </description>
  <retvals>
    integer ArmState - returns 1(armed) or 0(unarmed)
    
     integer InputChannel - returns the InputChannel
    --1 - No Input
    -1-16(more?) - Mono Input Channel
    -1024 - Stereo Channel 1 and 2
    -1026 - Stereo Channel 3 and 4
    -1028 - Stereo Channel 5 and 6
    -...
    -5056 - Virtual MIDI Keyboard all Channels
    -5057 - Virtual MIDI Keyboard Channel 1
    -...
    -5072 - Virtual MIDI Keyboard Channel 16
    -5088 - All MIDI Inputs - All Channels
    -5089 - All MIDI Inputs - Channel 1
    -...
    -5104 - All MIDI Inputs - Channel 16
    
     integer MonitorInput - 0 monitor off, 1 monitor on, 2 monitor on tape audio style
     
     integer RecInput - returns rec-input type
    -0 input(Audio or Midi)
    -1 Record Output Stereo
    -2 Disabled, Input Monitoring Only
    -3 Record Output Stereo, Latency Compensated
    -4 Record Output MIDI
    -5 Record Output Mono
    -6 Record Output Mono, Latency Compensated
    -7 MIDI overdub
    -8 MIDI replace
    -9 MIDI touch replace
    -10 Record Output Multichannel
    -11 Record Output Multichannel, Latency Compensated 
    -12 Record Input Force Mono
    -13 Record Input Force Stereo
    -14 Record Input Force Multichannel
    -15 Record Input Force MIDI
    -16 MIDI latch replace
    
     integer MonitorWhileRec - Monitor Trackmedia when recording, 0 is off, 1 is on
    
     integer presPDCdelay - preserve PDC delayed monitoring in media items
    
     integer RecordingPath  - recording path used 
    -0 - Primary Recording-Path only
    -1 - Secondary Recording-Path only
    -2 - Primary Recording Path and Secondary Recording Path(for invisible backup)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, midi, recordingpath, path, input, recinput, pdc, monitor, arm, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackRecState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackRecState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackRecState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get rec-state
  str=str:match("REC(%s.-)%c")
  -- L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s(.-)%s")),
         
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A1,A2,A3,A4,A5,A6,A7=ultraschall.GetTrackRecState(1)

function ultraschall.GetTrackVUState(tracknumber, str)
-- returns 0 if MultiChannelMetering is off
-- returns 2 if MultichannelMetering is on
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackVUState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer VUState = ultraschall.GetTrackVUState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns VUState. 
    
    It's the entry VU
  </description>
  <retvals>
    integer VUState  - nil if MultiChannelMetering is off, 2 if MultichannelMetering is on, 3 Metering is off
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, vu, metering, meter, multichannel, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackVUState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackVUState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackVUState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get VU-state
  str=str:match("VU(%s.-)%c")
  -- L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackVUState(1)

function ultraschall.GetTrackHeightState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackHeightState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>integer height, integer heightstate2, integer unknown = ultraschall.GetTrackHeightState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns height of the track.
    
    It's the entry TRACKHEIGHT
  </description>
  <retvals>
    integer height - 24 up to 443
    integer heightstate2 - 0 - use height, 1 - compact the track and ignore the height
    integer unknown - unknown    
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, height, compact, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackHeightState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackHeightState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackHeightState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get trackheight-state
  str=str:match("(TRACKHEIGHT%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s"))
end
  
--A1,A2, A3, A4=ultraschall.GetTrackHeightState(1)
  
function ultraschall.GetTrackINQState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackINQState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer quantMIDI, integer quantPOS, integer quantNoteOffs, number quantToFractBeat, integer quantStrength, integer swingStrength, integer quantRangeMin, integer quantRangeMax =  ultraschall.GetTrackINQState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    Gets INQ-state, mostly the quantize-settings for MIDI, as set in the "Track: View track recording settings (MIDI quantize, file format/path) for last touched track"-dialog (action 40604)
    
    It's the entry INQ
  </description>
  <retvals>
    integer quantMIDI -  quantize MIDI; 0 or 1
    integer quantPOS -  quantize to position; -1,prev; 0, nearest; 1, next
    integer quantNoteOffs -  quantize note-offs; 0 or 1
    number quantToFractBeat -  quantize to (fraction of beat)
    integer quantStrength -  quantize strength; -128 to 127
    integer swingStrength -  swing strength; -128 to 127
    integer quantRangeMin -  quantize range minimum; -128 to 127
    integer quantRangeMax -  quantize range maximum; -128 to 127
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, inq, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackINQState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackINQState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackINQState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get INQ-state
  str=str:match("(INQ%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s(.-)%s")),
         
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s"))
end
--A1,A2,A3,A4,A5,A6,A7,A8=ultraschall.GetTrackINQState(2)

function ultraschall.GetTrackNChansState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackNChansState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer channelnumber = ultraschall.GetTrackNChansState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the number of channels for this track, as set in the routing.
    
    It's the entry NCHAN
  </description>
  <retvals>
    integer channelnumber  - number of channels for this track
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, channels, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackNChansState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
    
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackNChansState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackNChansState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get Nchans-state
  str=str:match("(NCHAN%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackNChansState(1)


function ultraschall.GetTrackBypFXState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackBypFXState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer FXState = ultraschall.GetTrackBypFXState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the off/bypass(0) or nobypass(1) state of the FX-Chain
    
    It's the entry FX
  </description>
  <retvals>
    integer FXState - off/bypass(0) or nobypass(1)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, bypass, fx, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackBypFXState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackBypFXState", "tracknumber", "no such track", -2) return nil end

      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackBypFXState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get bypFX-state
  str=str:match("(FX%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackBypFXState(0)

function ultraschall.GetTrackPerfState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackPerfState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer TrackPerfState = ultraschall.GetTrackPerfState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns TrackPerformance-state
    
    It's the entry PERF
  </description>
  <retvals>
    integer TrackPerfState  - TrackPerformance-state
    -0 - allow anticipative FX + allow media buffering
    -1 - allow anticipative FX + prevent media buffering 
    -2 - prevent anticipative FX + allow media buffering
    -3 - prevent anticipative FX + prevent media buffering
    -settings seem to repeat with higher numbers (e.g. 4(like 0) - allow anticipative FX + allow media buffering)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, trackperformance, fx, buffering, media, anticipative, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackPerfState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackPerfState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackPerfState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get perf-state
  str=str:match("(PERF%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackPerfState(1)

function ultraschall.GetTrackMIDIOutState(tracknumber, str)
-- -1 no output
-- 416 - microsoft GS wavetable synth - send to original channels
-- 417-432 - microsoft GS wavetable synth - send to channel state-416
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMIDIOutState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer MidiOutState = ultraschall.GetTrackMIDIOutState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns MIDI_Out-State, as set in the Routing-Settings
    
    It's the entry MIDIOUT
  </description>
  <retvals>
    integer MidiOutState  - MIDI_Out-State, as set in the Routing-Settings
    --1 no output
    -416 - microsoft GS wavetable synth - send to original channels
    -417-432 - microsoft GS wavetable synth - send to channel state minus 416
    --31 - no Output, send to original channel 1
    --16 - no Output, send to original channel 16
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, midi, outstate, routing, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMIDIOutState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
    
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMIDIOutState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMIDIOutState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get MIDIout-state
  str=str:match("(MIDIOUT%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))end

--A=ultraschall.GetTrackMIDIOutState(1)

function ultraschall.GetTrackMainSendState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMainSendState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer MainSendOn, integer ParentChannels = ultraschall.GetTrackMainSendState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns, if Main-Send is on(1) or off(0) and the ParentChannels(0-63), as set in the Routing-Settings.
    
    It's the entry MAINSEND
  </description>
  <retvals>
    integer MainSendOn - Main-Send is on(1) or off(0)
    integer ParentChannels - ParentChannels(0-63)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, parent, channel, send, main, routing, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMainSendState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMainSendState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMainSendState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get mainsend-state
  str=str:match("(MAINSEND%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s"))
end

--A,AA= ultraschall.GetTrackMainSendState(1.1)

function ultraschall.GetTrackGroupFlagsState(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackGroupFlagsState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer GroupState_as_Flags, array IndividualGroupState_Flags = ultraschall.GetTrackGroupFlagsState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.
    
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):
      group1=groups_bitfield_table[1]&1
      group2=groups_bitfield_table[1]&4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    The GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.
    
    This function will work only for Groups 1 to 32. To get Groups 33 to 64, use <a href="#GetTrackGroupFlags_HighState">GetTrackGroupFlags_HighState</a> instead!
    
    It's the entry GROUP_FLAGS
    
    returns -1 in case of failure
  </description>
  <retvals>
    integer GroupState_as_Flags - returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.
    -returns -1 in case of failure
    -
    -the following flags are available:
    -2^0 - Volume Master
    -2^1 - Volume Slave
    -2^2 - Pan Master
    -2^3 - Pan Slave
    -2^4 - Mute Master
    -2^5 - Mute Slave
    -2^6 - Solo Master
    -2^7 - Solo Slave
    -2^8 - Record Arm Master
    -2^9 - Record Arm Slave
    -2^10 - Polarity/Phase Master
    -2^11 - Polarity/Phase Slave
    -2^12 - Automation Mode Master
    -2^13 - Automation Mode Slave
    -2^14 - Reverse Volume
    -2^15 - Reverse Pan
    -2^16 - Do not master when slaving
    -2^17 - Reverse Width
    -2^18 - Width Master
    -2^19 - Width Slave
    -2^20 - VCA Master
    -2^21 - VCA Slave
    -2^22 - VCA pre-FX slave
    
     array IndividualGroupState_Flags  - returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.
    -e.g. If Volume Master is set only in Group 1, entry 1 in the array will be set to 1. If Volume Master is set on Group 2 and Group 4, the first entry in the array will be set to 10.
    -refer to the upper GroupState_as_Flags list to see, which entry in the array is for which set flag, e.g. array[22] is VCA pre-F slave, array[16] is Do not master when slaving, etc
    -As said before, the values in each entry is a flag, that tells you, which of the groups is set with a certain flag. The following flags determine, in which group a certain flag is set:
    -2^0 - Group 1
    -2^1 - Group 2
    -2^2 - Group 3
    -2^3 - Group 4
    -...
    -2^30 - Group 31
    -2^31 - Group 32
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, group, groupstate, individual, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackGroupFlagsState", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackGroupFlagsState", "tracknumber", "no such track", -2) return -1 end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if ultraschall.IsValidTrackStateChunk(str)==false then ultraschall.AddErrorMessage("GetTrackGroupFlagsState", "TrackStateChunk", "no valid TrackStateChunk", -3) return -1 end
    
  local retval=0


  local Track_TrackGroupFlags=str:match("GROUP_FLAGS.-%c") 
  if Track_TrackGroupFlags==nil then ultraschall.AddErrorMessage("GetTrackGroupFlagsState", "", "no trackgroupflags available", -4) return -1 end
  
  
  -- get groupflags-state
  
  local GroupflagString= Track_TrackGroupFlags:match("GROUP_FLAGS (.-)%c")
  local count, Tracktable=ultraschall.CSV2IndividualLinesAsArray(GroupflagString, " ")

  for i=1,23 do
    Tracktable[i]=tonumber(Tracktable[i])
    if Tracktable[i]~=nil and Tracktable[i]>=1 then retval=retval+2^(i-1) end
  end
  
  return retval, Tracktable
end

--A,B=ultraschall.GetTrackGroupFlagsState(1)

function ultraschall.GetTrackGroupFlags_HighState(tracknumber, str)

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackGroupFlags_HighState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>integer GroupState_as_Flags, array IndividualGroupState_Flags = ultraschall.GetTrackGroupFlags_HighState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the state of the group-flags, as set in the menu Track Grouping Parameters. Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.
    
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to get Volume Master(table entry 1) to check if it's set in Group 33(2^0=1) and 35(2^2=4):
      group1=groups_bitfield_table[1]&1
      group2=groups_bitfield_table[1]&4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    The GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.
    
    This function will work only for Groups 33(2^0) to 64(2^31). To get Groups 1 to 32, use <a href="#GetTrackGroupFlagsState">GetTrackGroupFlagsState</a> instead!
    
    It's the entry GROUP_FLAGS_HIGH
    
    returns -1 in case of failure
  </description>
  <retvals>
    integer GroupState_as_Flags - returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.
    -returns -1 in case of failure
    -
    -the following flags are available:
    -2^0 - Volume Master
    -2^1 - Volume Slave
    -2^2 - Pan Master
    -2^3 - Pan Slave
    -2^4 - Mute Master
    -2^5 - Mute Slave
    -2^6 - Solo Master
    -2^7 - Solo Slave
    -2^8 - Record Arm Master
    -2^9 - Record Arm Slave
    -2^10 - Polarity/Phase Master
    -2^11 - Polarity/Phase Slave
    -2^12 - Automation Mode Master
    -2^13 - Automation Mode Slave
    -2^14 - Reverse Volume
    -2^15 - Reverse Pan
    -2^16 - Do not master when slaving
    -2^17 - Reverse Width
    -2^18 - Width Master
    -2^19 - Width Slave
    -2^20 - VCA Master
    -2^21 - VCA Slave
    -2^22 - VCA pre-FX slave
    
     array IndividualGroupState_Flags  - returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.
    -e.g. If Volume Master is set only in Group 33, entry 1 in the array will be set to 1. If Volume Master is set on Group 34 and Group 36, the first entry in the array will be set to 10.
    -refer to the upper GroupState_as_Flags list to see, which entry in the array is for which set flag, e.g. array[22] is VCA pre-F slave, array[16] is Do not master when slaving, etc
    -As said before, the values in each entry is a flag, that tells you, which of the groups is set with a certain flag. The following flags determine, in which group a certain flag is set:
    -2^0 - Group 33
    -2^1 - Group 34
    -2^2 - Group 35
    -2^3 - Group 36
    -...
    -2^30 - Group 63
    -2^31 - Group 64
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, group, groupstate, individual, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackGroupFlags_HighState", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackGroupFlags_HighState", "tracknumber", "no such track", -2) return -1 end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if ultraschall.IsValidTrackStateChunk(str)==false then ultraschall.AddErrorMessage("GetTrackGroupFlags_HighState", "TrackStateChunk", "no valid TrackStateChunk", -3) return -1 end
    
  local retval=0


  local Track_TrackGroupFlags=str:match("GROUP_FLAGS_HIGH.-%c") 
  if Track_TrackGroupFlags==nil then ultraschall.AddErrorMessage("GetTrackGroupFlags_HighState", "", "no trackgroupflags available", -4) return -1 end
  
  
  -- get groupflags-state
  
  local GroupflagString= Track_TrackGroupFlags:match("GROUP_FLAGS_HIGH (.-)%c")
  local count, Tracktable=ultraschall.CSV2IndividualLinesAsArray(GroupflagString, " ")

  for i=1,23 do
    Tracktable[i]=tonumber(Tracktable[i])
    if Tracktable[i]~=nil and Tracktable[i]>=1 then retval=retval+2^(i-1) end
  end
  
  return retval, Tracktable
end

--A,B=ultraschall.GetTrackGroupFlags_HighState(1.1)

--B=2^22
--A,A1=ultraschall.GetTrackGroupFlags_HighState(1)
--A=2^2

-- GROUP_FLAGS 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1

function ultraschall.GetTrackLockState(tracknumber, str)
-- Get the state of, if the track has locked controls(1) or not(0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackLockState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer lockedstate = ultraschall.GetTrackLockState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns, if the track-controls of this track are locked(1) or not(nil).
    
    It's the entry LOCK
    Only the LOCK within TrackStateChunks, but not MediaItemStateChunks
  </description>
  <retvals>
    integer lockedstate  - locked(1) or not(nil)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, lockstate, locked, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackLockState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackLockState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackLockState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end

  -- get lock-state  
  str=str:match("(LOCK%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A=ultraschall.GetTrackLockState(1)

function ultraschall.GetTrackLayoutNames(tracknumber, str)
-- Get the state of the current TrackLayout-names. Returns the name of the current 
-- TCP and the current MCP-layout or nil if default is selected.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackLayoutNames</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string TCP_Layoutname, string MCP_Layoutname = ultraschall.GetTrackLayoutNames(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the current selected layouts for TrackControlPanel and MixerControlPanel for this track as strings. Returns nil, if default is set.
    
    It's the entry LAYOUTS
  </description>
  <retvals>
    string TCP_Layoutname - name of the TCP-Layoutname
    string MCP_Layoutname  - name of the MCP-Layoutname
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, theme, layout, name, mcp, tcp, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackLayoutNames", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackLayoutNames", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackLayoutNames", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end

  -- get layout-names
  local Track_LayoutTCP
  local Track_LayoutMCP
  
  str=str:match("(LAYOUTS%s.-)%c")
  if str==nil then return "","" end
  str=str.." "
  local L=str
  if str~=nil then str=str.." " else return nil end
  Track_LayoutTCP, offset1 = str:match("%s\"(.-)\"%s()")
  if Track_LayoutTCP==nil then Track_LayoutTCP, offset = str:match("%s(.-)%s()") str=str:sub(offset, -1) else str=str:sub(offset1, -1) end
  Track_LayoutMCP = str:match("\"(.-)\"%s")
  if Track_LayoutMCP==nil then Track_LayoutMCP = str:match("(.-)%s") end  

  return Track_LayoutTCP, Track_LayoutMCP
end

--A,AA=ultraschall.GetTrackLayoutNames(2)

function ultraschall.GetTrackAutomodeState(tracknumber, str)
-- returns current state of Automation-Mode
-- 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackAutomodeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer automodestate = ultraschall.GetTrackAutomodeState(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns, if the automation-mode for envelopes of this track
    
    It's the entry AUTOMODE
  </description>
  <retvals>
    integer automodestate  - is set to 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch.
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, automode, envelopes, automation, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackAutomodeState", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackAutomodeState", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackAutomodeState", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get automode-state
  str=str:match("(AUTOMODE%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end


--A=ultraschall.GetTrackAutomodeState(2)

function ultraschall.GetTrackIcon_Filename(tracknumber, str)
-- Get the path and filename of the current track-icon
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackIcon_Filename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string filename_with_path = ultraschall.GetTrackIcon_Filename(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the filename with path for the track-icon of the current track. Returns nil, if no trackicon has been set.
    
    It's the entry TRACKIMGFN
  </description>
  <retvals>
    string filename_with_path  - filename with path for the current track-icon.
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, graphics, image, icon, trackicon, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackIcon_Filename", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackIcon_Filename", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackIcon_Filename", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get trackicon-filename
  local Track_Image=str:match("TRACKIMGFN.-%c")
  if Track_Image~=nil then Track_Image=Track_Image:sub(13,-3)
  end
  return Track_Image
end

--A,A2=ultraschall.GetTrackIcon_Filename(1)

function ultraschall.GetTrackRecCFG(tracknumber, str)
  --returns the Rec-configuration-string, with which recordings are made
  --
  --tracknumber - the number of the track
  --cfg_nr - the number of the reccfg, beginning with 0(there can be more than one)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackRecCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string reccfg = ultraschall.GetTrackRecCFG(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the Rec-configuration-string, with which recordings are made. Returns nil, if no reccfg exists.
    
    It's the entry <RECCFG
  </description>
  <retvals>
    string reccfg - the string, that encodes the recording configuration of the track.
    integer reccfgnr - the number of the recording-configuration of the track; 
                     - 0, use default project rec-setting
                     - 1, use track-customized rec-setting, as set in the "Track: View track recording settings (MIDI quantize, file format/path) for last touched track"-dialog (action 40604)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, reccfg, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackRecCFG", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackRecCFG", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackRecCFG", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end

  -- get reccfg
  local RECCFGNR=str:match("<RECCFG (.-)%c")
  if RECCFGNR==nil then return nil end
  local RECCFG=str:match("<RECCFG.-%c(.-)%c")
  
  return RECCFG, tonumber(RECCFGNR)
end

--A,B=ultraschall.GetTrackRecCFG(1)

function ultraschall.GetTrackMidiInputChanMap(tracknumber, str)
--returns the Midi Input Channel Map-state or nil, if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMidiInputChanMap</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer MidiInputChanMap_state = ultraschall.GetTrackMidiInputChanMap(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns the state of the MIDIInputChanMap for the current track, as set in the Input-MIDI->Map Input to Channel menu. 0 for channel 1, 2 for channel 2, etc. Nil, if not existing.
    
    It's the entry MIDI_INPUT_CHANMAP
  </description>
  <retvals>
    integer MidiInputChanMap_state  - 0 for channel 1, 1 for channel 2, ... 15 for channel 16; nil, source channel.
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, midi, input, chanmap, channelmap, channel, mapping, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMidiInputChanMap", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMidiInputChanMap", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMidiInputChanMap", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
  
  -- get midi-input-chanmap
  local Track_MidiChanMap=str:match("MIDI_INPUT_CHANMAP (.-)%c")
  return tonumber(Track_MidiChanMap)
end

--A=ultraschall.GetTrackMidiInputChanMap(1)

function ultraschall.GetTrackMidiCTL(tracknumber, str)
--returns the Midi CTL-state, or nil if not existing
-- returns LinkedToMidiChannel, unknown value
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMidiCTL</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer LinkedToMidiChannel, integer unknown = ultraschall.GetTrackMidiCTL(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns linked to Midi channel and an unknown value. Nil if not existing.
    
    It's the entry MIDICTL
  </description>
  <retvals>
    integer LinkedToMidiChannel - linked to midichannel
    integer unknown  - unknown
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, midi, channel, linked, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMidiCTL", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMidiCTL", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMidiCTL", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get midi ctl
  str=str:match("(MIDICTL%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s"))
end

--A,A2=ultraschall.GetTrackMidiCTL(1)

function ultraschall.GetTrackWidth(tracknumber, str)
--returns the Width of the track, or nil if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number width = ultraschall.GetTrackWidth(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns width of the track. 1 if set to +100%. 
    
    Note for TrackStateChunk-enthusiasts: When set to +100%, it is not stored in the TrackStateChunk
    
    It's the entry WIDTH
  </description>
  <retvals>
    number width - width of the track, from -1(-100%) to 1(+100%)
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, width, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackWidth", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackWidth", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackWidth", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get widtch-state
  str=str:match("(WIDTH%s.-)%c")
  local L=str
  if str==nil then return 1 end
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A,A2=ultraschall.GetTrackWidth(1)

function ultraschall.GetTrackPanMode(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackPanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer PanMode = ultraschall.GetTrackPanMode(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns Panmode of the track.
    
    It's the entry PANMODE
  </description>
  <retvals>
    integer PanMode - the Panmode of the track
    - nil - Project Default
    - 0 - Reaper 3.x balance (deprecated)
    - 3 - Stereo Balance/ Mono Pan(Default)
    - 5 - Stereo Balance
    - 6 - Dual Pan
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, panmode, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackPanMode", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then

    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackPanMode", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackPanMode", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get panmode-state
  str=str:match("(PANMODE%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s"))
end

--A,A2=ultraschall.GetTrackPanMode(1)

function ultraschall.GetTrackMidiColorMapFn(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMidiColorMapFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MidiColorMapFn = ultraschall.GetTrackMidiColorMapFn(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns MidiColorMap-Filename of the track. Nil if not existing.
    
    It's the entry MIDICOLORMAPFN
  </description>
  <retvals>
    string MidiColorMapFn - the MidiColorMap-Filename; nil if not existing
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, midicolormap, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMidiColorMapFn", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMidiColorMapFn", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMidiColorMapFn", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get midicolormap-filename
  local Track_MIDICOLORMAPFN=str:match("MIDICOLORMAPFN (.-)%c")
  return Track_MIDICOLORMAPFN
end

--A,A2=ultraschall.GetTrackMidiColorMapFn(1)

function ultraschall.GetTrackMidiBankProgFn(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMidiBankProgFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MidiBankProgFn = ultraschall.GetTrackMidiBankProgFn(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns MidiBankProg-Filename of the track. Nil if not existing.
    
    It's the entry MIDIBANKPROGFN
  </description>
  <retvals>
    string MidiBankProgFn - the MidiBankProg-Filename; nil if not existing
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, midibankprog, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMidiBankProgFn", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMidiBankProgFn", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMidiBankProgFn", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get midibank-prog-filename
  local Track_MIDIBANKPROGFN=str:match("MIDIBANKPROGFN (.-)%c")
  return Track_MIDIBANKPROGFN
end

--A,A2=ultraschall.GetTrackMidiBankProgFn(1)


function ultraschall.GetTrackMidiTextStrFn(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackMidiTextStrFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MidiTextStrFn = ultraschall.GetTrackMidiTextStrFn(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns MidiTextStrFn-Filename of the track. Nil if not existing.
    
    It's the entry MIDIEXTSTRFN
  </description>
  <retvals>
    string MidiTextStrFn - the MidiTextStrFn-Filename; nil if not existing
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, MidiTextStrFn, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackMidiTextStrFn", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackMidiTextStrFn", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackMidiTextStrFn", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get midi-text-str-filename
  local Track_MIDITEXTSTRFN=str:match("MIDITEXTSTRFN (.-)%c")
  return Track_MIDITEXTSTRFN
end

--A,A2=ultraschall.GetTrackMidiTextStrFn(1)

function ultraschall.GetTrackID(tracknumber, str)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string TrackID = ultraschall.GetTrackID(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns TrackID of the track.
    
    It's the entry TRACKID
  </description>
  <retvals>
    string TrackID - the TrackID as GUID
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, trackid, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackID", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackID", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackID", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  --get track-id
  local Track_TRACKID=str:match("TRACKID (.-)%c")
  return Track_TRACKID
end

--A,A2=ultraschall.GetTrackID(1.1)

function ultraschall.GetTrackScore(tracknumber, str)
--returns the Width of the track, or nil if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackScore</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer Score1, integer Score2, number Score3, number Score4  = ultraschall.GetTrackScore(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns Score of the track.
    
    It's the entry SCORE
  </description>
  <retvals>
    integer Score1 - unknown 
    integer Score2 - unknown
    number Score3 - unknown
    number Score4 - unknown
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, get, score, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackScore", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackScore", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackScore", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get score
  str=str:match("(SCORE%s.-)%c")
  local L=str
  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s(.-)%s"))
end

--A,A2,A3,A4=ultraschall.GetTrackScore(1)

function ultraschall.GetTrackVolPan(tracknumber, str)
--returns the Width of the track, or nil if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackVolPan</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number Vol, number Pan, number OverridePanLaw, number unknown, number unknown2 = ultraschall.GetTrackVolPan(integer tracknumber, optional string TrackStateChunk)</functioncall>
  <description>
    returns Vol and Pan-states of the track.
    
    It's the entry VOLPAN
  </description>
  <retvals>
    number Vol - Volume Settings
    - -Inf dB(0) to +12dB (3.98107170553497)
    number Pan - Pan Settings
    - -1(-100%); 0(center); 1(100% R)
    number OverridePanLaw - Override Default Pan Track Law
    - 0dB(1) to -144dB(0.00000006309573)
    number unknown - unknown
    number unknown2 - unknown
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master track; -1, if you want to use the parameter TrackStateChunk instead.
    optional string TrackStateChunk - a TrackStateChunk that you want to use, instead of a given track
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, get, vol, pan, override, panlaw, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackVolPan", "tracknumber", "must be an integer", -1) return nil end
  if tracknumber~=-1 then
  
    -- get trackstatechunk
    local retval, MediaTrack
    if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackVolPan", "tracknumber", "no such track", -2) return nil end
      if tracknumber==0 then MediaTrack=reaper.GetMasterTrack(0)
      else MediaTrack=reaper.GetTrack(0, tracknumber-1)
      end
      retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "test", false)
  else
  end
  if str==nil or str:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetTrackVolPan", "TrackStateChunk", "no valid TrackStateChunk", -3) return nil end
    
  -- get track-vol-pan-state
  str=str:match("(VOLPAN%s.-)%c")

  if str~=nil then str=str.." " else return nil end
  return tonumber(str:match("%s(.-)%s")),
         tonumber(str:match("%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(str:match("%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--L1=reaper.GetTrack(0,0)
--L2,L3=reaper.GetTrackStateChunk(L1, "", true)

--Mst=reaper.GetMasterTrack(0)
--L2,MstStCh=reaper.GetTrackStateChunk(Mst,"",true)

--A,A2,A3,A4,A5=ultraschall.GetTrackVolPan(2)

--reaper.MB(MstStCh,"",0)



--------------------------
---- Set Track States ----
--------------------------

function ultraschall.SetTrackName(tracknumber, name, TrackStateChunk)
--Sets Name of the Track
-- tracknumber - counted from 0
-- name - new name of the track
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackName</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackName(integer tracknumber, string name, optional string TrackStateChunk)</functioncall>
  <description>
    Set the name of a track or a trackstatechunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string name - new name of the track
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, name, set, state, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackName", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackName", "tracknumber", "no such track in the project", -2) return false end
  if type(name)~="string" then ultraschall.AddErrorMessage("SetTrackName", "name", "must be a string", -3) return false end
  
  -- create state-entry
  local str="NAME \""..name.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackName", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)NAME")
  local B3=AA:match("NAME.-%c(.*)")

  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3
end


--ATA,ATA2=ultraschall.SetTrackName(1,"HulaKanula33")

function ultraschall.SetTrackPeakColorState(tracknumber, colorvalue, TrackStateChunk)
--Sets Color of the Track
-- tracknumber - counted from 0
-- colorvalue - a colorvalue that colors this track
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackPeakColorState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackPeakColorState(integer tracknumber, integer colorvalue, optional string TrackStateChunk)</functioncall>
  <description>
    Set the color of the track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer colorvalue - the color for the track
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, color, state, set, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackPeakColorState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackPeakColorState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(colorvalue)~="integer" then ultraschall.AddErrorMessage("SetTrackPeakColorState", "colorvalue", "must be an integer", -3) return false end
  
  if colorvalue<0 then ultraschall.AddErrorMessage("SetTrackPeakColorState", "colorvalue", "must be positive value", -4) return false end
  
  -- create state-entry
  local str="PEAKCOL "..colorvalue
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackPeakColorState", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end      
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)PEAKCOL")
  local B3=AA:match("PEAKCOL.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    local B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--L,LL=ultraschall.SetTrackPeakColorState(-1,1,L3)
--reaper.ShowConsoleMsg(L)

function ultraschall.SetTrackBeatState(tracknumber, beatstate, TrackStateChunk)
--Sets BEAT of a track.
-- tracknumber - counted from 0
-- beatstate - tracktimebase for this track; -1 - Project time base, 0 - Time, 1 - Beats position, length, rate, 2 - Beats position only
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackBeatState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackBeatState(integer tracknumber, integer beatstate, optional string TrackStateChunk)</functioncall>
  <description>
    Set the timebase for a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer beatstate - tracktimebase for this track; -1 - Project time base, 0 - Time, 1 - Beats position, length, rate, 2 - Beats position only
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, beat, state, set, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackBeatState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackBeatState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(beatstate)~="integer" then ultraschall.AddErrorMessage("SetTrackBeatState", "beatstate", "must be an integer", -3) return false end
  
  -- create state-entry
  local str="BEAT "..beatstate
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackBeatState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)BEAT")
  local B3=AA:match("BEAT.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackBeatState(1.1,1, L3)

function ultraschall.SetTrackAutoRecArmState(tracknumber, autorecarmstate, TrackStateChunk)
--Sets Autorecarmstate of the Track
-- tracknumber - counted from 0
-- autorecarmstate - 1 - autorecarm on, <> than 1 - off
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackAutoRecArmState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackAutoRecArmState(integer tracknumber, integer autorecarmstate, optional string TrackStateChunk)</functioncall>
  <description>
    Set the AutoRecArmState for a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer autorecarmstate - autorecarmstate - 1 - autorecarm on, <> than 1 - off
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, autorecarm, rec, arm, track, set, state, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackAutoRecArmState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackAutoRecArmState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(autorecarmstate)~="integer" then ultraschall.AddErrorMessage("SetTrackAutoRecArmState", "autorecarmstate", "must be an integer", -3) return false end
  
  local str=""
  
  -- create state-entry
  if autorecarmstate==1 then str="AUTO_RECARM "..autorecarmstate end
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackAutoRecArmState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)AUTO_RECARM")
  local B3=AA:match("AUTO_RECARM.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  
  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackAutoRecArmState(1,0,L3)

function ultraschall.SetTrackMuteSoloState(tracknumber, Mute, Solo, SoloDefeat, TrackStateChunk)
--Sets Mute, Solo and SoloDefeat of the Track
-- tracknumber - counted from 0
-- Mute - 0 - Mute off, <> than 0 - on
-- Solo - 0 - off, <> than 0 - on
-- Solo Defeat - 0 - off, <> than 0 - on
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMuteSoloState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMuteSoloState(integer tracknumber, integer Mute, integer Solo, integer SoloDefeat, optional string TrackStateChunk)</functioncall>
  <description>
    Set the Track Mute/Solo/Solodefeat for a track or a TrackStateChunk.
    Has no real effect on master track.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer Mute - Mute set to 0 - Mute off, 1 - Mute On
    integer Solo - Solo set to 0 - Solo off, 1 - Solo ignore routing, 2 - Solo on
    integer SoloDefeat - SoloDefeat set to 0 - off, 1 - on
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, mute, solo, solo defeat, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(Mute)~="integer" then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "Mute", "must be an integer", -3) return false end
  if math.type(Solo)~="integer" then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "Solo", "must be an integer", -4) return false end
  if math.type(SoloDefeat)~="integer" then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "SoloDefeat", "must be an integer", -5) return false end
  
  -- create state-entry
  local str="MUTESOLO "..Mute.." "..Solo.." "..SoloDefeat
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMuteSoloState", "TrackStateChunk", "must be a string", -6) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)MUTESOLO")
  local B3=AA:match("MUTESOLO.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackMuteSoloState(1,0,0,0,L3)

function ultraschall.SetTrackIPhaseState(tracknumber, iphasestate, TrackStateChunk)
--Sets IPhase, the Phase-Buttonstate of the Track
-- tracknumber - counted from 0
-- iphasestate - 0 - off, <> than 0 - on
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackIPhaseState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackIPhaseState(integer tracknumber, integer iphasestate, optional string TrackStateChunk)</functioncall>
  <description>
    Sets IPhase, the Phase-Buttonstate of the track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer iphasestate - 0-off, &lt;&gt; than 0-on
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, set, track, state, iphase, phase, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackIPhaseState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackIPhaseState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(iphasestate)~="integer" then ultraschall.AddErrorMessage("SetTrackIPhaseState", "iphasestate", "must be an integer", -3) return false end

  -- create state-entry
  local str="IPHASE "..iphasestate
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackIPhaseState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)IPHASE")
  local B3=AA:match("IPHASE.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackIPhaseState(1,0, L3)

function ultraschall.SetTrackIsBusState(tracknumber, busstate1, busstate2, TrackStateChunk)
--Sets ISBUS-state of the Track, if it's a folder track
-- tracknumber - counted from 0
-- track is no folder: busstate1=0, busstate2=0
-- track is a folder: busstate1=1, busstate2=1
-- track is a folder but view of all subtracks not compactible: busstate1=1, busstate2=2
-- track is last track in folder(no tracks of subfolders follow): busstate1=2, busstate2=-1  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackIsBusState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackIsBusState(integer tracknumber, integer busstate1, integer busstate2, optional string TrackStateChunk)</functioncall>
  <description>
    Sets ISBUS-state of the track or a TrackStateChunk; if it's a folder track.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    integer busstate1=0, integer busstate2=0 - track is no folder
    integer busstate1=1, integer busstate2=1 - track is a folder
    integer busstate1=1, integer busstate2=2 - track is a folder but view of all subtracks not compactible
    integer busstate1=2, integer busstate2=-1 - track is last track in folder(no tracks of subfolders follow)
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, busstate, folder, subfolder, compactible, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackIsBusState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber==0 or tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackIsBusState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(busstate1)~="integer" then ultraschall.AddErrorMessage("SetTrackIsBusState", "busstate1", "must be an integer", -3) return false end
  if math.type(busstate2)~="integer" then ultraschall.AddErrorMessage("SetTrackIsBusState", "busstate2", "must be an integer", -4) return false end
  
  -- create state-entry
  local str="ISBUS "..busstate1.." "..busstate2

  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    Mediatrack=reaper.GetTrack(0,tracknumber-1)
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackIsBusState", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end  

  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)ISBUS")
  local B3=AA:match("ISBUS.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackIsBusState(1,1,0,L3)



function ultraschall.SetTrackBusCompState(tracknumber, buscompstate1, buscompstate2, TrackStateChunk)
--Sets BUSCOMP-state of the Track, if tracks in a folder are compacted or not
-- tracknumber - counted from 0
-- BusCompState1:
-- 0 - no compacting
-- 1 - compacted tracks
-- 2 - minimized tracks

-- BusCompState2:
-- 0 - unknown
-- 1 - unknown  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackBusCompState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackBusCompState(integer tracknumber, integer buscompstate1, integer buscompstate2, optional string TrackStateChunk)</functioncall>
  <description>
    Sets BUSCOMP-state of the track or a TrackStateChunk; This is the state, if tracks in a folder are compacted or not.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    integer - buscompstate1 - 0 - no compacting, 1 - compacted tracks, 2 - minimized tracks
    integer - buscompstate2 - 0 - unknown, 1 - unknown
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, compacting, busstate, folder, minimize, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackBusCompState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber==0 or tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackBusCompState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(buscompstate1)~="integer" then ultraschall.AddErrorMessage("SetTrackBusCompState", "buscompstate1", "must be an integer", -3) return false end
  if math.type(buscompstate2)~="integer" then ultraschall.AddErrorMessage("SetTrackBusCompState", "buscompstate2", "must be an integer", -4) return false end
  
  -- create state-entry
  local str="BUSCOMP "..buscompstate1.." "..buscompstate2
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    Mediatrack=reaper.GetTrack(0,tracknumber-1)
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackBusCompState", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end

  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)BUSCOMP")
  local B3=AA:match("BUSCOMP.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackBusCompState(1,0,1,L3)

function ultraschall.SetTrackShowInMixState(tracknumber, MCPvisible, MCP_FX_visible, MCP_TrackSendsVisible, TCPvisible, ShowInMix5, ShowInMix6, ShowInMix7, ShowInMix8, TrackStateChunk)
-- Sets SHOWINMIX, that sets visibility of track in MCP and TCP
-- MCPvisible - 0 invisible, 1 visible
-- MCP_FX_visible - 0 visible, 1 FX-Parameters visible, 2 invisible
-- MCPTrackSendsVisible - 0 & 1.1 and higher TrackSends in MCP visible, every other number makes them invisible
-- TCPvisible - 0 track is invisible in TCP, 1 track is visible in TCP
-- ShowInMix5 - unknown
-- ShowInMix6 - unknown
-- ShowInMix7 - unknown
-- ShowInMix8 - unknown
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackShowInMixState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackShowInMixState(integer tracknumber, integer MCPvisible, number MCP_FX_visible, number MCP_TrackSendsVisible, integer TCPvisible, number ShowInMix5, integer ShowInMix6, integer ShowInMix7, integer ShowInMix8, optional string TrackStateChunk)</functioncall>
  <description>
    Sets SHOWINMIX, that sets visibility of track or TrackStateChunk in MCP and TCP.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer MCPvisible - 0 invisible, 1 visible
    number MCP_FX_visible - 0 visible, 1 FX-Parameters visible, 2 invisible
    number MCPTrackSendsVisible - 0 & 1.1 and higher TrackSends in MCP visible, every other number makes them invisible
    integer TCPvisible - 0 track is invisible in TCP, 1 track is visible in TCP
    - with Master-Track, 1 shows all active envelopes, 0 hides all active envelopes
    number ShowInMix5 - unknown
    integer ShowInMix6 - unknown
    integer ShowInMix7 - unknown
    integer ShowInMix8 - unknown
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, state, set, show in mix, mcp, fx, tcp, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackShowInMixState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(MCPvisible)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "MCPvisible", "must be an integer", -3) return false end
  if type(MCP_FX_visible)~="number" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "MCP_FX_visible", "must be a number", -4) return false end
  if type(MCP_TrackSendsVisible)~="number" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "MCP_TrackSendsVisible", "must be a number", -5) return false end
  if math.type(TCPvisible)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "TCPvisible", "must be an integer", -6) return false end
  if type(ShowInMix5)~="number" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "ShowInMix5", "must be a number", -7) return false end
  if math.type(ShowInMix6)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "ShowInMix6", "must be an integer", -8) return false end
  if math.type(ShowInMix7)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "ShowInMix7", "must be an integer", -9) return false end
  if math.type(ShowInMix8)~="integer" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "ShowInMix8", "must be an integer", -10) return false end
  
  -- create state-entry
  local str="SHOWINMIX "..MCP_FX_visible.." "..MCP_FX_visible.." "..MCP_TrackSendsVisible.." "..TCPvisible.." "..ShowInMix5.." "..ShowInMix6.." "..ShowInMix7.." "..ShowInMix8

  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackShowInMixState", "TrackStateChunk", "must be a string", -11) return false end
    AA=TrackStateChunk
  end

  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)SHOWINMIX")
  local B3=AA:match("SHOWINMIX.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  
  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end


--ATA,ATA2=ultraschall.SetTrackShowInMixState(1,1,1,1,1,0,0,0,0,L3)

function ultraschall.SetTrackFreeModeState(tracknumber, freemodestate, TrackStateChunk)
--Sets FREEMODE-State of the track
-- tracknumber - counted from 0
-- freemodestate- 0 - off, 1 - on
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackFreeModeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackFreeModeState(integer tracknumber, integer freemodestate, optional string TrackStateChunk)</functioncall>
  <description>
    Sets FREEMODE-state of a track or a TrackStateChunk; enables Track-Free Item Positioning.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    integer freemodestate - 0 - off, 1 - on
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, trackfree, item, positioning, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackFreeModeState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackFreeModeState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(freemodestate)~="integer" then ultraschall.AddErrorMessage("SetTrackFreeModeState", "freemodestate", "must be an integer", -3) return false end

  -- create state-entry
  local str="FREEMODE "..freemodestate

  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackFreeModeState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)FREEMODE")
  local B3=AA:match("FREEMODE.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- set trackstatechunk and include new-state
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackFreeModeState(1,0,L3)

function ultraschall.SetTrackRecState(tracknumber, ArmState, InputChannel, MonitorInput, RecInput, MonitorWhileRec, presPDCdelay, RecordingPath, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackRecState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackRecState(integer tracknumber, integer ArmState, integer InputChannel, integer MonitorInput, integer RecInput, integer MonitorWhileRec, integer presPDCdelay, integer RecordingPath, optional string TrackStateChunk)</functioncall>
  <description>
    Sets REC, that sets the Recording-state of the track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer ArmState - set to 1(armed) or 0(unarmed)
    
    integer InputChannel - the InputChannel
    --1 - No Input
    -1-16(more?) - Mono Input Channel
    -1024 - Stereo Channel 1 and 2
    -1026 - Stereo Channel 3 and 4
    -1028 - Stereo Channel 5 and 6
    -...
    -5056 - Virtual MIDI Keyboard all Channels
    -5057 - Virtual MIDI Keyboard Channel 1
    -...
    -5072 - Virtual MIDI Keyboard Channel 16
    -5088 - All MIDI Inputs - All Channels
    -5089 - All MIDI Inputs - Channel 1
    -...
    -5104 - All MIDI Inputs - Channel 16
    
    integer Monitor Input - 0 monitor off, 1 monitor on, 2 monitor on tape audio style
    
    integer RecInput - the rec-input type
    -0 input(Audio or Midi)
    -1 Record Output Stereo
    -2 Disabled, Input Monitoring Only
    -3 Record Output Stereo, Latency Compensated
    -4 Record Output MIDI
    -5 Record Output Mono
    -6 Record Output Mono, Latency Compensated
    -7 MIDI overdub
    -8 MIDI replace
    -9 MIDI touch replace
    -10 Record Output Multichannel
    -11 Record Output Multichannel, Latency Compensated 
    -12 Record Input Force Mono
    -13 Record Input Force Stereo
    -14 Record Input Force Multichannel
    -15 Record Input Force MIDI
    -16 MIDI latch replace
    
    integer MonitorWhileRec - Monitor Trackmedia when recording, 0 is off, 1 is on
    
    integer presPDCdelay - preserve PDC delayed monitoring in media items
    
    integer RecordingPath - 0 Primary Recording-Path only, 1 Secondary Recording-Path only, 2 Primary Recording Path and Secondary Recording Path(for invisible backup)
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, armstate, inputchannel, monitorinput, recinput, monitorwhilerec, pdc, recordingpath, midi, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackRecState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(ArmState)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "ArmState", "must be an integer", -3) return false end
  if math.type(InputChannel)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "InputChannel", "must be an integer", -4) return false end
  if math.type(MonitorInput)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "MonitorInput", "must be an integer", -5) return false end
  if math.type(RecInput)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "RecInput", "must be an integer", -6) return false end
  if math.type(MonitorWhileRec)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "MonitorWhileRec", "must be an integer", -7) return false end
  if math.type(presPDCdelay)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "presPDCdelay", "must be an integer", -8) return false end
  if math.type(RecordingPath)~="integer" then ultraschall.AddErrorMessage("SetTrackRecState", "RecordingPath", "must be an integer", -9) return false end
  
  -- create state-entry
  local str="REC "..ArmState.." "..InputChannel.." "..MonitorInput.." "..RecInput.." "..MonitorWhileRec.." "..presPDCdelay.." "..RecordingPath
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackRecState", "TrackStateChunk", "must be a string", -10) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1=AA:match("(.-)REC")
  local B3=AA:match("REC.-%c(.*)")
  
  -- set trackstatechunk and include new-state
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end


--ATA,ATA2=ultraschall.SetTrackRecState(1,0,1,1,1,1,1,1,L3)


function ultraschall.SetTrackVUState(tracknumber, VUState, TrackStateChunk)
--Sets VU-State
-- tracknumber - counted from 0
-- VUState - 0 if MultiChannelMetering is off, 2 if MultichannelMetering is on, 3 Metering is off
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackVUState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackVUState(integer tracknumber, integer VUState, optional string TrackStateChunk)</functioncall>
  <description>
    Sets VU-state of a track or a TrackStateChunk; the way metering shows.
    
    Has no real effect on master track.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer VUState -  0 MultiChannelMetering is off, 2 MultichannelMetering is on, 3 Metering is off;seems to have no effect on MasterTrack
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, armstate, vu, metering, multichannel, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackVUState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackVUState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(VUState)~="integer" then ultraschall.AddErrorMessage("SetTrackVUState", "VUState", "must be an integer", -3) return false end

  -- create state-entry
  local str="VU "..VUState
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then 
      Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackVUState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry
  local B1=AA:match("(.-)VU")
  local B3=AA:match("VU.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  
  -- insert new state into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--TR=reaper.GetMasterTrack(0)
--Ol,TRSC=reaper.GetTrackStateChunk(TR,"",false)
--ATA,ATA2=ultraschall.SetTrackVUState(1,0,L3)

function ultraschall.SetTrackHeightState(tracknumber, heightstate1, heightstate2, TrackStateChunk)
-- sets TRACKHEIGHT
-- tracknumber - number of the track, starting by 0
-- heightstate1 - 24 up to 443
-- heightstate2 - 0 - use height, 1 - compact the track and ignore the height
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackHeightState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackHeightState(integer tracknumber, integer height, integer heightstate2, optional string TrackStateChunk)</functioncall>
  <description>
    Sets TRACKHEIGHT-state; the height and compacted state of the track or a TrackStateChunk.
    
    Has no visible effect on the master-track.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer height -  24 up to 443 pixels
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, trackheight, height, compact, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackHeightState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackHeightState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(heightstate1)~="integer" then ultraschall.AddErrorMessage("SetTrackHeightState", "height", "must be an integer, between 24 and 443", -3) return false end
  if math.type(heightstate2)~="integer" then ultraschall.AddErrorMessage("SetTrackHeightState", "heightstate2", "must be an integer", -4) return false end
  
  -- create state-entry
  local str="TRACKHEIGHT "..heightstate1.." "..heightstate2
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackHeightState", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)TRACKHEIGHT")
  local B3=AA:match("TRACKHEIGHT.-%c(.*)")
  
  -- insert new state-entry into trackstatechunk
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--reaper.MB(L3,"",0)
--TRIT,TRIT2=ultraschall.SetTrackHeightState(1, 10, 0, L3)

function ultraschall.SetTrackINQState(tracknumber, INQ1, INQ2, INQ3, INQ4, INQ5, INQ6, INQ7, INQ8, TrackStateChunk)
-- sets INQ
-- tracknumber - number of the track, starting by 0
-- INQ1 - unknown
-- INQ2 - unknown
-- INQ3 - unknown
-- INQ4 - unknown
-- INQ5 - unknown
-- INQ6 - unknown
-- INQ7 - unknown
-- INQ8 - unknown
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackINQState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackINQState(integer tracknumber, integer quantMIDI, integer quantPOS, integer quantNoteOffs, number quantToFractBeat, integer quantStrength, integer swingStrength, integer quantRangeMin, integer quantRangeMax, optional string TrackStateChunk)</functioncall>
  <description>
    Sets INQ-state, mostly the quantize-settings for MIDI, of a track or a TrackStateChunk, as set in the "Track: View track recording settings (MIDI quantize, file format/path) for last touched track"-dialog (action 40604)
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer quantMIDI -  quantize MIDI; 0 or 1
    integer quantPOS -  quantize to position; -1,prev; 0, nearest; 1, next
    integer quantNoteOffs -  quantize note-offs; 0 or 1
    number quantToFractBeat -  quantize to (fraction of beat)
    integer quantStrength -  quantize strength; -128 to 127
    integer swingStrength -  swing strength; -128 to 127
    integer quantRangeMin -  quantize range minimum; -128 to 127
    integer quantRangeMax -  quantize range maximum; -128 to 127
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, inq, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackINQState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(INQ1)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ1", "must be an integer", -3) return false end
  if math.type(INQ2)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ2", "must be an integer", -4) return false end
  if math.type(INQ3)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ3", "must be an integer", -5) return false end
  if type(INQ4)~="number" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ4", "must be a number", -6) return false end
  if math.type(INQ5)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ5", "must be an integer", -7) return false end
  if math.type(INQ6)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ6", "must be an integer", -8) return false end
  if math.type(INQ7)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ7", "must be an integer", -9) return false end
  if math.type(INQ8)~="integer" then ultraschall.AddErrorMessage("SetTrackINQState", "INQ8", "must be an integer", -10) return false end
  
  -- create state-entry
  local str="INQ "..INQ1.." "..INQ2.." "..INQ3.." "..INQ4.." "..INQ5.." "..INQ6.." "..INQ7.." "..INQ8
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackINQState", "TrackStateChunk", "must be a string", -11) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry
  local B1=AA:match("(.-)INQ")
  local B3=AA:match("INQ.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3
end

--reaper.MB(MstStCh,"",0)

--ATA, ATA2=ultraschall.SetTrackINQState(nil, 1, 1, 1, 1, 3, 0, 0, 0, L3)
--reaper.MB(ATA2,"",0)


function ultraschall.SetTrackNChansState(tracknumber, NChans, TrackStateChunk)
--Sets NCHANS, the number of channels for this track, as set in the routing
-- tracknumber - counted from 0
-- NChans - 2 to 64, counted every second channel (2,4,6,8,etc) with stereo-tracks. Unknown, if Multichannel and Mono-tracks count differently
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackNChansState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackNChansState(integer tracknumber, integer NChans, optional string TrackStateChunk)</functioncall>
  <description>
    Sets NCHAN-state; the number of channels in this track or a TrackStateChunk, as set in the routing.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer NChans - 2 to 64, counted every second channel (2,4,6,8,etc) with stereo-tracks. Unknown, if Multichannel and Mono-tracks count differently.
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, channels, number, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackNChansState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackNChansState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(NChans)~="integer" then ultraschall.AddErrorMessage("SetTrackNChansState", "NChans", "must be an integer", -3) return false end
  
  -- create new state-entry
  local str="NCHAN "..NChans
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackNChansState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)NCHAN")
  local B3=AA:match("NCHAN.-%c(.*)")
  
  -- insert new state-entry into trackstatechunk
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA, ATA2 = ultraschall.SetTrackNChansState(nil,1, L3)

--reaper.MB(ATA2,"",0)



function ultraschall.SetTrackBypFXState(tracknumber, FXBypassState, TrackStateChunk)
--Sets FX, FX-Bypass-state
-- tracknumber - counted from 0
-- FXBypassState - 0 bypass, 1 activate fx; has only effect, if FX or instruments are added to this track
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackBypFXState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackBypFXState(integer tracknumber, integer FXBypassState, optional string TrackStateChunk)</functioncall>
  <description>
    Sets FX, FX-Bypass-state of the track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer FXBypassState  - 0 bypass, 1 activate fx; has only effect, if FX or instruments are added to this track
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, track, set, fx, bypass, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackBypFXState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackBypFXState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(FXBypassState)~="integer" then ultraschall.AddErrorMessage("SetTrackBypFXState", "FXBypassState", "must be an integer", -3) return false end
  
  -- create new state-entry
  local str="FX "..FXBypassState
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackBypFXState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)FX")
  local B3=AA:match("FX.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackBypFXState(1,1,MstStCh)

function ultraschall.SetTrackPerfState(tracknumber, Perf, TrackStateChunk)
--Sets PERF, TrackPerformance-State
-- tracknumber - counted from 0
-- Perf - 0 - allow anticipative FX + allow media buffering<br>
-- 1 - allow anticipative FX + prevent media buffering <br>
-- 2 - prevent anticipative FX + allow media buffering<br>
-- 3 - prevent anticipative FX + prevent media buffering<br>
--settings seem to repeat with higher numbers (e.g. 4(like 0) - allow anticipative FX + allow media buffering), but to be safe keep it between 0 and 3
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackPerfState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackPerfState(integer tracknumber, integer Perf, optional string TrackStateChunk)</functioncall>
  <description>
    Sets PERF, the TrackPerformance-State of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    integer Perf  - performance-state
    - 0 - allow anticipative FX + allow media buffering
    - 1 - allow anticipative FX + prevent media buffering
    - 2 - prevent anticipative FX + allow media buffering
    - 3 - prevent anticipative FX + prevent media buffering
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, state, set, fx, performance, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackPerfState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackPerfState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(Perf)~="integer" then ultraschall.AddErrorMessage("SetTrackPerfState", "FXBypassState", "must be an integer", -3) return false end
  
  -- create new state-entry
  local str="PERF "..Perf
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackPerfState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)PERF")
  local B3=AA:match("PERF.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1..""..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1..""..str.."\n"..B3
end

--reaper.MB(MstStCh,"",0)
--ultraschall.WriteValueToFile("c:\\hula2.txt",MstStCh)

--ATA, ATA2 = ultraschall.SetTrackPerfState(nil, 0, L3)
--reaper.MB(ATA2,"",0)



function ultraschall.SetTrackMIDIOutState(tracknumber, MIDIOutState, TrackStateChunk)
--Sets MIDIOut-State
-- tracknumber - counted from 0
-- MIDIOutState - 
--  -1 no output
-- 416 - microsoft GS wavetable synth - send to original channels
-- 417-432 - microsoft GS wavetable synth - send to channel state minus 416
-- -31 - no Output, send to original channel 1
-- -16 - no Output, send to original channel 16
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMIDIOutState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMIDIOutState(integer tracknumber, integer MIDIOutState, optional string TrackStateChunk)</functioncall>
  <description>
    Sets MIDIOUT, the state of MIDI out for this track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer MIDIOutState - 
    - %-1 no output
    - 416 %- microsoft GS wavetable synth-send to original channels
    - 417-432 %- microsoft GS wavetable synth-send to channel state minus 416
    - -31 %- no Output, send to original channel 1
    - -16 %- no Output, send to original channel 16
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, state, set, midi, midiout, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMIDIOutState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMIDIOutState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(MIDIOutState)~="integer" then ultraschall.AddErrorMessage("SetTrackMIDIOutState", "MIDIOutState", "must be an integer", -3) return false end

  -- create new state-entry
  local str="MIDIOUT "..MIDIOutState
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMIDIOutState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry into the trackstatechunk
  local B1=AA:match("(.-)MIDIOUT")
  local B3=AA:match("MIDIOUT.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into the trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA, ATA2 = ultraschall.SetTrackMIDIOutState(nil,8, L3)

--reaper.MB(ATA2,"",0)


function ultraschall.SetTrackMainSendState(tracknumber, MainSendOn, ParentChannels, TrackStateChunk)
-- sets MAINSEND-state
-- tracknumber - number of the track, starting by 0
-- MainSendOn - on(1) or off(0)
-- ParentChannels - the ParentChannels(0-64), interpreted as beginning with ParentChannels to ParentChannels+NCHAN
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMainSendState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMainSendState(integer tracknumber, integer MainSendOn, integer ParentChannels, optional string TrackStateChunk)</functioncall>
  <description>
    Sets MAINSEND, as set in the routing-settings, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer MainSendOn - on(1) or off(0)
    integer ParentChannels  - the ParentChannels(0-64), interpreted as beginning with ParentChannels to ParentChannels+NCHAN
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, state, set, mainsend, parent channels, parent, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMainSendState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMainSendState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(MainSendOn)~="integer" then ultraschall.AddErrorMessage("SetTrackMainSendState", "MainSendOn", "must be an integer", -3) return false end
  if math.type(ParentChannels)~="integer" then ultraschall.AddErrorMessage("SetTrackMainSendState", "ParentChannels", "must be an integer", -4) return false end

  -- create new state-entry
  local str="MAINSEND "..MainSendOn.." "..ParentChannels
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMainSendState", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MAINSEND")
  local B3=AA:match("MAINSEND.-%c(.*)")
  
  -- insert new state-entry into trackstatechunk
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--A,B=ultraschall.SetTrackMainSendState(1, 1, 1)
--reaper.MB(MstStCh,"",0)

function ultraschall.SetTrackLockState(tracknumber, LockedState, TrackStateChunk)
--Sets LOCK-State, as set by the menu entry Lock Track Controls
-- tracknumber - counted from 0
-- LockedState - 1 - locked, 0 - unlocked
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackLockState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackLockState(integer tracknumber, integer LockedState, optional string TrackStateChunk)</functioncall>
  <description>
    Sets LOCK-State, as set by the menu entry Lock Track Controls, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    integer LockedState  - 1 - locked, 0 - unlocked
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, lock, state, set, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackLockState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackLockState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(LockedState)~="integer" then ultraschall.AddErrorMessage("SetTrackLockState", "LockedState", "must be an integer", -3) return false end

  -- create new state-entry
  local str="LOCK "..LockedState
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B, B1, B3
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackLockState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry and insert new state-entry into trackstatechunk
  if AA:match("LOCK")=="LOCK" then
    B1=AA:match("(.-)LOCK")
    B3=AA:match("LOCK.-%c(.*)")
  else 
    B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackLockState(1,0, L3)
--reaper.MB(ATA2,"",0)

function ultraschall.SetTrackLayoutNames(tracknumber, TCP_Layoutname, MCP_Layoutname, TrackStateChunk)
--Sets LAYOUTS, the MCP and TCP-layout by name of the layout as defined in the theme.
-- tracknumber - counted from 0
-- TCP_Layoutname - name of the TrackControlPanel-Layout from the theme to use
-- MCP_Layoutname - name of the MixerControlPanel-Layout from the theme to use
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackLayoutNames</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackLayoutNames(integer tracknumber, string TCP_Layoutname, string MCP_Layoutname, optional string TrackStateChunk)</functioncall>
  <description>
    Sets LAYOUTS, the MCP and TCP-layout by name of the layout as defined in the theme, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string TCP_Layoutname  - name of the TrackControlPanel-Layout from the theme to use
    string MCP_Layoutname  - name of the MixerControlPanel-Layout from the theme to use
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, state, set, mcp, tcp, layout, mixer, trackcontrol, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackLayoutNames", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackLayoutNames", "tracknumber", "no such track in the project", -2) return false end
  if type(TCP_Layoutname)~="string" then ultraschall.AddErrorMessage("SetTrackLayoutNames", "TCP_Layoutname", "must be a string", -3) return false end
  if type(MCP_Layoutname)~="string" then ultraschall.AddErrorMessage("SetTrackLayoutNames", "MCP_Layoutname", "must be a string", -4) return false end
  
  -- create new state-entry
  local str="LAYOUTS \""..TCP_Layoutname.."\" \""..MCP_Layoutname.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackLayoutNames", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)LAYOUTS")
  local B3=AA:match("LAYOUTS.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into statechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1..""..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1..""..str.."\n"..B3
end

--A,BUB=ultraschall.SetTrackLayoutNames(nil,"Ultraschall 2","", L3)
--reaper.MB(BUB,"",0)


function ultraschall.SetTrackAutomodeState(tracknumber, automodestate, TrackStateChunk)
--Sets Automode-State, as set by the menu entry Set Track Automation Mode
-- tracknumber - counted from 0
-- automodestate - 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackAutomodeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackAutomodeState(integer tracknumber, integer automodestate, optional string TrackStateChunk)</functioncall>
  <description>
    Sets AUTOMODE-State, as set by the menu entry Set Track Automation Mode, for a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer automodestate - 0 - trim/read, 1 - read, 2 - touch, 3 - write, 4 - latch
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, automode, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackAutomodeState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackAutomodeState", "tracknumber", "no such track in the project", -2) return false end
  if math.type(automodestate)~="integer" then ultraschall.AddErrorMessage("SetTrackAutomodeState", "automodestate", "must be an integer", -3) return false end

  -- create new state-entry
  local str="AUTOMODE "..automodestate
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackAutomodeState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)AUTOMODE")
  local B3=AA:match("AUTOMODE.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1..""..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1..""..str.."\n"..B3
end

--ATA, ATA2=ultraschall.SetTrackAutomodeState(nil,2,L3)
--reaper.MB(ATA2,"",0)


function ultraschall.SetTrackIcon_Filename(tracknumber, Iconfilename_with_path, TrackStateChunk)
--Sets TRACKIMGFN, the trackicon-filename
-- tracknumber - counted from 0
-- Iconfilename_with_path - filename with path
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackIcon_Filename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackIcon_Filename(integer tracknumber, string Iconfilename_with_path, optional string TrackStateChunk)</functioncall>
  <description>
    Sets TRACKIMGFN, the trackicon-filename with path, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; -1 if you want to use parameter TrackStateChunk
    string Iconfilename_with_path - filename+path of the imagefile to use as the trackicon; "", to remove track-icon
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, state, track, set, trackicon, image, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackIcon_Filename", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackIcon_Filename", "tracknumber", "no such track in the project", -2) return false end
  if type(Iconfilename_with_path)~="string" then ultraschall.AddErrorMessage("SetTrackIcon_Filename", "Iconfilename_with_path", "must be a string", -3) return false end

  -- create new state-entry
  local str="TRACKIMGFN \""..Iconfilename_with_path.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackIcon_Filename", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)TRACKIMGFN")
  local B3=AA:match("TRACKIMGFN.-%c(.*)")
  
  -- insert new state-entry into trackstatechunk
  if B1==nil then B1=AA:match("(.-)FX") B3=AA:match(".-(FX.*)") end
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1..""..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3
end


--A,A2=ultraschall.SetTrackIcon_Filename(1,"",L3)
--reaper.CF_SetClipboard(A2)
--reaper.ShowConsoleMsg(A2,"",0)

--ultraschall.ShowLastErrorMessage()
--reaper.MB(MstStCh,"",0)
--ultraschall.WriteValueToFile("c:\\hula2.txt",MstStCh)


function ultraschall.SetTrackMidiInputChanMap(tracknumber, InputChanMap, TrackStateChunk)
--Sets MIDI_INPUT_CHANMAP, as set in the Input-MIDI->Map Input to Channel menu.
-- tracknumber - counted from 0
-- InputChanMap - 0 for channel 1, 2 for channel 2, etc. -1 if not existing.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMidiInputChanMap</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMidiInputChanMap(integer tracknumber, integer InputChanMap, optional string TrackStateChunk)</functioncall>
  <description>
    Sets MIDI_INPUT_CHANMAP, as set in the Input-MIDI->Map Input to Channel menu, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer InputChanMap - 0 for channel 1, 2 for channel 2, etc. -1 if not existing; nil, to remove MidiInputChanMap
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, input, chanmap, channelmap, midi, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiInputChanMap", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMidiInputChanMap", "tracknumber", "no such track in the project", -2) return false end
  if math.type(InputChanMap)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiInputChanMap", "InputChanMap", "must be an integer", -3) return false end

  -- create new state-entry
  local str="MIDI_INPUT_CHANMAP "..InputChanMap
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMidiInputChanMap", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end

  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MIDI_INPUT_CHANMAP")
  local B3=AA:match("MIDI_INPUT_CHANMAP.-%c(.*)")
  if B1==nil then B1=AA:match("(.-REC.-\n)") B3=AA:match(".-TRACK.-\n(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1..""..str.."\n"..B3,false)
  else
    B=true
  end

  return B, B1..""..str.."\n"..B3
end

--reaper.ClearConsole()
--ATA,ATA2=ultraschall.SetTrackMidiInputChanMap(1,-1,L3)
--reaper.ClearConsole()
--reaper.ShowConsoleMsg(ATA2,"",0)


function ultraschall.SetTrackMidiCTL(tracknumber, LinkedToMidiChannel, unknown, TrackStateChunk)
-- sets MIDICTL-state
-- tracknumber - number of the track, starting by 0
-- Parameters:
-- LinkedToMidiChannel
-- unknown - ?
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMidiCTL</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMidiCTL(integer tracknumber, integer LinkedToMidiChannel, integer unknown, optional string TrackStateChunk)</functioncall>
  <description>
    sets MIDICTL-state, the linkage to Midi-Channels of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer LinkedToMidiChannel - unknown; nil, to remove this setting completely
    integer unknown - unknown
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, linked, midi, midichannel, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiCTL", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMidiCTL", "tracknumber", "no such track in the project", -2) return false end
  if math.type(LinkedToMidiChannel)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiCTL", "LinkedToMidiChannel", "must be an integer", -3) return false end
  if math.type(unknown)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiCTL", "unknown", "must be an integer", -4) return false end

  -- create new state-entry
  local str="MIDICTL "..LinkedToMidiChannel.." "..unknown
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMidiCTL", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MIDICTL")
  local B3=AA:match("MIDICTL.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackMidiCTL(1, 0, 0, L3)
--reaper.ClearConsole()
--reaper.ShowConsoleMsg(ATA2)


function ultraschall.SetTrackID(tracknumber, TrackID, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackID(integer tracknumber, string guid, optional string TrackStateChunk)</functioncall>
  <description>
    sets the track-id, which must be a valid GUID, of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string guid - a valid GUID. Can be generated with the native Reaper-function reaper.genGuid()
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, guid, trackid, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackID", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackID", "tracknumber", "no such track in the project", -2) return false end
  if type(TrackID)~="string" then ultraschall.AddErrorMessage("SetTrackID", "TrackID", "must be a string", -3) return false end


  -- create new state-entry
  local str="TRACKID "..TrackID
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackID", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)TRACKID")
  local B3=AA:match("TRACKID.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackID(nil, "{12345678-1111-1111-1111-123456789012}", L3)

function ultraschall.SetTrackMidiColorMapFn(tracknumber, MIDI_ColorMapFN, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMidiColorMapFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMidiColorMapFn(integer tracknumber, string MIDI_ColorMapFN, optional string TrackStateChunk)</functioncall>
  <description>
    sets the filename+path to the MIDI-ColorMap-graphicsfile of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string MIDI_ColorMapFN - filename+path to the MIDI-ColorMap-file; "", to remove it
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, midi, colormap, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiColorMapFn", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMidiColorMapFn", "tracknumber", "no such track in the project", -2) return false end
  if type(MIDI_ColorMapFN)~="string" then ultraschall.AddErrorMessage("SetTrackMidiColorMapFn", "MIDI_ColorMapFN", "must be a string", -3) return false end

  -- create new state-entry
  local str="MIDICOLORMAPFN \""..MIDI_ColorMapFN.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMidiColorMapFn", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MIDICOLORMAPFN")
  local B3=AA:match("MIDICOLORMAPFN.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackMidiColorMapFn(1, "", L3)

function ultraschall.SetTrackMidiBankProgFn(tracknumber, MIDIBankProgFn, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMidiBankProgFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMidiBankProgFn(integer tracknumber, string MIDIBankProgFn, optional string TrackStateChunk)</functioncall>
  <description>
    sets the filename+path to the MIDI-Bank-Prog-file of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string MIDIBankProgFn - filename+path to the MIDI-Bank-Prog-file; "", to remove it
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, midi, bank, prog, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiBankProgFn", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMidiBankProgFn", "tracknumber", "no such track in the project", -2) return false end
  if type(MIDIBankProgFn)~="string" then ultraschall.AddErrorMessage("SetTrackMidiBankProgFn", "MIDIBankProgFn", "must be a string", -3) return false end

  -- create new state-entry
  local str="MIDIBANKPROGFN \""..MIDIBankProgFn.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMidiBankProgFn", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MIDIBANKPROGFN")
  local B3=AA:match("MIDIBANKPROGFN.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackMidiBankProgFn(1, "", L3)

--reaper.MB(ATA2,"",0)

function ultraschall.SetTrackMidiTextStrFn(tracknumber, MIDITextStrFn, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackMidiTextStrFn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackMidiTextStrFn(integer tracknumber, string MIDITextStrFn, optional string TrackStateChunk)</functioncall>
  <description>
    sets the filename+path to the MIDI-Text-Str-file of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string MIDITextStrFn - filename+path to the MIDI-Text-Str-file; "", to remove it
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, midi, text, str, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackMidiTextStrFn", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackMidiTextStrFn", "tracknumber", "no such track in the project", -2) return false end
  if type(MIDITextStrFn)~="string" then ultraschall.AddErrorMessage("SetTrackMidiTextStrFn", "MIDITextStrFn", "must be a string", -3) return false end

  -- create new state-entry
  local str="MIDITEXTSTRFN \""..MIDITextStrFn.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackMidiTextStrFn", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)MIDITEXTSTRFN")
  local B3=AA:match("MIDITEXTSTRFN.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackMidiTextStrFn(nil, "", L3)

function ultraschall.SetTrackPanMode(tracknumber, panmode, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackPanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackPanMode(integer tracknumber, integer panmode, optional string TrackStateChunk)</functioncall>
  <description>
    sets the panmode for a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer panmode - the Panmode of the track
                            -nil - Project Default
                            -0 - Reaper 3.x balance (deprecated)
                            -3 - Stereo Balance/ Mono Pan(Default)
                            -5 - Stereo Balance
                            -6 - Dual Pan
                            -7 - unknown mode
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, panmode, pan, balance, dual pan, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackPanMode", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackPanMode", "tracknumber", "no such track in the project", -2) return false end
  if math.type(panmode)~="integer" then ultraschall.AddErrorMessage("SetTrackPanMode", "panmode", "must be an integer", -3) return false end

  -- create new state-entry
  local str="PANMODE \""..panmode.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackPanMode", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)PANMODE")
  local B3=AA:match("PANMODE.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackPanMode(nil, 1, L3)

function ultraschall.SetTrackWidth(tracknumber, width, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackWidth(integer tracknumber, number width, optional string TrackStateChunk)</functioncall>
  <description>
    sets the width of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    number width - width of the track, from -1(-100%) to 1(+100%)
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, width, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackWidth", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackWidth", "tracknumber", "no such track in the project", -2) return false end
  if type(width)~="number" then ultraschall.AddErrorMessage("SetTrackWidth", "width", "must be a number", -3) return false end

  -- create new state-entry
  local str="WIDTH \""..width.."\""
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackWidth", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)WIDTH")
  local B3=AA:match("WIDTH.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ATA,ATA2=ultraschall.SetTrackWidth(nil, -0.9, L3)

function ultraschall.SetTrackScore(tracknumber, unknown1, unknown2, unknown3, unknown4, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackScore</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackScore(integer tracknumber, integer unknown1, integer unknown2, number unknown3, number unknown4, optional string TrackStateChunk)</functioncall>
  <description>
    sets the SCORE of a track or a TrackStateChunk.
    
    set unknown1 to unknown4 to 0 to remove the entry
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    integer unknown1 - unknown
    integer unknown2 - unknown
    number unknown3 - unknown
    number unknown4 - unknown
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, score, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackScore", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackScore", "tracknumber", "no such track in the project", -2) return false end
  if math.type(unknown1)~="integer" then ultraschall.AddErrorMessage("SetTrackScore", "unknown1", "must be an integer", -3) return false end
  if math.type(unknown2)~="integer" then ultraschall.AddErrorMessage("SetTrackScore", "unknown2", "must be an integer", -4) return false end
  if type(unknown3)~="number" then ultraschall.AddErrorMessage("SetTrackScore", "unknown3", "must be a number", -5) return false end
  if type(unknown4)~="number" then ultraschall.AddErrorMessage("SetTrackScore", "unknown4", "must be a number", -6) return false end

  -- create new state-entry
  local str="SCORE "..unknown1.." "..unknown2.." "..unknown3.." "..unknown4
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackScore", "TrackStateChunk", "must be a string", -7) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)SCORE")
  local B3=AA:match("SCORE.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ultraschall.SetTrackScore(1, 0, 0, 0, 0, "")

function ultraschall.SetTrackVolPan(tracknumber, vol, pan, overridepanlaw, unknown, unknown2, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackVolPan</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackVolPan(integer tracknumber, number Vol, number Pan, number OverridePanLaw, number unknown, number unknown2, optional string TrackStateChunk)</functioncall>
  <description>
    sets the VOLPAN-state of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1, if you want to use parameter TrackStateChunk
    number Vol - Volume Settings; -Inf dB(0) to +12dB (3.98107170553497)
    number Pan - Pan Settings; -1(-100%); 0(center); 1(100% R)
    number OverridePanLaw - Override Default Pan Track Law; 0dB(1) to -144dB(0.00000006309573)
    number unknown - unknown
    number unknown2 - unknown
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, vol, pan, override, panlaw, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackVolPan", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackVolPan", "tracknumber", "no such track in the project", -2) return false end
  if type(vol)~="number" then ultraschall.AddErrorMessage("SetTrackVolPan", "vol", "must be a number", -3) return false end
  if type(pan)~="number" then ultraschall.AddErrorMessage("SetTrackVolPan", "pan", "must be a number", -4) return false end
  if type(overridepanlaw)~="number" then ultraschall.AddErrorMessage("SetTrackVolPan", "overridepanlaw", "must be a number", -5) return false end
  if type(unknown)~="number" then ultraschall.AddErrorMessage("SetTrackVolPan", "unknown", "must be a number", -6) return false end
  if type(unknown2)~="number" then ultraschall.AddErrorMessage("SetTrackVolPan", "unknown1", "must be a number", -7) return false end

  -- create new state-entry
  local str="VOLPAN "..vol.." "..pan.." "..overridepanlaw.." "..unknown.." "..unknown2
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackVolPan", "TrackStateChunk", "must be a string", -8) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)VOLPAN")
  local B3=AA:match("VOLPAN.-%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--A=ultraschall.SetTrackVolPan(nil, 0, 1, 1, 1, 1)

function ultraschall.SetTrackRecCFG(tracknumber, reccfg_string, reccfg_nr, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackRecCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackRecCFG(integer tracknumber, string reccfg_string, integer reccfg_nr, optional string TrackStateChunk)</functioncall>
  <description>
    sets the RECCFG of a track or a TrackStateChunk.
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    string reccfg_string -  the string, that encodes the recording configuration of the track
    integer reccfgnr - the number of the recording-configuration of the track; 
                     - -1, removes the reccfg-setting
                     - 0, use default project rec-setting
                     - 1, use track-customized rec-setting, as set in the "Track: View track recording settings (MIDI quantize, file format/path) for last touched track"-dialog (action 40604)
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, state, reccfg, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackRecCFG", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackRecCFG", "tracknumber", "no such track in the project", -2) return false end
  if math.type(reccfg_nr)~="integer" then ultraschall.AddErrorMessage("SetTrackRecCFG", "reccfg_nr", "must be an integer", -3) return false end
  if type(reccfg_string)~="string" then ultraschall.AddErrorMessage("SetTrackRecCFG", "reccfg_string", "must be a string", -4) return false end

  -- create new state-entry
  local str="<RECCFG "..reccfg_nr.."\n"..reccfg_string.."\n>"
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackRecCFG", "TrackStateChunk", "must be a string", -5) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state-entry from trackstatechunk
  local B1=AA:match("(.-)<RECCFG")
  local B3=AA:match("RECCFG.->%c(.*)")
  if B1==nil then B1=AA:match("(.-TRACK)") B3=AA:match(".-TRACK(.*)") end

  -- insert new state-entry into trackstatechunk
  if tracknumber~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end  

  return B, B1.."\n"..str.."\n"..B3
end

--ultraschall.SetTrackRecCFG(1, "", -1, "")


------------------------------
---- Meta Data Management ----
-----------------------------


--------------------
---- Navigation ----
--------------------

function ultraschall.ToggleScrollingDuringPlayback(scrolling_switch, move_editcursor, goto_playcursor)
  -- integer scrolling_switch - 1-on, 0-off
  -- boolean move_editcursor - when scrolling stops, shall the editcursor be moved to current position of the playcursor(true) or not(false)
  -- boolean goto_playcursor - shall the view be moved to the playcursor(true) or not(false)? 
  -- changes, if necessary, the state of the actions 41817, 40036 and 40262
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleScrollingDuringPlayback</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.ToggleScrollingDuringPlayback(integer scrolling_switch, boolean move_editcursor, boolean goto_playcursor)</functioncall>
  <description>
    Toggles scrolling during playback and recording. Let's you choose to put the edit-marker at the playposition, where you toggled scrolling.
    You can also move the view to the playcursor-position.
    
    It changes, if necessary, the state of the actions 41817, 40036 and 40262 to scroll or not to scroll; keep that in mind, if you use these actions otherwise as well!
    
    returns -1 in case of error
  </description>
  <retvals>
    integer retval - -1, in case of an error
  </retvals>
  <parameters>
    integer scrolling_switch - 1-on, 0-off
    boolean move_editcursor - when scrolling stops, shall the editcursor be moved to current position of the playcursor(true) or not(false)
    boolean goto_playcursor - true, move view to playcursor; false, don't move
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, scrolling, toggle, edit cursor, play cursor</tags>
</US_DocBloc>
--]]
    if math.type(scrolling_switch)~="integer" then ultraschall.AddErrorMessage("ToggleScrollingDuringPlayback", "scrolling_switch", "must be an integer", -1) return -1 end
    if scrolling_switch<0 or scrolling_switch>1 then ultraschall.AddErrorMessage("ToggleScrollingDuringPlayback", "scrolling_switch", "0, turn scrolling off; 1, turn scrolling on", -2) return -1 end
    if type(move_editcursor)~="boolean" then ultraschall.AddErrorMessage("ToggleScrollingDuringPlayback", "move_editcursor", "must be a boolean", -3) return -1 end
    if type(goto_playcursor)~="boolean" then ultraschall.AddErrorMessage("ToggleScrollingDuringPlayback", "goto_playcursor", "must be a boolean", -4) return -1 end
    
    -- get current toggle-states
    local scroll_continuous=reaper.GetToggleCommandState(41817)
    local scroll_auto_play=reaper.GetToggleCommandState(40036)
    local scroll_auto_rec=reaper.GetToggleCommandState(40262)
  
    -- move editcursor, if move_editcursor is set to true
    if move_editcursor==true then
      reaper.SetEditCurPos(reaper.GetPlayPosition(), true, false)
    else
      reaper.SetEditCurPos(reaper.GetCursorPosition(), false, false)
    end
  
    -- set auto-scrolling-states
    if scrolling_switch~=scroll_continuous then
      reaper.Main_OnCommand(41817,0) -- continuous scroll
    end
  
    if scrolling_switch~=scroll_auto_play then
      reaper.Main_OnCommand(40036,0) -- autoscroll during play
    end
  
    if scrolling_switch~=scroll_auto_rec then
      reaper.Main_OnCommand(40262,0) -- autoscroll during rec
    end
  
    -- go to playcursor
    if goto_playcursor~=false then
      reaper.Main_OnCommand(40150,0) -- go to playcursor
    end  
  end

--ultraschall.ToggleScrollingDuringPlayback(1, false, true)

function ultraschall.SetPlayCursor_WhenPlaying(position)--, move_view)--, length_of_view)
-- changes position of the play-cursor, when playing
-- changes view to new playposition
-- has no effect during recording, when paused or stop and returns -1 in these cases!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetPlayCursor_WhenPlaying</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.SetPlayCursor_WhenPlaying(number position)</functioncall>
  <description>
    Changes position of the play-cursor, when playing. Changes view to new playposition. Has no effect during recording, when paused or stop and returns -1 in these cases!
  </description>
  <parameters>
    number position - in seconds
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, play cursor, set</tags>
</US_DocBloc>
--]]
  -- check parameters
  if reaper.GetPlayState()~=1 then ultraschall.AddErrorMessage("SetPlayCursor_WhenPlaying", "", "Works only, when it's playing.", -1) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("SetPlayCursor_WhenPlaying", "position", "position must be a number", -2) return -1 end
  
  -- prepare variables
  if move_view==true then move_view=false
  elseif move_view==false then move_viev=true end

  -- set playcursor
  reaper.SetEditCurPos(position, true, true) 
  if reaper.GetPlayState()==2 then -- during pause
    reaper.Main_OnCommand(1007,0)
    reaper.SetEditCurPos(reaper.GetCursorPosition(), false, false)  
    reaper.Main_OnCommand(1008,0)
   else
     reaper.SetEditCurPos(reaper.GetCursorPosition(), false, false)  -- during play
   end
end

--    reaper.SetEditCurPos(10, false, false)  
--ultraschall.SetPlayCursor_WhenPlaying(reaper.GetPlayPosition()+1000)

function ultraschall.SetPlayAndEditCursor_WhenPlaying(position)--, move_view)--, length_of_view)
-- changes position of the play-cursor and the edit-cursor, when playing
-- changes view to new playposition
-- has no effect during recording, when paused or stop!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetPlayAndEditCursor_WhenPlaying</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.SetPlayAndEditCursor_WhenPlaying(number position)</functioncall>
  <description>
    Changes position of the play and edit-cursor, when playing. Changes view to new playposition. Has no effect during recording, when paused or stop and returns -1 in these cases!
  </description>
  <parameters>
    number position - in seconds
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, set, play cursor, edit cursor</tags>
</US_DocBloc>
--]]
  -- check parameters
  if reaper.GetPlayState()==0 then ultraschall.AddErrorMessage("SetPlayAndEditCursor_WhenPlaying", "", "Works only, when it's not stopped.", -1) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("SetPlayAndEditCursor_WhenPlaying", "position", "position must be a number", -2) return -1 end

  -- prepare variables
  if move_view==true then move_view=false
  elseif move_view==false then move_viev=true end
  
  -- set play and edit-cursor
  reaper.SetEditCurPos(position, true, true)   
end

--ultraschall.SetPlayAndEditCursor_WhenPlaying(102)

function ultraschall.JumpForwardBy(seconds, seekplay)
--jumps forward by seconds
-- returns -1 if seconds is invalid or negative
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>JumpForwardBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.JumpForwardBy(number seconds, boolean seekplay)</functioncall>
  <description>
    Jumps editcursor forward by <i>seconds</i> seconds. Returns -1 if parameter is negative. During Recording: only the playcursor will be moved, the current recording-position is still at it's "old" position! If you want to move the current recording position as well, use <a href="#JumpForwardBy_Recording">ultraschall.JumpForwardBy_Recording</a> instead.
  </description>
  <parameters>
    number seconds - jump forward by seconds
    boolean seekplay - true, move playcursor as well; false, don't move playcursor
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, set, forward, jump</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(seconds)~="number" then ultraschall.AddErrorMessage("JumpForwardBy","seconds", "must be a number", -1) return -1 end
  if type(seekplay)~="boolean" then ultraschall.AddErrorMessage("JumpForwardBy","seekplay", "must be boolean", -2) return -1 end

  if seconds<0 then ultraschall.AddErrorMessage("JumpForwardBy","seconds", "must be bigger or equal 0", -3) return -1 end
    
  -- jump forward edit-cursor
  if reaper.GetPlayState()==0 then -- during stop
    reaper.SetEditCurPos(reaper.GetCursorPosition()+seconds, true, true) 
  else -- every other play/rec-state
    reaper.SetEditCurPos(reaper.GetCursorPosition()+seconds, true, seekplay)
  end
end

--A=ultraschall.JumpForwardBy(5.1, false)

function ultraschall.JumpBackwardBy(seconds, seekplay)
--jumps backwards by seconds
-- returns -1 if seconds is invalid or negative
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>JumpBackwardBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.JumpBackwardBy(number seconds, boolean seekplay)</functioncall>
  <description>
    Jumps editcursor backward by <i>seconds</i> seconds. Returns -1 if parameter is negative. During Recording: only the playcursor will be moved, the current recording-position is still at it's "old" position! If you want to move the current recording position as well, use <a href="#JumpBackwardBy_Recording">ultraschall.JumpBackwardBy_Recording</a> instead.
  </description>
  <parameters>
    number seconds - jump backwards by seconds
    boolean seekplay - true, move playcursor as well; false, leave playcursor at it's old position
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, set, backward, jump</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(seconds)~="number" then ultraschall.AddErrorMessage("JumpBackwardBy","seconds", "must be a number", -1) return -1 end

  if type(seekplay)~="boolean" then ultraschall.AddErrorMessage("JumpBackwardBy","seekplay", "must be boolean", -2) return -1 end
  if seconds<0 then ultraschall.AddErrorMessage("JumpBackwardBy","seconds", "must be bigger or equal 0", -3) return -1 end
  
  -- jump backwards edit-cursor
  if reaper.GetPlayState()==0 then -- when stopped
    reaper.SetEditCurPos(reaper.GetCursorPosition()-seconds, true, true) 
  else -- every other play/rec-state
    reaper.SetEditCurPos(reaper.GetCursorPosition()-seconds, true, seekplay)
  end
end

--A=ultraschall.JumpBackwardBy(10, false)

function ultraschall.JumpForwardBy_Recording(seconds)
--jumps forward by seconds and restarts recording on new position
-- returns -1 if seconds is invalid or negative or if not recording
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>JumpForwardBy_Recording</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.JumpForwardBy_Recording(number seconds)</functioncall>
  <description>
    Stops recording, jumps forward by <i>seconds</i> seconds and restarts recording. Will keep paused-recording, if recording was paused. Has no effect during play,play/pause and stop.
  </description>
  <parameters>
    number seconds - restart recording forwards by seconds
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, set, forward, recording</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(seconds)~="number" then ultraschall.AddErrorMessage("JumpForwardBy_Recording","seconds", "must be a number", -1) return -1 end

  if seconds<0 then ultraschall.AddErrorMessage("JumpForwardBy_Recording","seconds", "must be bigger or equal 0", -2) return -1 end
  
  -- stop recording, jump forward and restart recording
  if reaper.GetPlayState()==5 then -- during recording
    reaper.Main_OnCommand(1016,0)
    reaper.SetEditCurPos(reaper.GetPlayPosition()+seconds, true, true) 
    reaper.Main_OnCommand(1013,0)
  elseif reaper.GetPlayState()==6 then -- during paused-recording
    reaper.Main_OnCommand(1016,0)
    reaper.SetEditCurPos(reaper.GetPlayPosition()+seconds, true, true) 
    reaper.Main_OnCommand(1013,0)
    reaper.Main_OnCommand(1008,0)    
  else -- when recording hasn't started
    ultraschall.AddErrorMessage("JumpForwardBy_Recording", "", "Only while recording or pause recording possible.", -3)
    return -1
  end
end

--A=ultraschall.JumpForwardBy_Recording(5)

function ultraschall.JumpBackwardBy_Recording(seconds)
--jumps forward by seconds and restarts recording on new position
-- returns -1 if seconds is invalid or negative or if not recording
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>JumpBackwardBy_Recording</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.JumpBackwardBy_Recording(number seconds)</functioncall>
  <description>
    Stops recording, jumps backward by <i>seconds</i> seconds and restarts recording. Will keep paused-recording, if recording was paused. Has no effect during play,play/pause and stop.
  </description>
  <parameters>
    number seconds - restart recording backwards by seconds
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, jump, forward, recording</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(seconds)~="number" then ultraschall.AddErrorMessage("JumpBackwardBy_Recording","seconds", "must be a number", -1) return -1 end
  
  if seconds<0 then ultraschall.AddErrorMessage("JumpBackwardBy_Recording","seconds", "must be bigger or equal 0", -2) return -1 end
  
  -- stop recording, jump backward and restart recording
  if reaper.GetPlayState()==5 then -- during recording
    reaper.Main_OnCommand(1016,0)
    reaper.SetEditCurPos(reaper.GetPlayPosition()-seconds, true, true) 
    reaper.Main_OnCommand(1013,0)
  elseif reaper.GetPlayState()==6 then -- during pause-recording
    reaper.Main_OnCommand(1016,0)
    reaper.SetEditCurPos(reaper.GetPlayPosition()-seconds, true, true) 
    reaper.Main_OnCommand(1013,0)
    reaper.Main_OnCommand(1008,0)
  else -- every other play-state
    ultraschall.AddErrorMessage("JumpBackwardBy_Recording", "", "Only while recording or paused recording possible.", -3)
    return -1
  end
end

--A=ultraschall.JumpBackwardBy_Recording(1)

function ultraschall.GetNextClosestItemEdge(tracksstring, cursor_type, time_position)
-- returns time and item-object of the next closest item-start or item-end within the chosen tracks, as well as "beg" for begin and "end" for end of the returned item
-- can become slow when having thousands of items
-- string tracks - tracknumbers, separated by a comma. Negative Values will be ignored.
-- integer cursor_type - 0-edit_cursor, 1-play_cursor, 2-mouse-cursor, 3-timeposition
-- number time_position - only when cursor_type=3, else it will be ignored. time_position to check from for the next item.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetNextClosestItemEdge</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number position, integer item_number, string edgetype, MediaItem found_item  = ultraschall.GetNextClosestItemEdge(string trackstring, integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the position of the next closest item in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.
  </description>
  <retvals>
    number position  - the position of the next closest item-edge in tracks in trackstring
    integer item_number - the itemnumber in the project
    string edgetype - "beg" for beginning of the item, "end" for the end of the item
    MediaItem found_item - the next closest found MediaItem 
  </retvals>
  <parameters>
    string trackstring - a string with the numbers of tracks to check for closest items, separated by a comma (e.g. "0,1,6")
    integer cursor_type - next closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    optional number time_position - only, when cursor_type=3, a time position in seconds, from where to check for the next closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, next item, position, edge</tags>
</US_DocBloc>
--]]
  local cursortime=0
  
  -- check parameters
  local tracks=tracksstring
  if ultraschall.IsValidTrackString(tracks)==false then ultraschall.AddErrorMessage("GetNextClosestItemEdge", "tracks", "must be a valid trackstring", -5) return -1 end
  
  -- check cursor_type-parameter and do the proper cursor-type-position
  if cursor_type==nil then ultraschall.AddErrorMessage("GetNextClosestItemEdge","cursor_type", "must be an integer", -1) return -1 end
  if cursor_type==0 then cursortime=reaper.GetCursorPosition() end
  if cursor_type==1 then cursortime=reaper.GetPlayPosition() end
  if cursor_type==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetNextClosestItemEdge", "", "Mouse is not in arrange-view.", -2) return -1 end
  end
  if cursor_type==3 then
      if type(time_position)~="number" then ultraschall.AddErrorMessage("GetNextClosestItemEdge","time_position", "must be a number.", -3) return -1 end
      cursortime=time_position
  end
  if cursor_type>3 or cursor_type<0 then ultraschall.AddErrorMessage("GetNextClosestItemEdge","cursor_type", "no such cursor_type existing", -4) return -1 end  
  if time_position~=nil and type(time_position)~="number" then ultraschall.AddErrorMessage("GetNextClosestItemEdge", "time_position", "must be either nil or a number", -6) return -1 end  

  -- prepare variables
  if time_position==nil and reaper.GetPlayState()==0 then
    time_position=reaper.GetCursorPosition()
  elseif time_position==nil and reaper.GetPlayState~=0 then
    time_position=reaper.GetPlayPosition()
  end
  
  local closest_item=reaper.GetProjectLength(0)
  local found_item=nil
  local another_item=-1
  local another_item_nr=-1
  local position=""
  local item_number=-1  
  local _count
  
  
  -- get tracksnumbers from trackstring
  local _count, TrackArray = ultraschall.CSV2IndividualLinesAsArray(tracks)  
  local TrackArray2={}
  
  for k=0, reaper.CountTracks()+1 do
    if TrackArray[k]~=nil then TrackArray2[tonumber(TrackArray[k])]=TrackArray[k]end
  end
  
  
  -- find the closest item and it's closest edge
  for i=0, reaper.CountMediaItems(0)-1 do
    for j=0, reaper.CountTracks(0) do
       if TrackArray2[j]~=nil and tracks~=-1 then  
          if ultraschall.IsItemInTrack(j,i)==true then
             -- when item is in track, check beginning and endings of the item
             local MediaItem=reaper.GetMediaItem(0, i)
             local ItemStart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
             local ItemEnd=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")+reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
             if ItemStart>cursortime and ItemStart<closest_item then -- check if it's beginning of the item
                closest_item=ItemStart
                found_item=MediaItem
                position="beg"
                item_number=i
             end
             if ItemEnd>cursortime and ItemEnd<=closest_item then -- check if it's end of the item
                closest_item=ItemEnd
                position="end"
                found_item=MediaItem
                if MediaItem~=nil then another_item=found_item another_item_nr=i end
                item_number=i
             end
          end
       end
    end
  end

  -- return found item
  if found_item~=nil then return closest_item, item_number, position, found_item
  else ultraschall.AddErrorMessage("GetNextClosestItemEdge", "", "no item found", -6) return -1
  end
end

--A=reaper.CountMediaItems()
--A1,A2,A3,A4=ultraschall.GetNextClosestItemEdge("0,1,2,3",2,8)
--ultraschall.ToggleIDE_Errormessages(false)
--A1,A2,A3,A4=ultraschall.GetNextClosestItemEdge("0,1,2", 3)


function ultraschall.GetPreviousClosestItemEdge(tracksstring, cursor_type, time_position)
-- returns time and item-object of the previous closest item-start or item-end within the chosen tracks, as well as "beg" for begin and "end" for end of the returned item
-- can become slow when having thousands of items
-- string tracks - tracknumbers, separated by a comma. A single -1 means all tracks. Negative Values will be ignored.
-- integer cursor_type - 0-edit_cursor, 1-play_cursor, 2-mouse-cursor, 3-timeposition
-- number time_position - only when cursor_type=3, else it will be ignored. time_position to check from for the previous item.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPreviousClosestItemEdge</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number position, number position, integer item_number, string edgetype, MediaItem found_item = ultraschall.GetPreviousClosestItemEdge(string tracks, integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the position of the previous closest item-edge in seconds. It will return the position of the beginning or the end of that item, depending on what is closer.
  </description>
  <retvals>
    number position  - the position of the previous closest item edge in tracks in trackstring
    integer item_number - the itemnumber in the project
    string edgetype - "beg" for beginning of the item, "end" for the end of the item
    MediaItem found_item - the next closest found MediaItem 
  </retvals>
  <parameters>
    string tracks - a string with the numbers of tracks to check for closest items, separated by a comma (e.g. "0,1,6")
    integer cursor_type - previous closest item related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    optional time_position - only, when cursor_type=3, a time position in seconds, from where to check for the previous closest item. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, previous item, position, edge</tags>
</US_DocBloc>
--]]
  local cursortime=0
  local _count
  
  -- check parameters
  local tracks=tracksstring
  if ultraschall.IsValidTrackString(tracks)==false then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge","tracks", "must be a string", -5) return -1 end
  if time_position~=nil and type(time_position)~="number" then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge","time_position", "must be either nil or a number", -6) return -1 end
  
  -- check cursor_type-parameter and do the proper cursor-type-position
  if math.type(cursor_type)~="integer" then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge","cursor_type", "must be an integer", -1) return -1 end
  if cursor_type==0 then cursortime=reaper.GetCursorPosition() end
  if cursor_type==1 then cursortime=reaper.GetPlayPosition() end
  if cursor_type==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge", "", "mouse not in arrange-view", -2) return -1 end
  end
  if cursor_type==3 then
      if time_position==nil then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge","time_position", "no nil allowed", -3) return -1 end
      cursortime=time_position
  end
  if cursor_type>3 or cursor_type<0 then ultraschall.AddErrorMessage("GetPreviousClosestItemEdge","cursor_type", "no such cursortype existing", -4) return -1 end  
  

  -- prepare variables
  local _count, TrackArray = ultraschall.CSV2IndividualLinesAsArray(tracks)
  if time_position==nil and reaper.GetPlayState()==0 then
    time_position=reaper.GetCursorPosition()
  elseif time_position==nil and reaper.GetPlayState~=0 then
    time_position=reaper.GetPlayPosition()
  end
  local TrackArray2={}
  for k=0, reaper.CountTracks()+1 do
    if TrackArray[k]~=nil then TrackArray2[tonumber(TrackArray[k])]=TrackArray[k] end
  end
  
  local closest_item=-1
  local found_item=nil
  local position=""
  local item_number=-1


  -- find previous closest item and it's edge
  for i=0, reaper.CountMediaItems(0)-1 do
    for j=0, reaper.CountTracks(0) do 
      if TrackArray2[j]~=nil and tonumber(tracks)~=-1 then  
        if ultraschall.IsItemInTrack(j,i)==true then
          -- if item is in track, find the closest edge
          local MediaItem=reaper.GetMediaItem(0, i)
          local Aretval, Astr = reaper.GetItemStateChunk(MediaItem,"<ITEMPOSITION",false)
          local ItemStart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
          local ItemEnd=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")+reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
          if ItemEnd<cursortime and ItemEnd>closest_item then -- if it's item-end
              closest_item=ItemEnd
              position="end"
              found_item=MediaItem
              item_number=i
          elseif ItemStart<cursortime and ItemStart>closest_item then -- if it's item-beginning
              closest_item=ItemStart
              found_item=MediaItem
              position="beg"
              item_number=i
          end
        end
      end
    end
  end
  
  -- return found item
  if found_item~=nil then return closest_item, item_number, position, found_item
  else ultraschall.AddErrorMessage("GetPreviousClosestItemEdge", "", "no item found", -6) return -1
  end
end

--A1,A2,A3,A4=ultraschall.GetPreviousClosestItemEdge("1", 3)

function ultraschall.GetClosestNextMarker(cursor_type, time_position)
-- returns idx, position(in seconds) and name of the next closest marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestNextMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number markerindex, number position, string markertitle = ultraschall.GetClosestNextMarker(integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the markerindex(counted from all markers), the position and the name of the next closest marker in seconds.
  </description>
  <retvals>
    number markerindex - the next closest markerindex (of all(!) markers)
    number position - the position of the next closest marker
    string markertitle - the name of the next closest marker
  </retvals>
  <parameters>
    integer cursor_type - previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    optional number time_position - only, when cursor_type=3, a time position in seconds, from where to check for the next closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, next marker, position, marker </tags>
</US_DocBloc>
--]]
  local cursortime=0

  if math.type(cursor_type)~="integer" then ultraschall.AddErrorMessage("GetClosestNextMarker", "cursor_type", "must be an integer", -1) return -1 end
  if time_position~=nil and type(time_position)~="number" then ultraschall.AddErrorMessage("GetClosestNextMarker", "time_position", "must be either nil or a number", -5) return -1 end
  if time_position==nil and cursor_type>2 then ultraschall.AddErrorMessage("GetClosestNextMarker", "time_position", "must be a number when cursortype=3", -6) return -1 end

  -- check parameters  
  if time_position==nil and reaper.GetPlayState()==0 and cursor_type~=3 then
    time_position=reaper.GetCursorPosition()
  elseif time_position==nil and reaper.GetPlayState~=0 and cursor_type~=3 then
    time_position=reaper.GetPlayPosition()
  elseif time_position==nil and cursor_type~=3 then
    time_position=time_position
  end
  
  --  check cursor_type parameter and do the proper cursor-type-position
  if cursor_type==0 then cursortime=reaper.GetCursorPosition() end
  if cursor_type==1 then cursortime=reaper.GetPlayPosition() end
  if cursor_type==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetClosestNextMarker", "", "mouse not in arrange-view", -2) return -1 end
  end
  if cursor_type==3 then
      cursortime=time_position
  end
  if cursor_type>3 or cursor_type<0 then ultraschall.AddErrorMessage("GetClosestNextMarker","cursor_type", "no such cursor_type existing", -4) return -1 end
  
  
  -- prepare variables
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  local retposition=reaper.GetProjectLength(0)+1--*200000000 --Working Hack, but isn't elegant....
  local retindexnumber=-1
  local retmarkername=""
  
  -- find next closest marker
  for i=0,retval do
    local  retval2, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==false then
      if pos>cursortime and pos<retposition then
        retposition=pos
        retindexnumber=markrgnindexnumber
        retmarkername=name
      end
    end
  end
  -- return found marker
  if retindexnumber==-1 then retposition=-1 end
  return retindexnumber, retposition, retmarkername
end

--A,AA,AAA=ultraschall.GetClosestNextMarker(1,99)

function ultraschall.GetClosestPreviousMarker(cursor_type, time_position)
-- returns idx, position(in seconds) and name of the next closest marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestPreviousMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number markerindex, number position, string markertitle = ultraschall.GetClosestPreviousMarker(integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the markerindex(counted from all markers), the position and the name of the previous closest marker in seconds.
  </description>
  <retvals>
    number markerindex - the previous closest markerindex (of all(!) markers)
    number position - the position of the previous closest marker
    string markertitle - the name of the previous closest marker
  </retvals>
  <parameters>
    integer cursor_type - previous closest marker related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    optional number time_position - only, when cursor_type=3, a time position in seconds, from where to check for the previous closest marker. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, previous marker, position, marker</tags>
</US_DocBloc>
--]]
  local cursortime=0

  if math.type(cursor_type)~="integer" then ultraschall.AddErrorMessage("GetClosestPreviousMarker", "cursor_type", "must be an integer", -1) return -1 end
  if time_position~=nil and type(time_position)~="number" then ultraschall.AddErrorMessage("GetClosestPreviousMarker", "time_position", "must be either nil or a number", -5) return -1 end
  if time_position==nil and cursor_type>2 then ultraschall.AddErrorMessage("GetClosestPreviousMarker", "time_position", "must be a number when cursortype=3", -6) return -1 end

  
  -- check parameters
  if time_position==nil and reaper.GetPlayState()==0 and cursor_type~=3 then
    time_position=reaper.GetCursorPosition()
  elseif time_position==nil and reaper.GetPlayState~=0 and cursor_type~=3 then
    time_position=reaper.GetPlayPosition()
  elseif time_position==nil and cursor_type~=3 then
    time_position=time_position
  end
  -- check parameter cursor_type and do the cursor-type-position
  if cursor_type==0 then cursortime=reaper.GetCursorPosition() end
  if cursor_type==1 then cursortime=reaper.GetPlayPosition() end
  if cursor_type==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetClosestPreviousMarker", "", "mouse not in arrange-view", -2) return -1 end
  end
  if cursor_type==3 then
      cursortime=time_position
  end
  if cursor_type>3 or cursor_type<0 then ultraschall.AddErrorMessage("GetClosestPreviousMarker","cursor_type", "no such cursor-type existing", -4) return -1 end
  
  -- prepare variables
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  local found=false
  local retposition=-1
  local retindexnumber=-1
  local retmarkername=""
  
  -- find previous closest marker
  for i=0,retval-1 do
    local retval2, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==false then
      if pos<cursortime and pos>retposition then
        retposition=pos
        retindexnumber=markrgnindexnumber
        retmarkername=name
        found=true
      end
    end
  end
  -- return found marker
  if found==false then retposition=-1 retindexnumber=-1 end
  return retindexnumber,retposition, retmarkername
end

--A,AA,AAA=ultraschall.GetClosestPreviousMarker(3)

function ultraschall.GetClosestNextRegionEdge(cursor_type, time_position)
-- returns idx, position(in seconds) and name of the next closest marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestNextRegionEdge</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number markerindex, number position, string markertitle, string edge_type = ultraschall.GetClosestNextRegionEdge(integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the regionindex(counted from all markers and regions), the position and the name of the next closest regionstart/end(depending on which is closer to time_position) in seconds.
  </description>
  <retvals>
    number markerindex - the next closest markerindex (of all(!) markers)
    number position - the position of the next closest region
    string markertitle - the name of the next closest region
    string edge_type - the type of the edge of the region, either "beg" or "end"
  </retvals>
  <parameters>
    integer cursor_type - previous closest regionstart/end related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    only number time_position - only, when cursor_type=3, a time position in seconds, from where to check for the next closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, next region, region, position</tags>
</US_DocBloc>
--]]
  local cursortime=0
  
  -- check parameters
  if tonumber(time_position)==nil and reaper.GetPlayState()==0 and tonumber(cursor_type)~=3 then
    time_position=reaper.GetCursorPosition()
  elseif tonumber(time_position)==nil and reaper.GetPlayState~=0 and tonumber(cursor_type)~=3 then
    time_position=reaper.GetPlayPosition()
  elseif tonumber(time_position)==nil and tonumber(cursor_type)~=3 then
    time_position=tonumber(time_position)
  end
  -- check parameter cursor_type and do the cursor-type-position
  if math.type(cursor_type)~="integer" then ultraschall.AddErrorMessage("GetClosestNextRegionEdge", "cursor_type", "must be an integer", -1) return -1 end
  if tonumber(cursor_type)==0 then cursortime=reaper.GetCursorPosition() end
  if tonumber(cursor_type)==1 then cursortime=reaper.GetPlayPosition() end
  if tonumber(cursor_type)==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetClosestNextRegionEdge", "", "mouse not in arrange view", -2) return -1 end
  end
  if tonumber(cursor_type)==3 then
      if tonumber(time_position)==nil then ultraschall.AddErrorMessage("GetClosestNextRegionEdge","time_position", "no nil allowed when cursor_type=3", -3) return -1 end
      cursortime=tonumber(time_position)
  end
  if tonumber(cursor_type)>3 or tonumber(cursor_type)<0 then ultraschall.AddErrorMessage("GetClosestNextRegionEdge","cursor_type", "no such cursor_type existing", -4) return -1 end
  
  -- prepare variables
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  local retposition=reaper.GetProjectLength()+1--*200000000 --Working Hack, but isn't elegant....
  local retindexnumber=-1
  local retmarkername=""
  local retbegin=""
    
  -- find next region and it's closest edge
  for i=0,retval do
    local retval2, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==true then
      if pos>cursortime and pos<retposition then -- beginning of the region
        retposition=pos
        retindexnumber=markrgnindexnumber
        retmarkername=name
        retbegin="beg"
      end

      if rgnend>cursortime and rgnend<retposition then -- ending of the region
        retposition=rgnend
        retindexnumber=markrgnindexnumber
        retmarkername=name
        retbegin="end"
      end
    end
  end
  -- return found region
  if retindexnumber==-1 then retposition=-1 end
  return retindexnumber,retposition, retmarkername, retbegin
end

--A,AA,AAA,AAAA=ultraschall.GetClosestNextRegionEdge(3)

function ultraschall.GetClosestPreviousRegionEdge(cursor_type, time_position)
-- returns idx, position(in seconds) and name of the next closest marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestPreviousRegionEdge</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number markerindex, number position, string markertitle, string edge_type = ultraschall.GetClosestPreviousRegionEdge(integer cursor_type, optional number time_position)</functioncall>
  <description>
    returns the regionindex(counted from all markers and regions), the position and the name of the previous closest regionstart/end(depending on which is closer to time_position) in seconds.
  </description>
  <retvals>
    number markerindex - the previous closest markerindex (of all(!) markers)
    number position - the position of the previous closest marker
    string markertitle - the name of the previous closest marker
    string edge_type - the type of the edge of the region, either "beg" or "end"
  </retvals>
  <parameters>
    integer cursor_type - previous closest regionstart/end related to the current position of 0 - Edit Cursor, 1 - Play Cursor, 2 - Mouse Cursor, 3 - Timeposition
    optional number time_position - only, when cursor_type=3, a time position in seconds, from where to check for the previous closest regionstart/end. When omitted, it will take the current play(during play and rec) or edit-cursor-position.
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, previous region, region, position</tags>
</US_DocBloc>
--]]
  local cursortime=0
  
  -- check parameters
  if tonumber(time_position)==nil and reaper.GetPlayState()==0 and tonumber(cursor_type)~=3 then
    time_position=reaper.GetCursorPosition()
  elseif tonumber(time_position)==nil and reaper.GetPlayState~=0 and tonumber(cursor_type)~=3 then
    time_position=reaper.GetPlayPosition()
  elseif tonumber(time_position)==nil and tonumber(cursor_type)~=3 then
    time_position=tonumber(time_position)
  end
  -- check parameter cursor_type and do the cursor-type-position  
  if math.type(cursor_type)~="integer" then ultraschall.AddErrorMessage("GetClosestPreviousRegionEdge","cursor_type", "must be an integer", -1) return -1 end
  if tonumber(cursor_type)==0 then cursortime=reaper.GetCursorPosition() end
  if tonumber(cursor_type)==1 then cursortime=reaper.GetPlayPosition() end
  if tonumber(cursor_type)==2 then 
      reaper.BR_GetMouseCursorContext() 
      cursortime=reaper.BR_GetMouseCursorContext_Position() 
      if cursortime==-1 then ultraschall.AddErrorMessage("GetClosestPreviousRegionEdge", "", "mouse not in arrange-view", -2) return -1 end
  end
  if tonumber(cursor_type)==3 then
      if tonumber(time_position)==nil then ultraschall.AddErrorMessage("GetClosestPreviousRegionEdge","time_position", "no nil allowed when cursortype=3", -3) return -1 end
      cursortime=tonumber(time_position)
  end
  if tonumber(cursor_type)>3 or tonumber(cursor_type)<0 then ultraschall.AddErrorMessage("GetClosestPreviousRegionEdge","cursor_type", "no such cursortype existing", -4) return -1 end
  
  -- prepare variables
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  local retposition=-1
  local retindexnumber=-1
  local retmarkername=""
  local retbeg=""
  
  -- find closest previous region and it's closest edge
  for i=0,retval do
    local retval2, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==true then -- beginning of the item
      if pos<cursortime and pos>retposition then
        retposition=pos
        retindexnumber=markrgnindexnumber
        retmarkername=name
        retbeg="beg"
      end
      if rgnend<cursortime and rgnend>retposition then  -- ending of the item
        retposition=rgnend
        retbeg="end"
      end
    end
  end
  return retindexnumber, retposition, retmarkername, retbeg
end

--A,AA,AAA,AAAA=ultraschall.GetClosestPreviousRegionEdge(3,1)

function ultraschall.GetClosestGoToPoints(trackstring, time_position, check_itemedge, check_marker, check_region)
-- what are the closest markers/regions/item starts/itemends to position and within the chosen tracks
-- string tracks - tracknumbers, separated by a comma.
-- position - position in seconds
--
-- returns position of previous element, type of the element, elementnumber, position of next element, type of the element, elementnumber
-- positions - in seconds
-- type - can be "Item", "Marker", "Region", "ProjectStart", "ProjectEnd"
-- elementnumber - is either the number of the item or the number of the region/marker, -1 if it's an Item.

--reaper.MB(time_position,"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestGoToPoints</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number elementposition_prev, string elementtype_prev, integer number_prev, number elementposition_next, string elementtype_next, integer number_next = ultraschall.GetClosestGoToPoints(string trackstring, number time_position, optional boolean check_itemedge, optional boolean check_marker, optional boolean check_region)</functioncall>
  <description>
    returns, what are the closest markers/regions/item starts/itemends to position and within the chosen tracks.
    
    returns -1 in case of error
  </description>
  <retvals>
    number elementposition_prev - previous closest markers/regions/item starts/itemends
    string elementtype_prev - type of the previous closest markers/regions/item starts/itemends
    -the type can be either Itembeg, Itemend, Marker: name, Region_beg: name; Region_end: name, ProjectStart, ProjectEnd; "name" is the name of the marker or region
    integer number_prev - number of previous closest markers/regions/item starts/itemends
    number elementposition_next - previous closest markers/regions/item starts/itemends
    string elementtype_next - type of the previous closest markers/regions/item starts/itemends
    -the type can be either Itembeg, Itemend, Marker: name, Region_beg: name; Region_end: name, ProjectStart, ProjectEnd; "name" is the name of the marker or region
    integer number_next  - number of previous closest markers/regions/item starts/itemends
  </retvals>
  <parameters>
    string trackstring - tracknumbers, separated by a comma.
    number time_position - a time position in seconds, from where to check for the next/previous closest items/markers/regions.
                         - -1, for editcursorposition; -2, for playcursor-position, -3, the mouse-cursor-position in seconds(where in the project the mousecursor hovers over)
    optional boolean check_itemedge - true, look for itemedges as possible goto-points; false, do not
    optional boolean check_marker - true, look for markers as possible goto-points; false, do not
    optional boolean check_region - true, look for regions as possible goto-point; false, do not
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, previous, next, marker, region, item, edge</tags>
</US_DocBloc>
--]]

  -- check parameters
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("GetClosestGoToPoints", "trackstring", "must be a valid trackstring", -1) return -1 end
  if type(time_position)~="number" then ultraschall.AddErrorMessage("GetClosestGoToPoints", "time_position", "must be a number", -2) return -1 end
  if check_itemedge~=nil and type(check_itemedge)~="boolean" then ultraschall.AddErrorMessage("GetClosestGoToPoints", "check_itemedge", "must be a boolean", -3) return -1 end
  if check_marker~=nil and type(check_marker)~="boolean" then ultraschall.AddErrorMessage("GetClosestGoToPoints", "check_marker", "must be a boolean", -4) return -1 end
  if check_region~=nil and type(check_region)~="boolean" then ultraschall.AddErrorMessage("GetClosestGoToPoints", "check_region", "must be a boolean", -5) return -1 end
  
  if check_itemedge==nil then check_itemedge=true end
  if check_marker==nil then check_marker=true end
  if check_region==nil then check_region=true end

  if tonumber(time_position)==-1 then
    time_position=reaper.GetCursorPosition()
  elseif tonumber(time_position)==-2 then
    time_position=reaper.GetPlayPosition()
  elseif tonumber(time_position)==-3 then
    reaper.BR_GetMouseCursorContext()
    time_position=reaper.BR_GetMouseCursorContext_Position()
  else
    time_position=tonumber(time_position)
  end

  -- prepare variables
  local elementposition_prev, elementtype_prev, number_prev, elementposition_next, elementtype_next, number_next=nil
  local elementposition_prev=-1
  local elementposition_next=reaper.GetProjectLength()+1
  
  -- get closest items, markers and regions
  local nextitempos, nextitemid, nextedgetype =ultraschall.GetNextClosestItemEdge(trackstring,3,time_position)
  local previtempos, previtemid, prevedgetype =ultraschall.GetPreviousClosestItemEdge(trackstring,3,time_position)

  local nextmarkerid,nextmarkerpos,nextmarkername=ultraschall.GetClosestNextMarker(3, time_position)
  local prevmarkerid,prevmarkerpos,prevmarkername=ultraschall.GetClosestPreviousMarker(3,time_position)

  local nextrgnID, nextregionpos,nextregionname,nextedgetype=ultraschall.GetClosestNextRegionEdge(3,time_position)
  local prevrgnID, prevregionpos,prevregionname,prevedgetype=ultraschall.GetClosestPreviousRegionEdge(3,time_position)

  -- now we find, which is the closest element
  -- Item-Edges
  if check_itemedge==true then
    if previtempos~=-1 and elementposition_prev<=previtempos then number_prev=previtemid elementposition_prev=previtempos elementtype_prev="Item"..prevedgetype end
    if nextitempos~=-1 and elementposition_next>=nextitempos then number_next=nextitemid elementposition_next=nextitempos elementtype_next="Item"..nextedgetype end
  end
  
  -- Markers
  if check_marker==true then
    if prevmarkerid~=-1 and elementposition_prev<=prevmarkerpos then number_prev=prevmarkerid elementposition_prev=prevmarkerpos elementtype_prev="Marker: "..prevmarkername end
    if nextmarkerid~=-1 and elementposition_next>=nextmarkerpos then number_next=nextmarkerid elementposition_next=nextmarkerpos elementtype_next="Marker: "..nextmarkername end
  end
  
  -- Region-Edges
  if check_region==true then
    if elementposition_prev<=prevregionpos and prevrgnID~=-1 then number_prev=prevrgnID elementposition_prev=prevregionpos elementtype_prev="Region_"..prevedgetype..": "..prevregionname end
    if elementposition_next>=nextregionpos and nextrgnID~=-1 then number_next=nextrgnID elementposition_next=nextregionpos elementtype_next="Region_"..nextedgetype..": "..nextregionname end
  end
  
  -- if none was found, use projectend/projectstart
  if elementposition_prev<0 then elementposition_prev=0 elementtype_prev="ProjectStart" end
  if elementposition_next>reaper.GetProjectLength() then elementposition_next=reaper.GetProjectLength() elementtype_next="ProjectEnd" end

  return elementposition_prev, elementtype_prev, number_prev, elementposition_next, elementtype_next, number_next
end

--ultraschall.ToggleIDE_Errormessages(false)

--APrev1,APrev2,APrev3,Anext1,Anext2,Anext3 = ultraschall.GetClosestGoToPoints("1",-3)

-----------------------------
---- Muting/Cough Button ----
-----------------------------

function ultraschall.ToggleMute(track, position, state)
-- state 0=mute, 1=unmute
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleMute</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.ToggleMute(integer track, number position, integer state)</functioncall>
  <description>
    Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons. Returns -1, if it fails.
  </description>
  <retvals>
    integer retval  - toggling was 0 - success, -1 - fail
  </retvals>
  <parameters>
    integer track - the track-number, for where you want to set the mute-envelope-lane.
    number position - position in seconds
    integer state - 0 for mute the track on this position, 1 for unmuting the track on this position
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, cough, position</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("ToggleMute","track", "must be an integer.", -1) return -1 end  
  if track<1 or track>reaper.CountTracks(0) then ultraschall.AddErrorMessage("ToggleMute", "track", "no such track.", -2) return -1 end
  if type(position)~="number" or tonumber(position)<0 then ultraschall.AddErrorMessage("ToggleMute", "position", "no such position.", -3) return -1 end
  if type(state)~="number" or tonumber(state)<0 or tonumber(state)>1 then ultraschall.AddErrorMessage("ToggleMute", "state", "only 0 and 1 allowed.", -4) return -1 end
  
  -- prepare parameters
  local Track=reaper.GetTrack(0, track-1)
  if Track==nil then ultraschall.AddErrorMessage("ToggleMute", "track", "no such track.", -5) return -1 end
  local MuteEnvelopeTrack=reaper.GetTrackEnvelopeByName(Track, "Mute")
  if MuteEnvelopeTrack==nil then ultraschall.AddErrorMessage("ToggleMute", "track", "track has no activated Mute-Lane.", -6) return -1 end
  
  -- insert mute-envelope-point
  local C=reaper.InsertEnvelopePoint(MuteEnvelopeTrack, position, state, 1, 0, 0)
  reaper.UpdateArrange()
  return 0
end

--L=ultraschall.ToggleMute(1,reaper.GetPlayPosition(),1)

function ultraschall.ToggleMute_TrackObject(trackobject, position, state)
-- state 0=mute, 1=unmute
-- returns -1 when it didn't work
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleMute_TrackObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.ToggleMute_TrackObject(MediaTrack trackobject, number position, integer state)</functioncall>
  <description>
    Sets mute within the mute-envelope-lane, by inserting the fitting envelope-points. Can be used to program coughbuttons. Returns -1, if it fails.
    
    Works like <a href="#ToggleMute">ultraschall.ToggleMute</a> but uses a trackobject instead of the tracknumber as parameter.
  </description>
  <retvals>
    integer retval  - toggling was 0 - success, -1 - fail
  </retvals>
  <parameters>
    MediaTrack trackobject - the track-object for the track, where you want to set the mute-envelope-lane. Refer <a href="Reaper_API_Lua.html#reaper.GetTrack">GetTrack()</a> for more details.
    number position - position in seconds
    integer state - 0 for mute the track on this position, 1 for unmuting the track on this position
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, cough, position, trackobject, mediatrack</tags>
</US_DocBloc>
--]]
  -- check parameters
  if ultraschall.type(trackobject)~="MediaTrack" then ultraschall.AddErrorMessage("ToggleMute_TrackObject", "trackobject", "no MediaTrack-object.", -1) return -1 end
  local Aretval=reaper.ValidatePtr2(0, trackobject, "MediaTrack*")
  if Aretval==false then ultraschall.AddErrorMessage("ToggleMute_TrackObject", "trackobject", "no MediaTrack-object.", -2) return -1 end
  if type(position)~="number" or tonumber(position)<0 then ultraschall.AddErrorMessage("ToggleMute_TrackObject", "position", "no such position.", -3) return -1 end
  if type(state)~="number" or tonumber(state)<0 or tonumber(state)>1 then ultraschall.AddErrorMessage("ToggleMute_TrackObject", "state", "only 0 and 1 allowed.", -4) return -1 end
  
  -- prepare variables
  local numtracks=reaper.CountTracks(0)-1
  local itworked=-1
  
  -- include envelope-points into the mute-envelope of the track
  local MuteEnvelopeTrack=reaper.GetTrackEnvelopeByName(trackobject, "Mute")
  if MuteEnvelopeTrack==nil then ultraschall.AddErrorMessage("ToggleMute_TrackObject", "track", "track has no activated Mute-Lane.", -5) return -1 end
  local C=reaper.InsertEnvelopePoint(MuteEnvelopeTrack, position, state, 1, 0, 0)

  return 0
end

--Track=reaper.GetTrack(0, 0)
--A,AA,AAA=ultraschall.ToggleMute_TrackObject(Track,reaper.GetPlayPosition(),0)
--Track="MackieMesser"
--CC=ultraschall.ToggleMute(0,0,1)
--CC=ultraschall.ToggleMute_TrackObject(Track,7,1)
--reaper.UpdateArrange()


function ultraschall.GetNextMuteState(track, position)
-- returns the next mute-envelope-point, it's value and it's time
-- Envelope-Points numbering starts with 0!
-- returns -1 if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetNextMuteState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer envIDX, number envVal, number envPosition = ultraschall.GetNextMuteState(integer track, number position)</functioncall>
  <description>
    Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0! Returns -1 if not existing.
  </description>
  <retvals>
    integer envIDX - number of the muteenvelope-point
     number envVal - value of the muteenvelope-point (0 or 1)
     number envPosition  - position of the muteenvelope-point in seconds
  </retvals>
  <parameters>
    integer track - the track-number, for where you want to set the mute-envelope-lane, beginning with 1.
    number position - position in seconds, from where to look for the next mute-envelope-point
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, position, envelope, state, value</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("GetNextMuteState", "track", "must be an integer.", -1) return -1 end

  if type(position)~="number" then ultraschall.AddErrorMessage("GetNextMuteState", "position", "must be a number.", -2) return -1 end
  
  -- prepare variables
  local retval, time, value, shape, tension, selected 
  local MediaTrack=reaper.GetTrack(0, track-1)
  if MediaTrack==nil then ultraschall.AddErrorMessage("GetNextMuteState", "track", "no such track.", -3) return -1 end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetNextMuteState", "track", "track has no activated mute-lane.", -4) return -1 end
  
  -- get the next envelope-point from position
  local Ainteger=reaper.GetEnvelopePointByTime(TrackEnvelope, position) -- get the "prior" marker
  if Ainteger==-1 then retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, 0) Ainteger=-1
  else retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, Ainteger+1) -- get the marker "prior+1"
  end
  if Ainteger+1>reaper.CountEnvelopePoints(TrackEnvelope)-1 then ultraschall.AddErrorMessage("GetNextMuteState", "", "no next mute-envelope-point available", -5) return -1 end
  return Ainteger+1, value, time
end

--A,AA,AAA,AAAA=ultraschall.GetNextMuteState(1,1)

function ultraschall.GetPreviousMuteState(track, position)
-- returns the previous mute-envelope-point, it's value and it's time
-- Envelope-Points numbering starts with 0!
-- returns -1 if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPreviousMuteState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer envIDX, number envVal, number envPosition = ultraschall.GetPreviousMuteState(integer track, number position)</functioncall>
  <description>
    Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0! Returns -1 if not existing.
  </description>
  <retvals>
    integer envIDX - number of the muteenvelope-point
     number envVal - value of the muteenvelope-point (0 or 1)
     number envPosition  - position of the muteenvelope-point in seconds
  </retvals>
  <parameters>
    integer track - the track-number, for where you want to set the mute-envelope-lane, beginning with 1.
    number position - position in seconds, from where to look for the previous mute-envelope-point
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, position, envelope, state, value</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("GetPreviousMuteState", "track", "must be an integer", -1) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("GetPreviousMuteState", "track", "must be a number", -2) return -1 end
  
  -- prepare variables
  local MediaTrack=reaper.GetTrack(0, track-1)
  if MediaTrack==nil then ultraschall.AddErrorMessage("GetPreviousMuteState", "track", "no such track", -3) return -1 end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetPreviousMuteState", "track", "no activated mute-envelope", -4) return -1 end
  
  -- find previous mute-state
  local Ainteger=reaper.GetEnvelopePointByTime(TrackEnvelope, position)
  if Ainteger==-1 then ultraschall.AddErrorMessage("GetPreviousMuteState", "", "no previous mute-state available", -5) return -1 end
  local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, Ainteger)
  return Ainteger, value, time
end

--A,AA,AAA,AAAA=ultraschall.GetPreviousMuteState(1,reaper.GetPlayPosition())
--A,AA,AAA,AAAA=ultraschall.GetPreviousMuteState(1,1)



function ultraschall.GetNextMuteState_TrackObject(MediaTrack, position)
-- returns the next mute-envelope-point, it's value and it's time
-- Envelope-Points numbering starts with 0!
-- returns -1 if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetNextMuteState_TrackObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer envIDX, number envVal, number envPosition = ultraschall.GetNextMuteState_TrackObject(MediaTrack track, number position)</functioncall>
  <description>
    Returns the next mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0! Returns -1 if not existing.
  </description>
  <retvals>
    integer envIDX - number of the muteenvelope-point
     number envVal - value of the muteenvelope-point (0 or 1)
     number envPosition  - position of the muteenvelope-point in seconds
  </retvals>
  <parameters>
    MediaTrack track - the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.
    number position - position in seconds, from where to look for the next mute-envelope-point
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, position, envelope, state, value</tags>
</US_DocBloc>
--]]
  
  -- check parameters
  if reaper.ValidatePtr2(0, MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("GetNextMuteState_TrackObject", "track", "not a MediaTrack-object", -1) return -1 end
  local retval, time, value, shape, tension, selected
  if type(position)~="number" then ultraschall.AddErrorMessage("GetNextMuteState_TrackObject", "position", "only a number allowed", -2) return -1 end
  position=tonumber(position)
  if position<0 then ultraschall.AddErrorMessage("GetNextMuteState_TrackObject", "position", "must be a positive value", -3) return -1 end

  -- get Trackenvelope
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetNextMuteState_TrackObject", "", "no mute-envelope active", -4) return -1 end
  
  -- get and check envelope-point
  local envPoint=reaper.GetEnvelopePointByTime(TrackEnvelope, position) -- get mute-state at or prior position
  if envPoint==-1 then -- if there's no envelope-point at or prior position, get first envelope-point in mute-envelope
    retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, 0) envPoint=-1
  else -- if there's an envelope-point at or prior position, return the next one(which is the first one after position)
    retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, envPoint+1) 
  end
  if envPoint+1>reaper.CountEnvelopePoints(TrackEnvelope)-1 then ultraschall.AddErrorMessage("GetNextMuteState_TrackObject", "", "no next mute-state", -5) return -1 end
  return envPoint+1, value, time
end

--a=reaper.GetTrack(0,0)
--B,BB,BBB=ultraschall.GetNextMuteState_TrackObject(a,1)

function ultraschall.GetPreviousMuteState_TrackObject(MediaTrack, position)
-- returns the previous mute-envelope-point, it's value and it's time
-- Envelope-Points numbering starts with 0!
-- returns -1 if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPreviousMuteState_TrackObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer envIDX, number envVal, number envPosition = ultraschall.GetPreviousMuteState_TrackObject(MediaTrack track, number position)</functioncall>
  <description>
    Returns the previous mute-envelope-point-ID, it's value(0 or 1) and it's time. Envelope-Points numbering starts with 0! Returns -1 if not existing.
  </description>
  <retvals>
    integer envIDX - number of the muteenvelope-point
     number envVal - value of the muteenvelope-point (0 or 1)
     number envPosition  - position of the muteenvelope-point in seconds
  </retvals>
  <parameters>
    MediaTrack track - the MediaTrack-object, for the track, where you want to set the mute-envelope-lane.
    number position - position in seconds, from where to look for the previous mute-envelope-point
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, position, envelope, state, value</tags>
</US_DocBloc>
--]]
  -- check parameters
  if reaper.ValidatePtr2(0, MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("GetPreviousMuteState_TrackObject", "track", "must be a MediaTrack", -1) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("GetPreviousMuteState_TrackObject", "position", "must be a number", -2) return -1 end
  position=tonumber(position)
  if position<0 then ultraschall.AddErrorMessage("GetPreviousMuteState_TrackObject", "position", "must be a positive value", -3) return -1 end
  
  -- get mute-envelope
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetPreviousMuteState_TrackObject", "position", "no mute-envelope active", -4) return -1 end
  
  -- get mute-envelope-point
  local envPoint=reaper.GetEnvelopePointByTime(TrackEnvelope, position)
  local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, envPoint)
  return Ainteger, value, time
end

--  MediaTrack=reaper.GetTrack(0, 0)
--  A,AA,AAA=ultraschall.GetNextMuteState_TrackObject(MediaTrack,0)


  
function ultraschall.CountMuteEnvelopePoints(track)
--returns the number of the envelope-points in the Mute-lane of track "track"
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountMuteEnvelopePoints</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.CountMuteEnvelopePoints(integer track)</functioncall>
  <description>
    Returns the number of the envelope-points in the Mute-lane of track "track". Returns -1, if it fails.
  </description>
  <retvals>
    integer retval  - number of mute-envelope-points
  </retvals>
  <parameters>
    integer track - the track-number, for which you want to count the mute-envelope-points, beginning with 1.
  </parameters>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, mute, envelope, state</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("CountMuteEnvelopePoints", "track", "must be an integer", -1) return -1 end

  if track<1 then ultraschall.AddErrorMessage("CountMuteEnvelopePoints", "track", "track must be 1 and higher", -2) return -1 end
  
  -- get track and mute-envelope
  local MediaTrack=reaper.GetTrack(0, track-1)
  if MediaTrack==nil then ultraschall.AddErrorMessage("CountMuteEnvelopePoints", "track", "no such track", -3) return -1 end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("CountMuteEnvelopePoints", "track", "no mute-envelope active in track", -4) return -1 end

  -- return envelope-points
  return reaper.CountEnvelopePoints(TrackEnvelope)
end

--A=ultraschall.CountMuteEnvelopePoints(1)

-------------------------------
---- Toggle States&Buttons ----
-------------------------------

function ultraschall.CheckActionCommandIDFormat(aid)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckActionCommandIDFormat</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.CheckActionCommandIDFormat(action_command_id)</functioncall>
  <description>
    Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).
    
    Does not check, whether this action_command_id is a useable one, only if it's "syntax" is correct!
  </description>
  <retvals>
    boolean retval  - true, valid action_command_id; false, not a valid action_command_id
  </retvals>
  <parameters>
    actioncommand_id - the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command, commandid, actioncommandid, check, validity</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(aid)~="integer" and type(aid)~="string" then ultraschall.AddErrorMessage("CheckActionCommandIDFormat", "action_command_id", "must be an integer or a string", -1) return false end
  
  if type(aid)=="number" and tonumber(aid)==math.floor(tonumber(aid)) and tonumber(aid)<=65535 and tonumber(aid)>=0 then return true -- is it a valid number?
  elseif type(aid)=="string" and aid:sub(1,1)=="_" and aid:len()>1 then return true -- is it a valid string, formatted right=
  else return false -- if neither, return false
  end
end

function ultraschall.CheckActionCommandIDFormat2(aid)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckActionCommandIDFormat2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.CheckActionCommandIDFormat2(action_command_id)</functioncall>
  <description>
    Checks, whether an action command id is a valid commandid(which is a number) or a valid _action_command_id (which is a string with an _underscore in the beginning).
    
    Unlike CheckActionCommandIDFormat, this checks whether an action-command-id-string is an actual registered one(case sensitive!).
  </description>
  <retvals>
    boolean retval  - true, valid action_command_id; false, not a valid action_command_id
  </retvals>
  <parameters>
    actioncommand_id - the ActionCommandID you want to check; either a number or an action_command_id with an underscore at the beginning
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command, commandid, actioncommandid, check, validity</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(aid)~="integer" and type(aid)~="string" then ultraschall.AddErrorMessage("CheckActionCommandIDFormat2", "action_command_id", "must be an integer or a string", -1) return false end
  
  if type(aid)=="number" and tonumber(aid)==math.floor(tonumber(aid)) and tonumber(aid)<=65535 and tonumber(aid)>=0 then return true -- is it a valid number?
  elseif type(aid)=="string" and aid:sub(1,1)=="_" and aid:len()>1 and reaper.NamedCommandLookup(tostring(aid))~=0 then return true -- is it a valid string, formatted right=
  else return false -- if neither, return false
  end
end

--A=ultraschall.CheckActionCommandIDFormat2("_Ultraschall_OnAir")

function ultraschall.ToggleStateAction(section, actioncommand_id, state)
-- Toggles state of an actioncommand_id
-- returns current state of the action after toggling
--
-- section - section (usually 0 for main)
-- actioncommand_id - the ActionCommandID of the Action you'll want to toggle
-- state - 0 for off, 1 for on
--
-- If you have a button associated, you'll need to use RefreshToolbar() later!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleStateAction</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ToggleStateAction(integer section, string actioncommand_id, integer state)</functioncall>
  <description>
    Toggles state of an action using the actioncommand_id(instead of the CommandID-number)
    
    returns current state of the action after toggling or -1 in case of error.
  </description>
  <retvals>
    boolean retval  - state if the action, after it has been toggled
  </retvals>
  <parameters>
    integer section - the section of the action(see ShowActionlist-dialog)
                            -0 - Main
                            -100 - Main (alt recording)
                            -32060 - MIDI Editor
                            -32061 - MIDI Event List Editor
                            -32062 - MIDI Inline Editor
                            -32063 - Media Explorer
    string actioncommand_id - the ActionCommandID of the action to toggle
    integer state - 1 or 0
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command,commandid,actioncommandid,action,run,state,section</tags>
</US_DocBloc>
--]]
  -- check parameters
  if actioncommand_id==nil then ultraschall.AddErrorMessage("ToggleStateAction", "action_command_id", "must be a number or a string", -1) return -1 end
  if math.type(state)~="integer" then ultraschall.AddErrorMessage("ToggleStateAction", "state", "must be an integer", -2) return -1 end
  if math.type(section)~="integer" then ultraschall.AddErrorMessage("ToggleStateAction", "section", "must be an integer", -3) return -1 end
  
  -- do the toggling
  local command_id = reaper.NamedCommandLookup(actioncommand_id)
  reaper.SetToggleCommandState(section, command_id, state)
  return reaper.GetToggleCommandState(command_id)
end

--ultraschall.ToggleStateAction(0,"_Ultraschall_OnAir", 0)

function ultraschall.RefreshToolbar_Action(section, actioncommand_id)
-- Refreshes a toolbarbutton with an ActionCommandID
--
-- section - section
-- actioncommand_id - ActionCommandID of the action, associated with the toolbarbutton
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RefreshToolbar_Action</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> ultraschall.RefreshToolbar_Action(integer section, string actioncommand_id)</functioncall>
  <description>
    Refreshes a toolbarbutton with an ActionCommandID(instead of the CommandID-number)
    
    returns -1 in case of error
  </description>
  <parameters>
    integer section - section
                            -0 - Main
                            -100 - Main (alt recording)
                            -32060 - MIDI Editor
                            -32061 - MIDI Event List Editor
                            -32062 - MIDI Inline Editor
                            -32063 - Media Explorer
    string actioncommand_id - ActionCommandID of the action, associated with the toolbarbutton 
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command,commandid,actioncommandid,action,run,toolbar,refresh</tags>
</US_DocBloc>
--]]
  -- check parameters
  if actioncommand_id==nil then ultraschall.AddErrorMessage("RefreshToolbar_Action", "action_command_id", "must be a number or a string", -1) return -1 end
  if math.type(section)~="integer" then ultraschall.AddErrorMessage("RefreshToolbar_Action", "section", "must be an integer", -2) return -1 end
  
  -- do the refreshing
  local command_id = reaper.NamedCommandLookup(actioncommand_id)
  reaper.RefreshToolbar2(0, command_id)
  return 0
end

--ultraschall.RefreshToolbar_Action(0,"_Ultraschall_OnAir")

function ultraschall.ToggleStateButton(section, actioncommand_id, state)
-- Toggles state and refreshes the button of an actioncommand_id
-- section - section (usually 0 for main)
-- actioncommand_id - the ActionCommandID of the Action you'll want to toggle
-- state - 0 for off, 1 for on
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ToggleStateButton</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ToggleStateButton(integer section, string actioncommand_id, integer state)</functioncall>
  <description>
    Toggles state and refreshes the button of an actioncommand_id
    
    returns false in case of error
  </description>
  <retvals>
    boolean retval  - state of the State-Button, after toggling
  </retvals>
  <parameters>
    integer section - the section of the action(see ShowActionlist-dialog)
                            -0 - Main
                            -100 - Main (alt recording)
                            -32060 - MIDI Editor
                            -32061 - MIDI Event List Editor
                            -32062 - MIDI Inline Editor
                            -32063 - Media Explorer
    string actioncommand_id - the ActionCommandID of the action to toggle
    integer state - 1 or 0
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>command,commandid,actioncommandid,action,run,toolbar,toggle,button</tags>
</US_DocBloc>
--]]
  if actioncommand_id==nil then ultraschall.AddErrorMessage("ToggleStateButton", "action_command_id", "must be a string or a number", -1) return false end
  if math.type(state)~="integer" then ultraschall.AddErrorMessage("ToggleStateButton", "state", "must be an integer", -2) return false end
  if math.type(section)~="integer" then ultraschall.AddErrorMessage("ToggleStateButton", "section", "must be an integer", -3) return false end

  local command_id = reaper.NamedCommandLookup(actioncommand_id)
  local stater=reaper.SetToggleCommandState(section, command_id, state)
  reaper.RefreshToolbar(command_id)
  if stater==false then ultraschall.AddErrorMessage("ToggleStateButton", "action_command_id", "doesn't exist", -4) return false end
  return stater
end

--A=ultraschall.ToggleStateButton(0,"_Ultraschall_OnAir", 0)


---------------------
---- Add Markers ----
---------------------

function ultraschall.AddNormalMarker(position, shown_number, markertitle)
-- Adds a normal Marker, not specifically for shownotes or chapter, etc
-- position - position in seconds; must be positive value
-- shown_number - the indexnumber shown in Reaper for this marker
-- markertitle - the title of the marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddNormalMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer marker_number = ultraschall.AddNormalMarker(number position, integer shown_number, string markertitle)</functioncall>
  <description>
    Adds a normal marker. Returns the index of the marker as marker_number.
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
     integer marker_number  - the overall-marker-index, can be used for reaper's own marker-management functions
  </retvals>
  <parameters>
    number position - position in seconds.
    integer shown_number - the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.
    string markertitle - the title of the marker.
  </parameters>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, add, normal marker</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(position)~="number" then ultraschall.AddErrorMessage("AddNormalMarker", "position", "must be a number", -1) return -1 end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("AddNormalMarker", "shown_number", "must be an integer", -2) return -1 end
  if markertitle==nil then markertitle="" end

  -- create marker
  local noteID=0
  if position>=0 then noteID=reaper.AddProjectMarker2(0, false, position, 0, markertitle, shown_number, 0)
  else noteID=-1
  end
  return noteID
end


function ultraschall.AddPodRangeRegion(startposition, endposition)
-- creates a region that marks the begin and end of the podcast with a _PodRange:-region.
-- only one _PodRange:-region is allowed, all others will be deleted by this function!
-- helps find the right offsets for correct positioning of the chapters/shownote/markers 
-- in the exportfile
--
-- startposition - starting-position of the range in seconds; must be a positive value
-- endposition - end-position of the range in seconds; must be bigger than endposition
-- returns -1 if it fails

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddPodRangeRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer marker_number = ultraschall.AddPodRangeRegion(number startposition, number endposition)</functioncall>
  <description>
    Adds a region, which shows the time-range from the beginning to the end of the podcast.
  </description>
  <retvals>
    integer marker_number  - the overall-marker-index, can be used for reaper's own marker-management functions
  </retvals>
  <parameters>
    number startposition - begin of the podcast in seconds
    number endposition - end of the podcast in seconds
  </parameters>
  <chapter_context>
    Markers
    PodRange Region
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, add, podrange, region</tags>
</US_DocBloc>
--]]
  
  -- prepare variables
  local color=0
  local noteID=0
  
  -- prepare colorvalue
  local Os = reaper.GetOS()
  if string.match(Os, "OSX") then 
    color = 0xFFFFFF|0x1000000
  else
    color = 0xFFFFFF|0x1000000
  end

  local a,nummarkers,numregions=reaper.CountProjectMarkers(0)
  local count=0

  if type(startposition)~="number" then ultraschall.AddErrorMessage("AddPodRangeRegion", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("AddPodRangeRegion", "endposition", "must be a number", -2) return -1 end
  if startposition<0 then return -1 end
  if endposition<startposition then return -1 end
  
  for i=nummarkers+numregions, 0, -1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,10)=="_PodRange:" and isrgn==true then count=count+1 reaper.DeleteProjectMarkerByIndex(0,i) end 
  end
  
  noteID=reaper.AddProjectMarker2(0, 1, startposition, endposition, "_PodRange:", 0, color)

  return noteID
end

--A=ultraschall.AddPodRangeRegion(14,17)

function ultraschall.GetMarkerByName(searchname, searchisrgn)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerByName</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count_markers, array foundmarkers = ultraschall.GetMarkerByName(string searchname, boolean searchisrgn)</functioncall>
  <description>
    Get all markers/regions that have a certain name. This function is not case-sensitive.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer count_markers - the number of found markers/regions
    array foundmarkers - an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn)
  </retvals>
  <parameters>
    string searchname - the name to look for; must be exact; not case-sensitive
    boolean searchisrgn - true, search only within regions; false, search only within markers
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, marker, region, name</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(searchname)~="string" then ultraschall.AddErrorMessage("GetMarkerByName", "searchname", "must be a string", -1) return -1 end
  if type(searchisrgn)~="boolean" then ultraschall.AddErrorMessage("GetMarkerByName", "searchisrgn", "must be boolean", -2) return -1 end
  
  -- prepare variables
  local foundmarkers={}
  local count=1
  local markercount=0
  searchname=searchname:upper()
  
  -- look for markers/regions
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if searchisrgn==isrgn then markercount=markercount+1 end -- count markers/region
    if isrgn==searchisrgn and name:upper()==searchname:upper() then foundmarkers[count]=markercount count=count+1 end -- if right marker/region has been found,
                                                                                                                      -- add it to the foundmarkers-array
  end
  return count-1, foundmarkers
end

--A,AA,AAA=ultraschall.GetMarkerByName("", true)


function ultraschall.GetMarkerByName_Pattern(searchname, searchisrgn)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerByName_Pattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count_markers, array foundmarkers = ultraschall.GetMarkerByName_Pattern(string searchname, boolean searchisrgn)</functioncall>
  <description>
    Get all markers/regions that have a certain character-sequence in their name. This function is not case-sensitive.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer count_markers - the number of found markers/regions
    array foundmarkers - an array with all marker/region-numbers of the found markers; counts only regions or markers(depending on parameter searchisrgn)
  </retvals>
  <parameters>
    string searchname - the name to look for; a character-sequence that shall be part of the name; not case-sensitive
    boolean searchisrgn - true, search only within regions; false, search only within markers
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, marker, region, pattern</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(searchname)~="string" then ultraschall.AddErrorMessage("GetMarkerByName_Pattern", "searchname", "must be a string", -1) return -1 end
  if type(searchisrgn)~="boolean" then ultraschall.AddErrorMessage("GetMarkerByName_Pattern", "searchisrgn", "must be boolean", -2) return -1 end
  
  -- prepare variables
  local foundmarkers={}
  local count=1
  local markercount=0
  searchname=searchname:upper()
  
  -- look for markers/regions
  for i=0, reaper.CountProjectMarkers(0)-1 do
    retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    name=name:upper()    
    if searchisrgn==isrgn then markercount=markercount+1 end -- count marker/region
    if searchisrgn==isrgn and name:match(searchname)~=nil then foundmarkers[count]=markercount count=count+1 end -- if right marker/region has been found
                                                                                                                 -- add to foundmarkers-array
  end
  return count-1, foundmarkers
end

--A,A2,A3=ultraschall.GetMarkerByName_Pattern("w", true)

function ultraschall.GetMarkerAndRegionsByIndex(idx, searchisrgn)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerAndRegionsByIndex</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string name, integer shown_number, integer color, number pos, optional number rgnend = ultraschall.GetMarkerAndRegionsByIndex(integer idx, boolean searchisrgn)</functioncall>
  <description>
    Returns the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.
    
    returns nil in case of an error
  </description>
  <retvals>
    string name - the name of the marker/region
    integer markrgnindexnumber - the shown number of the marker/region
    integer color - the color-value of the marker/region
    number pos - the position of the marker/region
    optional number rgnend - the end of the region
  </retvals>
  <parameters>
    integer idx - the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to
    boolean searchisrgn - true, search only within regions; false, search only within markers
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, marker, region, index, color, name, position, regionend, shownnumber, shown</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetMarkerAndRegionsByIndex", "idx", "must be an integer", -1) return  end
  if type(searchisrgn)~="boolean" then ultraschall.AddErrorMessage("GetMarkerAndRegionsByIndex", "searchisrgn", "must be boolean", -2) return  end

  -- prepare variable
  local markercount=0
  
  -- look for the right marker/region
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if searchisrgn==isrgn then markercount=markercount+1 end -- count marker/region
    if searchisrgn==isrgn and isrgn==true and markercount==idx then return name, markrgnindexnumber, color, pos, rgnend end -- if right region, return values
    if searchisrgn==isrgn and isrgn==false and markercount==idx then return name, markrgnindexnumber, color, pos end -- if right marker, return values
  end
end

--A,B,C,D,E,F,G,H,I,J=ultraschall.GetMarkerByIndex(1, false)


function ultraschall.SetMarkerByIndex(idx, searchisrgn, shown_number, pos, rgnend, name, color, flags)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetMarkerByIndex</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetMarkerByIndex(integer idx, boolean searchisrgn, integer shown_number, number position, position rgnend, string name, integer color, integer flags)</functioncall>
  <description>
    Sets the values of a certain marker/region. The numbering of idx is either only for the markers or for regions, depending on what you set with parameter searchisrgn.
    
    returns nil in case of an error
  </description>
  <retvals>
    boolean retval - true, setting the marker/region was successful; false, setting of the marker/region was unsuccessful.
  </retvals>
  <parameters>
    integer idx - the number of the requested marker/region; counts only within either markers or regions, depending on what you've set searchisrgn to
    boolean searchisrgn - true, search only within regions; false, search only within markers
    integer shown_number - the shown-number of the region/marker; no duplicate numbers for regions allowed; nil to keep previous shown_number
    number position - the position of the marker/region in seconds; nil to keep previous position
    position rgnend - the end of the region in seconds; nil to keep previous region-end
    string name - the name of the marker/region; nil to keep the previous name
    integer color - color should be 0 to not change, or ColorToNative(r,g,b)|0x1000000; nil to keep the previous color
    integer flags - flags&1 to clear name; 0, keep it; nil to use the previous setting
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, set, marker, region, index, color, name, position, regionend, shownnumber, shown</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("SetMarkerByIndex", "idx", "must be an integer", -1) return -1 end
  if type(searchisrgn)~="boolean" then ultraschall.AddErrorMessage("SetMarkerByIndex", "searchisrgn", "must be boolean", -2) return -1 end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("SetMarkerByIndex", "shown_number", "must be an integer", -3) return -1 end
  if type(pos)~="number" then ultraschall.AddErrorMessage("SetMarkerByIndex", "pos", "must be a number", -4) return -1 end
  if type(rgnend)~="number" then ultraschall.AddErrorMessage("SetMarkerByIndex", "rgnend", "must be a number", -5) return -1 end
  if type(name)~="string" then ultraschall.AddErrorMessage("SetMarkerByIndex", "name", "must be a string", -5) return -1 end
  if math.type(color)~="integer" then ultraschall.AddErrorMessage("SetMarkerByIndex", "color", "must be an integer", -6) return -1 end
  if math.type(flags)~="integer" then ultraschall.AddErrorMessage("SetMarkerByIndex", "flags", "must be an integer", -7) return -1 end

  -- prepare variable
  local markercount=0
  
  -- search and set marker/region
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval2, isrgn, pos2, rgnend2, name2, markrgnindexnumber2, color2 = reaper.EnumProjectMarkers3(0,i)
    
    -- count marker/region
    if searchisrgn==isrgn then markercount=markercount+1 end
    if searchisrgn==isrgn and isrgn==true and markercount==idx then
      -- if the correct region has been found, change it
      if shown_number==nil then shown_number=markrgnindexnumber2 end
      if pos==nil then pos=pos2 end
      if rgnend==nil then rgnend=rgnend2 end
      if name==nil then name=name2 end
      if color==nil then color=color2 end
      return reaper.SetProjectMarkerByIndex2(0, i, true, pos, rgnend, shown_number, name, color, 0)
    end
    if searchisrgn==isrgn and isrgn==false and markercount==idx then 
      -- if the correct marker has been found, change it
      if shown_number==nil then shown_number=markrgnindexnumber2 end
      if pos==nil then pos=pos2 end
      if rgnend==nil then rgnend=rgnend2 end
      if name==nil then name=name2 end
      if color==nil then color=color2 end
      return reaper.SetProjectMarker4(0, i, false, pos, rgnend, name, color, flags) 
    end
  end
  
  -- if no such marker/region has been found
  if searchisrgn==true then ultraschall.AddErrorMessage("SetMarkerByIndex", "idx", "no such region", -8) return nil end
  if searchisrgn==false then ultraschall.AddErrorMessage("SetMarkerByIndex", "idx", "no such marker", -9) return nil end
  return false
end

--A,B=ultraschall.SetMarkerByIndex(1, true, 6, 7, 8, "Tudelu", reaper.ColorToNative(40,90,100)|0x1000000, 0)


function ultraschall.AddEditMarker(position, shown_number, edittitle)
-- Adds an Editmarker. 
-- position - is time in seconds, 
-- shown_number - the number shown with the Edit-Marker in Reaper
-- edittitle - a string of a description for this Edit-marker
--
-- If no chaptertitle is given, it will write "_Edit:" only
-- returns -1 if position isn't a valid value
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddEditMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer marker_number = ultraschall.AddEditMarker(number position, integer shown_number, string edittitle)</functioncall>
  <description>
    Adds an Edit marker. Returns the index of the marker as marker_number. 
  </description>
  <retvals>
     integer marker_number  - the overall-marker-index, can be used for reaper's own marker-management functions
  </retvals>
  <parameters>
    number position - position in seconds.
    integer shown_number - the number, that will be shown within Reaper. Can be multiple times. Use -1 to let Reaper decide the number.
    string edittitle - the title of the edit-marker; will be shown as _Edit:edittitle
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, add, edit, marker</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local color=0
  local noteID=0
  local Os = reaper.GetOS()
  if string.match(Os, "OSX") then 
    color = 0xFF0000|0x1000000
  else
    color = 0x0000FF|0x1000000
  end
  
  -- check parameters
  if type(position)~="number" then ultraschall.AddErrorMessage("AddEditMarker", "position", "must be a number", -1) return -1 end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("AddEditMarker", "shown_number", "must be a integer", -2) return -1 end
  if edittitle==nil then edittitle="" end

  -- set marker
  if position>=0 then noteID=reaper.AddProjectMarker2(0, false, position, 0, "_Edit"..edittitle, shown_number, color) -- set red edit-marker
  else noteID=-1
  end

  return noteID
end

--ultraschall.AddEditMarker(13,20,"hui")



-----------------------
---- Count Markers ----
-----------------------

function ultraschall.CountNormalMarkers()
-- returns number of normal markers in the project
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountNormalMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer number_of_markers = ultraschall.CountNormalMarkers()</functioncall>
  <description>
    Counts all normal markers. 
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
     integer number_of_markers  - number of normal markers
  </retvals>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, normal marker, marker, count</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local a,nummarkers,b=reaper.CountProjectMarkers(0)
  local count=0
  
  -- count normal-markers
  for i=0, a-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if name==nil then name="" end
    if name:sub(1,10)=="_Shownote:" or name:sub(1,5)=="_Edit" or color == ultraschall.ConvertColor(100,255,0) then 
        -- if marker is shownote, chapter, edit or planned chapter
    elseif isrgn==false then count=count+1 -- elseif marker is no region, count up
    end
  end 

  return count
end

--A=ultraschall.CountNormalMarkers()

function ultraschall.CountEditMarkers()
-- returns number of _Edit: markers in the project
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountEditMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer number_of_edit_markers = ultraschall.CountEditMarkers()</functioncall>
  <description>
    Counts all edit-markers.
  </description>
  <retvals>
     integer number_of_edit_markers  - number of edit markers
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, count, edit markers, edit</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local a,nummarkers,b=reaper.CountProjectMarkers(0)
  local count=0
  
  -- count edit-markers
  for i=0, a-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,5)=="_Edit" and isrgn==false then count=count+1 end 
  end

  return count
end

--A=ultraschall.CountEditMarkers()

---------------------------
---- Enumerate Markers ----
---------------------------

function ultraschall.GetPodRangeRegion()
-- returns startposition and endposition of the PodRange-Region.
-- only one _PodRange:-region is allowed, if there are more, it will return -1
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPodRangeRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> number start_position, number end_position = ultraschall.GetPodRangeRegion()</functioncall>
  <description>
    Gets the start_position and the end_position of the PodRangeRegion.
    
    returns -1 if no PodRangeRegion exists
  </description>
  <retvals>
     number start_position - beginning of the podrangeregion, that marks the beginning of the podcast
     number end_position  - end of the podrangeregion, that marks the end of the podcast
  </retvals>
  <chapter_context>
    Markers
    PodRange Region
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, enumerate, podrange region, podrange, region</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local color=ultraschall.ConvertColor(255,255,255)

  local a,nummarkers,numregions=reaper.CountProjectMarkers(0)
  local startposition=-1
  local endposition=-1
  local count=0
  
  -- find _Podrange-regions
  for i=nummarkers+numregions, 0, -1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,10)=="_PodRange:" and isrgn==true then startposition=pos endposition=rgnend count=count+1 end 
  end
  
  -- return positions
  if count>1 then return -1, -1
  else return startposition, endposition
  end
end

--A,AA=ultraschall.GetPodRangeRegion()



function ultraschall.EnumerateNormalMarkers(number)
-- returns number of markers in general(not chaptermarker!), the shown marker-number,chaptername-name of the marker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateNormalMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retnumber, integer retidxnum, number position, string markertitle = ultraschall.EnumerateNormalMarkers(integer number)</functioncall>
  <description>
    Get the data of a normal marker. 
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
    
    Returns -1 in case of error
  </description>
  <retvals>
     integer retnumber - overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of
    - markers but counts from position 00:00:00 to end of project. So if you created a marker at position 00:00:00 and move the first created marker to
    - the end of the timeline, it will be the last one, NOT the first one in the retval! For use with reaper's own marker-functions.
     integer retidxnum - indexnumber of the marker
     number position - the position of the marker
     string markertitle  - the name of the marker
  </retvals>
  <parameters>
    integer number - number of the marker(normal markers only). Refer <a href="#CountNormalMarkers">ultraschall.CountNormalMarkers</a> for getting the number of normal markers.
  </parameters>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, normal, normal marker, enumerate</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateNormalMarkers", "number", "must be an integer", -1) return -1 end
  
  -- prepare variables
  local a,nummarkers,b=reaper.CountProjectMarkers(0)
  local number=number-1
  local wentfine=0
  local count=-1
  local retnumber=0
  local retidxnum=""
  local markername=""
  local position=0
  
  -- find the right normal-marker
  for i=0, a-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color= reaper.EnumProjectMarkers3(0,i)
    if isrgn==false then
      if name:sub(1,10)~="_Shownote:" and name:sub(1,5)~="_Edit" and color~=ultraschall.ConvertColor(100,255,0) then count=count+1 end
    end
    if number>=0 and wentfine==0 and count==number then
        retnumber=retval 
        markername=name
        retidxnum=markrgnindexnumber
        position=pos
        wentfine=1
    end
  end
  
  -- return the found marker
  if wentfine==1 then return retnumber, retidxnum, position, markername
  else return -1
  end
end

--Aretnumber, Aretidxnum, Aposition, Amarkername = ultraschall.EnumerateNormalMarkers(0)

function ultraschall.EnumerateEditMarkers(number)
-- Get the data of an _Edit marker
-- returns number, ID, position(in seconds) and the editmarker-name
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateEditMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer retnumber, integer shown_number, number position, string edittitle = ultraschall.EnumerateEditMarkers(integer edit_index)</functioncall>
  <description>
    Get the data of an edit marker.
  </description>
  <retvals>
     integer retnumber - overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of
    - markers but counts from position 00:00:00 to end of project. So if you created a marker at position 00:00:00 and move the first created marker to
    - the end of the timeline, it will be the last one, NOT the first one in the retval! For use with reaper's own marker-functions.
     integer shown_number - indexnumber of the marker
     number position - the position of the marker
     string dummyname  - the name of the marker
  </retvals>
  <parameters>
    integer edit_index - number of the edit-marker. Refer <a href="#CountEditMarkers">ultraschall.CountEditMarkers</a> for getting the number of edit-markers.
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, enumerate, edit, edit marker</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateEditMarkers", "edit_index", "must be an integer", -1) return -1 end
  
  -- prepare variables
  local a,nummarkers,b=reaper.CountProjectMarkers(0)
  local number=number-1
  local wentfine=0
  local count=-1
  local retnumber=0
  local retidxnum=""
  local editname=""
  local position=0
  
  -- find the correct edit-marker
  for i=0, a-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==false then
      if name:sub(1,5)=="_Edit" then count=count+1 end 
      if number>=0 and wentfine==0 and count==number then 
          retnumber=retval 
          editname=name:sub(7,-1)
          retidxnum=markrgnindexnumber
          position=pos
          wentfine=1
      end
    end
  end
  
  -- return the found edit-marker
  if wentfine==1 then return retnumber, retidxnum, position, editname
  else return -1
  end
end

--A=ultraschall.AddEditMarker(4,4,"titleD")
--A,AA,AAA,AAAA=ultraschall.EnumerateEditMarkers(1)



function ultraschall.GetAllEditMarkers()
--returns the number of edits and an array of each editmarker in the format:
-- editmarkersarray [index] [0-position;1-editname]
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllEditMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer number_of_editmarkers, array editmarkersarray = ultraschall.GetAllEditMarkers()</functioncall>
  <description>
    returns the number of editmarkers and an array with each editmarker in the format:
    
        editmarkersarray[index][0] - position
        editmarkersarray[index][1] - name
        editmarkersarray[index][2] - idx
        
  </description>
  <retvals>
    integer number_of_editmarkers - the number of editmarkers returned
     array editmarkersarray  - an array with all the edit-markers of the project
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, get, get all, edit, edit marker</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local count=ultraschall.CountEditMarkers()
  local editmarkersarray = {}
  
  -- find all edit-markers and add their attributes to the editmarkersarray
  for i=1, count do
    editmarkersarray[i]={}
    local idx,b,position,name=ultraschall.EnumerateEditMarkers(i)
    editmarkersarray[i][0]=position
    editmarkersarray[i][1]=name
    editmarkersarray[i][2]=idx
  end

  -- return results
  return count, editmarkersarray
end

--A,AA, AAA=ultraschall.GetAllEditMarkers()

function ultraschall.GetAllNormalMarkers()
--returns the number of normal markers and an array of each normal marker in the format:
-- normalmarkersarray [index] [0-position;1-normalmarkername]
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllNormalMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> index number_of_normalmarkers, array normalmarkersarray = ultraschall.GetAllNormalMarkers()</functioncall>
  <description>
    returns the number of normalmarkers and an array with each normalmarker in the format:
    
    normalmarkersarray[index][0] - position
    normalmarkersarray[index][1] - name
    normalmarkersarray[index][2] - idx of the marker within all markers in project
    normalmarkersarray[index][3] - the shown index number of the marker
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
    integer number_of_normalmarkers - the number of normalmarkers returned
    array normalmarkersarray  - an array, that holds all normal markers of the project
  </retvals>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, get, get all, normal, normal marker</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local count=ultraschall.CountNormalMarkers()
  local normalmarkersarray = {}
  
  -- find all normal markers and add theyre attributes to normalmarkersarray
  for i=1, count do
    normalmarkersarray[i]={}
    local idx,shown,position,name=ultraschall.EnumerateNormalMarkers(i)
    normalmarkersarray[i][0]=position
    normalmarkersarray[i][1]=name
    normalmarkersarray[i][2]=idx
    normalmarkersarray[i][3]=shown
  end

  -- return results
  return count, normalmarkersarray
end

--A,AA=ultraschall.GetAllNormalMarkers()

function ultraschall.GetAllMarkers()
-- count - number of markers
-- markersarray - an array with all names excluding _edit:, _shownote:, _chapter:. Switching between markername, type of marker, markername, type of maker
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer number_of_all_markers, array allmarkersarray = ultraschall.GetAllMarkers()</functioncall>
  <description>
    To get all Markers in the project(normal, edit, chapter), regardless of their category.
    Doesn't return regions!
    
    returns the number of markers and an array with each marker in the format:
    
        markersarray[index][0] - position
        markersarray[index][1] - name
        markersarray[index][2] - indexnumber of the marker within all markers in the project
        markersarray[index][3] - the shown index-number
        markersarray[index][4] - the color of the marker
        
  </description>
  <retvals>
    integer number_of_allmarkers - the number of markers returned
    array allmarkersarray  - an array, that holds all markers(not regions!) of the project
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, get, get all</tags>
</US_DocBloc>
--]]
  -- prepare variable
  local count,aa,bb= reaper.CountProjectMarkers(0)
  local markersarray = {}

  -- get all markers and add their attributes to markersarray
  for i=1, count do
    markersarray[i]={}
    local retval, isrgn, position, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i-1)
    markersarray[i][0]=position
    markersarray[i][1]=name
    markersarray[i][2]=retval-1
    markersarray[i][3]=markrgnindexnumber
    markersarray[i][4]=color
  end

  -- return results
  return count, markersarray
end

--A,AA=ultraschall.GetAllMarkers()


----------------------
---- Set Markers -----
----------------------

function ultraschall.SetNormalMarker(number, position, shown_number, markertitle)
-- Sets values of a normal Marker(no _Chapter:, _Shownote:, etc)
-- number - number of the marker, 1 to current number of markers
-- position - position in seconds; -1 - keep the old value
-- shown_number - the number shown with the marker in Reaper; -1 - keep the old value
-- markertitle - title of the marker; nil - keep the old value
--
-- returns true if successful and false if not(i.e. marker doesn't exist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetNormalMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> boolean retval = ultraschall.SetNormalMarker(integer number, number position, integer shown_number, string markertitle)</functioncall>
  <description>
     Sets values of a normal Marker(no _Chapter:, _Shownote:, etc). Returns true if successful and false if not(i.e. marker doesn't exist)
     
     Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <parameters>
    integer number - the number of the normal marker
    number position - position of the marker in seconds
    integer shown_number - the number of the marker
    string markertitle - title of the marker
  </parameters>
  <retvals>
     boolean retval  - true if successful and false if not(i.e. marker doesn't exist)
  </retvals>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, set, set normal, normal marker</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(position)~="number" and position~=nil then ultraschall.AddErrorMessage("SetNormalMarker", "position", "must be a number", -1) return false end
  if position==nil or position<0 then position=-1 end
  if tonumber(shown_number)==nil then shown_number=-1 end
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("SetNormalMarker", "number", "must be an integer", -2) return false end
  
  -- prepare variable
  local color=0
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  number=tonumber(number)-1
  local wentfine=0
  local count=-1
  local retnumber=0
  
  -- find the right marker, that shall be changed
  for i=0, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==false then
      if name:sub(1,10)~="_Shownote:" and name:sub(1,5)~="_Edit" and color~=ultraschall.ConvertColor(100,255,0) then count=count+1 end
    end
    if number>=0 and wentfine==0 and count==number then
        if tonumber(position)==-1 or position==nil then position=pos end
        if tonumber(shown_number)<=-1 or shown_number==nil then shown_number=markrgnindexnumber end
        if markertitle==nil then markertitle=name end
        retnumber=i
        wentfine=1
    end
  end
  
  if markertitle==nil then markertitle="" end
  
  -- alter marker, if existing
  if wentfine==1 then return reaper.SetProjectMarkerByIndex(0, retnumber, 0, position, 0, shown_number, markertitle, 0)
  else ultraschall.AddErrorMessage("SetNormalMarker", "number", "no such marker", -3) return false
  end
end

--A=ultraschall.SetNormalMarker(0,nil,3,"hu")

function ultraschall.SetEditMarker(number, position, shown_number, edittitle)
-- Sets values of an Edit-Marker
-- number - number of the _Edit-marker, 1 to current number of _Edit-markers
-- position - position in seconds; -1 - keep the old value
-- shown_number - the number shown with the marker in Reaper; -1 - keep the old value
-- edittitle - title of the editmarker; nil - keep the old value
--
-- returns true if successful and false if not(i.e. marker doesn't exist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetEditMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> boolean retval = ultraschall.SetEditMarker(integer edit_index, number position, integer shown_number, string edittitle)</functioncall>
  <description>
    Sets values of an Edit Marker. Returns true if successful and false if not(i.e. marker doesn't exist)
  </description>
  <parameters>
    integer edit_index - the number of the edit marker
    number position - position of the marker in seconds
    integer shown_number - the number of the marker
    string markertitle - title of the marker
  </parameters>
  <retvals>
     boolean retval  - true if successful and false if not(i.e. marker doesn't exist)
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, set, set edit, edit marker</tags>
</US_DocBloc>
--]]
  
  -- check parameters
  if type(position)~="number" and position~=nil then ultraschall.AddErrorMessage("SetEditMarker", "position", "must be a number", -1) return false end
  if position==nil or position<0 then position=-1 end
  if tonumber(shown_number)==nil then shown_number=-1 end
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("SetEditMarker", "edit_index", "must be an integer", -2) return false end

  -- prepare variables
  local color=ultraschall.ConvertColor(255,0,0)  
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  number=tonumber(number)-1
  local wentfine=0
  local count=-1
  local retnumber=0
  
  -- look for the right edit-marker to change
  for i=0, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==false then
      if name:sub(1,5)=="_Edit" then count=count+1 end 
      if number>=0 and wentfine==0 and count==number then 
          if tonumber(position)==-1 or position==nil then position=pos end
          if tonumber(shown_number)<=-1 or shown_number==nil then shown_number=markrgnindexnumber end
          if edittitle==nil then edittitle=name:match("(_Edit:.*)") edittitle=edittitle:sub(7,-1) end
          retnumber=i
          wentfine=1
      end
    end
  end
  
  if edittitle==nil then edittitle="" end
  
  -- change edit-marker, if existing
  if wentfine==1 then return reaper.SetProjectMarkerByIndex(0, retnumber, 0, position, 0, shown_number, "_Edit:" .. edittitle, color)
  else ultraschall.AddErrorMessage("SetEditMarker", "edit_index", "no such edit-marker", -3) return false
  end
end

--A=ultraschall.SetEditMarker(1,nil,11,nil)


function ultraschall.SetPodRangeRegion(startposition, endposition)
-- Sets _PodRange:-Marker
-- startposition - startposition in seconds, must be positive value
-- endposition - endposition in seconds, must be bigger than startposition
-- returns -1 if it fails
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetPodRangeRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer retval = ultraschall.SetPodRangeRegion(number startposition, number endposition)</functioncall>
  <description>
    Sets "_PodRange:"-Region
    
    returns -1 if it fails.
  </description>
  <parameters>
    number startposition - begin of the podcast in seconds
    number endposition - end of the podcast in seconds
  </parameters>
  <retvals>
     integer retval  - number of the region, -1 if it fails
  </retvals>
  <chapter_context>
    Markers
    PodRange Region
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, set, set podrange, podrange region, region</tags>
</US_DocBloc>
--]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("SetPodRangeRegion", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("SetPodRangeRegion", "endposition", "must be a number", -2) return -1 end
  return ultraschall.AddPodRangeRegion(startposition, endposition)
end

--A,AA,AAA=ultraschall.SetPodRangeRegion(2,10)

-------------------------
---- Delete Markers -----
-------------------------

function ultraschall.DeletePodRangeRegion()
-- deletes the PodRange-Region
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeletePodRangeRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer retval = ultraschall.DeletePodRangeRegion()</functioncall>
  <description>
    deletes the PodRange-Region. 
    Returns false if unsuccessful
  </description>
  <retvals>
    boolean retval - true, if deleting was successful; false, if not
  </retvals>
  <chapter_context>
    Markers
    PodRange Region
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, delete, delete podrange, podrange region, region</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local a,nummarkers,numregions=reaper.CountProjectMarkers(0)
  local count=0
  local itworked=false
  
  -- look for podrange-region and remove it when found
  for i=nummarkers+numregions, 0, -1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,10)=="_PodRange:" and isrgn==true then itworked=reaper.DeleteProjectMarkerByIndex(0,i) end 
  end
  if itworked==false then ultraschall.AddErrorMessage("DeletePodRangeRegion", "", "no _Podrange-region found", -1) return false end
  return itworked
end

--A=ultraschall.AddPodRangeRegion(2,10)
--A2=ultraschall.DeletePodRangeRegion()

function ultraschall.DeleteNormalMarker(number)
-- Deletes a Normal-Marker
-- number - number of the _Normal-marker, 1 to current number of _Normal-markers
-- returns true if successful and false if not(i.e. marker doesn't exist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteNormalMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> boolean retval = ultraschall.DeleteNormalMarker(integer number)</functioncall>
  <description>
    Deletes a Normal-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use <a href="#EnumerateNormalMarkers">ultraschall.EnumerateNormalMarkers</a> to get the correct number.
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <parameters>
    integer number - number of a normal marker
  </parameters>
  <retvals>
     boolean retval  - true, if successful, false if not
  </retvals>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, delete, normal marker, normal</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("DeleteNormalMarker", "number", "must be a number", -1) return -1 end

  -- prepare variables
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  local number=number-1
  local wentfine=0
  local count=-1
  local retnumber=0
  
  -- look for the right normal marker
  for i=1, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==false then
      if name:sub(1,10)~="_Shownote:" and name:sub(1,5)~="_Edit" and color~=ultraschall.ConvertColor(100,255,0) then count=count+1 end
    end
    if number>=0 and wentfine==0 and count==number then
        retnumber=i
        wentfine=1
    end
  end
  
  -- remove the found normal-marker, if existing
  if wentfine==1 then return reaper.DeleteProjectMarkerByIndex(0, retnumber)
  else ultraschall.AddErrorMessage("DeleteNormalMarker", "number", "no such normal-marker found", -2) return false
  end
end

--A=ultraschall.AddNormalMarker(3,10,"marke")
--A2=ultraschall.DeleteNormalMarker(1)


function ultraschall.DeleteEditMarker(number)
-- Deletes a Edit-Marker
-- number - number of the _Edit-marker, 1 to current number of _Edit-markers
-- returns true if successful and false if not(i.e. marker doesn't exist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteEditMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> boolean retval = ultraschall.DeleteEditMarker(integer edit_index)</functioncall>
  <description>
    Deletes an _Edit:-Marker. Returns true if successful and false if not(i.e. marker doesn't exist) Use <a href="#EnumerateEditMarkers">ultraschall.EnumerateEditMarkers</a> to get the correct number.
  </description>
  <parameters>
    integer edit_index - number of an edit marker
  </parameters>
  <retvals>
     boolean retval  - true, if successful, false if not
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, delete, edit marker, edit</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("DeleteEditMarker", "edit_index", "must be integer", -1) return -1 end
  
  -- prepare variables
  number=number-1
  local wentfine=0
  local count=-1
  local retnumber=0
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  
  -- look for correct _Edit-marker
  for i=0, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,5)=="_Edit" then count=count+1 end 
    if number>=0 and wentfine==0 and count==number then 
        retnumber=i
        wentfine=1
    end
  end
  
  -- remove found _Edit-marker, if any
  if wentfine==1 then return reaper.DeleteProjectMarkerByIndex(0, retnumber)
  else ultraschall.AddErrorMessage("DeleteEditMarker", "edit_index", "no such _Edit-marker found", -2) return false
  end
end

--A=ultraschall.AddEditMarker(3,10,"markel")
--A2=ultraschall.DeleteEditMarker(1)


function ultraschall.SecondsToTime(pos)
-- converts timeposition in seconds(pos) to a timestring (h)hh:mm:ss.ms
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SecondsToTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string time_string = ultraschall.SecondsToTime(number pos)</functioncall>
  <description>
    converts timeposition in seconds(pos) to a timestring (h)hh:mm:ss.mss
    
    returns nil in case of error
  </description>
  <retvals>
    string time_string  - timestring in (h)hh:mm:ss.mss
  </retvals>
  <parameters>
    number pos - timeposition in seconds
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>timestring, converter, seconds, string</tags>
</US_DocBloc>
--]]
  -- check parameter
  if type(pos)~="number" then ultraschall.AddErrorMessage("SecondsToTime","pos", "only numbers allowed", -1) return nil end
  if pos>359999999999998175 then ultraschall.AddErrorMessage("SecondsToTime","pos", "out of range, maximum value is 359999999999998175", -2) return nil end
  
  -- prepare variables
  local hours=0
  local minutes=0
  local seconds=0
  local milliseconds=0
  local temp=0
  local tempo=0
  local tempo2=0
  local trailinghour=""
  local trailingminute=""
  local trailingsecond="" 
  local trailingmilli=""
  
  -- create time-string
  if pos>=3600 then temp=tostring(pos/3600) hours=tonumber(temp:match("%d*")) pos=pos-(3600*hours) end -- get hours
  if pos>=60 then temp=tostring(pos/60) minutes=tonumber(temp:match("(%d*)")) pos=pos-(60*minutes) end -- get minutes
  
  -- seconds
  temp=tostring(pos)
  seconds=pos
  
  -- milliseconds
  tempo=tostring(seconds)
  tempo2=tempo:match("%.%d*")
  if tempo2==nil then tempo2=".0" end
  milliseconds=tempo2:sub(2,4)
  if milliseconds:len()==2 then milliseconds=milliseconds.."0" end
  if milliseconds:len()==1 then milliseconds=milliseconds.."00" end
  if seconds==nil then seconds=0.0 end
  
  -- get trailing hours/minutes/seconds
  if hours<10 then trailinghour="0" else trailinghour="" end
  if minutes<10 then trailingminute="0" else trailingminute="" end
  if seconds<10 then trailingsecond="0" else trailingsecond="" end
  seconds=tostring(seconds)
  seconds=seconds:match("%d*.")
  if seconds:sub(-1,-1)=="." then seconds=seconds:sub(1,-2) end
  
  -- return created time-string
  return trailinghour..hours..":"..trailingminute..minutes..":"..trailingsecond..seconds.."."..milliseconds
end

--L=ultraschall.SecondsToTime(359999999999998176)

function ultraschall.TimeToSeconds(timestring)
-- converts a timestring days:hours:minutes:seconds.milliseconds to timeposition in seconds
-- it is ok, to have only some of them given, so excluding hours or days is ok.
-- 
-- a single integer will be seen as seconds.
-- to specifiy milliseconds in particular, start the number with a .
-- all other values are separated by :
--
-- returns -1 in case of error, timestring is a nil  or if you try to add an 
-- additional value, added before days
--
-- does not check for valid timeranges, so 61 minutes is possible to give, even if 
-- hours are present in the string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>TimeToSeconds</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>number position = ultraschall.TimeToSeconds(string timestring)</functioncall>
  <description>
    converts a timestring days:hours:minutes:seconds.milliseconds to timeposition in seconds
    it is ok, to have only some of the last ones given, so i.e. excluding days and hours is ok. Though excluding values inbetween does not work!
     
    A single integer in timestring will be seen as seconds.
    To only specifiy milliseconds in particular, start the number with a .
    all other values are separated by :
    
    returns -1 in case of error, timestring is a nil or if you try to add an additional value, added before days
    
    does not check for valid timeranges, so 61 minutes is possible to give, even if hours are present in the string
  </description>
  <retvals>
    number position  - the converted position
  </retvals>
  <parameters>
    string timestring - a string like: days:hours:minutes:seconds.milliseconds , i.e. 1:16:27:50.098
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>timestring, converter, seconds, string</tags>
</US_DocBloc>
--]]
  -- check parameter
  if type(timestring)~="string" then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "only string is allowed", -1) return -1 end

  -- prepare variables
  local hour=0
  local milliseconds=0
  local minute=0
  local seconds=0
  local time=0
  local day=0

  -- get milliseconds
  milliseconds=timestring:match("%..*")
  if tonumber(milliseconds)==nil and milliseconds~=nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring" ,"invalid milliseconds", -2) return -1 end
  if milliseconds==nil then milliseconds=0 end
  if milliseconds=="" then milliseconds=".0 " end
  if milliseconds=="0" then milliseconds=".0 " end
  if milliseconds==0 then milliseconds=".0 " end
  if milliseconds=="." then milliseconds=0 end
    
  -- get seconds  
  if timestring:match("%.%d*")~=nil then timestring=timestring:match("(.*)%.") end
  if tonumber(timestring)~=nil then seconds=tonumber(timestring)
  elseif timestring==nil then seconds=0
  else
    seconds=tonumber(timestring:match(".*:(.*)"))
  end
  if seconds==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid seconds", -3) return -1 end

  -- getminutes
  if timestring~=nil then timestring=timestring:match("(.*):") end
  if tonumber(timestring)~=nil then minute=tonumber(timestring)
  elseif timestring==nil then minute=0
  else
    minute=tonumber(timestring:match(".*:(.*)"))
  end
  if minute==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid minute", -4) return -1 end

  -- get hours
  if timestring~=nil then timestring=timestring:match("(.*):") end
  if tonumber(timestring)~=nil then hour=tonumber(timestring)
  elseif timestring==nil then hour=0
  else
    hour=tonumber(timestring:match(".*:(.*)"))
  end
  if hour==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid hour", -5) return -1 end

  -- get days
  if timestring~=nil then timestring=timestring:match("(.*):") end
  if tonumber(timestring)~=nil then day=tonumber(timestring)
  elseif timestring==nil then day=0
  else
    day=tonumber(timestring:match(".*:(.*)"))
  end
  if day==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid day", -6) return -1 end
  
  if timestring~=nil then timestring=timestring:match("(.*):") end
    
  if timestring~=nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid timestring, must be of format: \"days:hours:minutes:seconds.milliseconds\". You can omit the first ones, but never the last one!", -7) return -1 end

  -- check, if the found values are numbers
  if day~=nil and tonumber(day)==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid day", -8) return -1 end
  if hour~=nil and tonumber(hour)==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid hour", -9) return -1 end
  if minute~=nil and tonumber(minute)==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid minute", -10) return -1 end
  if seconds~=nil and tonumber(seconds)==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring", "invalid seconds", -11) return -1 end
  if milliseconds~=nil and tonumber(milliseconds)==nil then ultraschall.AddErrorMessage("TimeToSeconds","timestring" ,"invalid milliseconds", -12) return -1 end

  -- if certain values weren't found, set them to 0
  if day==nil then day=0 end
  if hour==nil then hour=0 end
  if minute==nil then minute=0 end
  if seconds==nil then seconds=0 end
  if milliseconds==nil then milliseconds=0 end
    
  -- return time
  return (day*86400)+(hour*3600)+(minute*60)+seconds+milliseconds
end

--L=ultraschall.TimeToSeconds("11:11:11:11.001") 

-------------------------
---- Export Markers -----
-------------------------

function ultraschall.ExportEditMarkersToFile(filename_with_path, PodRangeStart, PodRangeEnd)
--Export Edit-Markers to filename_with_path
--filename_with_path - filename of the file where the markers shall be exported to
--PodRangeStart - start of the Podcast;markers earlier of that will not be exported;markers exported will be markerposition minus PodRangeStart
--                must be a positive value; nil=0
--PodRangeEnd - end of the Podcast; markers later of that will not be exported; 
--              must be a positive value; nil=end of project
--
-- returns -1 in case of error
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ExportEditMarkersToFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer retval = ultraschall.ExportEditMarkersToFile(string filename_with_path, number PodRangeStart, number PodRangeEnd)</functioncall>
  <description>
    Export Edit-Markers (not regions!) to filename_with_path. 
    
    Each line in the exportfile contains an entry for such an edit-marker in the format:
    
    hh:mm:ss.mss Title
    
    Returns -1 in case of error.
  </description>
  <retvals>
     integer retval  - 1 in case of success, -1 if it failed
  </retvals>
  <parameters>
    string filename_with_path - the name of the export-file
     number PodRangeStart - beginning of the podcast in seconds
     number PodRangeEnd - end of the podcast in seconds
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, export, file, edit</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("ExportEditMarkersToFile", "filename_with_path", "must be a filename", -1) return -1 end
  PodRangeStart=tonumber(PodRangeStart)
  PodRangeEnd=tonumber(PodRangeEnd)
  if PodRangeStart==nil then PodRangeStart=0 end
  if PodRangeStart<0 then ultraschall.AddErrorMessage("ExportEditMarkersToFile", "PodRangeStart", "must be a number>=0", -2) return -1 end
  if PodRangeEnd==nil then PodRangeEnd=reaper.GetProjectLength(0) end
  if PodRangeEnd<PodRangeStart then ultraschall.AddErrorMessage("ExportEditMarkersToFile", "PodRangeEnd", "must be bigger than PodRangeStart", -3) return -1 end
  
  -- prepare variables
  number=ultraschall.CountEditMarkers()  
  local timestring="00:00:00.000"
  
  -- open exportfile
  local file=io.open(filename_with_path,"w")
  if file==nil then ultraschall.AddErrorMessage("ExportEditMarkersToFile", "filename_with_path", "exportfile can't be created", -4) return -1 end
  
  -- write editmarkers to exportfile
  for i=1,number do
    local idx,shown_number,pos,name=ultraschall.EnumerateEditMarkers(i)
    if pos>=PodRangeStart and pos<=PodRangeEnd then
      pos=pos-PodRangeStart
      timestring=ultraschall.SecondsToTime(pos)
      file:write(timestring.." "..name.."\n")
    end
  end
  
  -- close file and return
  local fileclose=io.close(file)
  return 1
end

--A,AA=ultraschall.AddEditMarker(10,10,"ed10")
--A,AA=ultraschall.AddEditMarker(20,20,"ed20")
--A,AA=ultraschall.AddEditMarker(30,30,"ed30")
--APACHEN=ultraschall.ExportEditMarkersToFile("c:\\edit-test.txt")



function ultraschall.ExportNormalMarkersToFile(filename_with_path, PodRangeStart, PodRangeEnd)
--Export Markers to filename_with_path
--filename_with_path - filename of the file where the markers shall be exported to
--PodRangeStart - start of the Podcast;markers earlier of that will not be exported;markers exported will be markerposition minus PodRangeStart
--                must be a positive value; nil=0
--PodRangeEnd - end of the Podcast; markers later of that will not be exported; 
--              must be a positive value; nil=end of project  
--
-- return -1 in case of error
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ExportNormalMarkersToFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer retval = ultraschall.ExportNormalMarkersToFile(string filename_with_path, number PodRangeStart, number PodRangeEnd)</functioncall>
  <description>
    Export Normal-Markers to filename_with_path. Returns -1 in case of error.
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
     integer retval  - 1 in case of success, -1 if it failed
  </retvals>
  <parameters>
    string filename_with_path - the name of the export-file
     number PodRangeStart - beginning of the podcast in seconds
     number PodRangeEnd - end of the podcast in seconds
  </parameters>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, export, file, normal</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("ExportNormalMarkersToFile", "filename_with_path", "must be a filename", -1) return -1 end
  PodRangeStart=tonumber(PodRangeStart)
  PodRangeEnd=tonumber(PodRangeEnd)
  if PodRangeStart==nil then PodRangeStart=0 end
  if PodRangeStart<0 then ultraschall.AddErrorMessage("ExportNormalMarkersToFile", "PodRangeStart", "must be a number>=0", -2) return -1 end
  if PodRangeEnd==nil then PodRangeEnd=reaper.GetProjectLength(0) end
  if PodRangeEnd<PodRangeStart then ultraschall.AddErrorMessage("ExportNormalMarkersToFile", "PodRangeEnd", "must be bigger than PodRangeStart", -3) return -1 end
  
  -- prepare variables
  local number=ultraschall.CountNormalMarkers()    
  local timestring="00:00:00.000"
  
  -- open file for write; return with error if impossible
  local file=io.open(filename_with_path,"w")  
  if file==nil then ultraschall.AddErrorMessage("ExportNormalMarkersToFile", "filename_with_path", "file can't be opened", -4) return -1 end
  
  -- write normal markers to fil
  for i=1,number do
    local idx,shown_number,pos,name, URL=ultraschall.EnumerateNormalMarkers(i)
    if pos>=PodRangeStart and pos<=PodRangeEnd then
      pos=pos-PodRangeStart
      timestring=ultraschall.SecondsToTime(pos)
      file:write(timestring.." "..name.."\n")
    end
  end
  
  -- close file and return
  local fileclose=io.close(file)
  return 1
end 
--A,AA=ultraschall.AddNormalMarker(10,10,"10mark")
--A,AA=ultraschall.AddNormalMarker(30,30,"30mark")
--A,AA=ultraschall.AddNormalMarker(20,20,"20mark")
--APPALACHEN=ultraschall.ExportNormalMarkersToFile("c:\\test.txt")


-------------------------
---- Import Markers -----
-------------------------


function ultraschall.ImportEditFromFile(filename_with_path,PodRangeStart)
-- Imports editentries from a file and returns an array of the imported values.
-- array[markernumber1][0] - position of the marker in seconds+PodRangeStart
-- array[markernumber1][1] - name of the marker
-- array[markernumber2][0] - position of the marker in seconds+PodRangeStart
-- array[markernumber2][1] - name of the marker
-- array[markernumberx][0] - position of the marker in seconds+PodRangeStart
-- array[markernumberx][1] - name of the marker

-- Parameters:
-- filename_with_path - filename with path of the file to import
-- Podrangestart - the start of the podcast in seconds. Will be added to the time-positions of each chaptermarker. 
--    Podrangestart=0 gives you the timepositions, as they were stored in the chapter-marker-import-file.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ImportEditFromFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> array editmarkers = ultraschall.ImportEditFromFile(string filename_with_path, PodRangestart)</functioncall>
  <description>
    Imports editentries from a file and returns an array of the imported values.
    
    returns -1 in case of error
  </description>
  <parameters>
    string filename_with_path - markerfile to be imported
    number PodRangeStart - podcast-start-offset
  </parameters>
  <retvals>
     array chapters  - array[0] is position of marker+PodRangeStart, array[1] is name of the marker
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, import, file, edit</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(filename_with_path) ~= "string" then ultraschall.AddErrorMessage("ImportEditFromFile", "filename_with_path", "must be a filename", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ImportEditFromFile", "filename_with_path", "file does not exist", -2) return -1 end
  PodRangeStart=tonumber(PodRangeStart)
  if PodRangeStart==nil then PodRangeStart=0 end
  
  -- prepare variables
  local markername=""
  local entry=0  
  local table = {}
      
  -- read entries from file and split them into time and name; add time and name to new entries in table
  for line in io.lines(filename_with_path) do
    entry=entry+1
    table[entry]={}
    time=ultraschall.TimeToSeconds(line:match("%d*:%d*:%d*.%d*"))+PodRangeStart
    markername=line:match("%s.*")
    if markername==nil then markername="_Edit"
    else markername="_Edit:"..markername
    end
    if time<0 then return -1 end
  
    table[entry][0]=time
    table[entry][1]=markername
  end
  
  -- return resulting marker-table
  return table
end

--ABAMA=ultraschall.ImportEditFromFile("c:\\test.txt",0)


function ultraschall.ImportMarkersFromFile(filename_with_path,PodRangeStart)
-- Imports markerentries from a file and returns an array of the imported values.
-- array[markernumber1][0] - position of the marker in seconds+PodRangeStart
-- array[markernumber1][1] - name of the marker
-- array[markernumber2][0] - position of the marker in seconds+PodRangeStart
-- array[markernumber2][1] - name of the marker
-- array[markernumberx][0] - position of the marker in seconds+PodRangeStart
-- array[markernumberx][1] - name of the marker

-- Parameters:
-- filename_with_path - filename with path of the file to import
-- Podrangestart - the start of the podcast in seconds. Will be added to the time-positions of each chaptermarker. 
--    Podrangestart=0 gives you the timepositions, as they were stored in the chapter-marker-import-file.
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ImportMarkersFromFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> array markers = ultraschall.ImportMarkersFromFile(string filename_with_path, PodrangeStart)</functioncall>
  <description>
    Imports markerentries from a file and returns an array of the imported values.
    
    returns -1 in case of error
  </description>
  <parameters>
    string filename_with_path - markerfile to be imported
    number PodRangeStart - podcast-start-offset
  </parameters>
  <retvals>
     array chapters  - array[0] is position of marker+PodRangeStart, array[1] is name of the marker
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, import, file</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(filename_with_path) ~= "string" then ultraschall.AddErrorMessage("ImportMarkersFromFile", "filename_with_path", "must be a filename", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ImportMarkersFromFile", "filename_with_path", "file does not exist", -2) return -1 end
  PodRangeStart=tonumber(PodRangeStart)
  if PodRangeStart==nil then PodRangeStart=0 end
  
  -- prepare variables
  local markername=""
  local entry=0  
  local table = {}
      
  -- read entries from file and split them into time and name; add time and name to new entries in table
  for line in io.lines(filename_with_path) do
    entry=entry+1
    table[entry]={}
    time=ultraschall.TimeToSeconds(line:match("%d*:%d*:%d*.%d*"))+PodRangeStart
    markername=line:match("%s.*")
    if markername==nil then markername=""
    end
    if time<0 then return -1 end
  
    table[entry][0]=time
    table[entry][1]=markername:sub(2,-1)
  end
  
  -- return resulting marker-table
  return table
end

--APPALACHEN=ultraschall.ImportMarkersFromFile("c:\\test.txt",10)

--A,AA,AAA,AAAA=ultraschall.EnumerateNormalMarkers(4)
--APPALACHEN=ultraschall.ExportMarkersToFile("c:\\test.txt",0,99999999)


-------------------------
---- Convert Markers ----
-------------------------

function ultraschall.MarkerToEditMarker(number)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MarkerToEditMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer idx, integer shown_number, number position, string markertitle = ultraschall.MarkerToEditMarker(integer markerindex)</functioncall>
  <description>
    Converts a normal-marker to an edit-marker.
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
     integer idx - overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of
    -markers but counts from position 00:00:00 to end of project. So if you created a marker at position 00:00:00 and move the first created marker to
    -the end of the timeline, it will be the last one, NOT the first one in the retval! For use with reaper's own marker-functions.
     integer shown_number - the shown number of the marker
     number position - the position of the marker in seconds
     string markertitle  - the markertitle
  </retvals>
  <parameters>
    integer markerindex - number of the normal-marker. Refer <a href="#CountNormalMarkers">ultraschall.CountNormalMarkers</a> for getting the number of normal-markers.
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, convert, edit, normal</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("MarkerToEditMarker", "merkerindex", "must be an integer", -1) return -1 end
  if number<1 then ultraschall.AddErrorMessage("MarkerToEditMarker", "markerindex", "must be greater than 0", -2) return -1 end
  
  -- prepare variables and get old marker-attributes
  local color = ultraschall.ConvertColor(255,0,0)
  local idx, shownmarker, position, markername = ultraschall.EnumerateNormalMarkers(number)
  if idx==-1 then  ultraschall.AddErrorMessage("MarkerToEditMarker", "markerindex", "no such normal marker", -3) return -1 end
  
  -- change the found marker to edit
  local itworks=reaper.SetProjectMarkerByIndex(0, idx-1, false, position, 0, shownmarker, "_Edit: "..markername, color)
  
  -- return the altered marker
  return idx, shownmarker, position, markername
end

--A,AA,AAA,AAAA=ultraschall.MarkerToEditMarker(nil)


function ultraschall.EditToMarker(number)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EditToMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall> integer idx, integer shown_number, number position, string markertitle = ultraschall.EditToMarker(integer edit_index)</functioncall>
  <description>
    Converts an edit-marker to a normal marker.
  </description>
  <retvals>
    integer idx - overallmarker/regionnumber of marker beginning with 1 for the first marker; ignore the order of first,second,etc creation of
    -markers but counts from position 00:00:00 to end of project. So if you created a marker at position 00:00:00 and move the first created marker to
    -the end of the timeline, it will be the last one, NOT the first one in the retval! For use with reaper's own marker-functions.
     integer shown_number - the shown number of the marker
     number position - the position of the marker in seconds
     string markertitle  - the markertitle
  </retvals>
  <parameters>
    integer edit_index - number of the edit-marker. Refer <a href="#CountEditMarkers">ultraschall.CountEditMarkers</a> for getting the number of edit-markers.
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, convert, normal, edit</tags>
</US_DocBloc>
--]]
  -- check parameter
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EditToMarker", "edit_index", "must be an integer", -1) return -1 end
  if number<1 then ultraschall.AddErrorMessage("EditToMarker", "edit_index", "must be greater than 0", -2) return -1 end
  
  -- prepare variables and get old marker-attributes  
  local color = ultraschall.ConvertColor(100,100,100)  
  local idx, shownmarker, position, markername = ultraschall.EnumerateEditMarkers(number)
  if idx==-1 then ultraschall.AddErrorMessage("EditToMarker", "edit_index", "no such edit-marker", -3) return -1 end

  -- change the found edit-marker to a normal marker
  if markername=="" then 
    reaper.DeleteProjectMarkerByIndex(0, number-1)
    reaper.AddProjectMarker2(0, false, position, 0, markername:match("%s%d*(.*)"), shownmarker, 0)
  else 
    reaper.DeleteProjectMarkerByIndex(0, number-1)
    reaper.AddProjectMarker2(0, false, position, 0, markername:match("%s%d*(.*)"), shownmarker, 0)
  end

  -- return altered marker-attributes
  return idx, shownmarker, position, markername
end

--A=ultraschall.AddEditMarker(9,7,"edittitle")
--A,AA,AAA,AAAA=ultraschall.EditToMarker(1)
--A,AA,AAA,AAAA=ultraschall.MarkerToEditMarker(1)




--------------------------------------------------
------ ULTRASCHALL FRAMEWORK 4.00 BETA 2 ---------
--------------------------------------------------


-----------------------------
---- Ultraschall Helpers ----
-----------------------------


function ultraschall.CreateTrackString_SelectedTracks()
-- returns a string with the all numbers from selected tracks, separated by a ,
-- e.g. firstnumber=4, lastnumber=8 -> 4,5,6,7,8

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackString_SelectedTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackString_SelectedTracks()</functioncall>
  <description>
    Creates a string with all numbers from selected tracks, separated by a ,
    
    Returns an empty string, if no tracks are selected.
  </description>
  <retvals>
    string trackstring - a string with the tracknumbers, separated by a string
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, datastructure</tags>
</US_DocBloc>
]]
  -- prepare variable
  local trackstring=""
  
  -- get the selected tracks and add their tracknumber to trackstring
  for i=1, reaper.CountTracks(0) do
    local MediaTrack=reaper.GetTrack(0,i-1)
    if reaper.IsTrackSelected(MediaTrack)==true then
      trackstring=trackstring..i..","
    end  
  end
  
  -- return trackstring
  return trackstring:sub(1,-2)
end

--A=ultraschall.CreateTrackString_SelectedTracks()


-------------------------
---- File Management ----
-------------------------

function ultraschall.ReadFullFile(filename_with_path, binary)
  -- Returns the whole file filename_with_path or nil in case of error

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadFullFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string contents, integer length_of_file, integer number_of_lines = ultraschall.ReadFullFile(string filename_with_path, boolean binary)</functioncall>
  <description>
    Return contents of filename_with_path.
    
    Returns nil in case of an error.
  </description>
  <retvals>
    string contents - the contents of the whole file.
    integer length_of_file - the number of bytes of the file
    integer number_of_lines - number of lines in file (-1 if parameter binary is set to true)
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    boolean binary - true if the file shall be read as a binary file; false if read as ASCII. Default is ASCII.
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, full file, binary, ascii</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(filename_with_path) ~= "string" then ultraschall.AddErrorMessage("ReadFullFile", "filename_with_path", "must be a string", -1) return nil end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ReadFullFile", "filename_with_path", "file does not exist", -2) return nil end
  
  -- prepare variables
  if binary==true then binary="b" else binary="" end
  local linenumber=0
  
  -- read file
  local file=io.open(filename_with_path,"r"..binary)
  if file==nil then ultraschall.AddErrorMessage("ReadFullFile", "filename_with_path", "could not read file, probably due another application accessing it.", -3) return nil end
  local filecontent=file:read("a")
  
  -- count lines in file, when non binary
  if binary~=true then
    for w in string.gmatch(filecontent, "\n") do
      linenumber=linenumber+1
    end
  else
    linenumber=-1
  end
  file:close()
  -- return read file, length and linenumbers
  return filecontent, filecontent:len(), linenumber
end


--A,B,C=ultraschall.ReadFullFile("c:\\msdia80.dll")

function ultraschall.ReadValueFromFile(filename_with_path, value)
  -- Returns 
  -- a string with the contents of the file "filename_with_path" as well as
  -- a string, that contains the linenumbers returned as a , separated csv-string and
  -- an integer the number of lines returned
  --
  -- If "value" is given, it will return all lines, containing the value in the 
  -- file "filename_with_path". The second line-numbers return-value is very valuable 
  -- when giving a "value". "Value" is not case-sensitive.
  -- Keep in mind, that you need to escape \ by writing \\, or it will not work

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadValueFromFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string contents, string linenumbers, integer numberoflines, integer number_of_foundlines = ultraschall.ReadValueFromFile(string filename_with_path, string value)</functioncall>
  <description>
    Return contents of filename_with_path. 
    
    If "value" is given, it will return all lines, containing the value in the file "filename_with_path". 
    The second line-numbers return-value is very valuable when giving a "value". "Value" is not case-sensitive.
    The value can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
  </description>
  <retvals>
    string contents - the contents of the file, or the lines that contain parameter value in it, separated by a newline
    string linenumbers - a string, that contains the linenumbers returned as a , separated csv-string
    integer numberoflines_in_file - the total number of lines in the file
    integer number_of_foundlines - the number of found lines
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    string value - the value to look in the file for. Not case-sensitive.
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, value, pattern, lines</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(filename_with_path) ~= "string" then ultraschall.AddErrorMessage("ReadValueFromFile", "filename_with_path", "must be a string", -1) return nil end
  if value==nil then value="" end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ReadValueFromFile", "filename_with_path", "file does not exist", -2) return nil end
  if ultraschall.IsValidMatchingPattern(value)==false then ultraschall.AddErrorMessage("ReadValueFromFile", "value", "malformed pattern", -3) return -1 end

  -- prepare variables
  local contents=""
  local b=0 -- temporary line-counting-variable
  local linenumbers="" -- the linenumbers of lines, where value has been found in the file, separated by a ,
  local number_of_lines=0 -- the number of lines in the file/number of lines, where value has been found
  local foundlines={} -- the found-lines throw into an array, with each entry being one line
  local countlines=0
  
  -- read file and find lines
  if value=="" then -- if no search-value is given
    for line in io.lines(filename_with_path) do 
      contents=contents..line.."\n"
      b=b+1
      linenumbers=linenumbers..tostring(b)..","
      number_of_lines=b
      countlines=countlines+1
    end
  else -- if a search-value is given
    for line in io.lines(filename_with_path) do
      local temp=line:lower()
      local valtemp=value:lower()
      b=b+1
      if temp:match(valtemp)~=nil then
        contents=contents..line.."\n"          
        linenumbers=linenumbers..tostring(b)..","
        number_of_lines=number_of_lines+1
        countlines=countlines+1
      end
      number_of_lines=b
    end
  end
  -- return found lines and values
  if return_lines_as_array==false then countlines=nil foundlines=nil end

  --string contents, string linenumbers, integer numberoflines
  return contents,linenumbers:sub(1,-2), number_of_lines, countlines
end


--A,B,C,D,E=ultraschall.ReadValueFromFile("c:\\testhelp-beta2-7-3.html", " = ultraschall.")

-- MESPOTINE


function ultraschall.ReadLinerangeFromFile(filename_with_path, firstlinenumber, lastlinenumber)
  -- Returns a string with the contents of the file "filename_with_path" from line
  -- firstlinenumber to lastlinenumber as well as a
  -- boolean false if fewer lines are returned than requested, true if as many lines returned as requested
  --
  -- every line is separated with a newline from each other
  -- Keep in mind, that you need to escape \ by writing \\, or it will not work
  -- returns nil in case of error like non existing file or invalid linenumbers
  -- returns "", if nothing was found
  --
  -- counting of linenumbers starts with 1 for the first line

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadLinerangeFromFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string contents, boolean correctnumberoflines, integer number_of_lines = ultraschall.ReadLinerangeFromFile(string filename_with_path, integer firstlinenumber, integer lastlinenumber)</functioncall>
  <description>
    Return contents of filename_with_path, from firstlinenumber to lastlinenumber. Counting of linenumbers starts with 1 for the first line.
    The returned string contains all requested lines, separated by a newline.
    
    Returns nil, if the linenumbers are invalid.
  </description>
  <retvals>
    string contents - the contents the lines of the file, that you requested
    boolean correctnumberoflines - true, if the number of lines are returned, as requested; false if fewer lines are returned
    integer number_of_lines - the number of read lines
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    integer firstlinenumber - the first linenumber to be returned. First line in the file begins with 1!
    integer lastlinenumber - the last linenumber to be returned; -1, for the whole file
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, range</tags>
</US_DocBloc>
]]
  if math.type(firstlinenumber)~="integer" then ultraschall.AddErrorMessage("ReadLinerangeFromFile","firstlinenumber", "Must be an integer!", -1) return nil end
  if math.type(lastlinenumber)~="integer" then ultraschall.AddErrorMessage("ReadLinerangeFromFile","lastlinenumber", "Must be an integer!", -2) return nil end
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("ReadLinerangeFromFile","filename_with_path", "Must be a string!", -3) return nil end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ReadLinerangeFromFile","filename_with_path", "File not found!", -4)return nil end
  
  local a=""
  local b=0

  for line in io.lines(filename_with_path) do 
     b=b+1
     if b>=firstlinenumber and lastlinenumber==-1 then
        a=a..line.."\n"
     elseif b>=firstlinenumber and b<=lastlinenumber then
        a=a..line.."\n"
     end
     if b>lastlinenumber and lastlinenumber~=-1 then return a, true, b-1 end
  end
  if b<lastlinenumber and lastlinenumber~=-1 then return a, false, b end
  
  return a, true, b
end


--A,B,C=ultraschall.ReadLinerangeFromFile("c:\\temp\\540.txt",1,9)

function ultraschall.MakeCopyOfFile(input_filename_with_path, output_filename_with_path)
--makes a copy of a textfile

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MakeCopyOfFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MakeCopyOfFile(string input_filename_with_path, string output_filename_with_path)</functioncall>
  <description>
    Copies input_filename_with_path to output_filename_with_path. 
    Only textfiles! For binary-files use MakeCopyOfFile_Binary() instead!
    
    Returns true, if it worked, false if it didn't.
  </description>
  <retvals>
    boolean retval - true, if copy worked, false if it didn't.
  </retvals>
  <parameters>
    string input_filename_with_path - filename of the file to copy
    string output_filename_with_path - filename of the copied file to be created.
  </parameters>
  <chapter_context>
    File Management
    Manipulate Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>read file, value</tags>
  <tags>filemanagement, copy, file management</tags>
</US_DocBloc>
]]
  if type(input_filename_with_path)~="string" then ultraschall.AddErrorMessage("MakeCopyOfFile", "input_filename_with_path", "must be a string", -1) return false end
  if type(output_filename_with_path)~="string" then ultraschall.AddErrorMessage("MakeCopyOfFile", "output_filename_with_path", "must be a string", -2) return false end
  if reaper.file_exists(input_filename_with_path)==true then
    local file=io.open(output_filename_with_path,"w")
    if file==nil then ultraschall.AddErrorMessage("MakeCopyOfFile", "output_filename_with_path", "can't create file", -3) return false end
    for line in io.lines(input_filename_with_path) do
      file:write(line.."\n")
    end
    file:close()
  else ultraschall.AddErrorMessage("MakeCopyOfFile", "input_filename_with_path", "file does not exist", -4) return false
  end
  return true
end

--A=ultraschall.MakeCopyOfFile("c:\\tt.rpp","c:\\huibh.txts")
--A=ultraschall.MakeCopyOfFile("2",1)

function ultraschall.MakeCopyOfFile_Binary(input_filename_with_path, output_filename_with_path)
--makes a copy of a binary-file

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MakeCopyOfFile_Binary</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MakeCopyOfFile_Binary(string input_filename_with_path, string output_filename_with_path)</functioncall>
  <description>
    Copies input_filename_with_path to output_filename_with_path as binary-file.
  </description>
  <retvals>
    boolean retval - returns true, if copy worked; false if it didn't
  </retvals>
  <parameters>
    string input_filename_with_path - filename of the file to copy
    string output_filename_with_path - filename of the copied file, that shall be created
  </parameters>
  <chapter_context>
    File Management
    Manipulate Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, binary</tags>
</US_DocBloc>
]]
  if type(input_filename_with_path)~="string" then ultraschall.AddErrorMessage("MakeCopyOfFile_Binary", "input_filename_with_path", "must be a string", -1) return false end
  if type(output_filename_with_path)~="string" then ultraschall.AddErrorMessage("MakeCopyOfFile_Binary", "output_filename_with_path", "must be a string", -2) return false end
  
  if reaper.file_exists(input_filename_with_path)==true then
    local fileread=io.open(input_filename_with_path,"rb")
    if fileread==nil then ultraschall.AddErrorMessage("MakeCopyOfFile_Binary", "input_filename_with_path", "could not read file, probably due another application accessing it.", -5) return nil end
    local file=io.open(output_filename_with_path,"wb")
    if file==nil then ultraschall.AddErrorMessage("MakeCopyOfFile_Binary", "output_filename_with_path", "can't create file", -3) return false end
    file:write(fileread:read("*a"))
    fileread:close()
    file:close()
  else ultraschall.AddErrorMessage("MakeCopyOfFile_Binary", "input_filename_with_path", "file does not exist", -4) return false
  end
  return true
end

--A=ultraschall.MakeCopyOfFile_Binary("c:\\testcopy.webm","c:\\testcopy2.webm")
--ultraschall.MakeCopyOfFile_Binary("c:\\reaper.exe","c:\\reaper.testrl")

function ultraschall.ReadBinaryFileUntilPattern(input_filename_with_path, pattern)
--reads a binary file until the first occurence of pattern
--pattern - case sensitive

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadBinaryFileUntilPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer length, string content = ultraschall.ReadBinaryFileUntilPattern(string input_filename_with_path, string pattern)</functioncall>
  <description>
    Returns a binary file, up until a pattern. The pattern is not case-sensitive.
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
  </description>
  <retvals>
    integer length - the length of the returned data
    string content - the content of the file, that has been read until pattern
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    string pattern - a pattern to search for. Case-sensitive.
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, pattern, binary</tags>
</US_DocBloc>
]]
  local temp=""
  local temp2
  if type(input_filename_with_path)~="string" then ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "input_filename_with_path", "must be a string", -1) return false end
  if type(pattern)~="string" then ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "pattern", "must be a string", -2) return false end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "pattern", "malformed pattern", -3) return -1 end
  
  if reaper.file_exists(input_filename_with_path)==true then
    local fileread=io.open(input_filename_with_path,"rb")
    if fileread==nil then ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "input_filename_with_path", "could not read file, probably due another application accessing it.", -6) return nil end
    temp=fileread:read("*a")
    temp2=temp:match("(.-"..pattern..")")
    if temp2==nil then fileread:close() ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "pattern", "pattern not found in file", -4) return false end
    fileread:close()
  else
    ultraschall.AddErrorMessage("ReadBinaryFileUntilPattern", "input_filename_with_path", "file does not exist", -5) return false
  end
  return temp2:len(), temp2
end

--A,AA=ultraschall.ReadBinaryFileUntilPattern("c:\\MarkerProject.RPP","VZOOMEX")
--reaper.MB(AA,"",0)

function ultraschall.ReadBinaryFileFromPattern(input_filename_with_path, pattern)
--reads a binary file from a first occurence of pattern to it's end. Doesn't show in ReaperConsole completely!
--pattern - case sensitive

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadBinaryFileFromPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer length, string content = ultraschall.ReadBinaryFileFromPattern(string input_filename_with_path, string pattern)</functioncall>
  <description>
    Returns a binary file, from pattern onwards. The pattern is not case-sensitive.
    
    The pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
  </description>
  <retvals>
    integer length - the length of the returned data
    string content - the content of the file, that has been read from pattern to the end
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    string pattern - a pattern to search for. Case-sensitive.
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, pattern, binary</tags>
</US_DocBloc>
]]
  local temp=""
  local temp2
  if type(input_filename_with_path)~="string" then ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "input_filename_with_path", "must be a string", -1) return false end
  if type(pattern)~="string" then ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "pattern", "must be a string", -2) return false end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "pattern", "malformed pattern", -3) return -1 end
  
  if reaper.file_exists(input_filename_with_path)==true then
    local fileread=io.open(input_filename_with_path,"rb")
    if fileread==nil then ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "input_filename_with_path", "could not read file, probably due another application accessing it.", -6) return nil end
    temp=fileread:read("*a")
    temp2=temp:match("("..pattern..".*)")
    if temp2==nil then fileread:close() ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "pattern", "pattern not found in file", -4) return false end
    fileread:close()
  else
    ultraschall.AddErrorMessage("ReadBinaryFileFromPattern", "input_filename_with_path", "file does not exist", -5) return false
  end
  return temp2:len(), temp2
end

--A,AA=ReadBinaryFileUntilPattern("c:\\reaper.exe","c:\\reaper.test","REAPER")
--A,AA=ReadBinaryFileUntilPattern("c:\\test.txt","c:\\test.temp","Ultraschall")
--A,BB=ultraschall.ReadBinaryFileFromPattern("c:\\MarkerProject.rpp","VZOOMEX")
--reaper.MB(BB,"",0)

--CC=AA..BB--:sub(9,-1)
--laeng=CC:len()
--laengA=AA:len()
--laengB=BB:len()

--ultraschall.WriteValueToFile("c:\\test2.txt",CC)
--A

function ultraschall.CountLinesInFile(filename_with_path)
  -- counts the number of lines in a file "filename_with_path" and returns it as integer
  -- Keep in mind, that you need to escape \ by writing \\, or it will not work
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountLinesInFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer linesinfile = ultraschall.CountLinesInFile(string filename_with_path)</functioncall>
  <description>
    Counts lines in a textfile. In binary files, the number of lines may be weird and unexpected!
    Returns -1, if no such file exists.
  </description>
  <retvals>
    integer linesinfile - number of lines in a textfile; -1 in case of error
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
  </parameters>
  <chapter_context>
    File Management
    File Analysis
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, count</tags>
</US_DocBloc>
]]
  -- check parameters  
  if type(filename_with_path) ~= "string" then ultraschall.AddErrorMessage("CountLinesInFile", "filename_with_path", "must be a string", -1) return nil end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("CountLinesInFile", "filename_with_path", "no such file", -2) return nil end

  -- prepare variable
  local b=0
  
  -- count the lines
  for line in io.lines(filename_with_path) do 
      b=b+1
  end
  
  -- return result
  return b
end

--A=ultraschall.CountLinesInFile("c:\\Reaper5_92\\reaper.exe")

--------------------------
---- Ini-Config-Files ----
--------------------------
---- must be:  ----
---- [section] ----
---- key=value ----
----  style -------
-------------------
function ultraschall.SetIniFileExternalState(section, key, value, ini_filename_with_path)
-- stores value into ini_filename_with_path
-- returns true if successful, false if unsuccessful

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetIniFileExternalState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetIniFileExternalState(string section, string key, string value, string ini_filename_with_path)</functioncall>
  <description>
    Sets an external state into ini_filename_with_path. Returns false, if it doesn't work.
  </description>
  <retvals>
    boolean retval - true, if setting the state was successful; false, if setting was unsuccessful
  </retvals>
  <parameters>
    string section - section of the external state. No = allowed!
    string key - key of the external state. No = allowed!
    string value - value for the key
    string filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, set, external state, value, ini-files</tags>
</US_DocBloc>
]]
  if type(section)~="string" then ultraschall.AddErrorMessage("SetIniFileExternalState", "section", "must be a string.", -1) return false end
  if type(key)~="string" then ultraschall.AddErrorMessage("SetIniFileExternalState", "key", "must be a string.", -2) return false end
  if type(value)~="string" then ultraschall.AddErrorMessage("SetIniFileExternalState", "value", "must be a string.", -3) return false end
  if type(ini_filename_with_path)~="string" then ultraschall.AddErrorMessage("SetIniFileExternalState", "ini_filename_with_path", "must be a string.", -4) return false end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("SetIniFileExternalState", "ini_filename_with_path", "file can't be accessed.", -5) end
  if section:match(".*%=.*") then ultraschall.AddErrorMessage("SetIniFileExternalState", "section", "= is not allowed in section", -6) return false end
  if key:match(".*%=.*") then ultraschall.AddErrorMessage("SetIniFileExternalState", "key", "= is not allowed in key.", -7) return false end

  return ultraschall.SetIniFileValue(section, key, value, ini_filename_with_path)
end

--A=ultraschall.SetIniFileExternalState("hulasu","bulaabama","MamulaDoo","c:\\huhududu.ini")

function ultraschall.GetIniFileExternalState(section, key, ini_filename_with_path)
-- gets a value from ini_filename_with_path
-- returns length of entry(integer) and the entry itself(string)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetIniFileExternalState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string value = ultraschall.GetIniFileExternalState(string section, string key, string ini_filename_with_path)</functioncall>
  <description>
    Gets an external state from ini_filename_with_path. Returns -1, if the file does not exist or parameters are invalid.
  </description>
  <retvals>
    integer entrylength - the length of the returned value
    string value - the value stored in a section->key in a configuration-file
  </retvals>
  <parameters>
    string section - section of the external state
    string key - key of the external state. No = allowed!
    string filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, get, external state, value, ini-files</tags>
</US_DocBloc>
]]
  if type(section)~="string" then ultraschall.AddErrorMessage("GetIniFileExternalState","section", "must be a string", -1) return -1 end
  if type(key)~="string" then ultraschall.AddErrorMessage("GetIniFileExternalState","key", "must be a string", -2) return -1 end
  if type(ini_filename_with_path)~="string" then ultraschall.AddErrorMessage("GetIniFileExternalState","ini_filename_with_path", "must be a string", -3) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("GetIniFileExternalState","ini_filename_with_path", "file does not exist", -4) return -1 end
    
  local L,LL=ultraschall.GetIniFileValue(section, key, "", ini_filename_with_path)
  if L==nil then ultraschall.AddErrorMessage("GetIniFileExternalState","key", "does not exist", -5) return -1
  else
  return L,LL
  end
end

--A,AA=ultraschall.GetIniFileExternalState("REAPER","defsplitxfadelen","c:\\REAPER5_78_portable\\reaper.ini")

function ultraschall.CountIniFileExternalState_sec(ini_filename_with_path)
--count number of sections in the ini_filename_with_path
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountIniFileExternalState_sec</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer sectioncount = ultraschall.CountIniFileExternalState_sec(string ini_filename_with_path)</functioncall>
  <description>
    Count external-state-[sections] from an ini-configurationsfile.
    
    Returns -1, if the file does not exist.
  </description>
  <retvals>
    integer sectioncount - number of sections within an ini-configuration-file
  </retvals>
  <parameters>
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, sections, ini-files</tags>
</US_DocBloc>
]]
  
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("CountIniFileExternalState_sec", "ini_filename_with_path", "File does not exist.", -1) return -1 end
  local count=0
  
  for line in io.lines(ini_filename_with_path) do
    local check=line:match(".*=.*")
    if check~=nil then check="" count=count+1 end
  end
  return count
end

--AA=ultraschall.CountIniFileExternalState_sec("c:\\test.ini")


function ultraschall.CountIniFileExternalState_key(section, ini_filename_with_path)
--count number of keys in the section in ini_filename_with_path
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountIniFileExternalState_key</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer keyscount = ultraschall.CountIniFileExternalState_key(string section, string ini_filename_with_path)</functioncall>
  <description>
    Count external-state-keys within a specific section, in a ini_filename_with_path.
    
    Returns -1, if file does not exist.
  </description>
  <retvals>
    integer keyscount - number of keys with section within an ini-configuration-file
  </retvals>
  <parameters>
    string section - the section within the ini-filename
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, keys, ini-files</tags>
</US_DocBloc>
]]
  local count=0
  local startcount=0
  if type(section)~="string" then ultraschall.AddErrorMessage("CountIniFileExternalState_key", "section", "Must be a string.", -1) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("CountIniFileExternalState_key", "ini_filename_with_path", "File does not exist.", -2) return -1 end
    
  for line in io.lines(ini_filename_with_path) do
   local check=line:match("%[.*.%]")
    if startcount==1 and line:match(".*=.*") then
      count=count+1
    else
      startcount=0
    if "["..section.."]" == check then startcount=1 end
    if check==nil then check="" end
    end
  end
  return count
end

--A=ultraschall.CountIniFileExternalState_key("hula","c:\\test.ini")

function ultraschall.EnumerateIniFileExternalState_sec(number_of_section, ini_filename_with_path)
-- returns name of the numberth section in ini_filename_with_path or nil, if invalid
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateIniFileExternalState_sec</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string sectionname = ultraschall.EnumerateIniFileExternalState_sec(integer number_of_section, string ini_filename_with_path)</functioncall>
  <description>
    Returns the numberth section in an ini_filename_with_path.
    
    Returns nil, in case of an error.
  </description>
  <retvals>
    string sectionname - the name of the numberth section in the ini-file
  </retvals>
  <parameters>
    integer number_of_section - the section within the ini-filename; 1, for the first section
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, get, section, enumerate, ini-files</tags>
</US_DocBloc>
]]
  if math.type(number_of_section)~="integer" then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_sec", "number_of_section", "Must be an integer.", -1) return nil end
  if type(ini_filename_with_path)~="string" then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_sec", "ini_filename_with_path", "Must be a string.", -2) return nil end

  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_sec", "ini_filename_with_path", "File does not exist.", -3) return nil end
  
  if number_of_section<=0 then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_sec", "ini_filename_with_path", "No such section.", -4) return nil end
  if number_of_section>ultraschall.CountIniFileExternalState_sec(ini_filename_with_path) then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_sec", "ini_filename_with_path", "No such section.", -5) return nil end
  
  local count=0
  for line in io.lines(ini_filename_with_path) do
    local check=line:match(".*=.*")
    if check==nil then count=count+1 end
    if count==number_of_section then return line:sub(2,-2) end
  end
end

--A=ultraschall.EnumerateIniFileExternalState_sec(0,"c:\\test.ini")

function ultraschall.EnumerateIniFileExternalState_key(section, number, ini_filename_with_path)
-- returns name of a numberth key within a section in ini_filename_with_path or nil if invalid or not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateIniFileExternalState_key</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string keyname = ultraschall.EnumerateIniFileExternalState_key(string section, integer number, string ini_filename_with_path)</functioncall>
  <description>
    Returns the numberth key within a section in an ini_filename_with_path.
    
    Returns nil, in case of an error.
  </description>
  <retvals>
    string keyname - the name of the numberth key within section in the ini-file
  </retvals>
  <parameters>
    string section - the name of the section
    integer number - the number of the key within a section within the ini-filename, with 1 for the first key in the section
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, get, key, enumerate, ini-files</tags>
</US_DocBloc>
]]
  if type(section)~="string" then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_key", "section", "Must be a string.", -1) return nil end
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_key", "number", "Must be an integer.", -2) return nil end

  if type(ini_filename_with_path)~="string" then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_key", "ini_filename_with_path", "Must be a string.", -3) return nil end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("EnumerateIniFileExternalState_key", "ini_filename_with_path", "File does not exist.", -4) return nil end

  local count=0
  local startcount=0
  
  for line in io.lines(ini_filename_with_path) do
    local check=line:match("%[.*.%]")
    if startcount==1 and line:match(".*=.*") then
      count=count+1
      if count==number then local temp=line:match(".*=") return temp:sub(1,-2) end
    else
      startcount=0
      if "["..section.."]" == check then startcount=1 end
      if check==nil then check="" end
    end
  end
  return nil
end


--A=ultraschall.EnumerateIniFileExternalState_key("GuiElement_1",0,"c:\\test.ini")

function ultraschall.CountSectionsByPattern(pattern, ini_filename_with_path)
--uses "pattern"-string to determine, how often a section with a certain pattern exists. Good for sections, that have a number in them, like
--[section1], [section2], [section3]
--returns the number of sections, that include that pattern as well as
--a string, that includes the names of all such sections, separated by a comma
--refer pattern-matching for lua for more details
--pattern - the pattern to look for. Is case-sensitive!

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountSectionsByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer number_of_sections, string sectionnames = ultraschall.CountSectionsByPattern(string pattern, string ini_filename_with_path)</functioncall>
  <description>
    Counts the number of sections within an ini-file, that fit a specific pattern.
    
    Uses "pattern"-string to determine, how often a section with a certain pattern exists. Good for sections, that have a number in them, like [section1], [section2], [section3].
    Returns the number of sections, that include that pattern as well as a string, that includes the names of all such sections, separated by a comma.
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns -1, in case of an error.
  </description>
  <retvals>
    integer number_of_sections - the number of sections, that fit the pattern
    string sectionnames - a string, like: [section1],[section8],[section99]
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, sections, pattern, get, ini-files</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("CountSectionsByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("CountSectionsByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("CountSectionsByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("CountSectionsByPattern", "pattern", "malformed pattern", -4) return -1 end
  
  local count=0
  local sections=""
  for line in io.lines(ini_filename_with_path) do
    if line:match("%[.*"..pattern..".*%]") then count=count+1 sections=sections..line:match("(%[.*"..pattern..".*%])").."," end
  end
  return count, sections:sub(1,-2)
end

--A,AA=ultraschall.CountSectionsByPattern("","c:\\test.ini")

function ultraschall.CountKeysByPattern(pattern, ini_filename_with_path)
--uses "pattern"-string to determine, how often a key with a certain pattern exists. Good for keys, that have a number in them, like
--key1, key2, key3
--returns the number of sections, that include keys with that pattern as well as
--a string with all [sections] that contain keys= with a pattern, separated by a , i.e. [section1],key1=,key2=,key3=,[section2],key1,key4
--refer pattern-matching for lua for more details
--pattern - the pattern to look for

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountKeysByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer number_of_keys, string sections_and_keys = ultraschall.CountKeysByPattern(string pattern, string ini_filename_with_path)</functioncall>
  <description>
    Counts the number of keys within an ini-file, that fit a specific pattern.
    
    Uses "pattern"-string to determine, how often a key with a certain pattern exists. Good for keys, that have a number in them, like key1, key2, key3.
    Returns the number of keys, that include the pattern, as well as a string with all [sections] that contain keys= with a pattern, separated by a , i.e. [section1],key1=,key2=,key3=,[section2],key1=,key4=
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns -1, in case of an error.
  </description>
  <retvals>
    integer number_of_keys - the number of keys, that fit the pattern
    string sections_and_keys - a string, like: [section1],Key1=,Key2=,Key3=[section2],Key7=
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, keys, pattern, get, ini-files</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("CountKeysByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("CountKeysByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("CountKeysByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("CountKeysByPattern", "pattern", "malformed pattern", -4) return -1 end
  
  local retpattern=""
  local count=0
  local tiff=0
  local temppattern=nil
  for line in io.lines(ini_filename_with_path) do
    if line:match("%[.*%]") then temppattern=line tiff=1 end--:match("%[(.*)%]") tiff=1 end-- reaper.MB(temppattern,"",0) end
    if line:match("%[.*%]")==nil and line:match(pattern..".*=") then count=count+1 
        if tiff==1 then retpattern=retpattern..temppattern.."," end 
        retpattern=retpattern..line:match(".*"..pattern..".*=")..","
        tiff=0 
    end
  end
  return count, retpattern:sub(1,-2)
end

--A,AA=ultraschall.CountKeysByPattern("","c:\\test.ini")


function ultraschall.CountValuesByPattern(pattern, ini_filename_with_path)
--uses "pattern"-string to determine, how often a value with a certain pattern exists. Good for values, that have a number in them, like
--value1, value2, value3
--returns the number of sections, that include that pattern as well as 
--a string, that contains the [sections] and the keys= that contain values that fit the pattern, separated by a comma
-- e.g. [section1], key1=, value, key4=, value, [section4], key2=, value
--refer pattern-matching for lua for more details
--pattern - the pattern to look for

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountValuesByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer number_of_keys, string sections_and_keys = ultraschall.CountValuesByPattern(string pattern, string ini_filename_with_path)</functioncall>
  <description>
    Counts the number of values within an ini-file, that fit a specific pattern.
    
    Uses "pattern"-string to determine, how often a value with a certain pattern exists. Good for values, that have a number in them, like value1, value2, value3
    Returns the number of values, that include that pattern as well as a string, that contains the [sections] and the keys= and values , the latter that contain the pattern, separated by a comma
     e.g. [section1], key1=, value, key4=, value, [section4], key2=, value
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns -1, in case of an error.
  </description>
  <retvals>
    integer number_of_values - the number of values, that fit the pattern
    string sections_keys_values - a string, like: [section1],key1=,value,key4=,value,[section4],key2=,value
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, count, values, pattern, get, ini-files</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("CountValuesByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("CountValuesByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("CountValuesByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("CountValuesByPattern", "pattern", "malformed pattern", -4) return -1 end
  
  local retpattern=""
  local count=0
  local tiff=0
  local temppattern=nil
  for line in io.lines(ini_filename_with_path) do
    if line:match("%[.*%]") then temppattern=line tiff=1 end--:match("%[(.*)%]") tiff=1 end-- reaper.MB(temppattern,"",0) end
    if line:match("%[.*%]")==nil and line:match(".*=("..pattern..")") then count=count+1 
        if tiff==1 then retpattern=retpattern..temppattern.."," end 
        retpattern=retpattern..line:match(".*=")..","
        retpattern=retpattern..line:match(".*=("..pattern..")")..","
        tiff=0 
    end
  end
  return count, retpattern:sub(1,-2)
end

--A,AA=ultraschall.CountValuesByPattern("Mamula","c:\\test.ini")


function ultraschall.EnumerateSectionsByPattern(pattern, id, ini_filename_with_path)
--uses "pattern"-string to determine a section with a certain pattern. Good for sections, that have a number in them, like
--[section1], [section2], [section3]
--returns the full section-name of the "id"-th section, that fits the pattern description
--refer pattern-matching for lua for more details
--pattern - the pattern to look for
--id - the number of the section, that fits that pattern scheme

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateSectionsByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string sectionname = ultraschall.EnumerateSectionsByPattern(string pattern, integer id, string ini_filename_with_path)</functioncall>
  <description>
    Returns the numberth section within an ini-file, that fits the pattern, e.g. the third section containing "hawaii" in it.
    
    Uses "pattern"-string to determine if a section contains a certain pattern. Good for sections, that have a number in them, like section1, section2, section3
    Returns the section that includes that pattern as a string, numbered by id.
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns nil, in case of an error.
  </description>
  <retvals>
    string sectionname - a string, that contains the sectionname
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    integer id - the number of section, that contains pattern
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, enumerate, section, pattern, get, ini-files</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("EnumerateSectionsByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("EnumerateSectionsByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("EnumerateSectionsByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if math.type(id)~="integer" then ultraschall.AddErrorMessage("EnumerateSectionsByPattern", "id", "must be an integer", -4) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("EnumerateSectionsByPattern", "pattern", "malformed pattern", -5) return -1 end
  
  local count=0
  for line in io.lines(ini_filename_with_path) do
    if line:match("%[.*"..pattern..".*%]") then count=count+1 end
    if count==id then return line:match("%[(.*"..pattern..".*)%]") end
  end
  return nil--count, sections:sub(1,-2)
end

--A,AA=ultraschall.EnumerateSectionsByPattern("hu",2,"c:\\test.ini")

function ultraschall.EnumerateKeysByPattern(pattern, section, id, ini_filename_with_path)
--uses "pattern"-string to determine, how often a key with a certain pattern exists. Good for keys, that have a number in them, like
--key1, key2, key3
--returns the full key-name of the "id"-th key, that fits the pattern description
--refer pattern-matching for lua for more details
--pattern - the pattern to look for
--section - the section, to where look for the key
--id - the number of the key, that fits that pattern scheme

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateKeysByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string keyname = ultraschall.EnumerateKeysByPattern(string pattern, string section, integer id, string ini_filename_with_path)</functioncall>
  <description>
    Returns the numberth key within a section in an ini-file, that fits the pattern, e.g. the third key containing "hawaii" in it.
    
    Uses "pattern"-string to determine if a key contains a certain pattern. Good for keys, that have a number in them, like key1=, key2=, key3=
    Returns the key that includes that pattern as a string, numbered by id.
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns nil, in case of an error.
  </description>
  <retvals>
    string keyname - a string, that contains the keyname
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    string section - the section, in which to look for the key
    integer id - the number of key, that contains pattern
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, ini-files, enumerate, section, key, pattern, get</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("EnumerateKeysByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("EnumerateKeysByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("EnumerateKeysByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if math.type(id)~="integer" then ultraschall.AddErrorMessage("EnumerateKeysByPattern", "id", "must be an integer", -4) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("EnumerateKeysByPattern", "pattern", "malformed pattern", -5) return -1 end
  
  local count=0
  local tiff=0
  local temppattern=nil
  for line in io.lines(ini_filename_with_path) do
    if tiff==1 and line:match("%[.*%]")~=nil then return nil end
    if line:match(section) then temppattern=line tiff=1 end
    if tiff==1 and line:match(pattern..".*=") then count=count+1 
        if count==id then return line:match("(.*"..pattern..".*)=") end
    end
  end
end

--A=ultraschall.EnumerateKeysByPattern("l","hula",3,"c:\\test.ini")

function ultraschall.EnumerateValuesByPattern(pattern, section, id, ini_filename_with_path)
--uses "pattern"-string to determine, how often a value with a certain pattern exists. Good for values, that have a number in them, like
--values1, value2, value3
--returns the full value of the "id"-th value, that fits the pattern description
--refer pattern-matching for lua for more details
--pattern - the pattern to look for
--id - the number of the value, that fits that pattern scheme

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateValuesByPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>string value, string keyname = ultraschall.EnumerateValuesByPattern(string pattern, string section, string id, string ini_filename_with_path)</functioncall>
  <description>
    Returns the numberth value(and it's accompanying key) within a section in an ini-file, that fits the pattern, e.g. the third value containing "hawaii" in it.
    
    Uses "pattern"-string to determine if a value contains a certain pattern. Good for values, that have a number in them, like value1, value2, value3
    Returns the value that includes that pattern as a string, numbered by id, as well as it's accompanying key.
    
    Pattern can also contain patterns for pattern matching. Refer the LUA-docs for pattern matching.
    i.e. characters like ^$()%.[]*+-? must be escaped with a %, means: %[%]%(%) etc
    
    Returns nil, in case of an error.
  </description>
  <retvals>
    string value - the value that contains the pattern
    string keyname - a string, that contains the keyname
  </retvals>
  <parameters>
    string pattern - the pattern itself. Case sensitive.
    string section - the section, in which to look for the key
    integer id - the number of key, that contains pattern
    string ini_filename_with_path - filename of the ini-file
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, ini-files, enumerate, section, key, value, pattern, get</tags>
</US_DocBloc>
]]
  if type(pattern)~="string" then ultraschall.AddErrorMessage("EnumerateValuesByPattern", "pattern", "must be a string", -1) return -1 end
  if ini_filename_with_path==nil then ultraschall.AddErrorMessage("EnumerateValuesByPattern", "ini_filename_with_path", "must be a string", -2) return -1 end
  if reaper.file_exists(ini_filename_with_path)==false then ultraschall.AddErrorMessage("EnumerateValuesByPattern", "ini_filename_with_path", "file does not exist", -3) return -1 end
  if math.type(id)~="integer" then ultraschall.AddErrorMessage("EnumerateValuesByPattern", "id", "must be an integer", -4) return -1 end
  if ultraschall.IsValidMatchingPattern(pattern)==false then ultraschall.AddErrorMessage("EnumerateValuesByPattern", "pattern", "malformed pattern", -5) return -1 end
  
  local count=0
  local tiff=0
  local temppattern=nil
  for line in io.lines(ini_filename_with_path) do
    if tiff==1 and line:match("%[.*%]")~=nil then return nil end
    if line:match(section) then temppattern=line tiff=1 end
    if tiff==1 and line:match("=.*"..pattern..".*") then count=count+1 
        if count==id then return line:match("=(.*"..pattern..".*)"), line:match("(.*)=.*"..pattern..".*") end
    end
  end
end

--A,AA=ultraschall.EnumerateValuesByPattern("l","l",1,"c:\\test.ini")


---------------------------
---- Marker Management ----
---------------------------

function ultraschall.GetMarkerByScreenCoordinates(xmouseposition, retina)
--returns a string with the marker(s) in the timeline at given 
--screen-x-position. No Regions!
--string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2"

--xmouseposition - x mouseposition
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerByScreenCoordinates</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string marker = ultraschall.GetMarkerByScreenCoordinates(integer xmouseposition, boolean retina)</functioncall>
  <description>
    returns the markers at a given absolute-x-pixel-position. It sees markers according their graphical representation in the arrange-view, not just their position! Returned string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2\n...".
    Returns only markers, no time markers or regions!
    
    returns nil in case of an error
  </description>
  <retvals>
    string marker - a string with all markernumbers, markerpositions and markertitles, separated by a newline. 
    -Can contain numerous markers, if there are more markers in one position.
  </retvals>
  <parameters>
    integer xmouseposition - the absolute x-screen-position, like current mouse-position
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get marker, position, marker</tags>
</US_DocBloc>
]]
  if math.type(xmouseposition)~="integer" then ultraschall.AddErrorMessage("GetMarkerByScreenCoordinates", "xmouseposition", "must be an integer", -1) return nil end
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  for i=0, retval do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==false then
      if markrgnindexnumber>999999999 then temp=ten
      elseif markrgnindexnumber>99999999 and markrgnindexnumber<1000000000  then temp=nine
      elseif markrgnindexnumber>9999999 and markrgnindexnumber<100000000 then temp=eight
      elseif markrgnindexnumber>999999 and markrgnindexnumber<10000000 then temp=seven
      elseif markrgnindexnumber>99999 and markrgnindexnumber<1000000 then temp=six
      elseif markrgnindexnumber>9999 and markrgnindexnumber<100000 then temp=five
      elseif markrgnindexnumber>999 and markrgnindexnumber<10000 then temp=four
      elseif markrgnindexnumber>99 and markrgnindexnumber<1000 then temp=three
      elseif markrgnindexnumber>9 and markrgnindexnumber<100 then temp=two
      elseif markrgnindexnumber>-1 and markrgnindexnumber<10 then temp=one
      end
      local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, xmouseposition-temp,xmouseposition) 
      local ALABAMA=xmouseposition
      if pos>=Ax and pos<=AAx then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name end
    end
  end
  return retstring--:match("(.-)%c.-%c")), tonumber(retstring:match(".-%c(.-)%c")), retstring:match(".-%c.-%c(.*)")
end

--AAAA=ultraschall.GetMarkerByScreenCoordinates(reaper.GetMousePosition(), false)
--reaper.ClearConsole()
--reaper.ShowConsoleMsg(string.gsub(AAAA,"\n","\n").."A")

--B=ultraschall.GetMarkerByScreenCoordinates(reaper.GetMousePosition(), false)

function ultraschall.GetMarkerByTime(position, retina)
--returns a string with the marker(s) at given timeline-position. No Regions!
--string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2"

--position - position in time
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerByTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string markers = ultraschall.GetMarkerByTime(number position, boolean retina)</functioncall>
  <description>
    returns the markers at a given project-position in seconds. 
    It sees markers according their actual graphical representation in the arrange-view, not just their position. 
    If, for example, you pass to it the current playposition, the function will return the marker as long as the playcursor is behind the marker-graphics.
    
    Returned string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2\n...".
    Returns only markers, no time markers or regions!
  </description>
  <retvals>
    string marker - a string with all markernumbers, markerpositions and markertitles, separated by a newline. 
    -Can contain numerous markers, if there are more markers in one position.
  </retvals>
  <parameters>
    number position - the time-position in seconds
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get marker, position, marker</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("GetMarkerByTime", "position", "must be a number", -1) return nil end
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  for i=0, retval do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==false then
      if markrgnindexnumber>999999999 then temp=ten
      elseif markrgnindexnumber>99999999 and markrgnindexnumber<1000000000  then temp=nine
      elseif markrgnindexnumber>9999999 and markrgnindexnumber<100000000 then temp=eight
      elseif markrgnindexnumber>999999 and markrgnindexnumber<10000000 then temp=seven
      elseif markrgnindexnumber>99999 and markrgnindexnumber<1000000 then temp=six
      elseif markrgnindexnumber>9999 and markrgnindexnumber<100000 then temp=five
      elseif markrgnindexnumber>999 and markrgnindexnumber<10000 then temp=four
      elseif markrgnindexnumber>99 and markrgnindexnumber<1000 then temp=three
      elseif markrgnindexnumber>9 and markrgnindexnumber<100 then temp=two
      elseif markrgnindexnumber>-1 and markrgnindexnumber<10 then temp=one
      end 
      local Aretval,ARetval2=ultraschall.GetIniFileValue("REAPER", "leftpanewid", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")
      local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, ARetval2+57-temp,ARetval2+57) 
      local Bx=AAx-Ax
      if Bx+pos>=position and pos<=position then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name end      
    end
  end
  return retstring
end

--L=reaper.GetPlayPosition()
--B=ultraschall.GetMarkerByTime(reaper.GetPlayPosition(), false)
--Aretval,ARetval2=reaper.BR_Win32_GetPrivateProfileString("REAPER", "leftpanewid", "", reaper.GetResourcePath().."\\reaper.ini")
--Ax,AAx= reaper.GetSet_ArrangeView2(0, false, ARetval2+57,ARetval2+57+84) 

--AAA=GetMarkerByTime(6475,false) --6476 in 6495
--Astart_time, Aend_time = reaper.GetSet_ArrangeView2(0, false, 0, 0)

function ultraschall.main()
  Dx,Dy = reaper.GetMousePosition()
  Gx,Gy=gfx.clienttoscreen(Dx,Dy)  
  Hx,Ix= reaper.GetSet_ArrangeView2(0, false, Dx-84,Dx+84) --Das kann ich in Pixel umrechnen, da ich Mouse-und Time von Startposition habe und Bereich von Startarrange bis timposition DX
    
  gfx.update()
  --a,b,c,d,e,f,g,h,i=gfx.dock(-1,0,0,0,0)
  --gfx.screentoclient(x,y)
  reaper.defer(main)
end
--AA=reaper.GetResourcePath().."\\reaper.ini"
--HWND=reaper.GetMainHwnd()
--main()
--Aretval=reaper.BR_Win32_WritePrivateProfileString("REAPER", "wnd_w", "100", reaper.GetResourcePath().."\\reaper.ini")

function ultraschall.GetRegionByScreenCoordinates(xmouseposition, retina)
--returns a string with the marker(s) at given screen-x-position in the timeline. No Regions!
--string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2"

--xmouseposition - x mouseposition
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetRegionByScreenCoordinates</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string markers = ultraschall.GetRegionByScreenCoordinates(integer xmouseposition, boolean retina)</functioncall>
  <description>
    returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be "Regionidx\npos\nName\nRegionidx2\npos2\nName2\n...".
    Returns only regions, no time markers or other markers!
  </description>
  <retvals>
    string marker - a string with all regionnumbers, regionpositions and regionnames, separated by a newline. 
    -Can contain numerous regions, if there are more regions in one position.
  </retvals>
  <parameters>
    integer xmouseposition - the absolute x-screen-position, like current mouse-position
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get region, position, region</tags>
</US_DocBloc>
]]
  if math.type(xmouseposition)~="integer" then ultraschall.AddErrorMessage("GetRegionByScreenCoordinates", "xmouseposition", "must be an integer", -1) return nil end
  
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  for i=0, retval do
    local ALABAMA=xmouseposition
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==true then
      if markrgnindexnumber>999999999 then temp=ten
      elseif markrgnindexnumber>99999999 and markrgnindexnumber<1000000000  then temp=nine
      elseif markrgnindexnumber>9999999 and markrgnindexnumber<100000000 then temp=eight
      elseif markrgnindexnumber>999999 and markrgnindexnumber<10000000 then temp=seven
      elseif markrgnindexnumber>99999 and markrgnindexnumber<1000000 then temp=six
      elseif markrgnindexnumber>9999 and markrgnindexnumber<100000 then temp=five
      elseif markrgnindexnumber>999 and markrgnindexnumber<10000 then temp=four
      elseif markrgnindexnumber>99 and markrgnindexnumber<1000 then temp=three
      elseif markrgnindexnumber>9 and markrgnindexnumber<100 then temp=two
      elseif markrgnindexnumber>-1 and markrgnindexnumber<10 then temp=one
      end
      local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, xmouseposition-temp,xmouseposition) 
      if pos>=Ax and pos<=AAx then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name.."\n" 
      elseif Ax>=pos and Ax<=rgnend then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name
      end
    end
  end
  return retstring
end

--A=ultraschall.GetRegionByScreenCoordinates(reaper.GetMousePosition(),false)
--reaper.ClearConsole()
--reaper.ShowConsoleMsg(A)
function ultraschall.GetRegionByTime(position, retina)
--returns a string with the marker(s) at given timeline-position. No Regions!
--string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2"

--position - position in time
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetRegionByTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string markers = ultraschall.GetRegionByTime(number position, boolean retina)</functioncall>
  <description>
    returns the regions at a given absolute-x-pixel-position. It sees regions according their graphical representation in the arrange-view, not just their position! Returned string will be "Regionidx\npos\nName\nRegionidx2\npos2\nName2\n...".
    Returns only regions, no time markers or other markers!
  </description>
  <retvals>
    string marker - a string with all regionnumbers, regionpositions and regionnames, separated by a newline. 
    -Can contain numerous regions, if there are more regions in one position.
  </retvals>
  <parameters>
    number position - position in seconds
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get region, position, region</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("GetRegionByTime", "position", "must be a number", -1) return nil end
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  for i=0, retval do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==true then
      if markrgnindexnumber>999999999 then temp=ten
      elseif markrgnindexnumber>99999999 and markrgnindexnumber<1000000000  then temp=nine
      elseif markrgnindexnumber>9999999 and markrgnindexnumber<100000000 then temp=eight
      elseif markrgnindexnumber>999999 and markrgnindexnumber<10000000 then temp=seven
      elseif markrgnindexnumber>99999 and markrgnindexnumber<1000000 then temp=six
      elseif markrgnindexnumber>9999 and markrgnindexnumber<100000 then temp=five
      elseif markrgnindexnumber>999 and markrgnindexnumber<10000 then temp=four
      elseif markrgnindexnumber>99 and markrgnindexnumber<1000 then temp=three
      elseif markrgnindexnumber>9 and markrgnindexnumber<100 then temp=two
      elseif markrgnindexnumber>-1 and markrgnindexnumber<10 then temp=one
      end
      local Aretval,ARetval2=ultraschall.GetIniFileValue("REAPER", "leftpanewid", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")
      local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, ARetval2+57-temp,ARetval2+57) 
      local Bx=AAx-Ax
      if Bx+pos>=position and pos<=position then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name.."\n"
      elseif pos<=position and rgnend>=position then retstring=retstring..markrgnindexnumber.."\n"..pos.."\n"..name
      end
    end
  end
  return retstring
end

--A=ultraschall.GetRegionByTime(73, false)
--reaper.ShowConsoleMsg(A)

function ultraschall.GetTimesignaturesByScreenCoordinates(xmouseposition, retina)
--returns a string with the marker(s) at given screen-x-position. No Regions!
--string will be "Markeridx\npos\nMarkeridx2\npos2\n"

--xmouseposition - x mouseposition
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTimesignaturesByScreenCoordinates</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string markers = ultraschall.GetTimesignaturesByScreenCoordinates(integer xmouseposition, boolean retina)</functioncall>
  <description>
    returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be "tempomarkeridx\npos\ntempomarkeridx2\npos2\n...".
    Returns only time-signature-markers, no regions or other markers!
  </description>
  <retvals>
    string marker - a string with all markernumbers and markerpositions, separated by a newline. 
    -Can contain numerous markers, if there are more markers in one position.
  </retvals>
  <parameters>
    integer xmouseposition - the absolute x-screen-position, like current mouse-position
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get region, position, time signature, tempo, marker, tempo marker</tags>
</US_DocBloc>
]]
  if math.type(xmouseposition)~="integer" then ultraschall.AddErrorMessage("GetTimesignaturesByScreenCoordinates", "xmouseposition", "must be an integer", -1) return nil end
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  
  local timeretval = reaper.CountTempoTimeSigMarkers(0)
  for i=0, timeretval-1 do
    local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
    temp=one
    
    local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, xmouseposition-temp,xmouseposition) 
    local ALABAMA=xmouseposition
    if timepos>=Ax and timepos<=AAx then retstring=retstring..i.."\n"..timepos.."\n" end
  end
  return retstring
end

--A=ultraschall.GetTimesignaturesByScreenCoordinates(reaper.GetMousePosition(),false)
--reaper.ClearConsole()
--reaper.ShowConsoleMsg(A.."A")

function ultraschall.GetTimeSignaturesByTime(position, retina)
--returns a string with the marker(s) at given position. No Regions!
--string will be "Markeridx\npos\nName\nMarkeridx2\npos2\nName2"

--position - position in time
--retina - if it's retina/hiDPI, set it true, else, set it false

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTimeSignaturesByTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string markers = ultraschall.GetTimeSignaturesByTime(number position, boolean retina)</functioncall>
  <description>
    returns the time-signature/tempo-marker at a given absolute-x-pixel-position. It sees time-signature/tempo-markers according their graphical representation in the arrange-view, not just their position! Returned string will be "tempomarkeridx\npos\ntempomarkeridx2\npos2\n...".
    Returns only time-signature-markers, no other markers or regions!
  </description>
  <retvals>
    string marker - a string with all markernumbers and markerpositions, separated by a newline. 
    -Can contain numerous markers, if there are more markers in one position.
  </retvals>
  <parameters>
    number position - position in seconds
    boolean retina - if the screen-resolution is retina or hidpi, turn this true, else false
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get region, position, time signature, tempo, marker, tempo marker</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("GetTimeSignaturesByTime", "position", "must be a number", -1) return nil end
  local one,two,three,four,five,six,seven,eight,nine,ten
  if retina==false then
    ten=84
    nine=76
    eight=68
    seven=60
    six=52
    five=44
    four=36
    three=28
    two=20
    one=12
  else
    ten=84*2
    nine=76*2
    eight=68*2
    seven=60*2
    six=52*2
    five=44*2
    four=36*2
    three=28*2
    two=20*2
    one=12*2
  end
  local retstring=""
  local temp
  
  local timeretval = reaper.CountTempoTimeSigMarkers(0)
  for i=0, timeretval-1 do
    local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
    temp=one    
    local Aretval,ARetval2=ultraschall.GetIniFileValue("REAPER", "leftpanewid", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")
    local Ax,AAx= reaper.GetSet_ArrangeView2(0, false, ARetval2+57-temp,ARetval2+57) 
    local Bx=AAx-Ax
    if Bx+timepos>=position and timepos<=position then retstring=retstring..i.."\n"..timepos.."\n" end
  end
  return retstring
end

--A=ultraschall.GetTimeSignaturesByTime(reaper.GetCursorPosition(),false)
--reaper.ShowConsoleMsg(A.."A")
--A,AA=GetRegionByTime(16.269,false)


function ultraschall.IsMarkerEdit(markerid)
--checks, if a marker is an _Edit:-Marker
--returns true or false
--returns nil, if markerid isn't valid

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMarkerEdit</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsMarkerEdit(integer markerid)</functioncall>
  <description>
    returns true, if the marker is an edit-marker, false if not. Returns nil, if markerid is invalid.
    Markerid is the marker-number for all markers, as used by marker-functions from Reaper.
  </description>
  <retvals>
    boolean retval - true, if it's an edit-marker, false if not
  </retvals>
  <parameters>
    integer markerid - the markerid of all markers in the project, beginning with 0 for the first marker
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, check, edit marker, edit</tags>
</US_DocBloc>
]]
  if math.type(markerid)~="integer" then ultraschall.AddErrorMessage("IsMarkerEdit","markerid", "must be an integer", -1) return nil end

  local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, markerid)
  if retval>0 then
    if isrgn==false then
      if name:sub(1, 5)=="_Edit" then return true      
      else return false
      end
    end
  end
  return false
end

--A=ultraschall.IsMarkerEdit(1.1)



function ultraschall.IsMarkerNormal(markerid)
--checks, if a marker is a Normal-Marker
--returns true or false
--returns nil, if markerid isn't valid
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMarkerNormal</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsMarkerNormal(integer markerid)</functioncall>
  <description>
    returns true, if the marker is a normal-marker, false if not. Returns nil, if markerid is invalid.
    Markerid is the marker-number for all markers, as used by marker-functions from Reaper.
  </description>
  <retvals>
    boolean retval - true, if it's an normal-marker, false if not
  </retvals>
  <parameters>
    integer markerid - the markerid of all markers in the project, beginning with 0 for the first marker
  </parameters>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, check, normal marker, normal</tags>
</US_DocBloc>
]]
  if math.type(markerid)~="integer" then ultraschall.AddErrorMessage("IsMarkerNormal","markerid", "must be an integer", -1) return nil end

  local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, markerid)
  if retval>0 then
    if isrgn==false then
      if name:sub(1,10)~="_Shownote:" and name:sub(1,5)~="_Edit" and color~=ultraschall.ConvertColor(100,255,0) then return true
      else return false
      end
    end
  end
  return false
end

--A=ultraschall.IsMarkerNormal(1)

function ultraschall.IsRegionPodrange(markerid)
--checks, if a marker is a _PodRange:-Region
--returns true or false
--returns nil, if markerid isn't valid
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsRegionPodrange</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsRegionPodrange(integer markerid)</functioncall>
  <description>
    returns true, if the marker is a Podrange-region, false if not. Returns nil, if markerid is invalid.
    Markerid is the marker-number for all markers, as used by marker-functions from Reaper.
  </description>
  <retvals>
    boolean retval - true, if it's a PodRange-Region, false if not
  </retvals>
  <parameters>
    integer markerid - the markerid of all markers in the project, beginning with 0 for the first marker
  </parameters>
  <chapter_context>
    Markers
    PodRange Region
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, check, podrangeregion, podrange, region</tags>
</US_DocBloc>
]]
  if math.type(markerid)~="integer" then ultraschall.AddErrorMessage("IsRegionPodrange","markerid", "must be an integer", -1) return nil end
  
  local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, markerid)
  if retval>0 then
    if isrgn==true then
     if name:sub(1, 10)=="_PodRange:" then return true      
     else return false
     end
    end
  end
  return false
end

--A=ultraschall.IsRegionPodrange(3)

function ultraschall.IsRegionEditRegion(markerid)
--checks, if a marker is an _Edit:-Region
--returns true or false
--returns nil, if markerid isn't valid
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsRegionEditRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsRegionEditRegion(integer markerid)</functioncall>
  <description>
    returns true, if the marker is an Edit-region, false if not. Returns nil, if markerid is invalid.
    Markerid is the marker-number for all markers, as used by marker-functions from Reaper.
  </description>
  <retvals>
    boolean retval - true, if it's an Edit-Region, false if not
  </retvals>
  <parameters>
    integer markerid - the markerid of all markers in the project, beginning with 0 for the first marker
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, check, edit region, edit, region</tags>
</US_DocBloc>
]]
  if math.type(markerid)~="integer" then ultraschall.AddErrorMessage("IsRegionEditRegion","markerid", "must be an integer", -1) return nil end
  
  local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, markerid)
  if retval>0 then
    if isrgn==true then
      if name:sub(1, 5)=="_Edit" then return true      
      else return false
      end
    end
  end
  return false
end

--A=ultraschall.IsRegionEditRegion(1)

----------------------
---- Edit Regions ----
----------------------

function ultraschall.AddEditRegion(startposition, endposition, text)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddEditRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer markernr = ultraschall.AddEditRegion(number startposition, number endposition, string text)</functioncall>
  <description>
    Adds a new edit-region and returns index of the newly created edit-marker-region.
    
  </description>
  <retvals>
    integer markernr - the number of the newly created region
  </retvals>
  <parameters>
    number startposition - startposition in seconds
    number endposition - endposition in seconds
    string text - the title of the marker
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, add, edit region, edit, region</tags>
</US_DocBloc>
]]
  local color=0
  local retval=0
  local isrgn=true
  local pos=0
  local rgnend=0
  local name=""
  local markrgnindexnumber=""
  local noteID=0
  
  local Os = reaper.GetOS()
  if string.match(Os, "OSX") then 
    color = 0xFF0000|0x1000000
  else
    color = 0x0000FF|0x1000000
  end
  
  local count=0
  if type(startposition)~="number" then ultraschall.AddErrorMessage("AddEditRegion", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("AddEditRegion", "endposition", "must be a number", -2) return -1 end
  if startposition<0 then ultraschall.AddErrorMessage("AddEditRegion", "startposition", "must be bigger than 0", -3) return -1 end
  if endposition<startposition then ultraschall.AddErrorMessage("AddEditRegion", "endposition", "must be bigger than startposition", -4) return -1 end
  if text~=nil and type(text)~="string" then ultraschall.AddErrorMessage("AddEditRegion", "text", "must be a string or nil", -5) return -1 end
  if text==nil then text="" end
  
  noteID=reaper.AddProjectMarker2(0, 1, startposition, endposition, "_Edit:"..text, 0, color)
  
  return noteID
end

--A=ultraschall.AddEditRegion(10,26,"")

function ultraschall.SetEditRegion(number, position, endposition, edittitle)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetEditRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetEditRegion(integer number, number position, number endposition, string edittitle)</functioncall>
  <description>
    Sets the values of an already existing edit-region. To retain an already set position, endposition and/or edittitle, use nil.
    Returns true in case of success, false if not.
    Note: if you set the new beginning of the region before another region, the indexnumber of the edit-region changes. So if you want to set an edit-region repeatedly, you should get the indexnumber using <a href="#EnumerateEditRegion">ultraschall.EnumerateEditRegion</a>, or you might accidently change another region!
  </description>
  <retvals>
    boolean retval - true, in case of success, false if not
  </retvals>
  <parameters>
    integer number - the number of the edit-region, beginning with 1 for the first edit-region
    number startposition - startposition in seconds, nil to retain the old value
    number endposition - endposition in seconds, nil to retain the old value
    string text - the title of the marker, nil to retain the old value
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, set, edit region, edit, region</tags>
</US_DocBloc>
]]
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("SetEditRegion", "number", "must be an integer", -1) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("SetEditRegion", "position", "must be a number", -2) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("SetEditRegion", "endposition", "must be a number", -3) return -1 end
  if edittitle~=nil and type(edittitle)~="string" then ultraschall.AddErrorMessage("SetEditRegion", "edittitle", "must be either a string or nil", -4) return -1 end
  if endposition<0 then ultraschall.AddErrorMessage("SetEditRegion", "endposition", "must be bigger than 0", -5) return -1 end
  if position<0 then ultraschall.AddErrorMessage("SetEditRegion", "position", "must be bigger than 0", -6) return -1 end
  if endposition<position then ultraschall.AddErrorMessage("SetEditRegion", "endposition", "must be bigger than position", -7) return -1 end

  local color=0
  local Os = reaper.GetOS()
  if string.match(Os, "OSX") then 
    color = 0xFF0000|0x1000000
  else
    color = 0x0000FF|0x1000000
  end
  
  local shown_number=-1
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  number=tonumber(number)-1
  local wentfine=0
  local count=-1
  local retnumber=0
  for i=0, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==true then
      if name:sub(1,5)=="_Edit" then count=count+1 end 
      if number>=0 and wentfine==0 and count==number then 
          if tonumber(position)==-1 or position==nil then position=pos end
          if tonumber(endposition)==-1 or position==nil then endposition=rgnend end
          if tonumber(shown_number)<=-1 or shown_number==nil then shown_number=markrgnindexnumber end
          if edittitle==nil then edittitle=name:match("(_Edit:.*)") edittitle=edittitle:sub(7,-1) end
          retnumber=i
          wentfine=1
      end
      end
  end
  
  if edittitle==nil then edittitle="" end
  
  if wentfine==1 then return reaper.SetProjectMarkerByIndex(0, retnumber, true, position, endposition, shown_number, "_Edit:" .. edittitle, color)
  else return false
  end
end

--A=ultraschall.SetEditRegion(1,10,200,"hula")

function ultraschall.DeleteEditRegion(number)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteEditRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteEditRegion(integer number)</functioncall>
  <description>
    Deletes an already existing edit-region.
    Returns true in case of success, false if not.
  </description>
  <retvals>
    boolean retval - true, in case of success, false if not
  </retvals>
  <parameters>
    integer number - the number of the edit-region, beginning with 1 for the first edit-region
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, delete, edit region, edit, region</tags>
</US_DocBloc>
]]   
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("DeleteEditRegion","number", "must be an integer", -1) return false end
  
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  local number=tonumber(number)-1
  local wentfine=0
  local count=-1
  local retnumber=-1
  for i=0, c-1 do
     local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==true then
      if name:sub(1,5)=="_Edit" then count=count+1 
        if count==number then retnumber=i end
      end 
    end
  end
  
  return reaper.DeleteProjectMarkerByIndex(0, retnumber)
  
end

--A=ultraschall.DeleteEditRegion(1)

function ultraschall.EnumerateEditRegion(number)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateEditRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, number position, number endposition, string title, integer rgnindexnumber = ultraschall.EnumerateEditRegion(integer number)</functioncall>
  <description>
    Returns the values of an edit-region.
  </description>
  <retvals>
    integer retval - the overall marker-index-number of all markers in the project, -1 in case of error
    number position - position in seconds
    number endposition - endposition in seconds
    string title - the title of the region
    integer rgnindexnumber - the overall region index number, as used by other of Reaper's own marker-functions
  </retvals>
  <parameters>
    integer number - the number of the edit-region, beginning with 1 for the first edit-region
  </parameters>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, get, enumerate, edit region, edit, region</tags>
</US_DocBloc>
]]   
  if math.type(number)~="integer" then ultraschall.AddErrorMessage("EnumerateEditRegion","number", "must be an integer", -1) return false end
  
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  number=tonumber(number)-1
  local wentfine=-1
  local count=-1
  local retnumber=0
  for i=0, c-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if isrgn==true then
      if name:sub(1,5)=="_Edit" then count=count+1  
        if count==number then wentfine=i end
      end
    end
  end
  local retval, isrgn, pos, rgnend, name, markrgnindexnumber=reaper.EnumProjectMarkers(wentfine)
  if wentfine~=-1 then return retval, pos, rgnend, name, markrgnindexnumber
  else return -1
  end
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.EnumerateEditRegion(1)


function ultraschall.CountEditRegions()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountEditRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.CountEditRegions()</functioncall>
  <description>
    returns the number of edit-regions in the project.
  </description>
  <retvals>
    integer retval - the number of edit-regions in the project
  </retvals>
  <chapter_context>
    Markers
    Edit Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, navigation, count, edit region, edit, region</tags>
</US_DocBloc>
]]  
  local c,nummarkers,b=reaper.CountProjectMarkers(0)
  local count=0
  for i=0, c do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers(i)
    if name:sub(1,6)=="_Edit:" and isrgn==true then count=count+1 end 
  end
  return count
end


--AA=ultraschall.CountEditRegions()

---------------------------
---- kb-ini management ----
---------------------------

--[[ Eventuell kannste das Aktualisieren der reaper-kb.ini hiermit erzwingen?
integer reaper.AddRemoveReaScript(boolean add, integer sectionID, string scriptfn, boolean commit)

Add a ReaScript (return the new command ID, or 0 if failed) or remove a ReaScript (return >0 on success). 
Use commit==true when adding/removing a single script. When bulk adding/removing n scripts, you can optimize 
the n-1 first calls with commit==false and commit==true for the last call.

Leider nein, nur das hinzufgen der neu reingebauten Scripts :(
--]]

--integer=reaper.AddRemoveReaScript(true, 0, reaper.GetResourcePath().."\\Scripts\\hula.lua", true)

function ultraschall.GetKBIniFilepath()
  -- returns file with path to the reaper-kb.ini-file

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniFilepath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string kb_ini_path = ultraschall.GetKBIniFilepath()</functioncall>
  <description>
    Returns the path and filename of the Reaper-kb.ini-file.
  </description>
  <retvals>
    string kb_ini_path - path and filename of the reaper-kb.ini
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get</tags>
</US_DocBloc>
]]  
  return reaper.GetResourcePath()..ultraschall.Separator.."reaper-kb.ini"
end

--AA=ultraschall.GetKBIniFilepath()

function ultraschall.CountKBIniActions(filename_with_path)

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountKBIniActions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer actions = ultraschall.CountKBIniActions(string filename_with_path)</functioncall>
  <description>
    Count the number of "ACT"-Actions of the Reaper-kb.ini-file.
    Returns -1, if no such file exists.
  </description>
<parameter>
string filename_with_path - path and filename of the reaper-kb.ini
</parameter>
  <retvals>
    integer actions - number of actions in the reaper-kb.ini
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, count, actions, action</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("CountKBIniActions", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("CountKBIniActions", "filename_with_path", "file does not exist", -2) return -1 end
  local count=0
    for line in io.lines(filename_with_path) do 
      if line:sub(1,3)=="ACT" then 
        count=count+1
      end
    end
  if count>0 then return count
  else return -1
  end
end

--AAAAA=ultraschall.CountKBIniActions(nil)

function ultraschall.CountKBIniScripts(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountKBIniScripts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer scripts = ultraschall.CountKBIniScripts(string filename_with_path)</functioncall>
  <description>
    Count the number of "SCR"-Scripts of the Reaper-kb.ini-file.
    Returns -1, if no such file exists.
  </description>
<parameter>
string filename_with_path - path and filename of the reaper-kb.ini
</parameter>
  <retvals>
    integer scripts - number of scripts in the reaper-kb.ini
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, count, scripts, script</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("CountKBIniScripts", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("CountKBIniScripts", "filename_with_path", "file does not exist", -2) return -1 end
  local count=0
    for line in io.lines(filename_with_path) do 
      if line:sub(1,3)=="SCR" then 
        count=count+1
      end
    end
  if count>0 then return count
  else return -1
  end
end

--AAAAA=ultraschall.CountKBIniScripts("c:\\test.txt")

function ultraschall.CountKBIniKeys(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountKBIniKeys</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer keys = ultraschall.CountKBIniKeys(string filename_with_path)</functioncall>
  <description>
    Count the number of "KEY"-Keybindings of the Reaper-kb.ini-file.
    Returns -1, if no such file exists.
  </description>
<parameter>
string filename_with_path - path and filename of the reaper-kb.ini
</parameter>
  <retvals>
    integer keys - number of keys in the reaper-kb.ini
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, count, keys, key</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("CountKBIniKeys", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("CountKBIniKeys", "filename_with_path", "file does not exist", -2) return -1 end
  local count=0
    for line in io.lines(filename_with_path) do 
      if line:sub(1,3)=="KEY" then 
        count=count+1
      end
    end
  if count>0 then return count
  else return -1
  end
end

--AAAAA=ultraschall.CountKBIniKeys("c:\\test.txt")


function ultraschall.GetKBIniActions(filename_with_path, idx)
-- returns integer consolidate, integer section, string ActionCommandID, string Description, string ActionsToBeExecuted
-- returns -1 if no such Action exist or filename/idx is invalid

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniActions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer consolidate, integer section, string ActionCommandID, string description, string ActionsToBeExecuted = ultraschall.GetKBIniActions(string filename_with_path, integer idx)</functioncall>
  <description>
    Get the states of "ACT"-Action number idx. Returns consolidate, section, ActionCommandID, description, ActionsToBeExecuted.
    Returns -1, if no such entry or file exists.
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    integer idx - the number of the action to get, beginning with 1 for the first one
  </parameters>
  <retvals>
    integer consolidate - consolidate-state
    -1 consolidate undo points, 
    -2 show in Actions-Menu, 
    -3 consolidate undo points AND show in Actions Menu; 
    -maybe 4 and higher?
    
    integer section - the section, in which this action is executed
    -0 - Main
    -1 - action stays invisible but is kept, if Reaper rewrites the reaper-kb.ini. Menu-buttons with this action associated appear but don't work.
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
    
    string ActionCommandID - the ActionCommandID given to this Action
    string description - the description of this action
    string ActionsToBeExecuted - the actions that are run, the ActionCommandIDs beginning with _, multiple ActionCommandIDs are separated by whitespaces
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, actions, action</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniActions", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniActions", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetKBIniActions", "idx", "must be an integer", -3) return -1 end

  local count=0
  for line in io.lines(filename_with_path) do 
    if line:sub(1,3)=="ACT" then count=count+1 
      if count==idx then 
        return tonumber(line:match("%s(.-)%s")), -- consolidate
           tonumber(line:match("%s.-%s(.-)%s")), -- section
           line:match("%s.-%s.-%s(.-)%s"), -- ActionCommandID
           line:match("%s.-%s.-%s.-%s\"(.-)\"%s"), -- Description
           line:match("%s.-%s.-%s.-%s\".-\"%s(.*)") -- Actions
      end
    end
  end
  return -1
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetKBIniActions("c:\\test.txt",35)

function ultraschall.GetKBIniScripts(filename_with_path, idx)
-- returns integer terminateinstance, integer section, string ActionCommandID, string Description, string Scriptfile
-- returns -1 if no such Script exist or filename/idx is invalid

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniScripts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer terminateinstance, integer section, string ActionCommandID, string description, string scriptfile = ultraschall.GetKBIniScripts(string filename_with_path, integer idx)</functioncall>
  <description>
    Get the states of "SCR"-Scripts number idx. Returns terminateinstance, section, ActionCommandID, description, scriptfile.
    Returns -1, if no such entry or file exists.
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    integer idx - the number of the action to get, beginning with 1 for the first one
  </parameters>
  <retvals>
    integer terminateinstance - the state of terminating instances
    -4 - Dialogwindow appears(Terminate, New Instance, Abort), if another instance of a given script is started, that's already running
    -260 - always Terminate Instances, when an instance of the script is already running
    -516 - always start a New Instance of the script already running
    
    integer section - the section, in which this action is executed
    -0 - Main
    -1 - action stays invisible but is kept, if Reaper rewrites the reaper-kb.ini. Menu-buttons with this action associated appear but don't work.
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
    
    string ActionCommandID - the ActionCommandID given to this Action
    string description - the description of this action
    string scriptfile - the filename of the script that shall be run
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, scripts, script</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniScripts", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniScripts", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetKBIniScripts", "idx", "must be an integer", -3) return -1 end
  
  local count=0
  for line in io.lines(filename_with_path) do 
    if line:sub(1,3)=="SCR" then count=count+1 
      if count==idx then 
        return tonumber(line:match("%s(.-)%s")), 
               tonumber(line:match("%s.-%s(.-)%s")),
               line:match("%s.-%s.-%s(.-)%s"), -- ActionCommandID
               line:match("%s.-%s.-%s.-%s\"(.-)\"%s"),
               line:match("%s.-%s.-%s.-%s\".-\"%s(.*)")
      end
    end
  end
  return -1
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetKBIniScripts(ultraschall.GetKBIniFilepath(),165)

function ultraschall.GetKBIniKeys(filename_with_path, idx)
-- returns integer Keytype/Modifier/MidiChannel, integer Key/MidiNote, string ActionCommandID, integer section
-- returns -1 if no such Script exist or filename/idx is invalid

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniKeys</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer keytype_modifier_midichan, integer key_midinote, string ActionCommandID, integer section = ultraschall.GetKBIniKeys(string filename_with_path, integer idx)</functioncall>
  <description>
    Get the states of "KEY"-Keybinding-number idx, for MIDI/Key-bindings. Returns keytype_modifier_midichan, key_midinote, ActionCommandID, section.
    
    For a detailed description in how KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    
    Returns -1, if no such entry or file exists.
    Doesn't return OSC-bindings!
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    integer idx - the number of the action to get, beginning with 1 for the first one
  </parameters>
  <retvals>
    integer keytype_modifier_midichan - Type of Keytype, modifier or midichannel
                                      - For a detailed description in how keytype/modifier in KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    integer key_midinote - the key(like ASCII-Codes) or midinote. 
                                      - For a detailed description in how key/midinotes in KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    
    string ActionCommandID - the ActionCommandID associated with this shortcut.
    integer section - the section, in which this shortcut is used
    -0 - Main
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, keys, key</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniKeys", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniKeys", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetKBIniKeys", "idx", "must be an integer", -3) return -1 end
  
  local count=0
  for line in io.lines(filename_with_path) do 
    if line:sub(1,3)=="KEY" then count=count+1 
      if count==idx then 
        return tonumber(line:match("%s(.-)%s")), 
               tonumber(line:match("%s.-%s(.-)%s")),
               line:match("%s.-%s.-%s(.-)%s"),
               tonumber(line:match("%s.-%s.-%s.-%s(.*)"))
      end
    end
  end
  return -1
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetKBIniKeys(ultraschall.GetKBIniFilepath(),103)

function ultraschall.GetKBIniActionsID_ByActionCommandID(filename_with_path, ActionCommandID)
-- returns the idx(s) of an Action with a given ActionCommandID 
-- return false, if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniActionsID_ByActionCommandID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string retval = ultraschall.GetKBIniActionsID_ByActionCommandID(filename_with_path, ActionCommandID)</functioncall>
  <description>
    Returns the indexnumber(s) of actions by ActionCommandIDs within a reaper-kb.ini.
    Returns -1, if no such entry or file exists.
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    string ActionCommandID - the ActionCommandID
  </parameters>
  <retvals>
    string retval - the ids of actions with ActionCommandID, separated by a ,
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, actions, action</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniActionsID_ByActionCommandID", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniActionsID_ByActionCommandID", "filename_with_path", "file does not exist", -2) return -1 end
  if ultraschall.CheckActionCommandIDFormat(ActionCommandID)==false then ultraschall.AddErrorMessage("GetKBIniActionsID_ByActionCommandID", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return -1 end
  
  local idx_string=""
  local consolidate, section, AID, Description, ActionsToBeExecuted
  for i=1, ultraschall.CountKBIniActions(filename_with_path)-1 do
    consolidate, section, AID, Description, ActionsToBeExecuted=ultraschall.GetKBIniActions(filename_with_path,i)
    if AID:sub(1,1)=="\"" then AID=AID:sub(2,-1) end
    if AID:sub(-1,-1)=="\"" then AID=AID:sub(1,-2) end
    if ActionCommandID==AID then idx_string=idx_string..i.."," end
  end
  return idx_string:sub(1,-2)
end

--A=ultraschall.GetKBIniActionsID_ByActionCommandID("c:\\test.txt","_Ultraschall_ZoomToSelection")

function ultraschall.GetKBIniScripts_ByActionCommandID(filename_with_path, ActionCommandID)
-- returns the idx(s) of a script with a given ActionCommandID
-- return false, if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniScripts_ByActionCommandID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string retval = ultraschall.GetKBIniScripts_ByActionCommandID(filename_with_path, ActionCommandID)</functioncall>
  <description>
    Returns the indexnumber(s) of scripts by ActionCommandIDs within a reaper-kb.ini.
    Returns -1, if no such entry or file exists.
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    string ActionCommandID - the ActionCommandID
  </parameters>
  <retvals>
    string retval - the ids of scripts with ActionCommandID, separated by a ,
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, scripts, script</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniScripts_ByActionCommandID", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniScripts_ByActionCommandID", "filename_with_path", "file does not exist", -2) return -1 end
  if ultraschall.CheckActionCommandIDFormat(ActionCommandID)==false then ultraschall.AddErrorMessage("GetKBIniScripts_ByActionCommandID", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return -1 end
  
  local idx_string=""
  local consolidate, section, AID, Description, ScriptFile
  for i=1, ultraschall.CountKBIniScripts(filename_with_path)-1 do
    consolidate, section, AID, Description, ScriptFile=ultraschall.GetKBIniScripts(filename_with_path,i)
    if AID:sub(1,1)=="\"" then AID=AID:sub(2,-1) end
    if AID:sub(-1,-1)=="\"" then AID=AID:sub(1,-2) end
    if ActionCommandID==AID then idx_string=idx_string..i.."," end
  end
  return idx_string:sub(1,-2)
end

--A=ultraschall.GetKBIniScripts_ByActionCommandID("c:\\test.txt", "Haselnuss") --

function ultraschall.GetKBIniKeys_ByActionCommandID(filename_with_path, ActionCommandID)
-- returns the idx(s) of a key with a given ActionCommandID
-- return false, if not existing
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetKBIniKeys_ByActionCommandID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string retval = ultraschall.GetKBIniKeys_ByActionCommandID(filename_with_path, ActionCommandID)</functioncall>
  <description>
    Returns the indexnumber(s) of keys by ActionCommandIDs within a reaper-kb.ini.
    Returns -1, if no such entry or file exists.
  </description>
  <parameters>
    string filename_with_path - path and filename of the reaper-kb.ini
    string ActionCommandID - the ActionCommandID
  </parameters>
  <retvals>
    string retval - the ids of keys with ActionCommandID, separated by a ,
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, get, keys, key</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("GetKBIniKeys_ByActionCommandID", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("GetKBIniKeys_ByActionCommandID", "filename_with_path", "file does not exist", -2) return -1 end
  if ultraschall.CheckActionCommandIDFormat(ActionCommandID)==false then ultraschall.AddErrorMessage("GetKBIniKeys_ByActionCommandID", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return -1 end
  
  local idx_string=""
  local Keytype, KeyNote, AID, section
  for i=1, ultraschall.CountKBIniKeys(filename_with_path)-1 do
    Keytype, KeyNote, AID, section=ultraschall.GetKBIniKeys(filename_with_path,i)
    if AID:sub(1,1)=="\"" then AID=AID:sub(2,-1) end
    if AID:sub(-1,-1)=="\"" then AID=AID:sub(1,-2) end
    if ActionCommandID==AID then idx_string=idx_string..i.."," end
  end
  return idx_string:sub(1,-2)
end

--A=ultraschall.GetKBIniKeys_ByActionCommandID("c:\\test.txt","40626")

function ultraschall.ReadFileAsLines_Array(filename_with_path, firstlinenumber, lastlinenumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadFileAsLines_Array</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>array contents, boolean correctnumberoflines, integer number_of_lines = ultraschall.ReadFileAsLines_Array(string filename_with_path, integer firstlinenumber, integer lastlinenumber)</functioncall>
  <description>
    Return contents of filename_with_path, from firstlinenumber to lastlinenumber as an array. Counting of linenumbers starts with 1 for the first line.
    The returned array contains all requested lines, which each entry holding one returned line.
    
    Returns nil, if the linenumbers are invalid.
  </description>
  <retvals>
    array contents - the contents the lines of the file, that you requested as an array, in which each entry hold one line of the file
    boolean correctnumberoflines - true, if the number of lines are returned, as you requested; false if fewer lines are returned
    integer number_of_lines - the number of lines returned
  </retvals>
  <parameters>
    string filename_with_path - filename of the file to be read
    integer firstlinenumber - the first linenumber to be returned. First line in the file begins with 1!
    integer lastlinenumber - the last linenumber to be returned; -1, read all lines in the file
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, range, array</tags>
</US_DocBloc>
]]  
  if math.type(firstlinenumber)~="integer" then ultraschall.AddErrorMessage("ReadFileAsLines_Array","firstlinenumber", "Must be an integer!", -1) return nil end
  if math.type(lastlinenumber)~="integer" then ultraschall.AddErrorMessage("ReadFileAsLines_Array","lastlinenumber", "Must be an integer!", -2) return nil end
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("ReadFileAsLines_Array","filename_with_path", "Must be a string!", -3) return nil end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ReadFileAsLines_Array","filename_with_path", "File not found!", -4)return nil end
  
  local LineArray={}

  local b=0

  for line in io.lines(filename_with_path) do 
     b=b+1
     if b>=firstlinenumber and lastlinenumber==-1 then
        LineArray[b]=line
     elseif b>=firstlinenumber and b<=lastlinenumber then
        LineArray[b]=line
     end
     if b>lastlinenumber and lastlinenumber~=-1 then return LineArray, true, b-1 end
  end
  if b<lastlinenumber and lastlinenumber~=-1 then return LineArray, false, b end
  
  return LineArray, true, b
end

--A,B,C,D = ultraschall.ReadFileAsLines_Array("c:\\render-queue-test.txt", 1, "")


function ultraschall.SetKBIniActions(filename_with_path, consolidate, section, ActionCommandID, Description, ActionCommandIDs, replace)
-- adds/sets existing Actions
-- integer consolidate - 
-- integer section - 
-- string ActionCommandID - the ActionCommandID for this Action
-- string Description - the description as shown in the "Show Actions List"-window
-- string ActionCommandIDs - the Action-CommandIDs that shall be executed, when calling this action. Each ActioncommandID separated by a space.
-- boolean replace - true - replace an "old" Action with this new one, false - keep the "old" Action

--returns false if file does not exist, invalid parameters or the first "ActionCommandID"-parameter starts with an _

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetKBIniActions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer actionnumber = ultraschall.SetKBIniActions(string filename_with_path, integer consolidate, integer section, string ActionCommandID, string Description, string ActionCommandIDs, boolean replace)</functioncall>
  <description>
    Adds or sets(if it already exists) an "ACT"-action of a reaper-kb.ini.
    Returns true/false when adding or setting worked/didn't work, as well as the action-number within the reaper-kb.ini
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer consolidate - consolidation state of this action
    -1 consolidate undo points, 
    -2 show in Actions-Menu, 
    -3 consolidate undo points AND show in Actions Menu; 
    -maybe 4 and higher?
    
    integer section - section, in which this action is started
    -0 - Main
    -1 - action stays invisible but is kept, if Reaper rewrites the reaper-kb.ini. Menu-buttons with this action associated appear but don't work.
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
    
    string ActionCommandID - the ActionCommandID of this action
    string Description - a description for this action
    string ActionCommandIDs - the ActionCommandIDs for the actions, that are triggered by this action; unlike CommandID-numbers, every ActionCommandID must begin with _ ; will not be checked vor valid ones!
    boolean replace - true if an already existing entry shall be replaced, false if not
  </parameters>
  <retvals>
    boolean retval - true, if adding/setting worked, false if it didn't
    integer actionnumber - the entrynumber within the reaper-kb.ini of this action
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, add, set, replace, action, actions</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("SetKBIniActions", "filename_with_path", "must be a string", -1) return false end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("SetKBIniActions", "filename_with_path", "file does not exist", -2) return false end
  if type(ActionCommandID)~="string" then ultraschall.AddErrorMessage("SetKBIniActions", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return false end
  
  if math.type(consolidate)~="integer" then ultraschall.AddErrorMessage("SetKBIniActions", "consolidate", "must be an integer", -4) return false end 
  if math.type(section)~="integer" then ultraschall.AddErrorMessage("SetKBIniActions", "section", "must be an integer", -5) return false end 

  if type(Description)~="string" then ultraschall.AddErrorMessage("SetKBIniActions", "Description", "must be a string", -6) return false end 
  if type(ActionCommandIDs)~="string" then ultraschall.AddErrorMessage("SetKBIniActions", "ActionCommandIDs", "must be a string", -7) return false end 
  
  if type(replace)~="boolean" then ultraschall.AddErrorMessage("SetKBIniActions", "replace", "must be a boolean", -8) return false end 

  local contents, correctnumberoflines, number_of_lines = ultraschall.ReadFileAsLines_Array(filename_with_path, 1, -1) 
  local checkstring="ACT "..section.." \""..ActionCommandID.."\""
--  checkstring_len=checkstring:len()

  local found=0
  
  -- find the entrynumber of the action, if it's already existing
  for i=1, number_of_lines do
    local temp, temp2, temp3=contents[i]:match("(ACT) .- (.-) (.-) ")
    if temp~=nil then
      temp=temp.." "..temp2.." "..temp3
      if temp==checkstring then found=i break 
    end
    end    
  end
  
  -- if already existing and replace=true then replace it, otherwise return
  -- if it doesn't exist, add the entry before all other entries
  local newcontent=""
  if found~=0 and replace==true then
    contents[found]="ACT "..consolidate.." "..section.." \""..ActionCommandID.."\" \""..Description.."\" "..ActionCommandIDs
  elseif found~=0 and replace==false then ultraschall.AddErrorMessage("SetKBIniActions", "ActionCommandID", "ActionCommandID already exists; set replace=true to replace it", -9) return false
  else
    newcontent="ACT "..consolidate.." "..section.." \""..ActionCommandID.."\" \""..Description.."\" "..ActionCommandIDs.."\r\n"
  end

  -- Create string with all entries and write them to file
  for i=1, number_of_lines do
    newcontent=newcontent..contents[i].."\r\n"
  end
  ultraschall.WriteValueToFile(filename_with_path, newcontent)
  if found==0 then found=1 end
  
  return true, found
end
--ACT 0 0 "9859d0c7f8dd418bb56a41f242ea92c1"
--AA,BB=ultraschall.SetKBIniActions("c:\\test.txt",3,2,"ATest","Atest2: hullebull","_one _tw", true)
--AA,BB=ultraschall.SetKBIniActions("c:\\test.txt",1,2,"ATest","Description","_one", true)
--AA,BB=ultraschall.SetKBIniActions("c:\\test.txt",0,0,"A","ALTZSALABAMA","20 42 21 22", false)
--AA,BB=ultraschall.SetKBIniActions("c:\\test.txt",0,0,"AAA","ALTZSALABAMA","20 42 21 22", true)

function ultraschall.SetKBIniScripts(filename_with_path, terminate_state, section, ActionCommandID, Description, Scriptname, replace)
--adds/sets existing Scripts
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetKBIniScripts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer scriptnumber = ultraschall.SetKBIniScripts(string filename_with_path, integer terminate, integer section, string ActionCommandID, string Description, string Scriptname, boolean replace)</functioncall>
  <description>
    Adds or sets(if it already exists) an "SCR"-script of a reaper-kb.ini.
    Returns true/false when adding or setting worked/didn't work, as well as the script-number within the reaper-kb.ini
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer terminate_state - state of handling mulitple running scripts
    -4 - Dialogwindow appears(Terminate, New Instance, Abort), if another instance of a given script is started, that's already running
    -260 - always Terminate Instances, when an instance of the script is already running
    -516 - always start a New Instance of the script already running
    
    integer section - section, in which this script is started
    -0 - Main
    -1 - action stays invisible but is kept, if Reaper rewrites the reaper-kb.ini. Menu-buttons with this action associated appear but don't work.
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
    
    string ActionCommandID - the ActionCommandID of this action
    string Description - a description for this script
    string Scriptname - the name of the ReaScript, like .lua or .eel or .py
    boolean replace - true if an already existing entry shall be replaced, false if not
  </parameters>
  <retvals>
    boolean retval - true, if adding/setting worked, false if it didn't
    integer scriptnumber - the entrynumber within the reaper-kb.ini of this script
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, add, set, script, scripts, replace</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("SetKBIniScripts", "filename_with_path", "must be a string", -1) return false end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("SetKBIniScripts", "filename_with_path", "file does not exist", -2) return false end
  if type(ActionCommandID)~="string" then ultraschall.AddErrorMessage("SetKBIniScripts", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return false end
  
  if math.type(terminate_state)~="integer" then ultraschall.AddErrorMessage("SetKBIniScripts", "terminate_state", "must be an integer", -4) return false end 
  if math.type(section)~="integer" then ultraschall.AddErrorMessage("SetKBIniScripts", "section", "must be an integer", -5) return false end 

  if type(Description)~="string" then ultraschall.AddErrorMessage("SetKBIniScripts", "Description", "must be a string", -6) return false end 
  if type(Scriptname)~="string" then ultraschall.AddErrorMessage("SetKBIniScripts", "Scriptname", "must be a string", -7) return false end 
  
  if type(replace)~="boolean" then ultraschall.AddErrorMessage("SetKBIniScripts", "replace", "must be a boolean", -8) return false end 

  local contents, correctnumberoflines, number_of_lines = ultraschall.ReadFileAsLines_Array(filename_with_path, 1, -1) 
  local checkstring="SCR "..section.." "..ActionCommandID
--  checkstring_len=checkstring:len()

  local found=0
  
  -- find the entrynumber of the action, if it's already existing
  for i=1, number_of_lines do
    local temp, temp2, temp3=contents[i]:match("(SCR) .- (.-) (.-) ")
    if temp~=nil then
      temp=temp.." "..temp2.." "..temp3
      if temp==checkstring then found=i break 
    end
    end    
  end
  
  -- if already existing and replace=true then replace it, otherwise return
  -- if it doesn't exist, add the entry before all other entries
  local newcontent=""
  if found~=0 and replace==true then
    contents[found]="SCR "..terminate_state.." "..section.." "..ActionCommandID.." \""..Description.."\" "..Scriptname
  elseif found~=0 and replace==false then ultraschall.AddErrorMessage("SetKBIniScripts", "ActionCommandID", "ActionCommandID already exists; set replace=true to replace it", -9) return false
  else
    newcontent="SCR "..terminate_state.." "..section.." "..ActionCommandID.." \""..Description.."\" "..Scriptname.."\r\n"
  end

  -- Create string with all entries and write them to file
  for i=1, number_of_lines do
    newcontent=newcontent..contents[i].."\r\n"
  end
  ultraschall.WriteValueToFile(filename_with_path, newcontent)
  if found==0 then found=1 end
  
  return true, found
end

--AA,BB=ultraschall.SetKBIniScripts("c:\\test.txt", 42, 0, "Haselnussa", "musmusmusKusKus", "Hulasss.luaa", true)
--

function ultraschall.SetKBIniKeys(filename_with_path, KeyType, KeyNote, ActionCommandID, section, replace)
--adds/sets existing Keybinds
--returns false, if it doesn't work or you forgot the _ at the beginning of the ActionCommandID
--
-- string filename_with_path - filename to the kb.ini-file
-- integer KeyType - Keytype/Modifier/Midichannel
-- integer KeyNote - Key(in ASCII) or MidiNote
-- string ActionCommand - the _ActionCommandID, with which the key shall be bound. Must have a _ at the beginning!
-- integer section - section, in where this keybind shall work
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetKBIniKeys</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer keynumber = ultraschall.SetKBIniKeys(string filename_with_path, integer keytype_modifier_midichan, integer key_midinote, string ActionCommandID, integer section, boolean replace)</functioncall>
  <description>
    Adds or sets(if it already exists) a "KEY"-key of a reaper-kb.ini.
    Returns true/false when adding or setting worked/didn't work, as well as the keybinding-number within the reaper-kb.ini.
    Additional keybindings cannot share the same keytype_modifier_midichan, key_midinote and section at the same time, as every such keybind must be unique.
    
    For a detailed description in how KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    
    Does not support OSC-keybindings!
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer keytype_modifier_midichan - Type of Keytype, modifier or midichannel
                                      - For a detailed description in how keytype/modifier in KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    integer key_midinote - the key(like ASCII-Codes) or midinote. 
                                      - For a detailed description in how key/midinotes in KEY-entries work, refer to <a href="Reaper-Filetype-Descriptions.html#Reaper-kb.ini">Reaper-Filetype-Descriptions.html#Reaper-kb.ini</a>.
    string ActionCommandID - the ActionCommandID associated with this shortcut.
    integer section - the section, in which this shortcut is used
    -0 - Main
    -100 - Main (alt recording)
    -32060 - MIDI Editor
    -32061 - MIDI Event List Editor
    -32062 - MIDI Inline Editor
    -32063 - Media Explorer
    
    boolean replace - true if an already existing entry shall be replaced, false if not
  </parameters>
  <retvals>
    boolean retval - true, if adding/setting worked, false if it didn't
    integer scriptnumber - the entrynumber within the reaper-kb.ini of this script
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, add, set, key, keys, replace</tags>
</US_DocBloc>
]]  

-- filename_with_path, KeyType, KeyNote, ActionCommandID, section, replace

  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("SetKBIniKeys", "filename_with_path", "must be a string", -1) return false end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("SetKBIniKeys", "filename_with_path", "file does not exist", -2) return false end
  if ultraschall.CheckActionCommandIDFormat(ActionCommandID)==false then ultraschall.AddErrorMessage("SetKBIniKeys", "ActionCommandID", "must be a valid ActionCommandID or CommandID", -3) return false end
  
  if math.type(KeyType)~="integer" then ultraschall.AddErrorMessage("SetKBIniKeys", "KeyType", "must be an integer", -4) return false end 
  if math.type(KeyNote)~="integer" then ultraschall.AddErrorMessage("SetKBIniKeys", "KeyNote", "must be an integer", -5) return false end 

  if math.type(section)~="integer" then ultraschall.AddErrorMessage("SetKBIniKeys", "section", "must be a string", -6) return false end 
  
  if type(replace)~="boolean" then ultraschall.AddErrorMessage("SetKBIniKeys", "replace", "must be a boolean", -7) return false end 

  local contents, correctnumberoflines, number_of_lines = ultraschall.ReadFileAsLines_Array(filename_with_path, 1, -1) 
  local checkstring="KEY "..KeyType.." "..KeyNote.." "..section

  local found=0
  
  -- find the entrynumber of the action, if it's already existing
  for i=1, number_of_lines do
    local temp, temp2, temp3, temp4 =contents[i]:match("(KEY) (.-) (.-) .- (.*)")
    if temp~=nil then
      temp=temp.." "..temp2.." "..temp3.." "..temp4
      if temp==checkstring then found=i break 
    end
    end    
  end
  
  -- if already existing and replace=true then replace it, otherwise return
  -- if it doesn't exist, add the entry before all other entries
  local newcontent=""
  local tempcontent=""
  if found~=0 and replace==true then
    contents[found]="KEY "..KeyType.." "..KeyNote.." "..ActionCommandID.." "..section
  elseif found~=0 and replace==false then ultraschall.AddErrorMessage("SetKBIniKeys", "KeyType, KeyNote and section", "entry already exists; set replace=true to replace it", -8) return false
  else
    tempcontent="KEY "..KeyType.." "..KeyNote.." "..ActionCommandID.." "..section.."\r\n"
  end

  -- Create string with all entries and write them to file
  for i=1, number_of_lines do
    newcontent=newcontent..contents[i].."\r\n"
  end
  ultraschall.WriteValueToFile(filename_with_path, newcontent..tempcontent)
  if found==0 then found=1 end
  
  return true, found
end

--AAA,BB=ultraschall.SetKBIniKeys("c:\\test.txt",1,56,"_Ultraschall_Select_Track17",1, true)
--KEY 1 56  0

--AAA,BB=ultraschall.SetKBIniKeys("c:\\test.txt",110,110,"_Hulababula",101, true)

function ultraschall.DeleteKBIniActions(filename_with_path, idx)
--deletes the idx'th ACT-Action in the kb.ini-file
--returns false, if something went wrong, true in case of success
--string filename_with_path - the kb.ini-file with path
--integer idx - the ACT-Action entry-number, you'd like to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteKBIniActions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteKBIniActions(string filename_with_path, integer idx)</functioncall>
  <description>
    Deletes an "ACT"-action of a reaper-kb.ini.
    Returns true/false when deleting worked/didn't work.
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer idx - indexnumber of the action within the reaper-kb.ini
  </parameters>
  <retvals>
    boolean retval - true, if deleting worked, false if it didn't
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, delete, action, actions</tags>
</US_DocBloc>
]]  
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("DeleteKBIniActions", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("DeleteKBIniActions", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteKBIniActions", "idx", "must be an integer", -3) return -1 end
  
  local count=0
  local linecount=0
  local finallinecount=-1
  if reaper.file_exists(filename_with_path)==false then return false end
  for line in io.lines(filename_with_path) do 
    linecount=linecount+1
    if line:sub(1,3)=="ACT" then 
      count=count+1
      if count==idx then finallinecount=linecount end
    end
  end
  if finallinecount>-1 then 
    local FirstPart=ultraschall.ReadLinerangeFromFile(filename_with_path, 1, finallinecount-1)
    local LastPart=ultraschall.ReadLinerangeFromFile(filename_with_path, finallinecount+1,  ultraschall.CountLinesInFile(filename_with_path))
    ultraschall.WriteValueToFile(filename_with_path,FirstPart..LastPart)
    return true
  else 
    return false
  end
end

--A=ultraschall.DeleteKBIniActions("c:\\test.txt",1)

function ultraschall.DeleteKBIniScripts(filename_with_path, idx)
--deletes the idx'th SCR-Script in the kb.ini-file
--returns false, if something went wrong, true in case of success
--string filename_with_path - the kb.ini-file with path
--integer idx - the SCR-Script entry-number, you'd like to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteKBIniScripts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteKBIniScripts(string filename_with_path, integer idx)</functioncall>
  <description>
    Deletes an "SCR"-script of a reaper-kb.ini.
    Returns true/false when deleting worked/didn't work.
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer idx - indexnumber of the script within the reaper-kb.ini
  </parameters>
  <retvals>
    boolean retval - true, if deleting worked, false if it didn't
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, delete, script, scripts</tags>
</US_DocBloc>
]]
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("DeleteKBIniScripts", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("DeleteKBIniScripts", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteKBIniScripts", "idx", "must be an integer", -3) return -1 end
  
  local count=0
  local linecount=0
  local finallinecount=-1
  if reaper.file_exists(filename_with_path)==false then return false end
  for line in io.lines(filename_with_path) do 
  linecount=linecount+1
    if line:sub(1,3)=="SCR" then 
      count=count+1
      if count==idx then finallinecount=linecount end
    end
  end
  if finallinecount>-1 then 
    local FirstPart=ultraschall.ReadLinerangeFromFile(filename_with_path, 1, finallinecount-1)
    local LastPart=ultraschall.ReadLinerangeFromFile(filename_with_path, finallinecount+1,  ultraschall.CountLinesInFile(filename_with_path))
    ultraschall.WriteValueToFile(filename_with_path,FirstPart..LastPart)
    return true
  else 
    return false
  end
end

--A=ultraschall.DeleteKBIniScripts("c:\\test.txt",1)

function ultraschall.DeleteKBIniKeys(filename_with_path, idx)
--deletes the idx'th KEY-bind in the kb.ini-file
--returns false, if something went wrong, true in case of success
--string filename_with_path - the kb.ini-file with path
--integer idx - the KEY-bind entry-number, you'd like to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteKBIniKeys</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteKBIniKeys(string filename_with_path, integer idx)</functioncall>
  <description>
    Deletes a "KEY"-keybinding of a reaper-kb.ini.
    Returns true/false when deleting worked/didn't work.
    
    Needs a restart of Reaper for this change to take effect!
  </description>
  <parameters>
    string filename_with_path - filename with path for the reaper-kb.ini
    integer idx - indexnumber of the keybinding within the reaper-kb.ini
  </parameters>
  <retvals>
    boolean retval - true, if deleting worked, false if it didn't
  </retvals>
  <chapter_context>
    Configuration-Files Management
    Reaper-kb.ini
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationmanagement, reaper-kb.ini, kb.ini, keybindings, delete, key, keys, keybind</tags>
</US_DocBloc>
]]
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("DeleteKBIniKeys", "filename_with_path", "must be a string", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("DeleteKBIniKeys", "filename_with_path", "file does not exist", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteKBIniKeys", "idx", "must be an integer", -3) return -1 end
  
  local count=0
  local linecount=0
  local finallinecount=-1
  if reaper.file_exists(filename_with_path)==false then return false end
  for line in io.lines(filename_with_path) do 
  linecount=linecount+1
    if line:sub(1,3)=="KEY" then 
    count=count+1
      if count==idx then finallinecount=linecount end
    end
  end
  if finallinecount>-1 then 
    local FirstPart=ultraschall.ReadLinerangeFromFile(filename_with_path, 1, finallinecount-1)
    local LastPart=ultraschall.ReadLinerangeFromFile(filename_with_path, finallinecount+1,  ultraschall.CountLinesInFile(filename_with_path))
    ultraschall.WriteValueToFile(filename_with_path,FirstPart..LastPart)
    return true
  else 
    return false
  end
end

--A=ultraschall.DeleteKBIniKeys("c:\\test.txt",1)



---------------------------------------
---- Reaper RPP-Project-management ----
---------------------------------------


function ultraschall.IsValidProjectStateChunk(ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidProjectStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidProjectStateChunk(string ProjectStateChunk)</functioncall>
  <description>
    Checks, whether ProjectStateChunk is a valid ProjectStateChunk
  </description>
  <parameters>
    string ProjectStateChunk - the string to check, if it's a valid ProjectStateChunk
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid ProjectStateChunk; false, if not
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, projectstatechunk, statechunk, check, valid</tags>
</US_DocBloc>
]]  
  if type(ProjectStateChunk)=="string" and ProjectStateChunk:match("^<REAPER_PROJECT.*>")~=nil then return true else return false end
end



--- Get ---
function ultraschall.GetProject_ReaperVersion(projectfilename_with_path, ProjectStateChunk)
-- return Reaper-Version and TimeStamp
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_ReaperVersion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string reaperversion, string timestamp = ultraschall.GetProject_ReaperVersion(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the reaperversion and the timestamp from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry "&lt;REAPER_PROJECT"
    
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string reaperversion - the version of Reaper, with which this project had been saved
    string timestamp - a timestamp for this project
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, reaperversion, timestamp, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_ReaperVersion","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ReaperVersion","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_ReaperVersion","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ReaperVersion", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("(REAPER_PROJECT.-)\n").." "
  return ProjectStateChunk:match("REAPER_PROJECT%s.-%s\"(.-)\" (.-)%s")
end

--A,AA=ultraschall.GetProject_ReaperVersion("c:\\tt.rpp","<REAPER_PROJECT 0.1 \"5.77/x64\" 1529100928\n>")


function ultraschall.GetProject_RenderCFG(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string render_cfg = ultraschall.GetProject_RenderCFG(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-cfg-string, that contains all render-settings of a project from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry &lt;RENDER_CFG
    
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string render_cfg - the renderstring, which contains all render-settings for a project/projectstatechunk
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, renderstring, rendercfg</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderCFG","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderCFG","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderCFG","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  local retval=ProjectStateChunk:match("<RENDER_CFG.-\n%s*(.-)\n")
  if retval==">" then ultraschall.AddErrorMessage("GetProject_RenderCFG", "projectfilename_with_path", "No Render-CFG-code available!", -5) return nil end
  return retval
end

--A,AA=ultraschall.GetProject_RenderCFG("c:\\rendercode-project.RPP","")
--A,AA=ultraschall.GetProject_RenderCFG("c:\\ALLA.RPP","")

function ultraschall.GetProject_RippleState(projectfilename_with_path, ProjectStateChunk)
-- Set RippleState in a projectfilename_with_path
--  0 - no Ripple, 1 - Ripple One Track, 2 - Ripple All
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RippleState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer ripplestate = ultraschall.GetProject_RippleState(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the ripple-state from an RPP-Projectfile or a ProjectStateChunk.

    It's the entry RIPPLE

    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer ripplestate - 0, no Ripple; 1, Ripple One Track; 2, Ripple All
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, ripple, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RippleState","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RippleState","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RippleState","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RippleState", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("REAPER_PROJECT.-(RIPPLE%s.-)%c.-<RECORD_CFG").." "
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_RippleState("c:\\tt.rpp")
--A=ultraschall.GetProject_RippleState(nil,"<REAPER_PROJECT 0.1 \"5.77/x64\" 1529100928\n>")
--reaper.ShowConsoleMsg(A)

function ultraschall.GetProject_GroupOverride(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_GroupOverride</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer group_override1, integer group_override2, integer group_override3 = ultraschall.GetProject_GroupOverride(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the group-override-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry GROUPOVERRIDE
    
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer group_override1 - the group-override state
    integer track_group_enabled - the track_group_enabled-setting, as set in the context-menu of the Master-Track; 1, checked; 0, unchecked
    integer group_override3 - the group-override state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, group, override, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_GroupOverride","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GroupOverride","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_GroupOverride","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GroupOverride", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(GROUPOVERRIDE.-)%c.-<RECORD_CFG").." "

  return tonumber(ProjectStateChunk:match("%s(.-)%s.-%s.-%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s.-%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA=ultraschall.GetProject_GroupOverride("c:\\tt.rpp")
--A,AA,AAA=ultraschall.GetProject_GroupOverride(nil, ultraschall.GetStringFromClipboard_SWS())

function ultraschall.GetProject_AutoCrossFade(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_AutoCrossFade</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer autocrossfade_state = ultraschall.GetProject_AutoCrossFade(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the autocrossfade-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry AUTOXFADE
    
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    string ProjectStateChunk - a ProjectStateChunk to use instead if a filename
  </parameters>
  <retvals>
    integer autocrossfade_state - the autocrossfade-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, crossfade, state, auto, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_AutoCrossFade","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AutoCrossFade","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_AutoCrossFade","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AutoCrossFade", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(AUTOXFADE.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_AutoCrossFade("c:\\tt.rpp")
--A,AA,AAA=ultraschall.GetProject_AutoCrossFade(nil, ultraschall.GetStringFromClipboard_SWS())
--reaper.ShowConsoleMsg(A)

function ultraschall.GetProject_EnvAttach(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_EnvAttach</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer env_attach = ultraschall.GetProject_EnvAttach(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the EnvAttach-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry ENVATTACH
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path of the rpp-project-file; nil, use parameter ProjectStateChunk instead
    string ProjectStateChunk - a projectstatechunk to read the value from; only used, projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer env_attach - the env-attach state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, envattach</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_EnvAttach","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_EnvAttach","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_EnvAttach","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_EnvAttach", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(ENVATTACH%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--L=ultraschall.ReadFullFile("c:\\tt.rpp")
--M=ultraschall.IsValidProjectStateChunk(L)
--reaper.MB(L,"",0)
--A=ultraschall.GetProject_EnvAttach(nil, L)

function ultraschall.GetProject_MixerUIFlags(projectfilename_with_path, ProjectStateChunk)
--state1 - 0 - Show tracks in folders, Auto arrange tracks in mixer
--         1 - Show normal top level tracks
--         2 - Show Folders
--         4 - Group folders to left
--         8 - Show tracks that have receives
--         16 - Group tracks that have receives to left
--         32 - don't show tracks that are in folder
--         64 - No Autoarrange tracks in mixer
--         128 - ?
--         256 - ?

--state2 - 0 - Master track in mixer
--         1 - Don't show multiple rows of tracks, when size permits
--         2 - Show maximum rows even when tracks would fit in less rows
--         4 - Master Show on right side of mixer
--         8 - ?
--         16 - Show FX inserts when size permits
--         32 - Show sends when size permits
--         64 - Show tracks in mixer
--         128 - Show FX parameters, when size permits
--         256 - Don't show Master track in mixer

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MixerUIFlags</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer state1, integer state2 = ultraschall.GetProject_MixerUIFlags(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the MixerUI-state-flags from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry MIXERUIFLAGS
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer state1 - folders, receives, etc 
    -0 - Show tracks in folders, Auto arrange tracks in mixer
    -1 - Show normal top level tracks
    -2 - Show Folders
    -4 - Group folders to left
    -8 - Show tracks that have receives
    -16 - Group tracks that have receives to left
    -32 - don't show tracks that are in folder
    -64 - No Autoarrange tracks in mixer
    -128 - ?
    -256 - ?
    
    integer state2 - master-track, FX, Mixer
    -0 - Master track in mixer
    -1 - Don't show multiple rows of tracks, when size permits
    -2 - Show maximum rows even when tracks would fit in less rows
    -4 - Master Show on right side of mixer
    -8 - ?
    -16 - Show FX inserts when size permits
    -32 - Show sends when size permits
    -64 - Show tracks in mixer
    -128 - Show FX parameters, when size permits
    -256 - Don't show Master track in mixer
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, mixer, ui, flags</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MixerUIFlags","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MixerUIFlags","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MixerUIFlags","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MixerUIFlags", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(MIXERUIFLAGS%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s"))
end

--A,AA=ultraschall.GetProject_MixerUIFlags("c:\\tt.rpp")

function ultraschall.GetProject_PeakGain(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_PeakGain</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number peakgain_state = ultraschall.GetProject_PeakGain(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the GetProject_PeakGain-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry PEAKGAIN
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path of the rpp-project-file
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number peakgain_state - peakgain-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, mixer, peakgain, peak, gain</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_PeakGain","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PeakGain","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_PeakGain","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PeakGain", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(PEAKGAIN%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_PeakGain("c:\\tt.rpp")



function ultraschall.GetProject_Feedback(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Feedback</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer feedback_state = ultraschall.GetProject_Feedback(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the GetProject_Feedback-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry FEEDBACK
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer feedback_state - feedback-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, mixer, feedback</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Feedback","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Feedback","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Feedback","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Feedback", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(FEEDBACK%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_Feedback("c:\\tt.rpp")

function ultraschall.GetProject_PanLaw(projectfilename_with_path, ProjectStateChunk)
--returns
-- number state - as set in the project-settings->Advanced->Pan law/mode->Pan:law(db)
--                0.5(-6.02 db) to 1(default +0.0 db)

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_PanLaw</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number panlaw_state = ultraschall.GetProject_PanLaw(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the GetProject_PanLaw-state from an RPP-Projectfile or a ProjectStateChunk, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db).
    
    It's the entry PANLAW
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number panlaw_state - state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, mixer, panlaw, pan</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_PanLaw","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PanLaw","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_PanLaw","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PanLaw", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(PANLAW%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_PanLaw("c:\\tt.rpp")

function ultraschall.GetProject_ProjOffsets(projectfilename_with_path, ProjectStateChunk)
--returns Projectoffset (ProjectSettings->ProjectSettings->Project Start Time/Measure)
-- Project Start Time - in seconds
-- Project Start Measure - starting with 0, unlike the Settingswindow, where the 0 becomes 1 as measure
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_ProjOffsets</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>number start_time, integer start_measure, integer base_ruler_marking_off_this_measure = ultraschall.GetProject_ProjOffsets(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the Project Offset-state from an RPP-Projectfile or a ProjectStateChunk, start time as well as start measure.
    as set in ProjectSettings->ProjectSettings->Project Start Time/Measure and the checkbox Base Ruler Marking Off This Measure-checkbox
    
    It's the entry PROJOFFS
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number start_time - the project-start-time in seconds
    integer start_measure - starting with 0, unlike the Settingswindow, where the 0 becomes 1 as measure
    integer base_ruler_marking_off_this_measure - 0, checkbox unchecked; 1, checkbox checked
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, project, offset, start, starttime</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_ProjOffsets","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ProjOffsets","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_ProjOffsets","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ProjOffsets", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the values and returns them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(PROJOFFS%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")), 
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

--BB,B=reaper.EnumProjects(-1,"")
--A,AA,AAA=ultraschall.GetProject_ProjOffsets(B)

function ultraschall.GetProject_MaxProjectLength(projectfilename_with_path, ProjectStateChunk)
-- returns ProjectSettings->Advanced->
-- checkbox "Limit project length, stop playback/recording at:" - 0 off, 1 on
-- Projectlengthlimit - in seconds

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MaxProjectLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer limit_project_length, number projectlength_limit = ultraschall.GetProject_MaxProjectLength(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the maximum-project-length from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Advanced->
    as set in ProjectSettings->ProjectSettings->Project Start Time/Measure.
    
    It's the entry MAXPROJLEN
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer limit_project_length - checkbox "Limit project length, stop playback/recording at:" - 0 off, 1 on
    number projectlength_limit - projectlength-limit in seconds
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, project, end, length, limit</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MaxProjectLength","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MaxProjectLength","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MaxProjectLength","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MaxProjectLength", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the values and returns them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(MAXPROJLEN%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s"))
end

--A,AA=ultraschall.GetProject_MaxProjectLength("c:\\tt.rpp")

function ultraschall.GetProject_Grid(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Grid</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer gridstate1, integer gridstate2, number gridstate3, integer gridstate4, number gridstate5, integer gridstate6, integer gridstate7, number gridstate8 = ultraschall.GetProject_Grid(string projectfilename_with_path)</functioncall>
  <description>
    Returns the grid-state from an RPP-Projectfile or a ProjectStateChunk.

    It's the entry GRID

    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path of the rpp-project-file
  </parameters>
  <retvals>
    integer gridstate1 - gridstate1
    integer gridstate2 - gridstate2
    number gridstate3 - gridstate3
    integer gridstate4 - gridstate4
    number gridstate5 - gridstate5
    integer gridstate6 - gridstate6
    integer gridstate7 - gridstate7
    number gridstate8 - gridstate8
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, grid</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Grid","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Grid","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Grid","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Grid", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the values and returns them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(GRID%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA=ultraschall.GetProject_Grid("c:\\tt.rpp")

function ultraschall.GetProject_Timemode(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Timemode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer ruler_timemode, integer timemode2, integer showntime, integer timemode4, integer timemode5 = ultraschall.GetProject_Timemode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the timemode-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry TIMEMODE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer ruler_timemode - ruler-timemode-state
    - -1, Use ruler time unit
    -  0, Minutes:Seconds
    -  1, Measures.Beats / Minutes:Seconds
    -  2, Measures.Beats
    -  3, Seconds
    -  4, Samples
    -  5, Hours:Minutes:Seconds:Frames
    -  8, Absolute Frames
    integer timemode2 - timemode-state
    integer showntime - Transport shown time
    -      -1 - use ruler time unit
    -       0 - minutes:seconds
    -       1 - measures:beats/minutes:seconds
    -       2 - measures:beats
    -       3 - seconds
    -       4 - samples
    -       5 - hours:minutes:seconds:frames
    -       8 - absolute frames
    integer timemode4 - timemode-state
    integer timemode5 - timemode-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, timemode</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Timemode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Timemode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Timemode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Timemode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the values and returns them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(TIMEMODE%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetProject_Timemode("c:\\tt.rpp")

function ultraschall.GetProject_VideoConfig(projectfilename_with_path, ProjectStateChunk)
-- returns:
-- integer preferredVidSizeX - preferred video size, x pixels
-- integer preferredVidSizeY - preferred video size, y pixels
-- integer settingsBitfield3 - settings
--              0 - turned on/selected: use high quality filtering, 
--                      preserve aspect ratio(letterbox) when resizing, Items in higher numbered tracks replace lower,
--                      as well as Video colorspace set to Auto
--              1 - Video colorspace: I420/YV12
--              2 - Video colorspace: YUV2
--              3 - RGB
--              256 - Items in lower numbered tracks replace higher
--              512 - Always resize video sources to preferred video size
--              1024 - Always resize output to preferred video size
--              2048 - turn off "Use high quality filtering when resizing"
--              4096 - turn off "preserve aspect ratio (letterbox) when resizing"
-- returns nil, in case of error

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_VideoConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer preferredVidSizeX, integer preferredVidSizeY, integer settingsflags = ultraschall.GetProject_VideoConfig(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the videoconfig-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry VIDEO_CONFIG
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer preferredVidSizeX - preferred video size, x pixels
    integer preferredVidSizeY - preferred video size, y pixels
    integer settingsflags - settings
    -             0 - turned on/selected: use high quality filtering, preserve aspect ratio(letterbox) when resizing,
    -                                     Video colorspace set to Auto,
    -                                     Items in higher numbered tracks replace lower, as well as Video colorspace set to Auto
    -             1 - Video colorspace: I420/YV12
    -             2 - Video colorspace: YUV2
    -             3 - RGB
    -             256 - Items in lower numbered tracks replace higher
    -             512 - Always resize video sources to preferred video size
    -             1024 - Always resize output to preferred video size
    -             2048 - turn off "Use high quality filtering when resizing"
    -             4096 - turn off "preserve aspect ratio (letterbox) when resizing"
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, video, videoconfig</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_VideoConfig","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_VideoConfig","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_VideoConfig","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_VideoConfig", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the values and returns them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(VIDEO_CONFIG%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA=ultraschall.GetProject_VideoConfig("c:\\tt.rpp")

function ultraschall.GetProject_PanMode(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_PanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer panmode_state = ultraschall.GetProject_PanMode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the panmode-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry PANMODE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer panmode_state - panmode-state
    -0 reaper 3.x balance (deprecated)
    -3 Stereo balance / mono pan (default)
    -5 Stereo pan
    -6 Dual Pan
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, panmode</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_PanMode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PanMode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_PanMode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_PanMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(PANMODE%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_PanMode("c:\\tt.rpp")

function ultraschall.GetProject_CursorPos(projectfilename_with_path, ProjectStateChunk)
-- returns cursorposition in seconds
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_CursorPos</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number cursorpos = ultraschall.GetProject_CursorPos(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the cursorposition-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry CURSOR
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number cursorpos - editcursorposition in seconds
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, cursor, position, cursorposition, editcursor, edit</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_CursorPos","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CursorPos","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_CursorPos","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CursorPos", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(CURSOR%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_CursorPos("c:\\tt.rpp")

function ultraschall.GetProject_HorizontalZoom(projectfilename_with_path, ProjectStateChunk)
-- returns:
-- number HorizontalZoom - 0.007 to 1000000, zoomfactor
-- integer horizontalscrollbarpos - 0 - 4294967296
-- integer scrollbarfactor - 0 to 500837, counts up, when maximum horizontalscrollbarpos overflows
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_HorizontalZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number hzoom, integer hzoomscrollpos, integer scrollbarfactor = ultraschall.GetProject_HorizontalZoom(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the horizontal-zoom-state from an RPP-Projectfile or a ProjectStateChunk.
    Keep in mind, that hzoomscrollpos and scrollbarfactor depend on each other. hzoomscrollpos is a smaller positioning-unit, while scrollbarfactor is the bigger positioning-unit.
    Experiment with it to get an idea.
    
    It's the entry ZOOM
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number hzoom - HorizontalZoomfactor, 0.007 to 1000000
    integer hzoomscrollpos - horizontalscrollbarposition - 0 - 4294967296
    integer scrollbarfactor - 0 to 500837, counts up, when maximum hzoomscrollpos overflows
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, zoom, horizontal, scrollbar, factor</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_HorizontalZoom","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_HorizontalZoom","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_HorizontalZoom","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_HorizontalZoom", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(ZOOM%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

--A1,AA,AAA=ultraschall.GetProject_HorizontalZoom("c:\\tt.rpp")

function ultraschall.GetProject_VerticalZoom(projectfilename_with_path, ProjectStateChunk)
-- returns vertical zoomfactor(0-40)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_VerticalZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer vzoom = ultraschall.GetProject_VerticalZoom(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the verticalzoom from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry VZOOMEX
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer vzoom - vertical zoomfactor(0-40)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, zoom, vertical, scrollbar, factor</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_VerticalZoom","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_VerticalZoom","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_VerticalZoom","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_VerticalZoom", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(VZOOMEX%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_VerticalZoom("c:\\tt.rpp")

function ultraschall.GetProject_UseRecConfig(projectfilename_with_path, ProjectStateChunk)
-- ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc
-- 0 - Automatic .wav (recommended)
-- 1 - Custom (use ultraschall.GetProject_ApplyFXCFG to get recording_cfg_string)
-- 2 - Recording Format

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_UseRecConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer rec_cfg = ultraschall.GetProject_UseRecConfig(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the rec-cfg-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry USE_REC_CFG
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer rec_cfg - recording-cfg-state
    - 0 - Automatic .wav (recommended)
    - 1 - Custom (use ultraschall.GetProject_ApplyFXCFG to get recording_cfg_string)
    - 2 - Recording Format
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, rec, config</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_UseRecConfig","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_UseRecConfig","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_UseRecConfig","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_UseRecConfig", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(USE_REC_CFG%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))         
end

--A=ultraschall.GetProject_UseRecConfig("c:\\tt.rpp")

function ultraschall.GetProject_RecMode(projectfilename_with_path, ProjectStateChunk)
--returns Recording Mode
-- 0 - Autopunch/Selected Items
-- 1 - normal
-- 2 - Time Selection/Auto Punch

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RecMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer rec_mode = ultraschall.GetProject_RecMode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the rec-mode-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry RECMODE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer rec_mode - recording-mode-state
    - 0 - Autopunch/Selected Items
    - 1 - normal
    - 2 - Time Selection/Auto Punch
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, rec, mode</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RecMode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecMode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RecMode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(RECMODE%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_RecMode("c:\\tt.rpp")

function ultraschall.GetProject_SMPTESync(projectfilename_with_path, ProjectStateChunk)
-- ProjectSettings->Advanced->External Timecode Synchronization
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_SMPTESync</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer smptesync_state1, number smptesync_fps, integer smptesync_resyncdrift, integer smptesync_skipdropframes, integer smptesync_syncseek, integer smptesync_freewheel, integer smptesync_userinput, number smptesync_offsettimecode, integer smptesync_stop_rec_drift, integer smptesync_state10, integer smptesync_stop_rec_lacktime  = ultraschall.GetProject_SMPTESync(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the smpte-sync-state from an RPP-Projectfile or a ProjectStateChunk.

    It's the entry SMPTESYNC

    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer smptesync_state1 - flag 
    -0 - external timecode synchronization disabled
    -1 - external timecode synchronization enabled
    -4 - Start playback on valid timecode when stopped
    -8 - turned off: display flashing notification window when waiting for sync for recording
    -16 - playback off
    -32 - recording off
    -256 - MTC - 24/30fps MTC is 23.976/29.97ND works only with smptesync_userinput set to 4159
    -512 - MTC - 24/30fps MTC is 24/30ND
    
    number smptesync_fps - framerate in fps
    integer smptesync_resyncdrift - "Re-synchronize if drift exceeds" in ms (0 = never)
    integer smptesync_skipdropframes - "skip/drop frames if drift exceeds" in ms(0 - never)
    integer smptesync_syncseek - "Synchronize by seeking ahead" in ms (default = 1000)
    integer smptesync_freewheel - "Freewheel on missing time code for up to" in ms(0 = forever)
    integer smptesync_userinput - User Input-flag
    -0 - LTC: Input 1
    -1 - LTC: Input 2
    -4159 - MTC - All inputs - 24/30 fps MTC 23.976ND/29.97ND if project is ND
    -4223 - SPP: All Inputs
    -8192 - ASIO Positioning Protocol
    
    number smptesync_offsettimecode - Offset incoming timecode by in seconds
    integer smptesync_stop_rec_drift - "Stop recording if drift exceeds" in ms(0 = never)
    integer smptesync_state10 - smptesync-state
    integer smptesync_stop_rec_lacktime - "stop recording on lack of timecode after" in ms(0 = never)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, smpte, sync</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_SMPTESync","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_SMPTESync","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_SMPTESync","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_SMPTESync", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end

  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(SMPTESYNC.-)%c").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s(.-)%s")),
         
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s")),
         
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA,AL,AM=ultraschall.GetProject_SMPTESync("c:\\tt.rpp")

function ultraschall.GetProject_Loop(projectfilename_with_path, ProjectStateChunk)
-- Loopbutton-state
-- 0 - off
-- 1 - on

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Loop</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer loopbutton_state = ultraschall.GetProject_Loop(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the loop-button-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry LOOP
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer loop_mode - loopbutton-state, 0 - off, 1 - on
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, loop, button</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Loop","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Loop","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Loop","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Loop", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- gets the value and returns it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(LOOP%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_Loop("c:\\tt.rpp")

function ultraschall.GetProject_LoopGran(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_LoopGran</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer loopgran_state1, number loopgran_state2 = ultraschall.GetProject_LoopGran(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the loop_gran-state from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry LOOPGRAN
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer loopgran_state1 - loopgran_state1
    number loopgran_state2 - loopgran_state2
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, loop, gran</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_LoopGran","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_LoopGran","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_LoopGran","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_LoopGran", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(LOOPGRAN%s.-)%c.-<RECORD_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s"))
end

--A,AA=ultraschall.GetProject_LoopGran("c:\\tt.rpp")

function ultraschall.GetProject_RecPath(projectfilename_with_path, ProjectStateChunk)
--returns first and secondary recording paths
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RecPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string prim_recpath, string sec_recpath = ultraschall.GetProject_RecPath(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the primary and secondary recording-path from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry RECORD_PATH
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string prim_recpath - the primary recording path
    string sec_recpath - the secondary recording path
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, path, recording path, primary, secondary</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RecPath","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecPath","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RecPath","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecPath", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(RECORD_PATH%s\".-\")%c.-<RECORD_CFG").." "
  
  return ProjectStateChunk:match("%s\"(.-)\"%s\"(.-)\"")
end

--A,AA=ultraschall.GetProject_RecPath("c:\\tt.rpp")


function ultraschall.GetProject_RecordCFG(projectfilename_with_path, ProjectStateChunk)
--To Do: Research
-- ProjectSettings->Media->Recording
-- recording-cfg-string

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RecordCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string recording_cfg_string = ultraschall.GetProject_RecordCFG(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the recording-configuration as encoded BASE64-string from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Recording.
    
    It's the entry &lt;RECORD_CFG
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    recording_cfg_string - the record-configuration as encoded string
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, configuration</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RecordCFG","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecordCFG","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RecordCFG","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RecordCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  return ProjectStateChunk:match("<REAPER_PROJECT.-RECORD_CFG%c%s*(.-)%c.-RENDER_FILE")
end

--A=ultraschall.GetProject_RecordCFG("c:\\tt.rpp")

function ultraschall.GetProject_ApplyFXCFG(projectfilename_with_path, ProjectStateChunk)
--To Do: Research
-- ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc
-- recording_cfg-string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_ApplyFXCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string applyfx_cfg_string = ultraschall.GetProject_ApplyFXCFG(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the audioformat-configuration, for fx-appliance-operation, as an encoded BASE64-string from an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc
    
    It's the entry &lt;APPLY_CFG
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string applyfx_cfg_string - the file-format-configuration for fx-appliance as encoded string
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, fx, configuration</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_ApplyFXCFG","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ApplyFXCFG","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_ApplyFXCFG","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ApplyFXCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  
  return ProjectStateChunk:match("<REAPER_PROJECT.-APPLYFX_CFG%c%s*(.-)%c.-RENDER_FILE")
end

--A=ultraschall.GetProject_ApplyFXCFG("c:\\tt.rpp")


--A=ultraschall.GetProject_RenderFilename("C:\\Users\\meo\\Desktop\\hulaaa.RPP")

function ultraschall.GetProject_RenderPattern(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string render_pattern = ultraschall.GetProject_RenderPattern(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-pattern, that tells Reaper, how to automatically name the render-file, from an RPP-Projectfile or a ProjectStateChunk. If it contains nothing, you should check the Render_Pattern using <a href="#GetProject_RenderFilename">GetProject_RenderFilename</a>, as a render-pattern influences the rendering-filename as well.
    
    It's the entry RENDER_PATTERN
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string render_pattern - the pattern, with which the rendering-filename will be automatically created. Check also <a href="#GetProject_RenderFilename">GetProject_RenderFilename</a>
    -   Capitalizing the first character of the wildcard will capitalize the first letter of the substitution. 
    -    Capitalizing the first two characters of the wildcard will capitalize all letters.
    -
    -    Directories will be created if necessary. For example if the render target is "$project/track", the directory "$project" will be created.
    -
    - $item    media item take name, if the input is a media item
    - $itemnumber  1 for the first media item on a track, 2 for the second...
    - $track    track name
    - $tracknumber  1 for the first track, 2 for the second...
    - $parenttrack  parent track name
    - $region    region name
    - $regionnumber  1 for the first region, 2 for the second...
    - $namecount  1 for the first item or region of the same name, 2 for the second...
    - $start    start time of the media item, render region, or time selection
    - $end    end time of the media item, render region, or time selection
    - $startbeats  start time in beats of the media item, render region, or time selection
    - $endbeats  end time in beats of the media item, render region, or time selection
    - $timelineorder  1 for the first item or region on the timeline, 2 for the second...
    - $project    project name
    - $tempo    project tempo at the start of the render region
    - $timesignature  project time signature at the start of the render region, formatted as 4-4
    - $filenumber  blank (optionally 1) for the first file rendered, 1 (optionally 2) for the second...
    - $filenumber[N]  N for the first file rendered, N+1 for the second...
    - $note    C0 for the first file rendered,C#0 for the second...
    - $note[X]    X (example: B2) for the first file rendered, X+1 (example: C3) for the second...
    - $natural    C0 for the first file rendered, D0 for the second...
    - $natural[X]  X (example: F2) for the first file rendered, X+1 (example: G2) for the second...
    - $format    render format (example: wav)
    - $samplerate  sample rate (example: 44100)
    - $sampleratek  sample rate (example: 44.1)
    - $year    year
    - $year2    last 2 digits of the year
    - $month    month number
    - $monthname  month name
    - $day    day of the month
    - $hour    hour of the day in 24-hour format
    - $hour12    hour of the day in 12-hour format
    - $ampm    am if before noon,pm if after noon
    - $minute    minute of the hour
    - $second    second of the minute
    - $user    user name
    - $computer  computer name
    -
    - (this description has been taken from the Render Wildcard Help within the Render-Dialog of Reaper)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, render pattern, filename, render</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderPattern","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderPattern","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderPattern","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderPattern", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  local temp=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_PATTERN%s(.-)%c.-<RENDER_CFG")
--  if temp:sub(1,1)=="\"" then temp=temp:sub(2,-1) end
--  if temp:sub(-1,-1)=="\"" then temp=temp:sub(1,-2) end
  return temp
end

--A=ultraschall.GetProject_RenderPattern("c:\\tt.rpp")
--A=ultraschall.GetProject_RenderPattern("c:\\tt.rpp")

function ultraschall.GetProject_RenderFreqNChans(projectfilename_with_path, ProjectStateChunk)
-- returns an unknown number, Number_Channels(0-default) and RenderFrequency(0-default)
-- Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels
-- RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderFreqNChans</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer unknown, integer rendernum_chans, integer render_frequency = ultraschall.GetProject_RenderFreqNChans(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk.
    It's the entry RENDER_FMT
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer unknown - unknown number
    integer rendernum_chans - Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels
    integer render_frequency - RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, frequency, num channels, channels</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderFreqNChans","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderFreqNChans","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderFreqNChans","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderFreqNChans", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_FMT(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

-- A,AA,AAA=ultraschall.GetProject_RenderFreqNChans("c:\\tt.rpp")

function ultraschall.GetProject_RenderSpeed(projectfilename_with_path, ProjectStateChunk)
--    Rendering_Speed 0-Fullspeed Offline, 1-1x Offline, 
--                    2-Online Render, 3-Offline Render (Idle), 
--                    4-1x Offline Render (Idle)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderSpeed</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer render_speed = ultraschall.GetProject_RenderSpeed(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the rendering-speed from an RPP-Projectfile or a ProjectStateChunk.
    It's the entry RENDER_1X
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer render_speed - render_speed 
    -0-Fullspeed Offline
    -1-1x Offline
    -2-Online Render
    -3-Offline Render (Idle)
    -4-1x Offline Render (Idle)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, speed</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderSpeed","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderSpeed","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderSpeed","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderSpeed", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_1X(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_RenderSpeed("c:\\tt.rpp")

function ultraschall.GetProject_RenderRange(projectfilename_with_path, ProjectStateChunk)
-- returns RenderRange
-- Bounds: 0 Custom Time Range, 1 Entire Project, 2 Time Selection, 
--          3 Project Regions, 4 Selected Media Items(in combination with RENDER_STEMS 32)
-- TimeStart in milliseconds -2147483647 to 2147483647
-- TimeEnd in milliseconds 2147483647 to 2147483647
-- Tail: 
--0 Custom Time Range
--1 Entire Project
--2 Time Selection, 
--3 Project Regions
--4 Selected Media Items(in combination with RENDER_STEMS 32); to get RENDER_STEMS to 32, refer <a href="#GetProject_RenderStems">GetProject_RenderStems</a>
-- TailLength in milliseconds, valuerange 0 - 2147483647  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderRange</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer bounds, number time_start, number time_end, integer tail, integer tail_length = ultraschall.GetProject_RenderRange(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-range, render-timestart, render-timeend, render-tail and render-taillength from an RPP-Projectfile or a ProjectStateChunk. To get RENDER_STEMS, refer <a href="#GetProject_RenderStems">GetProject_RenderStems</a>
    
    It's the entry RENDER_RANGE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer bounds - the bounds of the project to be rendered
    -0 Custom Time Range
    -1 Entire Project
    -2 Time Selection, 
    -3 Project Regions
    -4 Selected Media Items(in combination with RENDER_STEMS 32); to get RENDER_STEMS, refer <a href="#GetProject_RenderStems">GetProject_RenderStems</a>
    
    number time_start - TimeStart in milliseconds -2147483647 to 2147483647
    number time_end - TimeEnd in milliseconds 2147483647 to 2147483647
    integer tail - Tail on/off-flags for individual bounds
    -0 - tail off for all bounds
    -1 - custom time range - tail on
    -2 - entire project - tail on
    -4 - time selection - tail on
    -8 - project regions - tail on
    
    integer tail_length - TailLength in milliseconds, valuerange 0 - 2147483647
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, timestart, timeend, range, tail, bounds</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderRange","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderRange","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderRange","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderRange", "projectfilename_with_path", "No valid RPP-Project!", -4) return nil end
  end
    
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_RANGE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetProject_RenderRange("c:\\tt.rpp")

function ultraschall.GetProject_RenderResample(projectfilename_with_path, ProjectStateChunk)
-- returns Resamplemode for a)Rendering and b)Playback as well as c)if both are combined
--- Resample_Mode - 0-medium (64pt Sinc), 1-Low (Linear Interpolation), 
--                2-Lowest (Point Sampling), 3-Good(192pt Sinc), 
--                4-Better(384pt Sinc), 5-Fast (IIR + Linear Interpolation), 
--                6-Fast (IIRx2 + Linear Interpolation), 7-Fast (16pt sinc) - Default, 
--                8-HQ (512pt Sinc), 9-Extreme HQ (768pt HQ Sinc)
-- Playback_Resample_Mode (as set in the Project-Settings)
--                0-medium (64pt Sinc), 1-Low (Linear Interpolation), 
--                2-Lowest (Point Sampling), 3-Good(192pt Sinc), 
--                4-Better(384pt Sinc), 5-Fast (IIR + Linear Interpolation), 
--                6-Fast (IIRx2 + Linear Interpolation), 7-Fast (16pt sinc) - Default, 
--                8-HQ (512pt Sinc), 9-Extreme HQ (768pt HQ Sinc)
-- Use_Project_Sample_Rate_for_Mixing_and_FX/Synth_Processing - 1 - yes, 0-no

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderResample</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer resample_mode, integer playback_resample_mode, integer project_smplrate4mix_and_fx = ultraschall.GetProject_RenderResample(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry RENDER_RESAMPLE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer resample_mode - Resample_Mode 
    -0-medium (64pt Sinc), 
    -1-Low (Linear Interpolation), 
    -2-Lowest (Point Sampling), 
    -3-Good(192pt Sinc), 
    -4-Better(384pt Sinc), 
    -5-Fast (IIR + Linear Interpolation), 
    -6-Fast (IIRx2 + Linear Interpolation), 
    -7-Fast (16pt sinc) - Default, 
    -8-HQ (512pt Sinc), 
    -9-Extreme HQ (768pt HQ Sinc)
    
    integer playback_resample_mode - Playback Resample Mode (as set in the Project-Settings)
    -0-medium (64pt Sinc), 
    -1-Low (Linear Interpolation), 
    -2-Lowest (Point Sampling), 
    -3-Good(192pt Sinc), 
    -4-Better(384pt Sinc), 
    -5-Fast (IIR + Linear Interpolation), 
    -6-Fast (IIRx2 + Linear Interpolation), 
    -7-Fast (16pt sinc) - Default, 
    -8-HQ (512pt Sinc), 
    -9-Extreme HQ (768pt HQ Sinc)
    
    integer project_smplrate4mix_and_fx - Use_Project_Sample_Rate_for_Mixing_and_FX/Synth_Processing 1 - yes, 0-no
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, resample, playback, mixing, fx, synth</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderResample","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderResample","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderResample","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderResample", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_RESAMPLE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.GetProject_RenderResample("c:\\tt.rpp")

function ultraschall.GetProject_AddMediaToProjectAfterRender(projectfilename_with_path, ProjectStateChunk)
-- returns the state, if rendered media shall be added to the project afterwards
-- 0 - don't add, 1 - add to project
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_AddMediaToProjectAfterRender</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer addmedia_after_render_state = ultraschall.GetProject_AddMediaToProjectAfterRender(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns, if rendered media shall be added to the project afterwards, from an RPP-Projectfile or a ProjectStateChunk.
    It's the entry RENDER_ADDTOPROJ
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer addmedia_after_render_state - 1, rendered media shall be added to the project afterwards; 0, don't add
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, add, media, after, project</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_AddMediaToProjectAfterRender","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AddMediaToProjectAfterRender","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_AddMediaToProjectAfterRender","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AddMediaToProjectAfterRender", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_ADDTOPROJ(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_AddMediaToProjectAfterRender("c:\\tt.rpp")

function ultraschall.GetProject_RenderStems(projectfilename_with_path, ProjectStateChunk)
-- returns the state of Render Stems
-- 0 - Source Master Mix, 1 - Source Master mix + stems, 3 - Source Stems, selected tracks, 
-- 4 - Multichannel Tracks to Multichannel Files, 8 - Source Region Render Matrix, 
-- 16 - Tracks with only Mono-Media to Mono Files,  
-- 32 Selected Media Items(in combination with RENDER_RANGE->Bounds->4)  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderStems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer render_stems = ultraschall.GetProject_RenderStems(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-stems-state from an rpp-project-file or a ProjectStateChunk.
    
    It's the entry RENDER_STEMS
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer render_stems - the state of Render Stems
    - 0 - Source Master Mix, 
    - 1 - Source Master mix + stems, 
    - 3 - Source Stems, selected tracks, 
    - 4 - Multichannel Tracks to Multichannel Files, 
    - 8 - Source Region Render Matrix, 
    - 16 - Tracks with only Mono-Media to Mono Files,  
    - 32 Selected Media Items(in combination with RENDER_RANGE->Bounds->4, refer to <a href="#GetProject_RenderRange">GetProject_RenderRange</a> to get RENDER_RANGE)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, stems, multichannel</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderStems","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderStems","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderStems","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderStems", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_STEMS(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_RenderStems("c:\\tt.rpp")

function ultraschall.GetProject_RenderDitherState(projectfilename_with_path, ProjectStateChunk)
-- returns the state of dithering of rendering
-- 0 - Dither Master Mix, 1 - Don't Dither Master Mix, 2 - Noise-shaping On Master Mix, 
-- 3 - Dither And Noiseshape Master Mix
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderDitherState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer renderdither_state = ultraschall.GetProject_RenderDitherState(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-dither-state from an rpp-project-file or a ProjectStateChunk.

    It's the entry RENDER_DITHER
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer renderdither_state - the state of render dithering
    -0 - Dither Master Mix, 
    -1 - Don't Dither Master Mix, 
    -2 - Noise-shaping On Master Mix, 
    -3 - Dither And Noiseshape Master Mix
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, render, dither, state, master, noise shaping</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderDitherState","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderDitherState","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderDitherState","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderDitherState", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_DITHER(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_RenderDitherState("c:\\tt.rpp")


function ultraschall.GetProject_TimeBase(projectfilename_with_path, ProjectStateChunk)
-- returns Time Base for items/envelopes/markers as set in the project settings
-- 0 - Time, 1 - Beats (position, length, rate), 2 - Beats (position only)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TimeBase</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer timebase = ultraschall.GetProject_TimeBase(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the timebase-state from an rpp-project-file or a ProjectStateChunk.
    It's the entry TIMELOCKMODE x
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer timebase - the timebase for items/envelopes/markers as set in the project settings
    -0 - Time, 
    -1 - Beats (position, length, rate), 
    -2 - Beats (position only)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, timebase, time, beats, items, envelopes, markers</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TimeBase","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TimeBase","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TimeBase","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TimeBase", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-TIMELOCKMODE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_TimeBase("c:\\tt.rpp")

function ultraschall.GetProject_TempoTimeSignature(projectfilename_with_path, ProjectStateChunk)
-- returns Time Base for tempo/time-signature as set in the project settings
-- 0 - Time, 1 - Beats
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TempoTimeSignature</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer tempotimesignature = ultraschall.GetProject_TempoTimeSignature(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the timebase for tempo/time-signature as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    It's the entry TEMPOENVLOCKMODE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer tempotimesignature - the timebase for tempo/time-signature as set in the project settings
    -0 - Time 
    -1 - Beats
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, timebase, time, beats, tempo, signature</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TempoTimeSignature","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TempoTimeSignature","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TempoTimeSignature","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TempoTimeSignature", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-TEMPOENVLOCKMODE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_TempoTimeSignature("c:\\tt.rpp")

function ultraschall.GetProject_ItemMixBehavior(projectfilename_with_path, ProjectStateChunk)
-- returns Project Settings Item Mix Behavior
-- 0 - Enclosed items replace enclosing items 
-- 1 - Items always mix
-- 2 - Items always replace earlier items

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_ItemMixBehavior</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer item_mix_behav_state = ultraschall.GetProject_ItemMixBehavior(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the item mix behavior, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    It's the entry ITEMMIX
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer item_mix_behav_state - item mix behavior
    - 0 - Enclosed items replace enclosing items 
    - 1 - Items always mix
    - 2 - Items always replace earlier items
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, item, mix</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_ItemMixBehavior","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ItemMixBehavior","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_ItemMixBehavior","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ItemMixBehavior", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-ITEMMIX(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_ItemMixBehavior("c:\\tt.rpp")

function ultraschall.GetProject_DefPitchMode(projectfilename_with_path, ProjectStateChunk)
-- returns Default Pitch Mode for project

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_DefPitchMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer def_pitch_mode_state = ultraschall.GetProject_DefPitchMode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the default-pitch-mode, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    
    It's the entry DEFPITCHMODE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer def_pitch_mode_state - the default pitch mode
    -      0 - Soundtouch(Default)
    -      1 - Soundtouch(High Quality)
    -      2 - Soundtouch(Fast)
    -      131072 - Simple Windowed(fast) (50ms window, 25ms fade)
    -      131073 - Simple Windowed(fast) (50ms window, 16ms fade)
    -      131074 - Simple Windowed(fast) (50ms window, 10ms fade)
    -      131075 - Simple Windowed(fast) (50ms window, 7ms fade)
    -      131076 - Simple Windowed(fast) (75ms window, 37ms fade)
    -      131077 - Simple Windowed(fast) (75ms window, 25ms fade)
    -      131078 - Simple Windowed(fast) (75ms window, 15ms fade)
    -      131079 - Simple Windowed(fast) (75ms window, 10ms fade)
    -      131080 - Simple Windowed(fast) (100ms window, 50ms fade)
    -      131081 - Simple Windowed(fast) (100ms window, 33ms fade)
    -      131082 - Simple Windowed(fast) (100ms window, 20ms fade)
    -      131083 - Simple Windowed(fast) (100ms window, 14ms fade)
    -      131084 - Simple Windowed(fast) (150ms window, 75ms fade)
    -      131085 - Simple Windowed(fast) (150ms window, 50ms fade)
    -      131086 - Simple Windowed(fast) (150ms window, 30ms fade)
    -      131087 - Simple Windowed(fast) (150ms window, 21ms fade)
    -      131088 - Simple Windowed(fast) (225ms window, 112ms fade)
    -      131089 - Simple Windowed(fast) (225ms window, 75ms fade)
    -      131090 - Simple Windowed(fast) (225ms window, 45ms fade)
    -      131091 - Simple Windowed(fast) (225ms window, 32ms fade)
    -      131092 - Simple Windowed(fast) (300ms window, 150ms fade)
    -      131093 - Simple Windowed(fast) (300ms window, 100ms fade)
    -      131094 - Simple Windowed(fast) (300ms window, 60ms fade)
    -      131095 - Simple Windowed(fast) (300ms window, 42ms fade)
    -      131096 - Simple Windowed(fast) (40ms window, 20ms fade)
    -      131097 - Simple Windowed(fast) (40ms window, 13ms fade)
    -      131098 - Simple Windowed(fast) (40ms window, 8ms fade)
    -      131099 - Simple Windowed(fast) (40ms window, 5ms fade)
    -      131100 - Simple Windowed(fast) (30ms window, 15ms fade)
    -      131101 - Simple Windowed(fast) (30ms window, 10ms fade)
    -      131102 - Simple Windowed(fast) (30ms window, 6s fade)
    -      131103 - Simple Windowed(fast) (30ms window, 4ms fade)
    -      131104 - Simple Windowed(fast) (20ms window, 10ms fade)
    -      131105 - Simple Windowed(fast) (20ms window, 6ms fade)
    -      131106 - Simple Windowed(fast) (20ms window, 4ms fade)
    -      131107 - Simple Windowed(fast) (20ms window, 2ms fade)
    -      131108 - Simple Windowed(fast) (10ms window, 5ms fade)
    -      131109 - Simple Windowed(fast) (10ms window, 3ms fade)
    -      131110 - Simple Windowed(fast) (10ms window, 2ms fade)
    -      131111 - Simple Windowed(fast) (10ms window, 1ms fade)
    -      131112 - Simple Windowed(fast) (5ms window, 2ms fade)
    -      131113 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131114 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131115 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131116 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131117 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131118 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131119 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      393216 - elastique 2.28 Pro Normal
    -      393217 - elastique 2.28 Pro Preserve Formants(Lowest Pitches)
    -      393218 - elastique 2.28 Pro Preserve Formants(Lower Pitches)
    -      393219 - elastique 2.28 Pro Preserve Formants(Low Pitches)
    -      393220 - elastique 2.28 Pro Preserve Formants(Most Pitches)
    -      393221 - elastique 2.28 Pro Preserve Formants(High Pitches)
    -      393222 - elastique 2.28 Pro Preserve Formants(Higher Pitches)
    -      393223 - elastique 2.28 Pro Preserve Formants(Highest Pitches)
    -      393224 - elastique 2.28 Pro Mid/Side
    -      393225 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      393226 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      393227 - elastique 2.28 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      393228 - elastique 2.28 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      393229 - elastique 2.28 Pro Mid/Side, Preserve Formants(High Pitches)
    -      393230 - elastique 2.28 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      393231 - elastique 2.28 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      393232 - elastique 2.28 Pro Synchronized: Normal
    -      393233 - elastique 2.28 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      393234 - elastique 2.28 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      393235 - elastique 2.28 Pro Synchronized: Preserve Formants(Low Pitches)
    -      393236 - elastique 2.28 Pro Synchronized: Preserve Formants(Most Pitches)
    -      393237 - elastique 2.28 Pro Synchronized: Preserve Formants(High Pitches)
    -      393238 - elastique 2.28 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      393239 - elastique 2.28 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      393240 - elastique 2.28 Pro Synchronized: Mid/Side 
    -      393241 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      393242 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      393243 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      393244 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      393245 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      393246 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      393247 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      458752 - elastique 2.28 Efficient Normal
    -      458753 - elastique 2.28 Efficient Mid/Side
    -      458754 - elastique 2.28 Efficient Synchronized: Normal
    -      458755 - elastique 2.28 Efficient Synchronized: Mid/Side
    -      524288 - elastique 2.28 Soloist Monophonic
    -      524289 - elastique 2.28 Soloist Monophonic [Mid/Side]
    -      524290 - elastique 2.28 Soloist Speech
    -      524291 - elastique 2.28 Soloist Speech [Mid/Side]
    -      589824 - elastique 3.2.3 Pro Normal
    -      589825 - elastique 3.2.3 Pro Preserve Formants(Lowest Pitches)
    -      589826 - elastique 3.2.3 Pro Preserve Formants(Lower Pitches)
    -      589827 - elastique 3.2.3 Pro Preserve Formants(Low Pitches)
    -      589828 - elastique 3.2.3 Pro Preserve Formants(Most Pitches)
    -      589829 - elastique 3.2.3 Pro Preserve Formants(High Pitches)
    -      589830 - elastique 3.2.3 Pro Preserve Formants(Higher Pitches)
    -      589831 - elastique 3.2.3 Pro Preserve Formants(Highest Pitches)
    -      589832 - elastique 3.2.3 Pro Mid/Side
    -      589833 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      589834 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      589835 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      589836 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      589837 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(High Pitches)
    -      589838 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      589839 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      589840 - elastique 3.2.3 Pro Synchronized: Normal
    -      589841 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      589842 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      589843 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Low Pitches)
    -      589844 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Most Pitches)
    -      589845 - elastique 3.2.3 Pro Synchronized: Preserve Formants(High Pitches)
    -      589846 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      589847 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      589848 - elastique 3.2.3 Pro Synchronized: Mid/Side 
    -      589849 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      589850 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      589851 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      589852 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      589855 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      655360 - elastique 3.2.3 Efficient Normal
    -      655361 - elastique 3.2.3 Efficient Mid/Side
    -      655362 - elastique 3.2.3 Efficient Synchronized: Normal
    -      655363 - elastique 3.2.3 Efficient Synchronized: Mid/Side
    -      720896 - elastique 3.2.3 Soloist (Monophonic)
    -      720897 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -      720898 - elastique 3.2.3 Soloist (Speech)
    -      720898 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851968 - nothing
    -      851969 - Preserve Formants
    -      851970 - Mid/Side
    -      851971 - Preserve Formants (Mid Side)
    -      851972 - Independent Phase
    -      851973 - Preserve Formants, Independent Phase
    -      851974 - Mid/Side, Independent Phase
    -      851975 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851984 - nothing
    -      851985 - Preserve Formants
    -      851986 - Mid/Side
    -      851987 - Preserve Formants (Mid Side)
    -      851988 - Independent Phase
    -      851989 - Preserve Formants, Independent Phase
    -      851990 - Mid/Side, Independent Phase
    -      851991 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      852000 - nothing
    -      852001 - Preserve Formants
    -      852002 - Mid/Side
    -      852003 - Preserve Formants (Mid Side)
    -      852004 - Independent Phase
    -      852005 - Preserve Formants, Independent Phase
    -      852006 - Mid/Side, Independent Phase
    -      852007 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852016 - nothing
    -      852017 - Preserve Formants
    -      852018 - Mid/Side
    -      852019 - Preserve Formants (Mid Side)
    -      852020 - Independent Phase
    -      852021 - Preserve Formants, Independent Phase
    -      852022 - Mid/Side, Independent Phase
    -      852023 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852032 - nothing
    -      852033 - Preserve Formants
    -      852034 - Mid/Side
    -      852035 - Preserve Formants (Mid Side)
    -      852036 - Independent Phase
    -      852037 - Preserve Formants, Independent Phase
    -      852038 - Mid/Side, Independent Phase
    -      852039 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852048 - nothing
    -      852049 - Preserve Formants
    -      852050 - Mid/Side
    -      852051 - Preserve Formants (Mid Side)
    -      852052 - Independent Phase
    -      852053 - Preserve Formants, Independent Phase
    -      852054 - Mid/Side, Independent Phase
    -      852055 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852064 - nothing
    -      852065 - Preserve Formants
    -      852066 - Mid/Side
    -      852067 - Preserve Formants (Mid Side)
    -      852068 - Independent Phase
    -      852069 - Preserve Formants, Independent Phase
    -      852070 - Mid/Side, Independent Phase
    -      852071 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852080 - nothing
    -      852081 - Preserve Formants
    -      852082 - Mid/Side
    -      852083 - Preserve Formants (Mid Side)
    -      852084 - Independent Phase
    -      852085 - Preserve Formants, Independent Phase
    -      852086 - Mid/Side, Independent Phase
    -      852087 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852096 - nothing
    -      852097 - Preserve Formants
    -      852098 - Mid/Side
    -      852099 - Preserve Formants (Mid Side)
    -      852100 - Independent Phase
    -      852101 - Preserve Formants, Independent Phase
    -      852102 - Mid/Side, Independent Phase
    -      852103 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852112 - nothing
    -      852113 - Preserve Formants
    -      852114 - Mid/Side
    -      852115 - Preserve Formants (Mid Side)
    -      852116 - Independent Phase
    -      852117 - Preserve Formants, Independent Phase
    -      852118 - Mid/Side, Independent Phase
    -      852119 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852128 - nothing
    -      852129 - Preserve Formants
    -      852130 - Mid/Side
    -      852131 - Preserve Formants (Mid Side)
    -      852132 - Independent Phase
    -      852133 - Preserve Formants, Independent Phase
    -      852134 - Mid/Side, Independent Phase
    -      852135 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852144 - nothing
    -      852145 - Preserve Formants
    -      852146 - Mid/Side
    -      852147 - Preserve Formants (Mid Side)
    -      852148 - Independent Phase
    -      852149 - Preserve Formants, Independent Phase
    -      852150 - Mid/Side, Independent Phase
    -      852151 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852160 - nothing
    -      852161 - Preserve Formants
    -      852162 - Mid/Side
    -      852163 - Preserve Formants (Mid Side)
    -      852164 - Independent Phase
    -      852165 - Preserve Formants, Independent Phase
    -      852166 - Mid/Side, Independent Phase
    -      852167 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852176 - nothing
    -      852177 - Preserve Formants
    -      852178 - Mid/Side
    -      852179 - Preserve Formants (Mid Side)
    -      852180 - Independent Phase
    -      852181 - Preserve Formants, Independent Phase
    -      852182 - Mid/Side, Independent Phase
    -      852183 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852192 - nothing
    -      852193 - Preserve Formants
    -      852194 - Mid/Side
    -      852195 - Preserve Formants (Mid Side)
    -      852196 - Independent Phase
    -      852197 - Preserve Formants, Independent Phase
    -      852198 - Mid/Side, Independent Phase
    -      852199 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852208 - nothing
    -      852209 - Preserve Formants
    -      852210 - Mid/Side
    -      852211 - Preserve Formants (Mid Side)
    -      852212 - Independent Phase
    -      852213 - Preserve Formants, Independent Phase
    -      852214 - Mid/Side, Independent Phase
    -      852215 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852224 - nothing
    -      852225 - Preserve Formants
    -      852226 - Mid/Side
    -      852227 - Preserve Formants (Mid Side)
    -      852228 - Independent Phase
    -      852229 - Preserve Formants, Independent Phase
    -      852230 - Mid/Side, Independent Phase
    -      852231 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852240 - nothing
    -      852241 - Preserve Formants
    -      852242 - Mid/Side
    -      852243 - Preserve Formants (Mid Side)
    -      852244 - Independent Phase
    -      852245 - Preserve Formants, Independent Phase
    -      852246 - Mid/Side, Independent Phase
    -      852247 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852256 - nothing
    -      852257 - Preserve Formants
    -      852258 - Mid/Side
    -      852259 - Preserve Formants (Mid Side)
    -      852260 - Independent Phase
    -      852261 - Preserve Formants, Independent Phase
    -      852262 - Mid/Side, Independent Phase
    -      852263 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852272 - nothing
    -      852273 - Preserve Formants
    -      852274 - Mid/Side
    -      852275 - Preserve Formants (Mid Side)
    -      852276 - Independent Phase
    -      852277 - Preserve Formants, Independent Phase
    -      852278 - Mid/Side, Independent Phase
    -      852279 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852288 - nothing
    -      852289 - Preserve Formants
    -      852290 - Mid/Side
    -      852291 - Preserve Formants (Mid Side)
    -      852292 - Independent Phase
    -      852293 - Preserve Formants, Independent Phase
    -      852294 - Mid/Side, Independent Phase
    -      852295 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852304 - nothing
    -      852305 - Preserve Formants
    -      852306 - Mid/Side
    -      852307 - Preserve Formants (Mid Side)
    -      852308 - Independent Phase
    -      852309 - Preserve Formants, Independent Phase
    -      852310 - Mid/Side, Independent Phase
    -      852311 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852320 - nothing
    -      852321 - Preserve Formants
    -      852322 - Mid/Side
    -      852323 - Preserve Formants (Mid Side)
    -      852324 - Independent Phase
    -      852325 - Preserve Formants, Independent Phase
    -      852326 - Mid/Side, Independent Phase
    -      852327 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852336 - nothing
    -      852337 - Preserve Formants
    -      852338 - Mid/Side
    -      852339 - Preserve Formants (Mid Side)
    -      852340 - Independent Phase
    -      852341 - Preserve Formants, Independent Phase
    -      852342 - Mid/Side, Independent Phase
    -      852343 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852352 - nothing
    -      852353 - Preserve Formants
    -      852354 - Mid/Side
    -      852355 - Preserve Formants (Mid Side)
    -      852356 - Independent Phase
    -      852357 - Preserve Formants, Independent Phase
    -      852358 - Mid/Side, Independent Phase
    -      852359 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852368 - nothing
    -      852369 - Preserve Formants
    -      852370 - Mid/Side
    -      852371 - Preserve Formants (Mid Side)
    -      852372 - Independent Phase
    -      852373 - Preserve Formants, Independent Phase
    -      852374 - Mid/Side, Independent Phase
    -      852375 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852384 - nothing
    -      852385 - Preserve Formants
    -      852386 - Mid/Side
    -      852387 - Preserve Formants (Mid Side)
    -      852388 - Independent Phase
    -      852389 - Preserve Formants, Independent Phase
    -      852390 - Mid/Side, Independent Phase
    -      852391 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852400 - nothing
    -      852401 - Preserve Formants
    -      852402 - Mid/Side
    -      852403 - Preserve Formants (Mid Side)
    -      852404 - Independent Phase
    -      852405 - Preserve Formants, Independent Phase
    -      852406 - Mid/Side, Independent Phase
    -      852407 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852416 - nothing
    -      852417 - Preserve Formants
    -      852418 - Mid/Side
    -      852419 - Preserve Formants (Mid Side)
    -      852420 - Independent Phase
    -      852421 - Preserve Formants, Independent Phase
    -      852422 - Mid/Side, Independent Phase
    -      852423 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852432 - nothing
    -      852433 - Preserve Formants
    -      852434 - Mid/Side
    -      852435 - Preserve Formants (Mid Side)
    -      852436 - Independent Phase
    -      852437 - Preserve Formants, Independent Phase
    -      852438 - Mid/Side, Independent Phase
    -      852439 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852448 - nothing
    -      852449 - Preserve Formants
    -      852450 - Mid/Side
    -      852451 - Preserve Formants (Mid Side)
    -      852452 - Independent Phase
    -      852453 - Preserve Formants, Independent Phase
    -      852454 - Mid/Side, Independent Phase
    -      852455 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852464 - nothing
    -      852465 - Preserve Formants
    -      852466 - Mid/Side
    -      852467 - Preserve Formants (Mid Side)
    -      852468 - Independent Phase
    -      852469 - Preserve Formants, Independent Phase
    -      852470 - Mid/Side, Independent Phase
    -      852471 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852480 - nothing
    -      852481 - Preserve Formants
    -      852482 - Mid/Side
    -      852483 - Preserve Formants (Mid Side)
    -      852484 - Independent Phase
    -      852485 - Preserve Formants, Independent Phase
    -      852486 - Mid/Side, Independent Phase
    -      852487 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852496 - nothing
    -      852497 - Preserve Formants
    -      852498 - Mid/Side
    -      852499 - Preserve Formants (Mid Side)
    -      852500 - Independent Phase
    -      852501 - Preserve Formants, Independent Phase
    -      852502 - Mid/Side, Independent Phase
    -      852503 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852512 - nothing
    -      852513 - Preserve Formants
    -      852514 - Mid/Side
    -      852515 - Preserve Formants (Mid Side)
    -      852516 - Independent Phase
    -      852517 - Preserve Formants, Independent Phase
    -      852518 - Mid/Side, Independent Phase
    -      852519 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852528 - nothing
    -      852529 - Preserve Formants
    -      852530 - Mid/Side
    -      852531 - Preserve Formants (Mid Side)
    -      852532 - Independent Phase
    -      852533 - Preserve Formants, Independent Phase
    -      852534 - Mid/Side, Independent Phase
    -      852535 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852544 - nothing
    -      852545 - Preserve Formants
    -      852546 - Mid/Side
    -      852547 - Preserve Formants (Mid Side)
    -      852548 - Independent Phase
    -      852549 - Preserve Formants, Independent Phase
    -      852550 - Mid/Side, Independent Phase
    -      852551 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852560 - nothing
    -      852561 - Preserve Formants
    -      852562 - Mid/Side
    -      852563 - Preserve Formants (Mid Side)
    -      852564 - Independent Phase
    -      852565 - Preserve Formants, Independent Phase
    -      852566 - Mid/Side, Independent Phase
    -      852567 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852576 - nothing
    -      852577 - Preserve Formants
    -      852578 - Mid/Side
    -      852579 - Preserve Formants (Mid Side)
    -      852580 - Independent Phase
    -      852581 - Preserve Formants, Independent Phase
    -      852582 - Mid/Side, Independent Phase
    -      852583 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852592 - nothing
    -      852593 - Preserve Formants
    -      852594 - Mid/Side
    -      852595 - Preserve Formants (Mid Side)
    -      852596 - Independent Phase
    -      852597 - Preserve Formants, Independent Phase
    -      852598 - Mid/Side, Independent Phase
    -      852599 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852608 - nothing
    -      852609 - Preserve Formants
    -      852610 - Mid/Side
    -      852611 - Preserve Formants (Mid Side)
    -      852612 - Independent Phase
    -      852613 - Preserve Formants, Independent Phase
    -      852614 - Mid/Side, Independent Phase
    -      852615 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852624 - nothing
    -      852625 - Preserve Formants
    -      852626 - Mid/Side
    -      852627 - Preserve Formants (Mid Side)
    -      852628 - Independent Phase
    -      852629 - Preserve Formants, Independent Phase
    -      852630 - Mid/Side, Independent Phase
    -      852631 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852640 - nothing
    -      852641 - Preserve Formants
    -      852642 - Mid/Side
    -      852643 - Preserve Formants (Mid Side)
    -      852644 - Independent Phase
    -      852645 - Preserve Formants, Independent Phase
    -      852646 - Mid/Side, Independent Phase
    -      852647 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852656 - nothing
    -      852657 - Preserve Formants
    -      852658 - Mid/Side
    -      852659 - Preserve Formants (Mid Side)
    -      852660 - Independent Phase
    -      852661 - Preserve Formants, Independent Phase
    -      852662 - Mid/Side, Independent Phase
    -      852663 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852672 - nothing
    -      852673 - Preserve Formants
    -      852674 - Mid/Side
    -      852675 - Preserve Formants (Mid Side)
    -      852676 - Independent Phase
    -      852677 - Preserve Formants, Independent Phase
    -      852678 - Mid/Side, Independent Phase
    -      852679 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852688 - nothing
    -      852689 - Preserve Formants
    -      852690 - Mid/Side
    -      852691 - Preserve Formants (Mid Side)
    -      852692 - Independent Phase
    -      852693 - Preserve Formants, Independent Phase
    -      852694 - Mid/Side, Independent Phase
    -      852695 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852704 - nothing
    -      852705 - Preserve Formants
    -      852706 - Mid/Side
    -      852707 - Preserve Formants (Mid Side)
    -      852708 - Independent Phase
    -      852709 - Preserve Formants, Independent Phase
    -      852710 - Mid/Side, Independent Phase
    -      852711 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852720 - nothing
    -      852721 - Preserve Formants
    -      852722 - Mid/Side
    -      852723 - Preserve Formants (Mid Side)
    -      852724 - Independent Phase
    -      852725 - Preserve Formants, Independent Phase
    -      852726 - Mid/Side, Independent Phase
    -      852727 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852736 - nothing
    -      852737 - Preserve Formants
    -      852738 - Mid/Side
    -      852739 - Preserve Formants (Mid Side)
    -      852740 - Independent Phase
    -      852741 - Preserve Formants, Independent Phase
    -      852742 - Mid/Side, Independent Phase
    -      852743 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852752 - nothing
    -      852753 - Preserve Formants
    -      852754 - Mid/Side
    -      852755 - Preserve Formants (Mid Side)
    -      852756 - Independent Phase
    -      852757 - Preserve Formants, Independent Phase
    -      852758 - Mid/Side, Independent Phase
    -      852759 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852768 - nothing
    -      852769 - Preserve Formants
    -      852770 - Mid/Side
    -      852771 - Preserve Formants (Mid Side)
    -      852772 - Independent Phase
    -      852773 - Preserve Formants, Independent Phase
    -      852774 - Mid/Side, Independent Phase
    -      852775 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852784 - nothing
    -      852785 - Preserve Formants
    -      852786 - Mid/Side
    -      852787 - Preserve Formants (Mid Side)
    -      852788 - Independent Phase
    -      852789 - Preserve Formants, Independent Phase
    -      852790 - Mid/Side, Independent Phase
    -      852791 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852800 - nothing
    -      852801 - Preserve Formants
    -      852802 - Mid/Side
    -      852803 - Preserve Formants (Mid Side)
    -      852804 - Independent Phase
    -      852805 - Preserve Formants, Independent Phase
    -      852806 - Mid/Side, Independent Phase
    -      852807 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852816 - nothing
    -      852817 - Preserve Formants
    -      852818 - Mid/Side
    -      852819 - Preserve Formants (Mid Side)
    -      852820 - Independent Phase
    -      852821 - Preserve Formants, Independent Phase
    -      852822 - Mid/Side, Independent Phase
    -      852823 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852832 - nothing
    -      852833 - Preserve Formants
    -      852834 - Mid/Side
    -      852835 - Preserve Formants (Mid Side)
    -      852836 - Independent Phase
    -      852837 - Preserve Formants, Independent Phase
    -      852838 - Mid/Side, Independent Phase
    -      852839 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852848 - nothing
    -      852849 - Preserve Formants
    -      852850 - Mid/Side
    -      852851 - Preserve Formants (Mid Side)
    -      852852 - Independent Phase
    -      852853 - Preserve Formants, Independent Phase
    -      852854 - Mid/Side, Independent Phase
    -      852855 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852864 - nothing
    -      852865 - Preserve Formants
    -      852866 - Mid/Side
    -      852867 - Preserve Formants (Mid Side)
    -      852868 - Independent Phase
    -      852869 - Preserve Formants, Independent Phase
    -      852870 - Mid/Side, Independent Phase
    -      852871 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852880 - nothing
    -      852881 - Preserve Formants
    -      852882 - Mid/Side
    -      852883 - Preserve Formants (Mid Side)
    -      852884 - Independent Phase
    -      852885 - Preserve Formants, Independent Phase
    -      852886 - Mid/Side, Independent Phase
    -      852887 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852896 - nothing
    -      852897 - Preserve Formants
    -      852898 - Mid/Side
    -      852899 - Preserve Formants (Mid Side)
    -      852900 - Independent Phase
    -      852901 - Preserve Formants, Independent Phase
    -      852902 - Mid/Side, Independent Phase
    -      852903 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852912 - nothing
    -      852913 - Preserve Formants
    -      852914 - Mid/Side
    -      852915 - Preserve Formants (Mid Side)
    -      852916 - Independent Phase
    -      852917 - Preserve Formants, Independent Phase
    -      852918 - Mid/Side, Independent Phase
    -      852919 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852928 - nothing
    -      852929 - Preserve Formants
    -      852930 - Mid/Side
    -      852931 - Preserve Formants (Mid Side)
    -      852932 - Independent Phase
    -      852933 - Preserve Formants, Independent Phase
    -      852934 - Mid/Side, Independent Phase
    -      852935 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852944 - nothing
    -      852945 - Preserve Formants
    -      852946 - Mid/Side
    -      852947 - Preserve Formants (Mid Side)
    -      852948 - Independent Phase
    -      852949 - Preserve Formants, Independent Phase
    -      852950 - Mid/Side, Independent Phase
    -      852951 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852960 - nothing
    -      852961 - Preserve Formants
    -      852962 - Mid/Side
    -      852963 - Preserve Formants (Mid Side)
    -      852964 - Independent Phase
    -      852965 - Preserve Formants, Independent Phase
    -      852966 - Mid/Side, Independent Phase
    -      852967 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852976 - nothing
    -      852977 - Preserve Formants
    -      852978 - Mid/Side
    -      852979 - Preserve Formants (Mid Side)
    -      852980 - Independent Phase
    -      852981 - Preserve Formants, Independent Phase
    -      852982 - Mid/Side, Independent Phase
    -      852983 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852992 - nothing
    -      852993 - Preserve Formants
    -      852994 - Mid/Side
    -      852995 - Preserve Formants (Mid Side)
    -      852996 - Independent Phase
    -      852997 - Preserve Formants, Independent Phase
    -      852998 - Mid/Side, Independent Phase
    -      852999 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      853008 - nothing
    -      853009 - Preserve Formants
    -      853010 - Mid/Side
    -      853011 - Preserve Formants (Mid Side)
    -      853012 - Independent Phase
    -      853013 - Preserve Formants, Independent Phase
    -      853014 - Mid/Side, Independent Phase
    -      853015 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853024 - nothing
    -      853025 - Preserve Formants
    -      853026 - Mid/Side
    -      853027 - Preserve Formants (Mid Side)
    -      853028 - Independent Phase
    -      853029 - Preserve Formants, Independent Phase
    -      853030 - Mid/Side, Independent Phase
    -      853031 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853040 - nothing
    -      853041 - Preserve Formants
    -      853042 - Mid/Side
    -      853043 - Preserve Formants (Mid Side)
    -      853044 - Independent Phase
    -      853045 - Preserve Formants, Independent Phase
    -      853046 - Mid/Side, Independent Phase
    -      853047 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853056 - nothing
    -      853057 - Preserve Formants
    -      853058 - Mid/Side
    -      853059 - Preserve Formants (Mid Side)
    -      853060 - Independent Phase
    -      853061 - Preserve Formants, Independent Phase
    -      853062 - Mid/Side, Independent Phase
    -      853063 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853072 - nothing
    -      853073 - Preserve Formants
    -      853074 - Mid/Side
    -      853075 - Preserve Formants (Mid Side)
    -      853076 - Independent Phase
    -      853077 - Preserve Formants, Independent Phase
    -      853078 - Mid/Side, Independent Phase
    -      853079 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853088 - nothing
    -      853089 - Preserve Formants
    -      853090 - Mid/Side
    -      853091 - Preserve Formants (Mid Side)
    -      853092 - Independent Phase
    -      853093 - Preserve Formants, Independent Phase
    -      853094 - Mid/Side, Independent Phase
    -      853095 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853104 - nothing
    -      853105 - Preserve Formants
    -      853106 - Mid/Side
    -      853107 - Preserve Formants (Mid Side)
    -      853108 - Independent Phase
    -      853109 - Preserve Formants, Independent Phase
    -      853110 - Mid/Side, Independent Phase
    -      853111 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853120 - nothing
    -      853121 - Preserve Formants
    -      853122 - Mid/Side
    -      853123 - Preserve Formants (Mid Side)
    -      853124 - Independent Phase
    -      853125 - Preserve Formants, Independent Phase
    -      853126 - Mid/Side, Independent Phase
    -      853127 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853136 - nothing
    -      853137 - Preserve Formants
    -      853138 - Mid/Side
    -      853139 - Preserve Formants (Mid Side)
    -      853140 - Independent Phase
    -      853141 - Preserve Formants, Independent Phase
    -      853142 - Mid/Side, Independent Phase
    -      853143 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853152 - nothing
    -      853153 - Preserve Formants
    -      853154 - Mid/Side
    -      853155 - Preserve Formants (Mid Side)
    -      853156 - Independent Phase
    -      853157 - Preserve Formants, Independent Phase
    -      853158 - Mid/Side, Independent Phase
    -      853159 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853168 - nothing
    -      853169 - Preserve Formants
    -      853170 - Mid/Side
    -      853171 - Preserve Formants (Mid Side)
    -      853172 - Independent Phase
    -      853173 - Preserve Formants, Independent Phase
    -      853174 - Mid/Side, Independent Phase
    -      853175 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853184 - nothing
    -      853185 - Preserve Formants
    -      853186 - Mid/Side
    -      853187 - Preserve Formants (Mid Side)
    -      853188 - Independent Phase
    -      853189 - Preserve Formants, Independent Phase
    -      853190 - Mid/Side, Independent Phase
    -      853191 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853200 - nothing
    -      853201 - Preserve Formants
    -      853202 - Mid/Side
    -      853203 - Preserve Formants (Mid Side)
    -      853204 - Independent Phase
    -      853205 - Preserve Formants, Independent Phase
    -      853206 - Mid/Side, Independent Phase
    -      853207 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853216 - nothing
    -      853217 - Preserve Formants
    -      853218 - Mid/Side
    -      853219 - Preserve Formants (Mid Side)
    -      853220 - Independent Phase
    -      853221 - Preserve Formants, Independent Phase
    -      853222 - Mid/Side, Independent Phase
    -      853223 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853232 - nothing
    -      853233 - Preserve Formants
    -      853234 - Mid/Side
    -      853235 - Preserve Formants (Mid Side)
    -      853236 - Independent Phase
    -      853237 - Preserve Formants, Independent Phase
    -      853238 - Mid/Side, Independent Phase
    -      853239 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853248 - nothing
    -      853249 - Preserve Formants
    -      853250 - Mid/Side
    -      853251 - Preserve Formants (Mid Side)
    -      853252 - Independent Phase
    -      853253 - Preserve Formants, Independent Phase
    -      853254 - Mid/Side, Independent Phase
    -      853255 - Preserve Formants, Mid/Side, Independent Phase
    
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, default, pitch mode, pitch</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_DefPitchMode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_DefPitchMode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_DefPitchMode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_DefPitchMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-DEFPITCHMODE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_DefPitchMode("c:\\tt.rpp")

function ultraschall.GetProject_TakeLane(projectfilename_with_path, ProjectStateChunk)
-- returns TakeLane state
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TakeLane</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer take_lane_state = ultraschall.GetProject_TakeLane(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the take-lane-state from an rpp-project-file or a ProjectStateChunk.
    
    It's the entry TAKELANE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer take_lane_state - take-lane-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, take, lane</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TakeLane","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TakeLane","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TakeLane","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TakeLane", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-(TAKELANE%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_TakeLane("c:\\tt.rpp")

function ultraschall.GetProject_SampleRate(projectfilename_with_path, ProjectStateChunk)
-- returns Project Settings Samplerate
--        a - Project Sample Rate
--        b - Checkbox: Project Sample Rate
--        c - Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_SampleRate</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer sample_rate, integer project_sample_rate, integer force_tempo_time_sig = ultraschall.GetProject_SampleRate(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the take-lane-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    
    It's the entry SAMPLERATE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer sample_rate - Project Sample Rate in Hz
    integer project_sample_rate - Checkbox: Project Sample Rate
    integer force_tempo_time_sig - Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples 
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, sample, rate, samplerate, tempo, time, signature</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_SampleRate","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_SampleRate","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_SampleRate","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_SampleRate", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-SAMPLERATE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s(.-)%s")),
         tonumber(ProjectStateChunk:match("%s.-%s.-%s(.-)%s"))
end

--A,AA,AAA=ultraschall.GetProject_SampleRate("c:\\tt.rpp")

function ultraschall.GetProject_TrackMixingDepth(projectfilename_with_path, ProjectStateChunk)
-- returns TrackMixingDepth
--          1 - 32 bit float
--          2 - 39 bit integer
--          3 - 24 bit integer
--          4 - 16 bit integer
--          5 - 12 bit integer
--          6 - 8 bit integer
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TrackMixingDepth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer track_mixing_depth = ultraschall.GetProject_TrackMixingDepth(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the track-mixing-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    It's the entry INTMIXMODE
    
    Returns -1 in case of error, nil if it's set to 64bit(default)!
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer track_mixing_depth - track mixing depth
    -nil - 64bit float (default)
    -1 - 32 bit float
    -2 - 39 bit integer
    -3 - 24 bit integer
    -4 - 16 bit integer
    -5 - 12 bit integer
    -6 - 8 bit integer
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, track, mixing, depth</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TrackMixingDepth","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return -1 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TrackMixingDepth","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return -1 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TrackMixingDepth","projectfilename_with_path", "File does not exist!", -3) return -1
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TrackMixingDepth", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return -1 end
  end
  -- get the values and return them
  ProjectStateChunk=ProjectStateChunk:match("<REAPER_PROJECT.-INTMIXMODE(%s.-)%c.-<RENDER_CFG").." "
  
  return tonumber(ProjectStateChunk:match("%s(.-)%s"))
end

--A=ultraschall.GetProject_TrackMixingDepth("c:\\tt.rpp")

function ultraschall.GetProject_TrackStateChunk(projectfilename_with_path, idx, deletetrackid, ProjectStateChunk)
-- returns a trackstatechunk from an rpp-projectfile
-- projectfilename_with_path - the projectfile
-- idx - the tracknumber you want to have
-- deletetrackid - deletes trackID, to avoid possible conflicts within a project, where it shall be imported to

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackstatechunk = ultraschall.GetProject_TrackStateChunk(string projectfilename_with_path, integer idx, boolean deletetrackid, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns an RPPXML-trackstatechunk from an rpp-project-file or a ProjectStateChunk, with tracknumber idx. IDX is 1 for the first track in the project-file, 2 for the second, etc
    Returns -1 in case of error.
    
    Use <a href="#GetProject_NumberOfTracks">GetProject_NumberOfTracks</a> to get the number of tracks within an rpp-file.
    
    The returned trackstatechunk can be inserted into the current project with <a href="#InsertTrack_TrackStateChunk">InsertTrack_TrackStateChunk</a>.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    integer idx - the tracknumber you want to have
    boolean deletetrackid - deletes the trackID in the trackstate-chunk, to avoid possible conflicts within a project, where it shall be imported to
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string trackstatechunk - an RPP-XML-Trackstate-chunk, that can be used by functions like reaper.SetTrackStateChunk()
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, track, chunk, rppxml, trackstate, trackstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TrackStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return -1 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TrackStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return -1 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TrackStateChunk","projectfilename_with_path", "File does not exist!", -3) return -1
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TrackStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return -1 end
  end
  -- get the values and return them
  local trackstate
  -- count til you found the right track
  for i=1,idx do
    trackstate=ProjectStateChunk:match("<TRACK.-%c%s%s>%c")
    if trackstate==nil then break end
    ProjectStateChunk=ProjectStateChunk:match("<TRACK.-%c%s%s%s%s>%c(.*)")
  end
  -- delete trackid, if requested
  if deletetrackid==true and trackstate~=nil then trackstate="<TRACK\n"..trackstate:match("%c(.*)")
    if trackstate:match("TRACKID")~=nil then trackstate=trackstate:match("(.-%c)%s-TRACKID")..trackstate:match("TRACKID.-%c(.*)") end
  end
  if trackstate==nil then ultraschall.AddErrorMessage("GetProject_TrackStateChunk","idx", "No such track exists!", -5) return -1 end
  return trackstate
end

--A=ultraschall.GetProject_TrackStateChunk("c:\\tt.rpp",2,true)

function ultraschall.GetProject_NumberOfTracks(projectfilename_with_path, GetProject_NumberOfTracks)
--returns the number of tracks within an rpp-projectfile
--beware of files with thousands of items, as this can take ages or even leave Reaper hang!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_NumberOfTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_tracks = ultraschall.GetProject_NumberOfTracks(string projectfilename_with_path, optional string GetProject_NumberOfTracks)</functioncall>
  <description>
    Returns the number of tracks within an rpp-project-file or a GetProject_NumberOfTracks.
    Returns -1 in case of error.
    
    Note: Beware of files with thousands of items, as this can take ages or even leave Reaper to hang!
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer number_of_tracks - the number of tracks within an projectfile
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, track, count</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_NumberOfTracks","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return -1 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_NumberOfTracks","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return -1 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_NumberOfTracks","projectfilename_with_path", "File does not exist!", -3) return -1
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_NumberOfTracks", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return -1 end
  end
  -- count tracks and return the number
  local count=0
  local trackstate=""
  while trackstate~=nil do
    trackstate=ProjectStateChunk:match("<TRACK.-%c%s%s>%c")
    if trackstate==nil then return count end
    count=count+1
    ProjectStateChunk=ProjectStateChunk:match("<TRACK.-%c%s%s%s%s>%c(.*)")
  end
  return count
end

--C=ultraschall.GetProject_NumberOfTracks("c:\\botz.RPP")

--MediaTrack=reaper.GetTrack(0,6)
--boolean=reaper.SetTrackStateChunk(MediaTrack, A, true)

--  reaper.ClearConsole()
--  reaper.ShowConsoleMsg(tostring(A))


function ultraschall.InsertTrack_TrackStateChunk(trackstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertTrack_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, MediaTrack MediaTrack = ultraschall.InsertTrack_TrackStateChunk(string trackstatechunk)</functioncall>
  <description>
    Creates a new track at the end of the project and sets it's trackstate, using the parameter trackstatechunk.
    Returns, if it succeeded and the newly created MediaTrack.
  </description>
  <parameters>
    string trackstatechunk - the rpp-xml-Trackstate-Chunk, as created by reaper.GetTrackStateChunk or <a href="#GetProject_TrackStateChunk">GetProject_TrackStateChunk</a>
  </parameters>
  <retvals>
    boolean retval - true, if creation succeeded, false if not
    MediaTrack MediaTrack - the newly created track, as MediaItem-trackobject
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackstring, track, create, trackstate, trackstatechunk, chunk, state</tags>
</US_DocBloc>
]]--
  if ultraschall.IsValidTrackStateChunk(trackstatechunk)==false then ultraschall.AddErrorMessage("InsertTrack_TrackStateChunk", "trackstatechunk", "Must be a valid TrackStateChunk", -1) return false end
  reaper.InsertTrackAtIndex(reaper.CountTracks(0), true)
  local MediaTrack=reaper.GetTrack(0,reaper.CountTracks(0)-1)
  if MediaTrack==nil then ultraschall.AddErrorMessage("InsertTrack_TrackStateChunk", "", "Couldn't create new track.", -2) return false end
  local bool=reaper.SetTrackStateChunk(MediaTrack, trackstatechunk, true)
  if bool==false then reaper.DeleteTrack(MediaTrack) ultraschall.AddErrorMessage("InsertTrack_TrackStateChunk", "trackstatechunk", "Couldn't set TrackStateChunk", -3) return false end
  return true, MediaTrack
end

--A=ultraschall.GetProject_TrackStateChunk("c:\\tt.rpp",3,true)
--B,B2=ultraschall.InsertTrack_TrackStateChunk(A)

function ultraschall.GetProject_Selection(projectfilename_with_path, ProjectStateChunk)
-- Set RippleState in a projectfilename_with_path
--  0 - no Ripple, 1 - Ripple One Track, 2 - Ripple All
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Selection</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number start_selection, number end_selection, number start_selection2, number end_selection2 = ultraschall.GetProject_Selection(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the selection-range from an RPP-Projectfile or a ProjectStateChunk.
    
    It's the entry SELECTION
    
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    number start_selection - start of the time-selection
    number end_selection - end of the time-selection
    number start_selection2 - start of the time-selection
    number end_selection2 - end of the time-selection
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, selection, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Selection","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Selection","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Selection","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Selection", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  ProjectStateChunk1=ProjectStateChunk:match("<REAPER_PROJECT.-SELECTION(%s.-)%c").." "
  ProjectStateChunk2=ProjectStateChunk:match("<REAPER_PROJECT.-SELECTION2(%s.-)%c").." "
  
  sel1_side1=tonumber(ProjectStateChunk1:match("%s(.-)%s"))
  sel1_side2=tonumber(ProjectStateChunk1:match("%s.-%s(.-)%s"))
  sel2_side1=tonumber(ProjectStateChunk2:match("%s(.-)%s"))
  sel2_side2=tonumber(ProjectStateChunk2:match("%s.-%s(.-)%s"))  
  
  if sel1_side1>sel1_side2 then sel1_side1,sel1_side2=sel1_side2,sel1_side1 end
  if sel2_side1>sel2_side2 then sel2_side1,sel2_side2=sel2_side2,sel2_side1 end
  return sel1_side1, sel1_side2, sel2_side1, sel2_side2
end

--P,PN=reaper.EnumProjects(-1,"")
--A1,A2,A3,A4=ultraschall.GetProject_Selection(PN)



--- Set ---

function ultraschall.SetProject_RippleState(projectfilename_with_path, ripple_state, ProjectStateChunk)
-- Set RippleState in a projectfilename_with_path
--  0 - no Ripple, 1 - Ripple One Track, 2 - Ripple All
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RippleState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RippleState(string projectfilename_with_path, integer ripple_state, optional string ProjectStatechunk)</functioncall>
  <description>
    Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer ripple_state - 0, no Ripple; 1, Ripple One Track; 2, Ripple All
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, ripple, all, one</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RippleState", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RippleState", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RippleState", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(ripple_state)~="integer" then ultraschall.AddErrorMessage("SetProject_RippleState", "ripple_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RippleState", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RIPPLE%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RIPPLE%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..ripple_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.ReadFullFile("c:\\tt.rpp")
--B,C=ultraschall.SetProject_RippleState("c:\\tt.RPP", 1, A)

function ultraschall.SetProject_Selection(projectfilename_with_path, starttime, endtime, starttime2, endtime2, ProjectStateChunk)
-- Set RippleState in a projectfilename_with_path
--  0 - no Ripple, 1 - Ripple One Track, 2 - Ripple All
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_Selection</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_Selection(string projectfilename_with_path, number starttime, number endtime, number starttime2, number endtime2, optional string ProjectStatechunk)</functioncall>
  <description>
    Sets the ripple-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number starttime - start of the selection in seconds
    number endtime - end of the selection in seconds
    number starttime2 - start of the second selection in seconds
    number endtime2 - end of the second selection in seconds
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, ripple, all, one</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Selection", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_Selection", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Selection", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(starttime)~="number" then ultraschall.AddErrorMessage("SetProject_Selection", "starttime", "Must be an integer", -4) return -1 end
  if type(endtime)~="number" then ultraschall.AddErrorMessage("SetProject_Selection", "endtime", "Must be an integer", -5) return -1 end
  if type(starttime2)~="number" then ultraschall.AddErrorMessage("SetProject_Selection", "starttime", "Must be an integer", -6) return -1 end
  if type(endtime2)~="number" then ultraschall.AddErrorMessage("SetProject_Selection", "endtime", "Must be an integer", -7) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Selection", "projectfilename_with_path", "No valid RPP-Projectfile!", -8) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-SELECTION%s).-%c")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-SELECTION2%s.-%c(.*)")
  
  ProjectStateChunk=FileStart..starttime.." "..endtime.."\n  SELECTION2 "..starttime2.." "..endtime2.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.ReadFullFile("c:\\tt.rpp")
--B,C=ultraschall.SetProject_Selection("c:\\A-.RPP", 1,2,3,4, A)
--D,E,F,G=ultraschall.GetProject_Selection("c:\\A-.RPP", 1,2,3,4, A)


--AB=ultraschall.GetProject_RippleState("c:\\tt.rpp")
--reaper.ShowConsoleMsg(A)

function ultraschall.SetProject_GroupOverride(projectfilename_with_path, group_override1, group_override2, group_override3, ProjectStateChunk)
-- Sets Group Override
-- integer state1 - 
-- integer state2 - 
-- integer state3 - 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_GroupOverride</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_GroupOverride(string projectfilename_with_path, integer group_override1, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the group-override-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer group_override1 - the group-override state
    integer group_override2 - the group-override state
    integer group_override3 - the group-override state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, group, override</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_GroupOverride", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_GroupOverride", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_GroupOverride", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(group_override1)~="integer" then ultraschall.AddErrorMessage("SetProject_GroupOverride", "group_override1", "Must be an integer", -4) return -1 end
  if math.type(group_override2)~="integer" then ultraschall.AddErrorMessage("SetProject_GroupOverride", "group_override2", "Must be an integer", -5) return -1 end
  if math.type(group_override3)~="integer" then ultraschall.AddErrorMessage("SetProject_GroupOverride", "group_override3", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_GroupOverride", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-GROUPOVERRIDE%s).-%s.-%s.-%s.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-GROUPOVERRIDE%s.-%s.-%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..group_override1.." "..group_override2.." "..group_override3.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA,AAA=ultraschall.SetProject_GroupOverride("c:\\tt.rpp",1,2,3)
--reaper.MB(AA,"",0)
--A,AA,AAA=ultraschall.GetProject_GroupOverride("c:\\tt.rpp")

function ultraschall.SetProject_AutoCrossFade(projectfilename_with_path, autocrossfade_state, ProjectStateChunk)
-- sets AutoCrossFade in a projectfilename_with_path
-- integer state
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_AutoCrossFade</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_AutoCrossFade(string projectfilename_with_path, integer autocrossfade_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the autocrossfade-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer autocrossfade_state - autocrossfade-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, autocrossfade, crossfade</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AutoCrossFade", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_AutoCrossFade", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AutoCrossFade", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(autocrossfade_state)~="integer" then ultraschall.AddErrorMessage("SetProject_AutoCrossFade", "autocrossfade_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AutoCrossFade", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-AUTOXFADE%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-AUTOXFADE%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..autocrossfade_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA=ultraschall.SetProject_AutoCrossFade("c:\\tt.rpp",9)
--A=ultraschall.GetProject_AutoCrossFade("c:\\tt.rpp")
--reaper.ShowConsoleMsg(AA:sub(1,1000))

function ultraschall.SetProject_EnvAttach(projectfilename_with_path, env_attach, ProjectStateChunk)
-- sets Enc Attach
-- integer state - 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_EnvAttach</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_EnvAttach(string projectfilename_with_path, integer env_attach, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the env_attach-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer env_attach  - env_attach-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, env, attach, envattach</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_EnvAttach", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_EnvAttach", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_EnvAttach", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(env_attach)~="integer" then ultraschall.AddErrorMessage("SetProject_EnvAttach", "env_attach", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_EnvAttach", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-ENVATTACH%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-ENVATTACH%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..env_attach.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end    
end

--A,AA=ultraschall.SetProject_EnvAttach("c:\\tt.rpp",6)
--A=ultraschall.GetProject_EnvAttach("c:\\tt.rpp")

function ultraschall.SetProject_MixerUIFlags(projectfilename_with_path, state_bitfield1, state_bitfield2, ProjectStateChunk)
--integer state_bitfield1 
--         0 - Show tracks in folders, Auto arrange tracks in mixer
--         1 - Show normal top level tracks
--         2 - Show Folders
--         4 - Group folders to left
--         8 - Show tracks that have receives
--         16 - Group tracks that have receives to left
--         32 - don't show tracks that are in folder
--         64 - No Autoarrange tracks in mixer
--         128 - ?
--         256 - ?

--integer state_bitfield2 
--         0 - Master track in mixer
--         1 - Don't show multiple rows of tracks, when size permits
--         2 - Show maximum rows even when tracks would fit in less rows
--         4 - Master Show on right side of mixer
--         8 - ?
--         16 - Show FX inserts when size permits
--         32 - Show sends when size permits
--         64 - Show tracks in mixer
--         128 - Show FX parameters, when size permits
--         256 - Don't show Master track in mixer

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_MixerUIFlags</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer state_bitfield1, integer state_bitfield2 = ultraschall.SetProject_MixerUIFlags(string projectfilename_with_path, integer state_bitfield1, integer state_bitfield2, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the Mixer-UI-state-flags in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer state_bitfield1 - folders, receives, etc 
    -             0 - Show tracks in folders, Auto arrange tracks in mixer
    -             1 - Show normal top level tracks
    -             2 - Show Folders
    -             4 - Group folders to left
    -             8 - Show tracks that have receives
    -             16 - Group tracks that have receives to left
    -             32 - don't show tracks that are in folder
    -             64 - No Autoarrange tracks in mixer
    -             128 - ?
    -             256 - ?
    
    integer state_bitfield2 - master-track, FX, Mixer
    -             0 - Master track in mixer
    -             1 - Don't show multiple rows of tracks, when size permits
    -             2 - Show maximum rows even when tracks would fit in less rows
    -             4 - Master Show on right side of mixer
    -             8 - ?
    -             16 - Show FX inserts when size permits
    -             32 - Show sends when size permits
    -             64 - Show tracks in mixer
    -             128 - Show FX parameters, when size permits
    -             256 - Don't show Master track in mixer
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, mixer, ui, flags, folders, tracks, master, fx, groups</tags>
</US_DocBloc>
]]         
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(state_bitfield1)~="integer" then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "state_bitfield1", "Must be an integer", -4) return -1 end
  if math.type(state_bitfield2)~="integer" then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "state_bitfield2", "Must be an integer", -5) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MixerUIFlags", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-MIXERUIFLAGS%s).-%s.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-MIXERUIFLAGS%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..tonumber(state_bitfield1).." "..tonumber(state_bitfield2).."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA=ultraschall.SetProject_MixerUIFlags("c:\\tt.rpp", 1, 2)
--A,AA=ultraschall.GetProject_MixerUIFlags("c:\\tt.rpp")

function ultraschall.SetProject_PeakGain(projectfilename_with_path, peakgain_state, ProjectStateChunk)
-- number state - 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_PeakGain</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_PeakGain(string projectfilename_with_path, number peakgain_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the peak-gain-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number peakgain_state  - peak-gain-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, peak, gain, peakgain</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PeakGain", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_PeakGain", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PeakGain", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(peakgain_state)~="number" then ultraschall.AddErrorMessage("SetProject_PeakGain", "peakgain_state", "Must be a number", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PeakGain", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-PEAKGAIN%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-PEAKGAIN%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..peakgain_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,A2=ultraschall.SetProject_PeakGain("c:\\tt.rpp", 2.87)
--A=ultraschall.GetProject_PeakGain("c:\\tt.rpp")

function ultraschall.SetProject_Feedback(projectfilename_with_path, feedback_state, ProjectStateChunk)
-- integer state - 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_Feedback</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_Feedback(string projectfilename_with_path, integer feedback_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the feedback-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer feedback_state - feedback-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, feedback</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Feedback", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_Feedback", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Feedback", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(feedback_state)~="integer" then ultraschall.AddErrorMessage("SetProject_Feedback", "feedback_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Feedback", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-FEEDBACK%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-FEEDBACK%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..feedback_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_Feedback("c:\\tt.rpp", 4)
--B=ultraschall.GetProject_Feedback("c:\\tt.rpp", 0)

function ultraschall.SetProject_PanLaw(projectfilename_with_path, panlaw_state, ProjectStateChunk)
-- number state - as set in the project-settings->Advanced->Pan law/mode->Pan:law(db)
--                0.5(-6.02 db) to 1(default +0.0 db)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_PanLaw</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_PanLaw(string projectfilename_with_path, number panlaw_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the panlaw-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number panlaw_state - state of the panlaw, as set in the project-settings->Advanced->Pan law/mode->Pan:law(db). 0.5(-6.02 db) to 1(default +0.0 db)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, pan, law, pan law</tags>
</US_DocBloc>
]]  
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanLaw", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_PanLaw", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanLaw", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(panlaw_state)~="number" then ultraschall.AddErrorMessage("SetProject_PanLaw", "state", "Must be a number", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanLaw", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-PANLAW%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-PANLAW%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..panlaw_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_PanLaw("c:\\tt.rpp",9.786)
--B=ultraschall.GetProject_PanLaw("c:\\tt.rpp")

function ultraschall.SetProject_ProjOffsets(projectfilename_with_path, start_time, start_measure, base_ruler_marking_off_this_measure, ProjectStateChunk)
-- number state1
-- integer state2
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_ProjOffsets</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_ProjOffsets(string projectfilename_with_path, number start_time, integer start_measure, integer base_ruler_marking_off_this_measure, optional ProjectStateChunk)</functioncall>
  <description>
    Sets the project-offset-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    
    The project-offset, as set in the ProjectSettings -> Project Time Start, Project start measure and Base Ruler Marking Off This Measure-checkbox
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number start_time - the project-start-time in seconds
    integer start_measure - the start-measure; starting with 0, unlike in the Project-Settings-window, where the 0 becomes 1 as startmeasure
    integer base_ruler_marking_off_this_measure - 0, checkbox unchecked; 1, checkbox checked
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, project, offset, start, starttime, measure</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(start_time)~="number" then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "start_time", "Must be a number", -4) return -1 end
  if math.type(start_measure)~="integer" then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "start_measure", "Must be an integer", -5) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ProjOffsets", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-PROJOFFS%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-PROJOFFS%s.-%c(.-<RECORD_CFG.*)")
  ProjectStateChunk=FileStart..start_time.." "..start_measure.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A,AA=ultraschall.SetProject_ProjOffsets("c:\\tt.rpp", 2,1)
--A,AA=ultraschall.SetProject_ProjOffsets("c:\\tt.rpp", "8","4")
--A,AA=ultraschall.GetProject_ProjOffsets("c:\\tt.rpp")

--

function ultraschall.SetProject_MaxProjectLength(projectfilename_with_path, limit_project_length, projectlength_limit, ProjectStateChunk)
-- integer state1 - 
-- number state 2 - 
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_MaxProjectLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_MaxProjectLength(string projectfilename_with_path, integer limit_project_length, number projectlength_limit, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the max-project-length-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer limit_project_length - checkbox "Limit project length, stop playback/recording at:" - 0 off, 1 on
    number projectlength_limit - projectlength-limit in seconds
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, project, end, length, limit</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(limit_project_length)~="integer" then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "limit_project_length", "Must be an integer", -4) return -1 end
  if type(projectlength_limit)~="number" then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "projectlength_limit", "Must be a number", -5) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_MaxProjectLength", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-MAXPROJLEN%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-MAXPROJLEN%s.-%c(.-<RECORD_CFG.*)")
  ProjectStateChunk=FileStart..limit_project_length.." "..projectlength_limit.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA=ultraschall.SetProject_MaxProjectLength("c:\\tt.rpp",3,2)
--A,AA=ultraschall.GetProject_MaxProjectLength("c:\\tt.rpp",1,2)

function ultraschall.SetProject_Grid(projectfilename_with_path, gridstate1, gridstate2, gridstate3, gridstate4, gridstate5, gridstate6, gridstate7, gridstate8, ProjectStateChunk)
-- integer state1 - 
-- integer state2 - 
-- number state3 - 
-- integer state4 -
-- number state5 -
-- integer state6 -
-- integer state7 -
-- number state8 - 

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_Grid</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_Grid(string projectfilename_with_path, integer gridstate1, integer gridstate2, number gridstate3, integer gridstate4, number gridstate5, integer gridstate6, integer gridstate7, number gridstate8, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the setproject-grid-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer gridstate1 - gridstate1
    integer gridstate2 - gridstate2
    number gridstate3 - gridstate3
    integer gridstate4 - gridstate4
    number gridstate5 - gridstate5
    integer gridstate6 - gridstate6
    integer gridstate7 - gridstate7
    number gridstate8 - gridstate8
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, grid</tags>
</US_DocBloc>
]]

  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Grid", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_Grid", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Grid", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(gridstate1)~="integer" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate1", "Must be an integer", -4) return -1 end
  if math.type(gridstate2)~="integer" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate2", "Must be an integer", -5) return -1 end
  if type(gridstate3)~="number" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate3", "Must be an integer", -6) return -1 end  
  if math.type(gridstate4)~="integer" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate4", "Must be an integer", -7) return -1 end
  if type(gridstate5)~="number" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate5", "Must be an integer", -8) return -1 end  
  if math.type(gridstate6)~="integer" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate6", "Must be an integer", -9) return -1 end
  if math.type(gridstate7)~="integer" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate7", "Must be an integer", -10) return -1 end
  if type(gridstate8)~="number" then ultraschall.AddErrorMessage("SetProject_Grid", "gridstate8", "Must be an integer", -11) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Grid", "projectfilename_with_path", "No valid RPP-Projectfile!", -12) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-GRID%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-GRID%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..gridstate1.." "..gridstate2.." "..gridstate3.." "..gridstate4.." "..gridstate5.." "..gridstate6.." "..gridstate7.." "..gridstate8.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_Grid("c:\\tt.rpp", 9,10,11,12,13,14,15,16,17)
--A,A1,A2,A3,A4,A5,A6,A7,A8,A9=ultraschall.GetProject_Grid("c:\\tt.rpp")


function ultraschall.SetProject_Timemode(projectfilename_with_path, timemode1, timemode2, showntime, timemode4, timemode5, ProjectStateChunk)
-- integer state1
-- integer state2
-- integer showntime - Transport shown time
--      -1 - use ruler time unit
--       0 - minutes:seconds
--       1 - measures:beats/minutes:seconds
--       2 - measures:beats
--       3 - seconds
--       4 - samples
--       5 - hours:minutes:seconds:frames
--       8 - absolute frames
-- integer state4
-- integer state5

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_Timemode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_Timemode(string projectfilename_with_path, integer timemode1, integer timemode2, integer showntime, integer timemode4, integer timemode5, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the timemode-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer ruler_timemode - ruler-timemode-state
      - -1, Use ruler time unit
      -  0, Minutes:Seconds
      -  1, Measures.Beats / Minutes:Seconds
      -  2, Measures.Beats
      -  3, Seconds
      -  4, Samples
      -  5, Hours:Minutes:Seconds:Frames
      -  8, Absolute Frames
    integer timemode2 - timemode-state
    integer showntime - Transport shown time
    -              -1 - use ruler time unit
    -              0 - minutes:seconds
    -              1 - measures:beats/minutes:seconds
    -              2 - measures:beats
    -              3 - seconds
    -              4 - samples
    -              5 - hours:minutes:seconds:frames
    -              8 - absolute frames
    integer timemode4 - timemode-state
    integer timemode5 - timemode-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, timemode</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Timemode", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_Timemode", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Timemode", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(timemode1)~="integer" then ultraschall.AddErrorMessage("SetProject_Timemode", "timemode1", "Must be an integer", -4) return -1 end
  if math.type(timemode2)~="integer" then ultraschall.AddErrorMessage("SetProject_Timemode", "timemode2", "Must be an integer", -5) return -1 end
  if math.type(showntime)~="integer" then ultraschall.AddErrorMessage("SetProject_Timemode", "showntime", "Must be an integer", -6) return -1 end
  if math.type(timemode4)~="integer" then ultraschall.AddErrorMessage("SetProject_Timemode", "timemode4", "Must be an integer", -7) return -1 end
  if math.type(timemode5)~="integer" then ultraschall.AddErrorMessage("SetProject_Timemode", "timemode5", "Must be an integer", -8) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Timemode", "projectfilename_with_path", "No valid RPP-Projectfile!", -9) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-TIMEMODE%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-TIMEMODE%s.-%c(.-<RECORD_CFG.*)")
  ProjectStateChunk=FileStart..timemode1.." "..timemode2.." "..showntime.." "..timemode4.." "..timemode5.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_Timemode("c:\\tt.rpp")
--A,A2,A3,A4,A5=ultraschall.GetProject_Timemode("c:\\tt.rpp",1,2,3,4,5)
--A,A2,A3,A4,A5=ultraschall.SetProject_Timemode("c:\\tt.rpp",2,3,4,5,6)
--A,A2,A3,A4,A5=ultraschall.GetProject_Timemode("c:\\tt.rpp",1,2,3,4,5)

-- MESPOTINE - hier gehts weiter

function ultraschall.SetProject_VideoConfig(projectfilename_with_path, preferredVidSizeX, preferredVidSizeY, settingsBitfield, ProjectStateChunk)
-- integer preferredVidSizeX - preferred video size, x pixels
-- integer preferredVidSizeY - preferred video size, y pixels
-- integer settingsBitfield3 - settings
--              0 - turned on/selected: use high quality filtering, 
--                      preserve aspect ratio(letterbox) when resizing, Items in higher numbered tracks replace lower,
--                      as well as Video colorspace set to Auto
--              1 - Video colorspace: I420/YV12
--              2 - Video colorspace: YUV2
--              3 - RGB
--              256 - Items in lower numbered tracks replace higher
--              512 - Always resize video sources to preferred video size
--              1024 - Always resize output to preferred video size
--              2048 - turn off "Use high quality filtering when resizing"
--              4096 - turn off "preserve aspect ratio (letterbox) when resizing"
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_VideoConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_VideoConfig(string projectfilename_with_path, integer preferredVidSizeX, integer preferredVidSizeY, integer settingsBitfield, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the video-config-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer preferredVidSizeX - preferred video size, x pixels
    integer preferredVidSizeY - preferred video size, y pixels
    integer settingsBitfield - settings
    -             0 - turned on/selected: use high quality filtering, preserve aspect ratio(letterbox) when resizing,
    -                                     Video colorspace set to Auto,
    -                                     Items in higher numbered tracks replace lower, as well as Video colorspace set to Auto
    -             1 - Video colorspace: I420/YV12
    -             2 - Video colorspace: YUV2
    -             3 - RGB
    -             256 - Items in lower numbered tracks replace higher
    -             512 - Always resize video sources to preferred video size
    -             1024 - Always resize output to preferred video size
    -             2048 - turn off "Use high quality filtering when resizing"
    -             4096 - turn off "preserve aspect ratio (letterbox) when resizing"
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, video, videoconfig</tags>
</US_DocBloc>
]]         
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VideoConfig", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_VideoConfig", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VideoConfig", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(preferredVidSizeX)~="integer" then ultraschall.AddErrorMessage("SetProject_VideoConfig", "preferredVidSizeX", "Must be an integer", -4) return -1 end
  if math.type(preferredVidSizeY)~="integer" then ultraschall.AddErrorMessage("SetProject_VideoConfig", "preferredVidSizeY", "Must be an integer", -5) return -1 end
  if math.type(settingsBitfield)~="integer"  then ultraschall.AddErrorMessage("SetProject_VideoConfig", "settingsBitfield", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VideoConfig", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-VIDEO_CONFIG%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-VIDEO_CONFIG%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..preferredVidSizeX.." "..preferredVidSizeY.." "..settingsBitfield.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA=ultraschall.SetProject_VideoConfig("c:\\tt.rpp",3,4,5)
--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA=ultraschall.SetProject_VideoConfig("c:\\tt.rpp")
--A,AA,AAA=ultraschall.GetProject_VideoConfig("c:\\tt.rpp",1,2,3)

function ultraschall.SetProject_PanMode(projectfilename_with_path, panmode_state, ProjectStateChunk)
-- Panmode as set in ProjectSettings->Advanced->Pan law/mode->Pan mode
-- integer state - 3 Stereo balance / mono pan (default)
--                 5 Stereo pan
--                 6 Dual Pan
--                 0 reaper 3.x balance (deprecated)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_PanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_PanMode(string projectfilename_with_path, integer panmode_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the panmode-settings, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer panmode_state - panmode-state - ProjectSettings->Advanced->Pan law/mode->Pan mode
    -             0 reaper 3.x balance (deprecated)
    -             3 Stereo balance / mono pan (default)
    -             5 Stereo pan
    -             6 Dual Pan
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, panmode</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanMode", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_PanMode", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanMode", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(panmode_state)~="integer" then ultraschall.AddErrorMessage("SetProject_PanMode", "panmode_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_PanMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-PANMODE%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-PANMODE%s.-%c(.-<RECORD_CFG.*)")
  if FileStart==nil or FileEnd==nil then 
    FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-)CURSOR.-<RECORD_CFG.*")
    FileEnd="  "..ProjectStateChunk:match("<REAPER_PROJECT.-(CURSOR.-<RECORD_CFG.*)")
    panmode_state="PANMODE "..panmode_state
  end
  
  ProjectStateChunk=FileStart..panmode_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_PanMode("c:\\tt.rpp", 1)
--A=ultraschall.SetProject_PanMode("c:\\tt.rpp", "99")
--A=ultraschall.GetProject_PanMode("c:\\tt.rpp", 0)

function ultraschall.SetProject_CursorPos(projectfilename_with_path, cursorpos, ProjectStateChunk)
-- number timeposition - in seconds
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_CursorPos</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_CursorPos(string projectfilename_with_path, number cursorpos, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the cursor-position in an rpp-project-file or a ProjectStateChunk
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number cursorpos - editcursorposition in seconds
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, cursor, position, cursorposition, editcursor, edit</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_CursorPos", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_CursorPos", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_CursorPos", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(cursorpos)~="integer" then ultraschall.AddErrorMessage("SetProject_CursorPos", "cursorpos", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_CursorPos", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-CURSOR%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-CURSOR%s.-%c(.-<RECORD_CFG.*)")
  ProjectStateChunk=FileStart..cursorpos.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_CursorPos("c:\\tt.rpp")
--A=ultraschall.SetProject_CursorPos("c:\\tt.rpp",8)
--A=ultraschall.GetProject_CursorPos("c:\\tt.rpp",1.954658736589369)

function ultraschall.SetProject_HorizontalZoom(projectfilename_with_path, hzoom, hzoomscrollpos, scrollbarfactor, ProjectStateChunk)
-- number HZoomfactor - 0.007 to 1000000, horizontal zoom factor
-- integer HScrollbarPos - 0 - 4294967296; horizontal scrollbar position
-- integer Scrollbarfactor - 0 to 500837, counts up, when maximum HScrollbarPos overflows
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_HorizontalZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_HorizontalZoom(string projectfilename_with_path, number hzoom, integer hzoomscrollpos, integer scrollbarfactor, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the horizontal-zoom in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    number hzoom - HorizontalZoomfactor, 0.007 to 1000000
    integer hzoomscrollpos - horizontalscrollbarposition - 0 - 4294967296
    integer scrollbarfactor - 0 to 500837, counts up, when maximum hzoomscrollpos overflows
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, zoom, horizontal, scrollbar, factor</tags>
</US_DocBloc>
]]         
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(hzoom)~="number" then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "hzoom", "Must be a number", -4) return -1 end
  if math.type(hzoomscrollpos)~="integer" then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "hzoomscrollpos", "Must be an integer", -5) return -1 end
  if math.type(scrollbarfactor)~="integer" then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "scrollbarfactor", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_HorizontalZoom", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-ZOOM%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-ZOOM%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..hzoom.." "..hzoomscrollpos.." "..scrollbarfactor.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA=ultraschall.SetProject_Zoom("c:\\tt.rpp")
--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA=ultraschall.SetProject_HorizontalZoom("c:\\tt.rpp",2,3,4)
--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA=ultraschall.GetProject_HorizontalZoom("c:\\tt.rpp",10,11,12)

function ultraschall.SetProject_VerticalZoom(projectfilename_with_path, vzoom, ProjectStateChunk)
--integer verticalzoom - 0-40; zoomfactor for vertical zoom
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_VerticalZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_VerticalZoom(string projectfilename_with_path, integer vzoom, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the vertical-zoom from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer vzoom - vertical zoomfactor(0-40)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, zoom, vertical, scrollbar, factor</tags>
</US_DocBloc>
]]         
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VerticalZoom", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_VerticalZoom", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VerticalZoom", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(vzoom)~="integer" then ultraschall.AddErrorMessage("SetProject_VerticalZoom", "vzoom", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_VerticalZoom", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-VZOOMEX%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-VZOOMEX%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..vzoom.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_VerticalZoom("c:\\tt.rpp",18)
--A=ultraschall.SetProject_VerticalZoom("c:\\tt.rpp","a")
--A=ultraschall.GetProject_VerticalZoom("c:\\tt.rpp",10)

function ultraschall.SetProject_UseRecConfig(projectfilename_with_path, rec_cfg, ProjectStateChunk)
--
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_UseRecConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_UseRecConfig(string projectfilename_with_path, integer rec_cfg, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer rec_cfg - recording-cfg-state
    -              0 - Automatic .wav (recommended)
    -              1 - Custom (use ultraschall.GetProject_ApplyFXCFG to get recording_cfg_string)
    -              2 - Recording Format
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, rec, config</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_UseRecConfig", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_UseRecConfig", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_UseRecConfig", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(rec_cfg)~="integer" then ultraschall.AddErrorMessage("SetProject_UseRecConfig", "rec_cfg", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_UseRecConfig", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-USE_REC_CFG%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-USE_REC_CFG%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart..rec_cfg.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_UseRecConfig("c:\\tt.rpp", 10)
--A=ultraschall.GetProject_UseRecConfig("c:\\tt.rpp", 0)

function ultraschall.SetProject_RecMode(projectfilename_with_path, rec_mode, ProjectStateChunk)
--returns Recording Mode
-- 0 - Autopunch/Selected Items
-- 1 - normal
-- 2 - Time Selection/Auto Punch

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RecMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RecMode(string projectfilename_with_path, integer rec_mode, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the recording-mode-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer rec_mode - recording mode
                    - 0, Autopunch/Selected Items
                    - 1, normal
                    - 2, Time Selection/Auto Punch
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, rec, mode</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecMode", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RecMode", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecMode", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(rec_mode)~="integer" then ultraschall.AddErrorMessage("SetProject_RecMode", "rec_mode", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RECMODE%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RECMODE%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..rec_mode.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_RecMode("c:\\tt.rpp",7)
--A=ultraschall.GetProject_RecMode("c:\\tt.rpp",1)

function ultraschall.SetProject_SMPTESync(projectfilename_with_path, smptesync_state1, smptesync_fps, smptesync_resyncdrift, smptesync_skipdropframes, smptesync_syncseek, smptesync_freewheel, smptesync_userinput, smptesync_offsettimecode, smptesync_stop_rec_drift, smptesync_state10, smptesync_stop_rec_lacktime, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_SMPTESync</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_SMPTESync(string projectfilename_with_path, integer smptesync_state1, number smptesync_fps, integer smptesync_resyncdrift, integer smptesync_skipdropframes, integer smptesync_syncseek, integer smptesync_freewheel, integer smptesync_userinput, number smptesync_offsettimecode, integer smptesync_stop_rec_drift, integer smptesync_state10, integer smptesync_stop_rec_lacktime, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the TimeCodeSyncronization-SMPTE-Config in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer smptesync_state1 - flag 
    -             0 - external timecode synchronization disabled
    -             1 - external timecode synchronization enabled
    -             4 - Start playback on valid timecode when stopped
    -             8 - turned off: display flashing notification window when waiting for sync for recording
    -             16 - playback off
    -             32 - recording off
    -             256 - MTC - 24/30fps MTC is 23.976/29.97ND works only with smptesync_userinput set to 4159
    -             512 - MTC - 24/30fps MTC is 24/30ND
    
    number smptesync_fps - framerate in fps
    integer smptesync_resyncdrift - "Re-synchronize if drift exceeds" in ms (0 = never)
    integer smptesync_skipdropframes - "skip/drop frames if drift exceeds" in ms(0 - never)
    integer smptesync_syncseek - "Synchronize by seeking ahead" in ms (default = 1000)
    integer smptesync_freewheel - "Freewheel on missing time code for up to" in ms(0 = forever)
    integer smptesync_userinput - User Input-flag
    -             0 - LTC: Input 1
    -             1 - LTC: Input 2
    -             4159 - MTC - All inputs - 24/30 fps MTC 23.976ND/29.97ND if project is ND
    -             4223 - SPP: All Inputs
    -             8192 - ASIO Positioning Protocol
    
    number smptesync_offsettimecode - Offset incoming timecode by in seconds
    integer smptesync_stop_rec_drift - "Stop recording if drift exceeds" in ms(0 = never)
    integer smptesync_state10 - smptesync-state
    integer smptesync_stop_rec_lacktime - "stop recording on lack of timecode after" in ms(0 = never)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, smpte, sync</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SMPTESync", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_SMPTESync", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SMPTESync", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(smptesync_state1)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_state1", "Must be an integer", -4) return -1 end
  if type(smptesync_fps)~="number" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_fps", "Must be an integer", -5) return -1 end
  if math.type(smptesync_resyncdrift)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_resyncdrift", "Must be an integer", -6) return -1 end
  if math.type(smptesync_skipdropframes)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_skipdropframes", "Must be an integer", -7) return -1 end
  if math.type(smptesync_syncseek)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_syncseek", "Must be an integer", -8) return -1 end
  if math.type(smptesync_freewheel)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_freewheel", "Must be an integer", -9) return -1 end
  if math.type(smptesync_userinput)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_userinput", "Must be an integer", -10) return -1 end
  if type(smptesync_offsettimecode)~="number" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_offsettimecode", "Must be an integer", -11) return -1 end
  if math.type(smptesync_stop_rec_drift)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_stop_rec_drift", "Must be an integer", -12) return -1 end
  if math.type(smptesync_state10)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_state10", "Must be an integer", -13) return -1 end
  if math.type(smptesync_stop_rec_lacktime)~="integer" then ultraschall.AddErrorMessage("SetProject_SMPTESync", "smptesync_stop_rec_lacktime", "Must be an integer", -14) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SMPTESync", "projectfilename_with_path", "No valid RPP-Projectfile!", -15) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-SMPTESYNC%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-SMPTESYNC%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart.." "..smptesync_state1.." "..smptesync_fps.." "..smptesync_resyncdrift.." "..smptesync_skipdropframes.." "..smptesync_syncseek.." "..smptesync_freewheel.." "..smptesync_userinput.." "..smptesync_offsettimecode.." "..smptesync_stop_rec_drift.." "..smptesync_state10.." "..smptesync_stop_rec_lacktime.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--B=ultraschall.SetProject_SMPTESync("c:\\tt.rpp",2,3,4,5,6,7,8,9,10,11,12)
--A,AA,AAA,AAAA,AAAAA,AAAAAA,AAAAAAA,AAAAAAAA,AAAAAAAAA,AL,AM,AN,AO=ultraschall.GetProject_SMPTESync("c:\\tt.rpp",1,2,3,4,5,6,7,8,9,10,11)

function ultraschall.SetProject_Loop(projectfilename_with_path, loopbutton_state, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_Loop</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_Loop(string projectfilename_with_path, integer loopbutton_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the UseRec-Config in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer loop_mode - loopbutton-state, 0, off; 1, on
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, loop, button</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Loop", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_Loop", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Loop", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(loopbutton_state)~="integer" then ultraschall.AddErrorMessage("SetProject_Loop", "loopbutton_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_Loop", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-LOOP%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-LOOP%s.-%c(.-<RECORD_CFG.*)")

  ProjectStateChunk=FileStart..loopbutton_state.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--B=ultraschall.SetProject_Loop("c:\\tt.rpp",11)
--A=ultraschall.GetProject_Loop("c:\\tt.rpp",1)

function ultraschall.SetProject_LoopGran(projectfilename_with_path, loopgran_state1, loopgran_state2, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_LoopGran</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_LoopGran(string projectfilename_with_path, integer loopgran_state1, number loopgran_state2, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the Loop-Gran-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer loopgran_state1 - loopgran_state1
    number loopgran_state2 - loopgran_state2
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, loop, gran</tags>
</US_DocBloc>
]]         
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_LoopGran", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_LoopGran", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_LoopGran", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(loopgran_state1)~="integer" then ultraschall.AddErrorMessage("SetProject_LoopGran", "loopgran_state1", "Must be an integer", -4) return -1 end
  if type(loopgran_state2)~="number" then ultraschall.AddErrorMessage("SetProject_LoopGran", "loopgran_state2", "Must be an integer", -5) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_LoopGran", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-LOOPGRAN%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-LOOPGRAN%s.-%c(.-<RECORD_CFG.*)")
  ProjectStateChunk=FileStart..loopgran_state1.." "..loopgran_state2.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A,AA=ultraschall.SetProject_LoopGran("c:\\tt.rpp",3,6)
--A,AA=ultraschall.GetProject_LoopGran("c:\\tt.rpp",1,2)

function ultraschall.SetProject_RecPath(projectfilename_with_path, prim_recpath, sec_recpath, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RecPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RecPath(string projectfilename_with_path, string prim_recpath, string sec_recpath, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the primary and secondary recording-paths in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    string prim_recpath - primary recording path
    string sec_recpath - secondary recording path
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, path, primary, secondary</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecPath", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RecPath", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecPath", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(prim_recpath)~="string" then ultraschall.AddErrorMessage("SetProject_RecPath", "prim_recpath", "Must be a string", -4) return -1 end
  if type(sec_recpath)~="string" then ultraschall.AddErrorMessage("SetProject_RecPath", "sec_recpath", "Must be a string", -5) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecPath", "projectfilename_with_path", "No valid RPP-Projectfile!", -6) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RECORD_PATH%s).-%c.-<RECORD_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RECORD_PATH%s.-%c(.-<RECORD_CFG.*)")
  
  ProjectStateChunk=FileStart.."\""..prim_recpath.."\" \""..sec_recpath.."\"\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA=ultraschall.GetProject_RecPath("c:\\tt.rpp","test","test2")
--ultraschall.SetProject_RecPath("c:\\tt.rpp","AAtest","BBtest2")


function ultraschall.SetProject_RecordCFG(projectfilename_with_path, recording_cfg_string, ProjectStateChunk)
--To Do: Research
-- ProjectSettings->Media->Recording
-- recording-cfg-string

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RecordCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RecordCFG(string projectfilename_with_path, string recording_cfg_string, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the recording-configuration as encoded string in an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Recording.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    recording_cfg_string - the record-configuration as encoded string
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, configuration</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecordCFG", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RecordCFG", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecordCFG", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(recording_cfg_string)~="string" then ultraschall.AddErrorMessage("SetProject_RecordCFG", "recording_cfg_string", "Must be a string", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RecordCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RECORD_CFG%c%s*).-%c.-RENDER_FILE.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RECORD_CFG%c%s*.-(%c.-RENDER_FILE.*)")
  
  ProjectStateChunk=FileStart..recording_cfg_string..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_RecordCFG("c:\\tt.rpp", "Hubbelbubbel==")
--A=ultraschall.GetProject_RecordCFG("c:\\tt.rpp")

function ultraschall.SetProject_RenderCFG(projectfilename_with_path, rendercfg_string, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderCFG(string projectfilename_with_path, string rendercfg_string, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-configuration as encoded string in an RPP-Projectfile or a ProjectStateChunk, as set in Render-Settings
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    rendercfg_string - the render-configuration as encoded string
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, configuration</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderCFG", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderCFG", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderCFG", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(rendercfg_string)~="string" then ultraschall.AddErrorMessage("SetProject_RenderCFG", "rendercfg_string", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_CFG%c%s*).-%c.->.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_CFG%c%s*.-(%c.->.*)")

  ProjectStateChunk=FileStart..rendercfg_string..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
    else return 1, ProjectStateChunk
  end  
end

--L=ultraschall.ReadFullFile("c:\\tt.rpp")
--B,C=ultraschall.SetProject_RenderCFG("c:\\tt.rpp", "Hubbelbubbel==")
--reaper.MB(C,"",0)
--A=ultraschall.GetProject_RenderCFG("c:\\tt.rpp", "IHBkZA=")

function ultraschall.SetProject_ApplyFXCFG(projectfilename_with_path, applyfx_cfg_string, ProjectStateChunk)
--To Do: Research
-- ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc
-- recording_cfg-string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_ApplyFXCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_ApplyFXCFG(string projectfilename_with_path, string applyfx_cfg_string, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the audioformat-configuration, for fx-appliance-operation, as an encoded string in an RPP-Projectfile or a ProjectStateChunk, as set in ProjectSettings->Media->Format for Apply FX, Glue, Freeze, etc
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    string applyfx_cfg_string - the file-format-configuration for fx-appliance as encoded string
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, fx, configuration</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ApplyFXCFG", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_ApplyFXCFG", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ApplyFXCFG", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(applyfx_cfg_string)~="string" then ultraschall.AddErrorMessage("SetProject_ApplyFXCFG", "applyfx_cfg_string", "Must be a string", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ApplyFXCFG", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-APPLYFX_CFG%c%s*).-%c.-RENDER_FILE.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-APPLYFX_CFG%c%s*.-(%c.-RENDER_FILE.*)")
  
  ProjectStateChunk=FileStart..applyfx_cfg_string..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_ApplyFXCFG("c:\\tt.rpp","nilfluss")
--A=ultraschall.GetProject_ApplyFXCFG("c:\\tt.rpp")

function ultraschall.SetProject_RenderFilename(projectfilename_with_path, renderfilename, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderFilename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderFilename(string projectfilename_with_path, string renderfilename, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set to "", if you want to set a render-pattern with <a href="#SetProject_RenderPattern">SetProject_RenderPattern</a>.
    
    The rendername is influenced by the settings in the RENDER_PATTERN-entry in the RPP-file, see <a href="#SetProject_RenderPattern">SetProject_RenderPattern</a> to influence or remove the RENDER_PATTERN-entry(Removing RENDER_PATTERN may help when Reaper rendering it to the name given in parameter render_filename.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk insteadO
    string render_filename - the filename for rendering, check also <a href="#GetProject_RenderPattern">GetProject_RenderPattern</a>
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, path, render filename, filename, render</tags>
</US_DocBloc>
]]  
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderFilename", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderFilename", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderFilename", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if type(renderfilename)~="string" then ultraschall.AddErrorMessage("SetProject_RenderFilename", "renderfilename", "Must be a string", -4) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_FILE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_FILE%s.-%c(.-<RENDER_CFG.*)")
  ProjectStateChunk=FileStart.."\""..renderfilename.."\" \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_RenderFilename("c:\\tt.rpp")
--A=ultraschall.SetProject_RenderFilename("c:\\tt.rpp", "c:\\testname22.ext")
--B=ultraschall.GetProject_RenderFilename("c:\\tt.rpp", "c:\\testname.ext")


--B,C=ultraschall.SetProject_RenderPattern("c:\\tt.rpp", "Tudelu")
--reaper.MB(C:sub(1,1000),"",0)
--D=ultraschall.GetProject_RenderPattern("c:\\tt.rpp")


function ultraschall.SetProject_RenderFreqNChans(projectfilename_with_path, unknown, rendernum_chans, render_frequency, ProjectStateChunk)
-- returns an unknown number, Number_Channels(0-default) and RenderFrequency(0-default)
-- Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels
-- RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderFreqNChans</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderFreqNChans(string projectfilename_with_path, integer unknown, integer rendernum_chans, integer render_frequency, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns an unknown number, the render-frequency and rendernumber of channels from an RPP-Projectfile or a ProjectStateChunk. 
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer unknown - unknown number
    integer rendernum_chans - Number_Channels 0-seems default-project-settings(?), 1-Mono, 2-Stereo, ... up to 64 channels
    integer render_frequency - RenderFrequency -2147483647 to 2147483647, except 0, which seems to be default-project-settings-frequency
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, frequency, num channels, channels</tags>
</US_DocBloc>
]]           
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(unknown)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "unknown", "Must be an integer", -4) return -1 end
  if math.type(rendernum_chans)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "rendernum_chans", "Must be an integer", -5) return -1 end
  if math.type(render_frequency)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "render_frequency", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderFreqNChans", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_FMT%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_FMT%s.-%c(.-<RENDER_CFG.*)")
  ProjectStateChunk=FileStart..unknown.." "..rendernum_chans.." "..render_frequency.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA,AAA=ultraschall.SetProject_RenderFreqNChans("c:\\tt.rpp",155,66,77)
--A,AA,AAA=ultraschall.GetProject_RenderFreqNChans("c:\\tt.rpp",1,4,3)

function ultraschall.SetProject_RenderSpeed(projectfilename_with_path, render_speed, ProjectStateChunk)
--    Rendering_Speed 0-Fullspeed Offline, 1-1x Offline, 
--                    2-Online Render, 3-Offline Render (Idle), 
--                    4-1x Offline Render (Idle)

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderSpeed</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderSpeed(string projectfilename_with_path, integer render_speed, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets a rendering-speed in an RPP-Projectfile or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer render_speed - render_speed 
    -             0-Fullspeed Offline
    -             1-1x Offline
    -             2-Online Render
    -             3-Offline Render (Idle)
    -            4-1x Offline Render (Idle)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, speed</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderSpeed", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderSpeed", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderSpeed", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(render_speed)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderSpeed", "render_speed", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderSpeed", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_1X%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_1X%s.-%c(.-<RENDER_CFG.*)")
  ProjectStateChunk=FileStart..render_speed.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_RenderSpeed("c:\\tt.rpp",199)
--A=ultraschall.GetProject_RenderSpeed("c:\\tt.rpp",0)

function ultraschall.SetProject_RenderRange(projectfilename_with_path, bounds, time_start, time_end, tail, tail_length, ProjectStateChunk)
-- returns RenderRange
-- Bounds: 0 Custom Time Range, 1 Entire Project, 2 Time Selection, 
--          3 Project Regions, 4 Selected Media Items(in combination with RENDER_STEMS 32)
-- TimeStart in milliseconds -2147483647 to 2147483647
-- TimeEnd in milliseconds 2147483647 to 2147483647
--integer tail - Tail on/off-flags for individual bounds
--0 - tail off for all bounds
--1 - custom time range - tail on
--2 - entire project - tail on
--4 - time selection - tail on
--8 - project regions - tail on
-- TailLength in milliseconds, valuerange 0 - 2147483647  


--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderRange</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderRange(string projectfilename_with_path, integer bounds, number time_start, number time_end, integer tail, integer tail_length, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-range, render-timestart, render-timeend, render-tail and render-taillength in an RPP-Projectfile or a ProjectStateChunk. 
    To get RENDER_STEMS, refer <a href="#GetProject_RenderStems">GetProject_RenderStems</a>
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer bounds - the bounds of the project to be rendered
    -             0 Custom Time Range
    -             1 Entire Project
    -             2 Time Selection, 
    -             3 Project Regions
    -             4 Selected Media Items(in combination with RENDER_STEMS 32); to get RENDER_STEMS, refer GetProject_RenderStems
    
    number time_start - TimeStart in milliseconds -2147483647 to 2147483647
    number time_end - TimeEnd in milliseconds 2147483647 to 2147483647
    integer tail - Tail on/off-flags for individual bounds
    -             0 - tail off for all bounds
    -             1 - custom time range - tail on
    -             2 - entire project - tail on
    -             4 - time selection - tail on
    -             8 - project regions - tail on
    
    integer tail_length - TailLength in milliseconds, valuerange 0 - 2147483647
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, timestart, timeend, range, tail, bounds</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderRange", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderRange", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderRange", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(bounds)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderRange", "bounds", "Must be an integer", -4) return -1 end
  if type(time_start)~="number" then ultraschall.AddErrorMessage("SetProject_RenderRange", "time_start", "Must be a number", -5) return -1 end
  if type(time_end)~="number" then ultraschall.AddErrorMessage("SetProject_RenderRange", "time_end", "Must be a number", -6) return -1 end
  if math.type(tail)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderRange", "tail", "Must be an integer", -7) return -1 end
  if math.type(tail_length)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderRange", "tail_length", "Must be an integer", -8) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderRange", "projectfilename_with_path", "No valid RPP-Projectfile!", -9) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_RANGE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_RANGE%s.-%c(.-<RENDER_CFG.*)")
  ProjectStateChunk=FileStart..bounds.." "..time_start.." "..time_end.." "..tail.." "..tail_length.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.SetProject_RenderRange("c:\\tt.rpp",2,3,4,5,6)
--A,AA,AAA,AAAA,AAAAA=ultraschall.GetProject_RenderRange("c:\\tt.rpp",0,-0.062,11.937,0,0)

function ultraschall.SetProject_RenderResample(projectfilename_with_path, resample_mode, playback_resample_mode, project_smplrate4mix_and_fx, ProjectStateChunk)
-- returns Resamplemode for a)Rendering and b)Playback as well as c)if both are combined
--- Resample_Mode - 0-medium (64pt Sinc), 1-Low (Linear Interpolation), 
--                2-Lowest (Point Sampling), 3-Good(192pt Sinc), 
--                4-Better(384pt Sinc), 5-Fast (IIR + Linear Interpolation), 
--                6-Fast (IIRx2 + Linear Interpolation), 7-Fast (16pt sinc) - Default, 
--                8-HQ (512pt Sinc), 9-Extreme HQ (768pt HQ Sinc)
-- Playback_Resample_Mode (as set in the Project-Settings)
--                0-medium (64pt Sinc), 1-Low (Linear Interpolation), 
--                2-Lowest (Point Sampling), 3-Good(192pt Sinc), 
--                4-Better(384pt Sinc), 5-Fast (IIR + Linear Interpolation), 
--                6-Fast (IIRx2 + Linear Interpolation), 7-Fast (16pt sinc) - Default, 
--                8-HQ (512pt Sinc), 9-Extreme HQ (768pt HQ Sinc)
-- Use_Project_Sample_Rate_for_Mixing_and_FX/Synth_Processing - 1 - yes, 0-no

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderResample</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderResample(string projectfilename_with_path, integer resample_mode, integer playback_resample_mode, integer project_smplrate4mix_and_fx, optional string ProjectStateChunk)</functioncall>
  <description>
    Resamplemode for a)Rendering and b)Playback as well as c)if both are combined from an RPP-Projectfile or a ProjectStateChunk. 
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer resample_mode - Resample_Mode 
    -             0-medium (64pt Sinc), 
    -             1-Low (Linear Interpolation), 
    -             2-Lowest (Point Sampling), 
    -             3-Good(192pt Sinc), 
    -             4-Better(384pt Sinc), 
    -             5-Fast (IIR + Linear Interpolation), 
    -             6-Fast (IIRx2 + Linear Interpolation), 
    -             7-Fast (16pt sinc) - Default, 
    -             8-HQ (512pt Sinc), 
    -             9-Extreme HQ (768pt HQ Sinc)
    
    integer playback_resample_mode - Playback Resample Mode (as set in the Project-Settings)
    -           0-medium (64pt Sinc), 
    -           1-Low (Linear Interpolation), 
    -           2-Lowest (Point Sampling), 
    -           3-Good(192pt Sinc), 
    -           4-Better(384pt Sinc), 
    -           5-Fast (IIR + Linear Interpolation), 
    -           6-Fast (IIRx2 + Linear Interpolation), 
    -           7-Fast (16pt sinc) - Default, 
    -           8-HQ (512pt Sinc), 
    -           9-Extreme HQ (768pt HQ Sinc)
    
    integer project_smplrate4mix_and_fx - Use_Project_Sample_Rate_for_Mixing_and_FX/Synth_Processing 1, yes; 0, no
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, resample, playback, mixing, fx, synth</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderResample", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderResample", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderResample", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(resample_mode)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderResample", "resample_mode", "Must be an integer", -4) return -1 end
  if math.type(playback_resample_mode)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderResample", "playback_resample_mode", "Must be an integer", -5) return -1 end
  if math.type(project_smplrate4mix_and_fx)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderResample", "project_smplrate4mix_and_fx", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderResample", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_RESAMPLE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_RESAMPLE%s.-%c(.-<RENDER_CFG.*)")
  ProjectStateChunk=FileStart..resample_mode.." "..playback_resample_mode.." "..project_smplrate4mix_and_fx.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA,AAA,AAAA,AAAAA=ultraschall.SetProject_RenderResample("c:\\tt.rpp",2,3,4)
--A,AA,AAA,AAAA,AAAAA=ultraschall.GetProject_RenderResample("c:\\tt.rpp", 1, 2, 3)

function ultraschall.SetProject_AddMediaToProjectAfterRender(projectfilename_with_path, addmedia_after_render_state, ProjectStateChunk)
-- returns the state, if rendered media shall be added to the project afterwards
-- 0 - don't add, 1 - add to project

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_AddMediaToProjectAfterRender</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_AddMediaToProjectAfterRender(string projectfilename_with_path, integer addmedia_after_render_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns, if rendered media shall be added to the project afterwards, from an RPP-Projectfile or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer addmedia_after_render_state - 1 - rendered media shall be added to the project afterwards, 0 - don't add
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, add, media, after, project</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AddMediaToProjectAfterRender", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_AddMediaToProjectAfterRender", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AddMediaToProjectAfterRender", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(addmedia_after_render_state)~="integer" then ultraschall.AddErrorMessage("SetProject_AddMediaToProjectAfterRender", "addmedia_after_render_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_AddMediaToProjectAfterRender", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_ADDTOPROJ%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_ADDTOPROJ%s.-%c(.-<RENDER_CFG.*)")
  
  ProjectStateChunk=FileStart..addmedia_after_render_state.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_AddMediaToProjectAfterRender("c:\\tt.rpp",9)
--A=ultraschall.GetProject_AddMediaToProjectAfterRender("c:\\tt.rpp",1)

function ultraschall.SetProject_RenderStems(projectfilename_with_path, render_stems, ProjectStateChunk)
-- returns the state of Render Stems
-- 0 - Source Master Mix, 1 - Source Master mix + stems, 3 - Source Stems, selected tracks, 
-- 4 - Multichannel Tracks to Multichannel Files, 8 - Source Region Render Matrix, 
-- 16 - Tracks with only Mono-Media to Mono Files,  
-- 32 Selected Media Items(in combination with RENDER_RANGE->Bounds->4)  

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderStems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderStems(string projectfilename_with_path, integer render_stems, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-stems-state from an RPP-Projectfile or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer render_stems - the state of Render Stems
    - 0 - Source Master Mix, 
    - 1 - Source Master mix + stems, 
    - 3 - Source Stems, selected tracks, 
    - 4 - Multichannel Tracks to Multichannel Files, 
    - 8 - Source Region Render Matrix, 
    - 16 - Tracks with only Mono-Media to Mono Files,  
    - 32 - Selected Media Items(in combination with RENDER_RANGE->Bounds->4, refer to <a href="#GetProject_RenderRange">GetProject_RenderRange</a> to get RENDER_RANGE)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, stems, multichannel</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderStems", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderStems", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderStems", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(render_stems)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderStems", "render_stems", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderStems", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_STEMS%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_STEMS%s.-%c(.-<RENDER_CFG.*)")

  ProjectStateChunk=FileStart..tonumber(render_stems).." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_RenderStems("c:\\tt.rpp",3)
--A=ultraschall.GetProject_RenderStems("c:\\tt.rpp", 2)

function ultraschall.SetProject_RenderDitherState(projectfilename_with_path, renderdither_state, ProjectStateChunk)
-- returns the state of dithering of rendering
-- 0 - Dither Master Mix, 1 - Don't Dither Master Mix, 2 - Noise-shaping On Master Mix, 
-- 3 - Dither And Noiseshape Master Mix

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderDitherState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderDitherState(string projectfilename_with_path, integer renderdither_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-dither-state from an RPP-Projectfile or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer renderdither_state - the state of render dithering
    -             0 - Dither Master Mix, 
    -             1 - Don't Dither Master Mix, 
    -             2 - Noise-shaping On Master Mix, 
    -             3 - Dither And Noiseshape Master Mix
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, render, dither, state, master, noise shaping</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderDitherState", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderDitherState", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderDitherState", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(renderdither_state)~="integer" then ultraschall.AddErrorMessage("SetProject_RenderDitherState", "renderdither_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderDitherState", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_DITHER%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_DITHER%s.-%c(.-<RENDER_CFG.*)")
  
  ProjectStateChunk=FileStart..tonumber(renderdither_state).." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_RenderDitherState("c:\\tt.rpp",1)
--A=ultraschall.GetProject_RenderDitherState("c:\\tt.rpp",1)


function ultraschall.SetProject_TimeBase(projectfilename_with_path, timebase, ProjectStateChunk)
-- returns Time Base for items/envelopes/markers as set in the project settings
-- 0 - Time, 1 - Beats (position, length, rate), 2 - Beats (position only)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_TimeBase</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_TimeBase(string projectfilename_with_path, integer timebase, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer timebase - the timebase for items/envelopes/markers as set in the project settings
    -             0 - Time, 
    -             1 - Beats (position, length, rate), 
    -             2 - Beats (position only)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, timebase, time, beats, items, envelopes, markers</tags>
</US_DocBloc>
]]  
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TimeBase", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_TimeBase", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TimeBase", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(timebase)~="integer" then ultraschall.AddErrorMessage("SetProject_TimeBase", "timebase", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TimeBase", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-TIMELOCKMODE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-TIMELOCKMODE%s.-%c(.-<RENDER_CFG.*)")

  ProjectStateChunk=FileStart..timebase.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_TimeBase("c:\\tt.rpp", 9)
--A=ultraschall.GetProject_TimeBase("c:\\tt.rpp")

function ultraschall.SetProject_TempoTimeSignature(projectfilename_with_path, tempotimesignature, ProjectStateChunk)
-- returns Time Base for tempo/time-signature as set in the project settings
-- 0 - Time, 1 - Beats
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_TempoTimeSignature</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_TempoTimeSignature(string projectfilename_with_path, integer tempotimesignature, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the timebase, as set in the project-settings, in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer tempotimesignature - the timebase for tempo/time-signature as set in the project settings
    -             0 - Time 
    -             1 - Beats
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, timebase, time, beats, tempo, signature</tags>
</US_DocBloc>
]]  
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TempoTimeSignature", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_TempoTimeSignature", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TempoTimeSignature", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(tempotimesignature)~="integer" then ultraschall.AddErrorMessage("SetProject_TempoTimeSignature", "tempotimesignature", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TempoTimeSignature", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-TEMPOENVLOCKMODE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-TEMPOENVLOCKMODE%s.-%c(.-<RENDER_CFG.*)")
  
  ProjectStateChunk=FileStart..tempotimesignature.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_TempoTimeSignature("c:\\tt.rpp",9)
--A=ultraschall.GetProject_TempoTimeSignature("c:\\tt.rpp",1)


function ultraschall.SetProject_ItemMixBehavior(projectfilename_with_path, item_mix_behav_state, ProjectStateChunk)
-- returns Project Settings Item Mix Behavior
-- 0 - Enclosed items replace enclosing items 
-- 1 - Items always mix
-- 2 - Items always replace earlier items

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_ItemMixBehavior</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_ItemMixBehavior(string projectfilename_with_path, integer item_mix_behav_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the item mix behavior, as set in the project-settings, from an rpp-project-file.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path of the rpp-project-file
    integer item_mix_behav_state - item mix behavior
    -              0 - Enclosed items replace enclosing items 
    -              1 - Items always mix
    -              2 - Items always replace earlier items
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, item, mix</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ItemMixBehavior", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_ItemMixBehavior", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ItemMixBehavior", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(item_mix_behav_state)~="integer" then ultraschall.AddErrorMessage("SetProject_ItemMixBehavior", "item_mix_behav_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_ItemMixBehavior", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end
  
  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-ITEMMIX%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-ITEMMIX%s.-%c(.-<RENDER_CFG.*)")
  
  ProjectStateChunk=FileStart..item_mix_behav_state.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_ItemMixBehavior("c:\\tt.rpp",99)
--A=ultraschall.GetProject_ItemMixBehavior("c:\\tt.rpp",0)

function ultraschall.SetProject_DefPitchMode(projectfilename_with_path, def_pitch_mode_state, ProjectStateChunk)
-- returns Default Pitch Mode for project
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_DefPitchMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_DefPitchMode(string projectfilename_with_path, integer def_pitch_mode_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the default-pitch-mode, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer def_pitch_mode_state - the default pitch mode
    -      0 - Soundtouch(Default)
    -      1 - Soundtouch(High Quality)
    -      2 - Soundtouch(Fast)
    -      131072 - Simple Windowed(fast) (50ms window, 25ms fade)
    -      131073 - Simple Windowed(fast) (50ms window, 16ms fade)
    -      131074 - Simple Windowed(fast) (50ms window, 10ms fade)
    -      131075 - Simple Windowed(fast) (50ms window, 7ms fade)
    -      131076 - Simple Windowed(fast) (75ms window, 37ms fade)
    -      131077 - Simple Windowed(fast) (75ms window, 25ms fade)
    -      131078 - Simple Windowed(fast) (75ms window, 15ms fade)
    -      131079 - Simple Windowed(fast) (75ms window, 10ms fade)
    -      131080 - Simple Windowed(fast) (100ms window, 50ms fade)
    -      131081 - Simple Windowed(fast) (100ms window, 33ms fade)
    -      131082 - Simple Windowed(fast) (100ms window, 20ms fade)
    -      131083 - Simple Windowed(fast) (100ms window, 14ms fade)
    -      131084 - Simple Windowed(fast) (150ms window, 75ms fade)
    -      131085 - Simple Windowed(fast) (150ms window, 50ms fade)
    -      131086 - Simple Windowed(fast) (150ms window, 30ms fade)
    -      131087 - Simple Windowed(fast) (150ms window, 21ms fade)
    -      131088 - Simple Windowed(fast) (225ms window, 112ms fade)
    -      131089 - Simple Windowed(fast) (225ms window, 75ms fade)
    -      131090 - Simple Windowed(fast) (225ms window, 45ms fade)
    -      131091 - Simple Windowed(fast) (225ms window, 32ms fade)
    -      131092 - Simple Windowed(fast) (300ms window, 150ms fade)
    -      131093 - Simple Windowed(fast) (300ms window, 100ms fade)
    -      131094 - Simple Windowed(fast) (300ms window, 60ms fade)
    -      131095 - Simple Windowed(fast) (300ms window, 42ms fade)
    -      131096 - Simple Windowed(fast) (40ms window, 20ms fade)
    -      131097 - Simple Windowed(fast) (40ms window, 13ms fade)
    -      131098 - Simple Windowed(fast) (40ms window, 8ms fade)
    -      131099 - Simple Windowed(fast) (40ms window, 5ms fade)
    -      131100 - Simple Windowed(fast) (30ms window, 15ms fade)
    -      131101 - Simple Windowed(fast) (30ms window, 10ms fade)
    -      131102 - Simple Windowed(fast) (30ms window, 6s fade)
    -      131103 - Simple Windowed(fast) (30ms window, 4ms fade)
    -      131104 - Simple Windowed(fast) (20ms window, 10ms fade)
    -      131105 - Simple Windowed(fast) (20ms window, 6ms fade)
    -      131106 - Simple Windowed(fast) (20ms window, 4ms fade)
    -      131107 - Simple Windowed(fast) (20ms window, 2ms fade)
    -      131108 - Simple Windowed(fast) (10ms window, 5ms fade)
    -      131109 - Simple Windowed(fast) (10ms window, 3ms fade)
    -      131110 - Simple Windowed(fast) (10ms window, 2ms fade)
    -      131111 - Simple Windowed(fast) (10ms window, 1ms fade)
    -      131112 - Simple Windowed(fast) (5ms window, 2ms fade)
    -      131113 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131114 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131115 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131116 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131117 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131118 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131119 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      393216 - elastique 2.28 Pro Normal
    -      393217 - elastique 2.28 Pro Preserve Formants(Lowest Pitches)
    -      393218 - elastique 2.28 Pro Preserve Formants(Lower Pitches)
    -      393219 - elastique 2.28 Pro Preserve Formants(Low Pitches)
    -      393220 - elastique 2.28 Pro Preserve Formants(Most Pitches)
    -      393221 - elastique 2.28 Pro Preserve Formants(High Pitches)
    -      393222 - elastique 2.28 Pro Preserve Formants(Higher Pitches)
    -      393223 - elastique 2.28 Pro Preserve Formants(Highest Pitches)
    -      393224 - elastique 2.28 Pro Mid/Side
    -      393225 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      393226 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      393227 - elastique 2.28 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      393228 - elastique 2.28 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      393229 - elastique 2.28 Pro Mid/Side, Preserve Formants(High Pitches)
    -      393230 - elastique 2.28 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      393231 - elastique 2.28 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      393232 - elastique 2.28 Pro Synchronized: Normal
    -      393233 - elastique 2.28 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      393234 - elastique 2.28 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      393235 - elastique 2.28 Pro Synchronized: Preserve Formants(Low Pitches)
    -      393236 - elastique 2.28 Pro Synchronized: Preserve Formants(Most Pitches)
    -      393237 - elastique 2.28 Pro Synchronized: Preserve Formants(High Pitches)
    -      393238 - elastique 2.28 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      393239 - elastique 2.28 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      393240 - elastique 2.28 Pro Synchronized: Mid/Side 
    -      393241 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      393242 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      393243 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      393244 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      393245 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      393246 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      393247 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      458752 - elastique 2.28 Efficient Normal
    -      458753 - elastique 2.28 Efficient Mid/Side
    -      458754 - elastique 2.28 Efficient Synchronized: Normal
    -      458755 - elastique 2.28 Efficient Synchronized: Mid/Side
    -      524288 - elastique 2.28 Soloist Monophonic
    -      524289 - elastique 2.28 Soloist Monophonic [Mid/Side]
    -      524290 - elastique 2.28 Soloist Speech
    -      524291 - elastique 2.28 Soloist Speech [Mid/Side]
    -      589824 - elastique 3.2.3 Pro Normal
    -      589825 - elastique 3.2.3 Pro Preserve Formants(Lowest Pitches)
    -      589826 - elastique 3.2.3 Pro Preserve Formants(Lower Pitches)
    -      589827 - elastique 3.2.3 Pro Preserve Formants(Low Pitches)
    -      589828 - elastique 3.2.3 Pro Preserve Formants(Most Pitches)
    -      589829 - elastique 3.2.3 Pro Preserve Formants(High Pitches)
    -      589830 - elastique 3.2.3 Pro Preserve Formants(Higher Pitches)
    -      589831 - elastique 3.2.3 Pro Preserve Formants(Highest Pitches)
    -      589832 - elastique 3.2.3 Pro Mid/Side
    -      589833 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      589834 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      589835 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      589836 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      589837 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(High Pitches)
    -      589838 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      589839 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      589840 - elastique 3.2.3 Pro Synchronized: Normal
    -      589841 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      589842 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      589843 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Low Pitches)
    -      589844 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Most Pitches)
    -      589845 - elastique 3.2.3 Pro Synchronized: Preserve Formants(High Pitches)
    -      589846 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      589847 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      589848 - elastique 3.2.3 Pro Synchronized: Mid/Side 
    -      589849 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      589850 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      589851 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      589852 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      589855 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      655360 - elastique 3.2.3 Efficient Normal
    -      655361 - elastique 3.2.3 Efficient Mid/Side
    -      655362 - elastique 3.2.3 Efficient Synchronized: Normal
    -      655363 - elastique 3.2.3 Efficient Synchronized: Mid/Side
    -      720896 - elastique 3.2.3 Soloist (Monophonic)
    -      720897 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -      720898 - elastique 3.2.3 Soloist (Speech)
    -      720898 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851968 - nothing
    -      851969 - Preserve Formants
    -      851970 - Mid/Side
    -      851971 - Preserve Formants (Mid Side)
    -      851972 - Independent Phase
    -      851973 - Preserve Formants, Independent Phase
    -      851974 - Mid/Side, Independent Phase
    -      851975 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851984 - nothing
    -      851985 - Preserve Formants
    -      851986 - Mid/Side
    -      851987 - Preserve Formants (Mid Side)
    -      851988 - Independent Phase
    -      851989 - Preserve Formants, Independent Phase
    -      851990 - Mid/Side, Independent Phase
    -      851991 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      852000 - nothing
    -      852001 - Preserve Formants
    -      852002 - Mid/Side
    -      852003 - Preserve Formants (Mid Side)
    -      852004 - Independent Phase
    -      852005 - Preserve Formants, Independent Phase
    -      852006 - Mid/Side, Independent Phase
    -      852007 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852016 - nothing
    -      852017 - Preserve Formants
    -      852018 - Mid/Side
    -      852019 - Preserve Formants (Mid Side)
    -      852020 - Independent Phase
    -      852021 - Preserve Formants, Independent Phase
    -      852022 - Mid/Side, Independent Phase
    -      852023 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852032 - nothing
    -      852033 - Preserve Formants
    -      852034 - Mid/Side
    -      852035 - Preserve Formants (Mid Side)
    -      852036 - Independent Phase
    -      852037 - Preserve Formants, Independent Phase
    -      852038 - Mid/Side, Independent Phase
    -      852039 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852048 - nothing
    -      852049 - Preserve Formants
    -      852050 - Mid/Side
    -      852051 - Preserve Formants (Mid Side)
    -      852052 - Independent Phase
    -      852053 - Preserve Formants, Independent Phase
    -      852054 - Mid/Side, Independent Phase
    -      852055 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852064 - nothing
    -      852065 - Preserve Formants
    -      852066 - Mid/Side
    -      852067 - Preserve Formants (Mid Side)
    -      852068 - Independent Phase
    -      852069 - Preserve Formants, Independent Phase
    -      852070 - Mid/Side, Independent Phase
    -      852071 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852080 - nothing
    -      852081 - Preserve Formants
    -      852082 - Mid/Side
    -      852083 - Preserve Formants (Mid Side)
    -      852084 - Independent Phase
    -      852085 - Preserve Formants, Independent Phase
    -      852086 - Mid/Side, Independent Phase
    -      852087 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852096 - nothing
    -      852097 - Preserve Formants
    -      852098 - Mid/Side
    -      852099 - Preserve Formants (Mid Side)
    -      852100 - Independent Phase
    -      852101 - Preserve Formants, Independent Phase
    -      852102 - Mid/Side, Independent Phase
    -      852103 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852112 - nothing
    -      852113 - Preserve Formants
    -      852114 - Mid/Side
    -      852115 - Preserve Formants (Mid Side)
    -      852116 - Independent Phase
    -      852117 - Preserve Formants, Independent Phase
    -      852118 - Mid/Side, Independent Phase
    -      852119 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852128 - nothing
    -      852129 - Preserve Formants
    -      852130 - Mid/Side
    -      852131 - Preserve Formants (Mid Side)
    -      852132 - Independent Phase
    -      852133 - Preserve Formants, Independent Phase
    -      852134 - Mid/Side, Independent Phase
    -      852135 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852144 - nothing
    -      852145 - Preserve Formants
    -      852146 - Mid/Side
    -      852147 - Preserve Formants (Mid Side)
    -      852148 - Independent Phase
    -      852149 - Preserve Formants, Independent Phase
    -      852150 - Mid/Side, Independent Phase
    -      852151 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852160 - nothing
    -      852161 - Preserve Formants
    -      852162 - Mid/Side
    -      852163 - Preserve Formants (Mid Side)
    -      852164 - Independent Phase
    -      852165 - Preserve Formants, Independent Phase
    -      852166 - Mid/Side, Independent Phase
    -      852167 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852176 - nothing
    -      852177 - Preserve Formants
    -      852178 - Mid/Side
    -      852179 - Preserve Formants (Mid Side)
    -      852180 - Independent Phase
    -      852181 - Preserve Formants, Independent Phase
    -      852182 - Mid/Side, Independent Phase
    -      852183 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852192 - nothing
    -      852193 - Preserve Formants
    -      852194 - Mid/Side
    -      852195 - Preserve Formants (Mid Side)
    -      852196 - Independent Phase
    -      852197 - Preserve Formants, Independent Phase
    -      852198 - Mid/Side, Independent Phase
    -      852199 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852208 - nothing
    -      852209 - Preserve Formants
    -      852210 - Mid/Side
    -      852211 - Preserve Formants (Mid Side)
    -      852212 - Independent Phase
    -      852213 - Preserve Formants, Independent Phase
    -      852214 - Mid/Side, Independent Phase
    -      852215 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852224 - nothing
    -      852225 - Preserve Formants
    -      852226 - Mid/Side
    -      852227 - Preserve Formants (Mid Side)
    -      852228 - Independent Phase
    -      852229 - Preserve Formants, Independent Phase
    -      852230 - Mid/Side, Independent Phase
    -      852231 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852240 - nothing
    -      852241 - Preserve Formants
    -      852242 - Mid/Side
    -      852243 - Preserve Formants (Mid Side)
    -      852244 - Independent Phase
    -      852245 - Preserve Formants, Independent Phase
    -      852246 - Mid/Side, Independent Phase
    -      852247 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852256 - nothing
    -      852257 - Preserve Formants
    -      852258 - Mid/Side
    -      852259 - Preserve Formants (Mid Side)
    -      852260 - Independent Phase
    -      852261 - Preserve Formants, Independent Phase
    -      852262 - Mid/Side, Independent Phase
    -      852263 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852272 - nothing
    -      852273 - Preserve Formants
    -      852274 - Mid/Side
    -      852275 - Preserve Formants (Mid Side)
    -      852276 - Independent Phase
    -      852277 - Preserve Formants, Independent Phase
    -      852278 - Mid/Side, Independent Phase
    -      852279 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852288 - nothing
    -      852289 - Preserve Formants
    -      852290 - Mid/Side
    -      852291 - Preserve Formants (Mid Side)
    -      852292 - Independent Phase
    -      852293 - Preserve Formants, Independent Phase
    -      852294 - Mid/Side, Independent Phase
    -      852295 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852304 - nothing
    -      852305 - Preserve Formants
    -      852306 - Mid/Side
    -      852307 - Preserve Formants (Mid Side)
    -      852308 - Independent Phase
    -      852309 - Preserve Formants, Independent Phase
    -      852310 - Mid/Side, Independent Phase
    -      852311 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852320 - nothing
    -      852321 - Preserve Formants
    -      852322 - Mid/Side
    -      852323 - Preserve Formants (Mid Side)
    -      852324 - Independent Phase
    -      852325 - Preserve Formants, Independent Phase
    -      852326 - Mid/Side, Independent Phase
    -      852327 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852336 - nothing
    -      852337 - Preserve Formants
    -      852338 - Mid/Side
    -      852339 - Preserve Formants (Mid Side)
    -      852340 - Independent Phase
    -      852341 - Preserve Formants, Independent Phase
    -      852342 - Mid/Side, Independent Phase
    -      852343 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852352 - nothing
    -      852353 - Preserve Formants
    -      852354 - Mid/Side
    -      852355 - Preserve Formants (Mid Side)
    -      852356 - Independent Phase
    -      852357 - Preserve Formants, Independent Phase
    -      852358 - Mid/Side, Independent Phase
    -      852359 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852368 - nothing
    -      852369 - Preserve Formants
    -      852370 - Mid/Side
    -      852371 - Preserve Formants (Mid Side)
    -      852372 - Independent Phase
    -      852373 - Preserve Formants, Independent Phase
    -      852374 - Mid/Side, Independent Phase
    -      852375 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852384 - nothing
    -      852385 - Preserve Formants
    -      852386 - Mid/Side
    -      852387 - Preserve Formants (Mid Side)
    -      852388 - Independent Phase
    -      852389 - Preserve Formants, Independent Phase
    -      852390 - Mid/Side, Independent Phase
    -      852391 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852400 - nothing
    -      852401 - Preserve Formants
    -      852402 - Mid/Side
    -      852403 - Preserve Formants (Mid Side)
    -      852404 - Independent Phase
    -      852405 - Preserve Formants, Independent Phase
    -      852406 - Mid/Side, Independent Phase
    -      852407 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852416 - nothing
    -      852417 - Preserve Formants
    -      852418 - Mid/Side
    -      852419 - Preserve Formants (Mid Side)
    -      852420 - Independent Phase
    -      852421 - Preserve Formants, Independent Phase
    -      852422 - Mid/Side, Independent Phase
    -      852423 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852432 - nothing
    -      852433 - Preserve Formants
    -      852434 - Mid/Side
    -      852435 - Preserve Formants (Mid Side)
    -      852436 - Independent Phase
    -      852437 - Preserve Formants, Independent Phase
    -      852438 - Mid/Side, Independent Phase
    -      852439 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852448 - nothing
    -      852449 - Preserve Formants
    -      852450 - Mid/Side
    -      852451 - Preserve Formants (Mid Side)
    -      852452 - Independent Phase
    -      852453 - Preserve Formants, Independent Phase
    -      852454 - Mid/Side, Independent Phase
    -      852455 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852464 - nothing
    -      852465 - Preserve Formants
    -      852466 - Mid/Side
    -      852467 - Preserve Formants (Mid Side)
    -      852468 - Independent Phase
    -      852469 - Preserve Formants, Independent Phase
    -      852470 - Mid/Side, Independent Phase
    -      852471 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852480 - nothing
    -      852481 - Preserve Formants
    -      852482 - Mid/Side
    -      852483 - Preserve Formants (Mid Side)
    -      852484 - Independent Phase
    -      852485 - Preserve Formants, Independent Phase
    -      852486 - Mid/Side, Independent Phase
    -      852487 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852496 - nothing
    -      852497 - Preserve Formants
    -      852498 - Mid/Side
    -      852499 - Preserve Formants (Mid Side)
    -      852500 - Independent Phase
    -      852501 - Preserve Formants, Independent Phase
    -      852502 - Mid/Side, Independent Phase
    -      852503 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852512 - nothing
    -      852513 - Preserve Formants
    -      852514 - Mid/Side
    -      852515 - Preserve Formants (Mid Side)
    -      852516 - Independent Phase
    -      852517 - Preserve Formants, Independent Phase
    -      852518 - Mid/Side, Independent Phase
    -      852519 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852528 - nothing
    -      852529 - Preserve Formants
    -      852530 - Mid/Side
    -      852531 - Preserve Formants (Mid Side)
    -      852532 - Independent Phase
    -      852533 - Preserve Formants, Independent Phase
    -      852534 - Mid/Side, Independent Phase
    -      852535 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852544 - nothing
    -      852545 - Preserve Formants
    -      852546 - Mid/Side
    -      852547 - Preserve Formants (Mid Side)
    -      852548 - Independent Phase
    -      852549 - Preserve Formants, Independent Phase
    -      852550 - Mid/Side, Independent Phase
    -      852551 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852560 - nothing
    -      852561 - Preserve Formants
    -      852562 - Mid/Side
    -      852563 - Preserve Formants (Mid Side)
    -      852564 - Independent Phase
    -      852565 - Preserve Formants, Independent Phase
    -      852566 - Mid/Side, Independent Phase
    -      852567 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852576 - nothing
    -      852577 - Preserve Formants
    -      852578 - Mid/Side
    -      852579 - Preserve Formants (Mid Side)
    -      852580 - Independent Phase
    -      852581 - Preserve Formants, Independent Phase
    -      852582 - Mid/Side, Independent Phase
    -      852583 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852592 - nothing
    -      852593 - Preserve Formants
    -      852594 - Mid/Side
    -      852595 - Preserve Formants (Mid Side)
    -      852596 - Independent Phase
    -      852597 - Preserve Formants, Independent Phase
    -      852598 - Mid/Side, Independent Phase
    -      852599 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852608 - nothing
    -      852609 - Preserve Formants
    -      852610 - Mid/Side
    -      852611 - Preserve Formants (Mid Side)
    -      852612 - Independent Phase
    -      852613 - Preserve Formants, Independent Phase
    -      852614 - Mid/Side, Independent Phase
    -      852615 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852624 - nothing
    -      852625 - Preserve Formants
    -      852626 - Mid/Side
    -      852627 - Preserve Formants (Mid Side)
    -      852628 - Independent Phase
    -      852629 - Preserve Formants, Independent Phase
    -      852630 - Mid/Side, Independent Phase
    -      852631 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852640 - nothing
    -      852641 - Preserve Formants
    -      852642 - Mid/Side
    -      852643 - Preserve Formants (Mid Side)
    -      852644 - Independent Phase
    -      852645 - Preserve Formants, Independent Phase
    -      852646 - Mid/Side, Independent Phase
    -      852647 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852656 - nothing
    -      852657 - Preserve Formants
    -      852658 - Mid/Side
    -      852659 - Preserve Formants (Mid Side)
    -      852660 - Independent Phase
    -      852661 - Preserve Formants, Independent Phase
    -      852662 - Mid/Side, Independent Phase
    -      852663 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852672 - nothing
    -      852673 - Preserve Formants
    -      852674 - Mid/Side
    -      852675 - Preserve Formants (Mid Side)
    -      852676 - Independent Phase
    -      852677 - Preserve Formants, Independent Phase
    -      852678 - Mid/Side, Independent Phase
    -      852679 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852688 - nothing
    -      852689 - Preserve Formants
    -      852690 - Mid/Side
    -      852691 - Preserve Formants (Mid Side)
    -      852692 - Independent Phase
    -      852693 - Preserve Formants, Independent Phase
    -      852694 - Mid/Side, Independent Phase
    -      852695 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852704 - nothing
    -      852705 - Preserve Formants
    -      852706 - Mid/Side
    -      852707 - Preserve Formants (Mid Side)
    -      852708 - Independent Phase
    -      852709 - Preserve Formants, Independent Phase
    -      852710 - Mid/Side, Independent Phase
    -      852711 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852720 - nothing
    -      852721 - Preserve Formants
    -      852722 - Mid/Side
    -      852723 - Preserve Formants (Mid Side)
    -      852724 - Independent Phase
    -      852725 - Preserve Formants, Independent Phase
    -      852726 - Mid/Side, Independent Phase
    -      852727 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852736 - nothing
    -      852737 - Preserve Formants
    -      852738 - Mid/Side
    -      852739 - Preserve Formants (Mid Side)
    -      852740 - Independent Phase
    -      852741 - Preserve Formants, Independent Phase
    -      852742 - Mid/Side, Independent Phase
    -      852743 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852752 - nothing
    -      852753 - Preserve Formants
    -      852754 - Mid/Side
    -      852755 - Preserve Formants (Mid Side)
    -      852756 - Independent Phase
    -      852757 - Preserve Formants, Independent Phase
    -      852758 - Mid/Side, Independent Phase
    -      852759 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852768 - nothing
    -      852769 - Preserve Formants
    -      852770 - Mid/Side
    -      852771 - Preserve Formants (Mid Side)
    -      852772 - Independent Phase
    -      852773 - Preserve Formants, Independent Phase
    -      852774 - Mid/Side, Independent Phase
    -      852775 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852784 - nothing
    -      852785 - Preserve Formants
    -      852786 - Mid/Side
    -      852787 - Preserve Formants (Mid Side)
    -      852788 - Independent Phase
    -      852789 - Preserve Formants, Independent Phase
    -      852790 - Mid/Side, Independent Phase
    -      852791 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852800 - nothing
    -      852801 - Preserve Formants
    -      852802 - Mid/Side
    -      852803 - Preserve Formants (Mid Side)
    -      852804 - Independent Phase
    -      852805 - Preserve Formants, Independent Phase
    -      852806 - Mid/Side, Independent Phase
    -      852807 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852816 - nothing
    -      852817 - Preserve Formants
    -      852818 - Mid/Side
    -      852819 - Preserve Formants (Mid Side)
    -      852820 - Independent Phase
    -      852821 - Preserve Formants, Independent Phase
    -      852822 - Mid/Side, Independent Phase
    -      852823 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852832 - nothing
    -      852833 - Preserve Formants
    -      852834 - Mid/Side
    -      852835 - Preserve Formants (Mid Side)
    -      852836 - Independent Phase
    -      852837 - Preserve Formants, Independent Phase
    -      852838 - Mid/Side, Independent Phase
    -      852839 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852848 - nothing
    -      852849 - Preserve Formants
    -      852850 - Mid/Side
    -      852851 - Preserve Formants (Mid Side)
    -      852852 - Independent Phase
    -      852853 - Preserve Formants, Independent Phase
    -      852854 - Mid/Side, Independent Phase
    -      852855 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852864 - nothing
    -      852865 - Preserve Formants
    -      852866 - Mid/Side
    -      852867 - Preserve Formants (Mid Side)
    -      852868 - Independent Phase
    -      852869 - Preserve Formants, Independent Phase
    -      852870 - Mid/Side, Independent Phase
    -      852871 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852880 - nothing
    -      852881 - Preserve Formants
    -      852882 - Mid/Side
    -      852883 - Preserve Formants (Mid Side)
    -      852884 - Independent Phase
    -      852885 - Preserve Formants, Independent Phase
    -      852886 - Mid/Side, Independent Phase
    -      852887 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852896 - nothing
    -      852897 - Preserve Formants
    -      852898 - Mid/Side
    -      852899 - Preserve Formants (Mid Side)
    -      852900 - Independent Phase
    -      852901 - Preserve Formants, Independent Phase
    -      852902 - Mid/Side, Independent Phase
    -      852903 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852912 - nothing
    -      852913 - Preserve Formants
    -      852914 - Mid/Side
    -      852915 - Preserve Formants (Mid Side)
    -      852916 - Independent Phase
    -      852917 - Preserve Formants, Independent Phase
    -      852918 - Mid/Side, Independent Phase
    -      852919 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852928 - nothing
    -      852929 - Preserve Formants
    -      852930 - Mid/Side
    -      852931 - Preserve Formants (Mid Side)
    -      852932 - Independent Phase
    -      852933 - Preserve Formants, Independent Phase
    -      852934 - Mid/Side, Independent Phase
    -      852935 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852944 - nothing
    -      852945 - Preserve Formants
    -      852946 - Mid/Side
    -      852947 - Preserve Formants (Mid Side)
    -      852948 - Independent Phase
    -      852949 - Preserve Formants, Independent Phase
    -      852950 - Mid/Side, Independent Phase
    -      852951 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852960 - nothing
    -      852961 - Preserve Formants
    -      852962 - Mid/Side
    -      852963 - Preserve Formants (Mid Side)
    -      852964 - Independent Phase
    -      852965 - Preserve Formants, Independent Phase
    -      852966 - Mid/Side, Independent Phase
    -      852967 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852976 - nothing
    -      852977 - Preserve Formants
    -      852978 - Mid/Side
    -      852979 - Preserve Formants (Mid Side)
    -      852980 - Independent Phase
    -      852981 - Preserve Formants, Independent Phase
    -      852982 - Mid/Side, Independent Phase
    -      852983 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852992 - nothing
    -      852993 - Preserve Formants
    -      852994 - Mid/Side
    -      852995 - Preserve Formants (Mid Side)
    -      852996 - Independent Phase
    -      852997 - Preserve Formants, Independent Phase
    -      852998 - Mid/Side, Independent Phase
    -      852999 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      853008 - nothing
    -      853009 - Preserve Formants
    -      853010 - Mid/Side
    -      853011 - Preserve Formants (Mid Side)
    -      853012 - Independent Phase
    -      853013 - Preserve Formants, Independent Phase
    -      853014 - Mid/Side, Independent Phase
    -      853015 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853024 - nothing
    -      853025 - Preserve Formants
    -      853026 - Mid/Side
    -      853027 - Preserve Formants (Mid Side)
    -      853028 - Independent Phase
    -      853029 - Preserve Formants, Independent Phase
    -      853030 - Mid/Side, Independent Phase
    -      853031 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853040 - nothing
    -      853041 - Preserve Formants
    -      853042 - Mid/Side
    -      853043 - Preserve Formants (Mid Side)
    -      853044 - Independent Phase
    -      853045 - Preserve Formants, Independent Phase
    -      853046 - Mid/Side, Independent Phase
    -      853047 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853056 - nothing
    -      853057 - Preserve Formants
    -      853058 - Mid/Side
    -      853059 - Preserve Formants (Mid Side)
    -      853060 - Independent Phase
    -      853061 - Preserve Formants, Independent Phase
    -      853062 - Mid/Side, Independent Phase
    -      853063 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853072 - nothing
    -      853073 - Preserve Formants
    -      853074 - Mid/Side
    -      853075 - Preserve Formants (Mid Side)
    -      853076 - Independent Phase
    -      853077 - Preserve Formants, Independent Phase
    -      853078 - Mid/Side, Independent Phase
    -      853079 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853088 - nothing
    -      853089 - Preserve Formants
    -      853090 - Mid/Side
    -      853091 - Preserve Formants (Mid Side)
    -      853092 - Independent Phase
    -      853093 - Preserve Formants, Independent Phase
    -      853094 - Mid/Side, Independent Phase
    -      853095 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853104 - nothing
    -      853105 - Preserve Formants
    -      853106 - Mid/Side
    -      853107 - Preserve Formants (Mid Side)
    -      853108 - Independent Phase
    -      853109 - Preserve Formants, Independent Phase
    -      853110 - Mid/Side, Independent Phase
    -      853111 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853120 - nothing
    -      853121 - Preserve Formants
    -      853122 - Mid/Side
    -      853123 - Preserve Formants (Mid Side)
    -      853124 - Independent Phase
    -      853125 - Preserve Formants, Independent Phase
    -      853126 - Mid/Side, Independent Phase
    -      853127 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853136 - nothing
    -      853137 - Preserve Formants
    -      853138 - Mid/Side
    -      853139 - Preserve Formants (Mid Side)
    -      853140 - Independent Phase
    -      853141 - Preserve Formants, Independent Phase
    -      853142 - Mid/Side, Independent Phase
    -      853143 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853152 - nothing
    -      853153 - Preserve Formants
    -      853154 - Mid/Side
    -      853155 - Preserve Formants (Mid Side)
    -      853156 - Independent Phase
    -      853157 - Preserve Formants, Independent Phase
    -      853158 - Mid/Side, Independent Phase
    -      853159 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853168 - nothing
    -      853169 - Preserve Formants
    -      853170 - Mid/Side
    -      853171 - Preserve Formants (Mid Side)
    -      853172 - Independent Phase
    -      853173 - Preserve Formants, Independent Phase
    -      853174 - Mid/Side, Independent Phase
    -      853175 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853184 - nothing
    -      853185 - Preserve Formants
    -      853186 - Mid/Side
    -      853187 - Preserve Formants (Mid Side)
    -      853188 - Independent Phase
    -      853189 - Preserve Formants, Independent Phase
    -      853190 - Mid/Side, Independent Phase
    -      853191 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853200 - nothing
    -      853201 - Preserve Formants
    -      853202 - Mid/Side
    -      853203 - Preserve Formants (Mid Side)
    -      853204 - Independent Phase
    -      853205 - Preserve Formants, Independent Phase
    -      853206 - Mid/Side, Independent Phase
    -      853207 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853216 - nothing
    -      853217 - Preserve Formants
    -      853218 - Mid/Side
    -      853219 - Preserve Formants (Mid Side)
    -      853220 - Independent Phase
    -      853221 - Preserve Formants, Independent Phase
    -      853222 - Mid/Side, Independent Phase
    -      853223 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853232 - nothing
    -      853233 - Preserve Formants
    -      853234 - Mid/Side
    -      853235 - Preserve Formants (Mid Side)
    -      853236 - Independent Phase
    -      853237 - Preserve Formants, Independent Phase
    -      853238 - Mid/Side, Independent Phase
    -      853239 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853248 - nothing
    -      853249 - Preserve Formants
    -      853250 - Mid/Side
    -      853251 - Preserve Formants (Mid Side)
    -      853252 - Independent Phase
    -      853253 - Preserve Formants, Independent Phase
    -      853254 - Mid/Side, Independent Phase
    -      853255 - Preserve Formants, Mid/Side, Independent Phase
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, default, pitch mode, pitch</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_DefPitchMode", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_DefPitchMode", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_DefPitchMode", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(def_pitch_mode_state)~="integer" then ultraschall.AddErrorMessage("SetProject_DefPitchMode", "def_pitch_mode_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_DefPitchMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-DEFPITCHMODE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-DEFPITCHMODE%s.-%c(.-<RENDER_CFG.*)")

  ProjectStateChunk=FileStart..def_pitch_mode_state .." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end
end

--A=ultraschall.SetProject_DefPitchMode("c:\\tt.rpp", 7865)
--A=ultraschall.GetProject_DefPitchMode("c:\\tt.rpp", 1987)

function ultraschall.SetProject_TakeLane(projectfilename_with_path, take_lane_state, ProjectStateChunk)
-- returns TakeLane state
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_TakeLane</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_TakeLane(string projectfilename_with_path, integer take_lane_state, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the take-lane-state in an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer take_lane_state - take-lane-state
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, take, lane</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TakeLane", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_TakeLane", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TakeLane", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(take_lane_state)~="integer" then ultraschall.AddErrorMessage("SetProject_TakeLane", "take_lane_state", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TakeLane", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-TAKELANE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-TAKELANE%s.-%c(.-<RENDER_CFG.*)")

  ProjectStateChunk=FileStart..take_lane_state.." \n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_TakeLane("c:\\tt.rpp",76)
--A=ultraschall.GetProject_TakeLane("c:\\tt.rpp",1)

function ultraschall.SetProject_SampleRate(projectfilename_with_path, sample_rate, project_sample_rate, force_tempo_time_sig, ProjectStateChunk)
-- returns Project Settings Samplerate
--        a - Project Sample Rate
--        b - Checkbox: Project Sample Rate
--        c - Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples 

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_SampleRate</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_SampleRate(string projectfilename_with_path, integer sample_rate, integer project_sample_rate, integer force_tempo_time_sig, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the project-samplerate-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer sample_rate - Project Sample Rate in Hz
    integer project_sample_rate - Checkbox: Project Sample Rate
    integer force_tempo_time_sig - Checkbox: Force Project Tempo/Time Signature changes to occur on whole samples 
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, sample, rate, samplerate, tempo, time, signature</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SampleRate", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_SampleRate", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SampleRate", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(sample_rate)~="integer" then ultraschall.AddErrorMessage("SetProject_SampleRate", "sample_rate", "Must be an integer", -4) return -1 end
  if math.type(project_sample_rate)~="integer" then ultraschall.AddErrorMessage("SetProject_SampleRate", "project_sample_rate", "Must be an integer", -5) return -1 end
  if math.type(force_tempo_time_sig)~="integer" then ultraschall.AddErrorMessage("SetProject_SampleRate", "force_tempo_time_sig", "Must be an integer", -6) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_SampleRate", "projectfilename_with_path", "No valid RPP-Projectfile!", -7) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-SAMPLERATE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-SAMPLERATE%s.-%c(.-<RENDER_CFG.*)")

  ProjectStateChunk=FileStart..sample_rate.." "..project_sample_rate.." "..force_tempo_time_sig.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A,AA,AAA=ultraschall.SetProject_SampleRate("c:\\tt.rpp",9,8,7)
--A,AA,AAA=ultraschall.GetProject_SampleRate("c:\\tt.rpp",8000,2,0)

function ultraschall.SetProject_TrackMixingDepth(projectfilename_with_path, mixingdepth, ProjectStateChunk)
-- returns TrackMixingDepth
--          1 - 32 bit float
--          2 - 39 bit integer
--          3 - 24 bit integer
--          4 - 16 bit integer
--          5 - 12 bit integer
--          6 - 8 bit integer

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_TrackMixingDepth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_TrackMixingDepth(string projectfilename_with_path, integer mixingdepth, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the project-samplerate-state, as set in the project-settings, from an rpp-project-file or a ProjectStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    integer mixingdepth - the track mixing depth
                        -   1 - 32 bit float
                        -   2 - 39 bit integer
                        -   3 - 24 bit integer
                        -   4 - 16 bit integer
                        -   5 - 12 bit integer
                        -   6 - 8 bit integer
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, sample, rate, samplerate, tempo, time, signature</tags>
</US_DocBloc>
]]
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TrackMixingDepth", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_TrackMixingDepth", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TrackMixingDepth", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if math.type(mixingdepth)~="integer" then ultraschall.AddErrorMessage("SetProject_TrackMixingDepth", "mixingdepth", "Must be an integer", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_TrackMixingDepth", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-INTMIXMODE%s).-%c.-<RENDER_CFG.*")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-INTMIXMODE%s.-%c(.-<RENDER_CFG.*)")

  if FileStart==nil or FileEnd==nil then 
    FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-)<RENDER_CFG.*")
    FileEnd="  "..ProjectStateChunk:match("<REAPER_PROJECT.-(<RENDER_CFG.*)")
    mixingdepth="INTMIXMODE "..mixingdepth
  end

  ProjectStateChunk=FileStart..mixingdepth.."\n"..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

--A=ultraschall.SetProject_TrackMixingDepth("c:\\tt.rpp",9865)
--A=ultraschall.GetProject_TrackMixingDepth("c:\\tt.rpp",2)


--- Delete ---



-------------------------------
---- Reaper.ini Management ----
-------------------------------

--- Get ---

--- Set ---

--- Delete ---


----------------------
---- FX-Snapshots ----
----------------------




--reaper.MB(reaper.GetAppVersion(),"",0)

function ultraschall.MoveTrackEnvelopePointsBy(startposition, endposition, moveby, MediaTrack, cut_at_border)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveTrackEnvelopePointsBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.MoveTrackEnvelopePointsBy(number startposition, number endposition, number moveby, MediaTrack MediaTrack, boolean cut_at_border)</functioncall>
  <description>
    Moves the envelopepoints between startposition and endposition by moveby in MediaTrack. 
    It moves all trackenvelope-points for all track-envelopes available.
    
    Does NOT move item-envelopepoints!
    
    Returns -1 in case of failure.
  </description>
  <retvals>
    integer retval - -1 in case of failure
  </retvals>
  <parameters>
    number startposition - the startposition in seconds
    number endposition - the endposition in seconds
    number moveby - in seconds, negative values: move toward beginning of project, positive values: move toward the end of project
    MediaTrack MediaTrack - the MediaTrack object of the track, where the EnvelopsPoints shall be moved
    boolean cut_at_border - true, cut envelope-points, that would move outside section between startposition and endposition
  </parameters>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, move, moveby</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("MoveTrackEnvelopePointsBy", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("MoveTrackEnvelopePointsBy", "endposition", "must be a number", -2) return -1 end
  if type(moveby)~="number" then ultraschall.AddErrorMessage("MoveTrackEnvelopePointsBy", "moveby", "must be a number", -3) return -1 end
  if reaper.ValidatePtr2(0, MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("MoveTrackEnvelopePointsBy", "MediaTrack", "must be a valid MediaTrack", -4) return -1 end
  if type(cut_at_border)~="boolean" then ultraschall.AddErrorMessage("MoveTrackEnvelopePointsBy", "cut_at_border", "must be a boolean", -5) return -1 end

  if moveby==0 then return -1 end
--[[

  local EnvTrackCount=reaper.CountTrackEnvelopes(MediaTrack)
--  local numtimesigmarkers = reaper.CountTempoTimeSigMarkers(0)
  
  local start, stop, step, boolean
  if moveby>0 then start=EnvTrackCount stop=0 step=-1
  elseif moveby<0 then start=0 stop=EnvTrackCount step=1
  end

  if cut_at_borders==true then
    for i=EnvTrackCount, 0, -1 do
      local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, i)
--    local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
      if timepos>=startposition and timepos<=endposition then
        if (timepos+moveby>endposition or timepos+moveby<startposition) then
          boolean=reaper.DeleteTempoTimeSigMarker(0, i)
        end
      end
    end
  end

  for i=start, stop, step do
    local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
    if timepos>=startposition and timepos<=endposition then
        boolean = reaper.SetTempoTimeSigMarker(0, i, timepos+moveby, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo)
    end
  end
  
  if update_timeline==true then reaper.UpdateTimeline() end
  return 1
end
--]]

  local EnvTrackCount=reaper.CountTrackEnvelopes(MediaTrack)

  for a=0, EnvTrackCount-1 do
    local TrackEnvelope=reaper.GetTrackEnvelope(MediaTrack, a)
    local EnvCount=reaper.CountEnvelopePoints(TrackEnvelope)
  
    for i=EnvCount, 0, -1 do
      local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, i)
      if time>=startposition and time<=endposition then
        if time+moveby>=tonumber(startposition) and time+moveby<=tonumber(endposition) then
          reaper.SetEnvelopePoint(TrackEnvelope, i, time+moveby,nil,nil,nil,nil,true)
        elseif cut_at_border==true and (time+moveby<tonumber(startposition) or time+moveby>tonumber(endposition)) then
          local boolean=reaper.DeleteEnvelopePointRange(TrackEnvelope, time, time+0.0000000000001)
        end
      end
    end
    reaper.Envelope_SortPoints(TrackEnvelope)
  end
  
end
--]]
--B=reaper.GetTrack(0,0)
--A=ultraschall.MoveTrackEnvelopePointsBy(20, 1068, 101, B, true)
--reaper.UpdateArrange()
--Envelope_SortPoints


---------------------------
---- Marker Management ----
---------------------------


function ultraschall.GetAllMarkersBetween(startposition, endposition)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMarkersBetween</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_all_markers, array allmarkersarray = ultraschall.GetAllMarkersBetween(number startposition, number endposition)</functioncall>
  <description>
    To get all Markers in the project(normal, edit, chapter), regardless of their category, between startposition and endposition.
    Doesn't return regions!
    
    returns the number of markers and an array with each marker in the format:
    
        markersarray[index][0] - position
        markersarray[index][1] - name
        markersarray[index][2] - indexnumber of the marker within all markers in the project
        markersarray[index][3] - the shown index-number
        markersarray[index][4] - the color of the marker
    
    returns -1 in case of error    
  </description>
  <retvals>
    integer number_of_allmarkers - the number of markers returned
    array allmarkersarray  - an array, that holds all markers(not regions!) of the project
  </retvals>
  <parameters>
    number startposition - the earliest position a returned marker may have
    number endposition - the latest position a returned marker may have
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, get, get all between</tags>
</US_DocBloc>
--]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("GetAllMarkersBetween","startposition", "Must be a number!", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("GetAllMarkersBetween","endposition", "Must be a number!", -2) return -1 end
  if endposition<startposition then ultraschall.AddErrorMessage("GetAllMarkersBetween","endposition", "Must be bigger than startposition!", -3) return -1 end
  if startposition<0 then ultraschall.AddErrorMessage("GetAllMarkersBetween","startposition", "Must be bigger or equal 0!", -4) return -1 end
  local A,B=ultraschall.GetAllMarkers()
  for i=A, 1, -1 do
    if B[i][0]<startposition or B[i][0]>endposition then table.remove(B,i) A=A-1 end
  end
  return A,B
end

--A,B=ultraschall.GetAllMarkersBetween(80, 300)

function ultraschall.GetAllRegions()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_all_regions, array allregionsarray = ultraschall.GetAllRegions()</functioncall>
  <description>
    To get all Regions in the project(normal, edit, chapter), regardless of their category.
    Doesn't return markers!
    
    returns the number of markers and an array with each marker in the format:
    
        regionarray[index][0] - position
        regionarray[index][1] - endposition
        regionarray[index][2] - name
        regionarray[index][3] - indexnumber of the region within all markers in the project
        regionarray[index][4] - the shown index-number
        regionarray[index][5] - the color of the region
        
  </description>
  <retvals>
    integer number_of_allregions - the number of regions returned
    array regionsarray - an array, that holds all regions(not markers!) of the project
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, region, get, get all</tags>
</US_DocBloc>
--]]
  local Count=reaper.CountProjectMarkers(0)
  local RegionArray={}
  local RegCount=1
  for i=0, Count-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==true then
      RegionArray[RegCount]={}
      RegionArray[RegCount][0]=pos
      RegionArray[RegCount][1]=rgnend
      RegionArray[RegCount][2]=name
      RegionArray[RegCount][3]=retval-1
      RegionArray[RegCount][4]=markrgnindexnumber
      RegionArray[RegCount][5]=color
      RegCount=RegCount+1
    end
  end
  return RegCount-1, RegionArray
end

--A,B=ultraschall.GetAllRegions()

function ultraschall.GetAllRegionsBetween(startposition, endposition, partial)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllRegionsBetween</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_all_regions, array allregionsarray = ultraschall.GetAllRegionsBetween(number startposition, number endposition, boolean partial)</functioncall>
  <description>
    To get all Regions in the project(normal, edit, chapter), regardless of their category between start- and endposition.
    Set partial to true, if you want to get regions as well, that are only partially between start- and endposition
    Doesn't return markers!
    
    returns the number of markers and an array with each marker in the format:
    
        regionarray[index][0] - position
        regionarray[index][1] - endposition
        regionarray[index][2] - name
        regionarray[index][3] - indexnumber of the region within all markers in the project
        regionarray[index][4] - the shown index-number
        regionarray[index][5] - the color of the region
        
  </description>
  <retvals>
    integer number_of_allregions - the number of regions returned
    array regionsarray - an array, that holds all regions(not markers!) of the project
  </retvals>
  <parameters>
    number startposition - the earliest position a returned region may have
    number endposition - the latest position a returned region may have
    boolean retval - true, to get regions that are partially within start and endposition as well; false, only regions completely within start/endposition.
  </parameters>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, region, get, get all</tags>
</US_DocBloc>
--]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("GetAllRegionsBetween","startposition", "Must be a number!", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("GetAllRegionsBetween","endposition", "Must be a number!", -2) return -1 end
  if endposition<startposition then ultraschall.AddErrorMessage("GetAllRegionsBetween","endposition", "Must be bigger than startposition!", -3) return -1 end
  if startposition<0 then ultraschall.AddErrorMessage("GetAllRegionsBetween","startposition", "Must be bigger or equal 0!", -4) return -1 end
  if type(partial)~="boolean" then ultraschall.AddErrorMessage("GetAllRegionsBetween","partial", "Must be boolean!", -4) return -1 end

  local A,B=ultraschall.GetAllRegions()
  for i=A, 1, -1 do
    if partial==false then
      if (B[i][0]<startposition or B[i][0]>endposition)
        or (B[i][1]<startposition or B[i][1]>endposition) then
          table.remove(B,i)
          A=A-1
      end
        
    elseif partial==true then
      if (B[i][0]>=startposition and B[i][0]<=endposition)
      or (B[i][1]>=startposition and B[i][1]<=endposition)
      or (B[i][0]<=startposition and B[i][1]>=endposition) then
      else
          table.remove(B,i)
          A=A-1
      end
    end
  end
  return A,B
end

--A,B=ultraschall.GetAllRegionsBetween(360, 810, false)

-------------------------------
---- Media Item Management ----
-------------------------------

function ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
--sorts entries in a trackstring and removes duplicate numbers.
--returns it as csv string(values separated by a ,), an array, with all the tracknumbers individually and the number of numbers in the trackstring
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RemoveDuplicateTracksInTrackstring</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, string trackstring, array trackstringarray, integer number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(string trackstring)</functioncall>
  <description>
    Sorts tracknumbers in trackstring and throws out duplicates. It also throws out entries, that are no numbers.
    Returns the "cleared" trackstring as string and as array, as well as the number of entries. Returns -1 in case of failure.
  </description>
  <parameters>
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    string trackstring - the cleared trackstring, -1 in case of error
    array trackstringarray - the "cleared" trackstring as an array
    integer number_of_entries - the number of entries in the trackstring
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, trackstring, sort, order</tags>
</US_DocBloc>
]]
    if type(trackstring)~="string" then ultraschall.AddErrorMessage("RemoveDuplicateTracksInTrackstring","trackstring", "must be a string", -1) return -1 end
    local _count, Trackstring_array=ultraschall.CSV2IndividualLinesAsArray(trackstring)    
    if Trackstring_array==nil then ultraschall.AddErrorMessage("RemoveDuplicateTracksInTrackstring","trackstring", "not a valid trackstring", -3) return -1 end
    table.sort(Trackstring_array)
    local count=2
    while Trackstring_array[count]~=nil do
      if Trackstring_array[count]==Trackstring_array[count-1] then table.remove(Trackstring_array,count) count=count-1 
      elseif tonumber(Trackstring_array[count])==nil then table.remove(Trackstring_array,count) count=count-1
      end
      count=count+1
    end
    count=1
    if tonumber(Trackstring_array[1])==nil then table.remove(Trackstring_array,1) end
    trackstring=""
    while Trackstring_array[count]~=nil do
      trackstring=trackstring..Trackstring_array[count]..","
      Trackstring_array[count]=tonumber(Trackstring_array[count])
      count=count+1
    end
    return 1, trackstring:sub(1,-2), Trackstring_array, count-1
end

--A,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring("1,2,99,8,4,1,1,2,2,1,2,6,8,66,6,445")

--C,CC=ultraschall.GetAllMediaItemsBetween(0,260,"1,2,3",false)
--P=ultraschall.OnlyMediaItemsOfTracksInTrackstring(CC, "2,3")


function ultraschall.GetMediaItemsAtPosition(position, trackstring)
-- returns the items at given position in your selected tracks
--
-- number position - time in seconds
-- string trackstring - the tracksnumbers, beginning with 1 for first track, separated by a ,
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemsAtPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetMediaItemsAtPosition(number position, string trackstring)</functioncall>
  <description>
    Gets all Mediaitems at position, from the tracks given by trackstring.
    Returns a MediaItemArray with the found MediaItems; returns -1 in case of error
  </description>
  <parameters>
    number position - position in seconds
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    integer number_of_items - the number of items at position
    array MediaItemArray - an array, that contains all MediaItems at position from the tracks given by trackstring.
    array MediaItemStateChunkArray - an array, that contains all Mediaitem's MediaItemStatechunks at position from the tracks given by trackstring.
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selection, statechunk</tags>
</US_DocBloc>
]]

  if type(position)~="number" then ultraschall.AddErrorMessage("GetMediaItemsAtPosition","position", "must be a number", -1) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("GetMediaItemsAtPosition","trackstring", "must be a valid trackstring", -2) return -1 end
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  
  local MediaItemArray={}
  local MediaItemStateChunkArray={}
  local count=0
  local Numbers, LineArray=ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local Anumber=reaper.CountMediaItems(0)
  local temp
  for i=0,Anumber-1 do
    local MediaItem=reaper.GetMediaItem(0, i)
    local Astart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
    local Alength=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
    local MediaTrack=reaper.GetMediaItem_Track(MediaItem)
    local MediaTrackNumber=reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")
    local Aend=Astart+Alength
    if position>=Astart and position<=Aend then
       for a=1, Numbers do
--       reaper.MB(MediaTrackNumber,LineArray[a],0)
        if tonumber(LineArray[a])==nil then ultraschall.AddErrorMessage("GetMediaItemsAtPosition","trackstring", "must be a valid trackstring", -2) return -1 end
        if MediaTrackNumber==tonumber(LineArray[a]) then
          count=count+1 
          MediaItemArray[count]=MediaItem
          temp, MediaItemStateChunkArray[count]=reaper.GetItemStateChunk(MediaItemArray[count], "", true)
--          reaper.MB(MediaTrackNumber,LineArray[a],0)
        end
       end
    end
  end
  return count, MediaItemArray, MediaItemStateChunkArray
end

--reaper.MB(tostring(AA[1],"",0),"",0)

--A,B,C=ultraschall.GetMediaItemsAtPosition(1, "1")
--C=ultraschall.OnlyMediaItemsOfTracksInTrackstring(B, "o")

function ultraschall.OnlyMediaItemsOfTracksInTrackstring(MediaItemArray, trackstring)
--Throws out all items, that are not in the tracks, as given by trackstring
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyMediaItemsOfTracksInTrackstring</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, array MediaItemArray = ultraschall.OnlyMediaItemsOfTracksInTrackstring(array MediaItemArray, string trackstring)</functioncall>
  <description>
    Throws all MediaItems out of the MediaItemArray, that are not within the tracks, as given with trackstring.
    Returns the "cleared" MediaItemArray; returns -1 in case of error
  </description>
  <parameters>
    array MediaItemArray - an array with MediaItems; no nil-entries allowed, will be seen as the end of the array
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    array MediaItemArray - the "cleared" array, that contains only Items in tracks, as given by trackstring, -1 in case of error
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selection</tags>
</US_DocBloc>
]]
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring","MediaItemArray", "must be a MediaItemArray", -1) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring","trackstring", "must be a valid trackstring", -2) return -1 end
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  
  local count=1
  local count2=1
  local i=1
  local _count, trackstring_array = ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local MediaItemArray2={}
  
  while MediaItemArray[count]~=nil do
    if MediaItemArray[count]==nil then break end
    i=1
    while trackstring_array[i]~=nil do
      if tonumber(trackstring_array[i])==nil then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring","MediaItemArray", "must be a valid MediaItemArray", -1) return -1 end
        if reaper.GetTrack(0,trackstring_array[i]-1)==reaper.GetMediaItem_Track(MediaItemArray[count]) then
          MediaItemArray2[count2]=MediaItemArray[count]
          count2=count2+1
        end
        i=i+1
    end
    count=count+1
  end
  return 1, MediaItemArray2
end

--A,B=ultraschall.GetMediaItemsAtPosition(1, "1,2,3")
--CT=ultraschall.OnlyMediaItemsOfTracksInTrackstring(B, "1")


function ultraschall.SplitMediaItems_Position(position, trackstring, crossfade)
-- Deletes ItemObject
-- MediaItem MediaItemObject - the MediaItem to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SplitMediaItems_Position</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array MediaItemArray = ultraschall.SplitMediaItems_Position(number position, string trackstring, boolean crossfade)</functioncall>
  <description>
    Splits items at position, in the tracks given by trackstring.
    If auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).
    
    Returns false, in case of error.
  </description>
  <parameters>
    number position - the position in seconds
    string trackstring - the numbers for the tracks, where split shall be applied to; numbers separated by a comma
    boolean crossfade - true or nil, automatic crossfade(if enabled) will be applied; false, automatic crossfade is off
  </parameters>
  <retvals>
    boolean retval - true - success, false - error
    array MediaItemArray - an array with the items on the right side of the split
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, split, edit, crossfade</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("SplitMediaItems_Position","position", "must be a number", -1) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("SplitMediaItems_Position","trackstring", "must be valid trackstring", -2) return -1 end

  local A,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("SplitMediaItems_Position","trackstring", "must be valid trackstring", -2) return -1 end

  local FadeOut, MediaItem, oldfade, oldlength
  local ReturnMediaItemArray={}
  local count=0
  local Numbers, LineArray=ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local Anumber=reaper.CountMediaItems(0)

  if crossfade~=nil and type(crossfade)~="boolean" then ultraschall.AddErrorMessage("SplitMediaItems_Position","crossfade", "must be boolean", -3) return false end
  for i=Anumber-1,0,-1 do
    MediaItem=reaper.GetMediaItem(0, i)
    local Astart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
    local Alength=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
    FadeOut=reaper.GetMediaItemInfo_Value(MediaItem, "D_FADEOUTLEN")
    local MediaTrack=reaper.GetMediaItem_Track(MediaItem)
    local MediaTrackNumber=reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")
    local Aend=(Astart+Alength)
    if position>=Astart and position<=Aend then
       for a=1, Numbers do
        if tonumber(LineArray[a])==nil then ultraschall.AddErrorMessage("SplitMediaItems_Position","trackstring", "must be valid trackstring", -2) return false end
        if MediaTrackNumber==tonumber(LineArray[a]) then
          count=count+1 
          ReturnMediaItemArray[count]=reaper.SplitMediaItem(MediaItem, position)
          if crossfade==false then 
              oldfade=reaper.GetMediaItemInfo_Value(MediaItem, "D_FADEOUTLEN_AUTO")
            oldlength=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
            reaper.SetMediaItemInfo_Value(MediaItem, "D_LENGTH", oldlength-oldfade)
          end
        end
       end
    end
  end
  return true, ReturnMediaItemArray
end

--retval, MediaItemArray = ultraschall.SplitMediaItems_Position(22.155, "1,3,4")

--AA,B=ultraschall.SplitMediaItems_Position(43, "1,2,3,4,5", false)

--D_FADEOUTLEN

--B=ultraschall.SplitMediaItems_Position(20,"1,2,3",false)
--boolean retval, string str = reaper.GetItemStateChunk(MediaItem item, string str, boolean isundo)

--retval, str = reaper.GetItemStateChunk(MediaItem item, "", true)

function ultraschall.SplitItemsAtPositionFromArray(position, MediaItemArray, crossfade)
-- Splits the MediaItems from MediaItemArray and returns it's right hand split as an array.
-- The MediaItemArray must not include nil-entries, as they'll be interpreted as end of array.
-- MediaItemArray must start with indexnumber 1 !

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SplitItemsAtPositionFromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array MediaItemArray = ultraschall.SplitItemsAtPositionFromArray(number position, array MediaItemArray, boolean crossfade)</functioncall>
  <description>
    Splits items in MediaItemArray at position, in the tracks given by trackstring.
    If auto-crossfade is set in the Reaper-preferences, crossfade turns it on(true) or off(false).
    
    Returns false, in case of error.
  </description>
  <parameters>
    number position - the position in seconds
    array MediaItemArray - an array with the items, where split shall be applied to. No nil-entries allowed!
    boolean crossfade - true - automatic crossfade(if enabled) will be applied; false - automatic crossfade is off
  </parameters>
  <retvals>
    boolean retval - true - success, false - error
    array MediaItemArray - an array with the items on the right side of the split
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, split, edit, crossfade, mediaitemarray</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("SplitItemsAtPositionFromArray", "position", "Must be a number", -1) return false end
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("SplitItemsAtPositionFromArray", "MediaItemArray", "Must be a valid MediaItemArray", -2) return false end
  if type(crossfade)~="boolean" then ultraschall.AddErrorMessage("SplitItemsAtPositionFromArray", "crossfade", "Must be a boolean", -3) return false end

  local ReturnMediaItemArray={}
  local count=1
  while MediaItemArray[count]~=nil do
    ReturnMediaItemArray[count]=reaper.SplitMediaItem(MediaItemArray[count], position)
    if crossfade==false then 
      oldfade=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_FADEOUTLEN_AUTO")
      oldlength=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH")
      reaper.SetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH", oldlength-oldfade)
    end
    count=count+1
  end
  return true, ReturnMediaItemArray
end

--reaper.MB(tostring(A2),"",0)
--A,AA=ultraschall.GetMediaItemsAtPosition(20, "1,3")
--B,BB=ultraschall.SplitItemsAtPositionFromArray(2,AA,false)

--reaper.UpdateArrange()

function ultraschall.DeleteMediaItem(MediaItemObject)
-- Deletes ItemObject
-- MediaItem MediaItemObject - the MediaItem to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMediaItem</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string MediaItemStateChunk = ultraschall.DeleteMediaItem(MediaItem MediaItem)</functioncall>
  <description>
    deletes a MediaItem. Returns true, in case of success, false in case of error.
    
    returns the MediaItemStateChunk of the deleted MediaItem as well, so you can do additional processing with a deleted item.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem to be deleted
  </parameters>
  <retvals>
    boolean retval - true, delete was successful; false was unsuccessful
    string MediaItemStateChunk - the StateChunk of the deleted MediaItem
                               - the statechunk contains an additional entry "ULTRASCHALL_TRACKNUMBER" which holds the tracknumber, in which the deleted MediaItem was located
  </retvals>
  <chapter_context>
    MediaItem Management
    Delete
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, delete</tags>
</US_DocBloc>
]]
    if reaper.ValidatePtr2(0, MediaItemObject, "MediaItem*")==false then ultraschall.AddErrorMessage("DeleteMediaItem","MediaItem", "must be a MediaItem", -1) return false end
    local MediaTrack=reaper.GetMediaItemTrack(MediaItemObject)
    local _temp, StateChunk=reaper.GetItemStateChunk(MediaItemObject, "", false)
    StateChunk = ultraschall.SetItemUSTrackNumber_StateChunk(StateChunk, math.floor(reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")))
    return reaper.DeleteTrackMediaItem(MediaTrack, MediaItemObject), StateChunk
end

-- MediaItem=reaper.GetMediaItem(0,0)
-- A,B=ultraschall.DeleteMediaItem(MediaItem)
-- reaper.MB(B,"",0)

function ultraschall.DeleteMediaItemsFromArray(MediaItemArray)
-- Deletes the MediaItems from MediaItemArray
-- The MediaItemArray must not include nil-entries, as they'll be interpreted as end of array.
-- MediaItemArray must start with indexnumber 1 !
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMediaItemsFromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array MediaItemArray = ultraschall.DeleteMediaItemsFromArray(array MediaItemArray)</functioncall>
  <description>
    deletes the MediaItems from MediaItemArray. Returns true, in case of success, false in case of error.
    In addition, it returns a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItems
  </description>
  <parameters>
    array MediaItemArray - a array with MediaItem-objects to delete; no nil entries allowed
  </parameters>
  <retvals>
    boolean retval - true, delete was successful; false was unsuccessful
    array MediaItemStateChunkArray - and array with all statechunks of all deleted MediaItems; 
                                   - each statechunk contains an additional entry "ULTRASCHALL_TRACKNUMBER" which holds the tracknumber, in which the deleted MediaItem was located
  </retvals>
  <chapter_context>
    MediaItem Management
    Delete
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, delete</tags>
</US_DocBloc>
]]  
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("DeleteMediaItemsFromArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return false end
--  reaper.MB(tostring(MediaItemArray),"",0)
-- Mespotine
  local count=1
  local MediaItemStateChunkArray={}
  local hula
  while MediaItemArray[count]~=nil do
    hula, MediaItemStateChunkArray[count]=ultraschall.DeleteMediaItem(MediaItemArray[count])
    count=count+1
  end
  return true, MediaItemStateChunkArray
end


--Aposition=24
--A1,A2=ultraschall.GetMediaItemsAtPosition(197, "1,2,3")
--AAAAAA=ultraschall.SplitItemsAtPosition(Aposition, A2)
--A3,A4=ultraschall.GetMediaItemsAtPosition(10, "1,2,3")
--AAAAAAA=ultraschall.SplitItemsAtPosition(Aposition+5, A4)
--K,K2=ultraschall.DeleteMediaItemsFromArray(A2)



function ultraschall.DeleteMediaItems_Position(position, trackstring)
-- Deletes ItemObject
-- MediaItem MediaItemObject - the MediaItem to delete
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMediaItems_Position</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array MediaItemStateChunkArray = ultraschall.DeleteMediaItems_Position(number position, string trackstring)</functioncall>
  <description>
    Delete the MediaItems at given position, from the tracks as given by trackstring.
    returns, if deleting was successful and an array with all statechunks of all deleted MediaItems
  </description>
  <parameters>
    number position - the position in seconds
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    boolean retval - true, delete was successful; false was unsuccessful
    array MediaItemStateChunkArray - and array with all statechunks of all deleted MediaItems; 
                                   - each statechunk contains an additional entry "ULTRASCHALL_TRACKNUMBER" which holds the tracknumber, in which the deleted MediaItem was located
  </retvals>
  <chapter_context>
    MediaItem Management
    Delete
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, delete</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("DeleteMediaItems_Position", "position", "must be a number", -1) return false end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("DeleteMediaItems_Position", "trackstring", "must be a valid trackstring", -2) return false end
  
  local count=0
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("DeleteMediaItems_Position", "trackstring", "must be a valid trackstring", -3) return false end
  local Numbers, LineArray=ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local Anumber=reaper.CountMediaItems(0)
  local MediaItemStateChunkArray={}
  local _temp
  
  for i=Anumber-1, 0, -1 do
    local MediaItem=reaper.GetMediaItem(0, i)
    local Astart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
    local Alength=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
    local MediaTrack=reaper.GetMediaItem_Track(MediaItem)
    local MediaTrackNumber=reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")
    local Aend=Astart+Alength
    if position>=Astart and position<=Aend then
       for a=1, Numbers do
        if tonumber(LineArray[a])==nil then return false end
        if MediaTrackNumber==tonumber(LineArray[a]) then
          count=count+1 
          _temp, MediaItemStateChunkArray[a] = ultraschall.DeleteMediaItem(MediaItem)
        end
       end
    end
  end
  return true, MediaItemStateChunkArray
end


-- L,LL=ultraschall.DeleteMediaItems_Position(207,"1,2,3")
--

--A,AA=ultraschall.SplitMediaItems_Position(207,"1")
--ALABAMAA=ultraschall.DeleteMediaItemsFromArray(AA)
--reaper.UpdateArrange()

function ultraschall.GetAllMediaItemsBetween(startposition, endposition, trackstring, inside)
--returns all MediaItems between startposition and endposition in the tracks given with trackstring
--
-- number startposition - time in seconds
-- number endposition - time in seconds
-- string trackstring - the tracksnumbers, beginning with 1 for first track, separated by a ,
-- boolean inside - true: only return items that are fully inside selection, 
--                  false: include items where at least start or end is inside selection

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItemsBetween</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetAllMediaItemsBetween(number startposition, number endposition, string trackstring, boolean inside)</functioncall>
  <description>
    Gets all MediaItems between startposition and endposition from the tracks as given by trackstring. 
    Set inside to true to get only items, that are fully within the start and endposition, set it to false, if you also want items, that are just partially inside(end or just the beginning of the item).
    
    Returns the number of items, an array with all the MediaItems and an array with all the MediaItemStateChunks of the items, as used by functions as <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    The statechunks include a new element "ULTRASCHALL_TRACKNUMBER", which contains the tracknumber of where the item originally was in; important, if you delete the items as you'll otherwise loose this information!
    Returns -1 in case of failure.
  </description>
  <parameters>
    number startposition - startposition in seconds
    number endposition - endposition in seconds
    string trackstring - the tracknumbers, separated by a comma
    boolean inside - true, only items that are completely within selection; false, include items that are partially within selection
  </parameters>
  <retvals>
    integer count - the number of selected items
    array MediaItemArray - an array with all the found MediaItems
    array MediaItemStateChunkArray - an array with the MediaItemStateChunks, that can be used to create new items with <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selection, position, statechunk, rppxml</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("GetAllMediaItemsBetween", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("GetAllMediaItemsBetween", "endposition", "must be a number", -2) return -1 end
  if startposition>endposition then ultraschall.AddErrorMessage("GetAllMediaItemsBetween", "endposition", "must be bigger than startposition", -3) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("GetAllMediaItemsBetween", "trackstring", "must be a valid trackstring", -4) return -1 end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("GetAllMediaItemsBetween", "inside", "must be a boolean", -5) return -1 end
    
  local MediaItemArray={}
  local MediaItemStateChunkArray={}
  local count=0
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return -1 end
  local Numbers, LineArray=ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local Anumber=reaper.CountMediaItems(0)
  local temp
  for i=0,Anumber-1 do
    local MediaItem=reaper.GetMediaItem(0, i)
    local Astart=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
    local Alength=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
    local MediaTrack=reaper.GetMediaItem_Track(MediaItem)
    local MediaTrackNumber=reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")
    local Aend=Astart+Alength
    if inside==true and Astart>=startposition and 
        Astart<=endposition  and
        Aend>=startposition and
        Aend<=endposition then
        for a=1, Numbers do
          if tonumber(LineArray[a])==nil then return -1 end
          if MediaTrackNumber==tonumber(LineArray[a]) then
            count=count+1 
            MediaItemArray[count]=MediaItem
            temp,MediaItemStateChunkArray[count] = reaper.GetItemStateChunk(MediaItem, "", true)
            local tempMediaTrack=reaper.GetMediaItemTrack(MediaItem)
            local Tnumber=reaper.GetMediaTrackInfo_Value(tempMediaTrack, "IP_TRACKNUMBER")
            if MediaItemStateChunkArray[count]~=nil then MediaItemStateChunkArray[count]="<ITEM\nULTRASCHALL_TRACKNUMBER "..math.floor(Tnumber).."\n"..MediaItemStateChunkArray[count]:match("<ITEM(.*)") end
          end
       end
    elseif inside==false then
      if (Astart>=startposition and Astart<=endposition) or
          (Aend>=startposition and Aend<=endposition) or
          (Astart<=startposition and Aend>=endposition) then
        for a=1, Numbers do
          if tonumber(LineArray[a])==nil then return -1 end
          if MediaTrackNumber==tonumber(LineArray[a]) then
            count=count+1 
            MediaItemArray[count]=MediaItem
            temp,MediaItemStateChunkArray[count]= reaper.GetItemStateChunk(MediaItem, "", true)
            local tempMediaTrack=reaper.GetMediaItemTrack(MediaItem)
            local Tnumber=reaper.GetMediaTrackInfo_Value(tempMediaTrack, "IP_TRACKNUMBER")
            MediaItemStateChunkArray[count]="<ITEM\nULTRASCHALL_TRACKNUMBER "..Tnumber..MediaItemStateChunkArray[count]:match("<ITEM(.*)")
          end
       end
      end 
    end
  end
  return count, MediaItemArray, MediaItemStateChunkArray

end

--A,MediaItem,statechunks=ultraschall.GetAllMediaItemsBetween(reaper.GetCursorPosition(),reaper.GetCursorPosition(),"1",false)
--reaper.MB(statechunks[1],"",0)

--A,AA=ultraschall.GetAllMediaItemsBetween(4,2100,"1,2,3",true)
--A,AA,AAA=ultraschall.GetAllMediaItemsBetween(0,200,"1,2,3",true)


function ultraschall.MoveMediaItemsAfter_By(oldposition, changepositionby, trackstring)
--Moves all MediaItems, between oldposition and the end of the project, by changepositionby, in all tracks given by trackstring
--intended for things as RippleCut
--
-- number oldposition - old position in seconds
-- number changepositionby - the difference in seconds. negative means, move toward projectstart, positive toward projectend
-- string trackstring - the tracksnumbers, beginning with 1 for first track, separated by a ,

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveMediaItemsAfter_By</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MoveMediaItemsAfter_By(number old_position, number change_position_by, string trackstring)</functioncall>
  <description>
    Moves all items after old_position by change_position_by-seconds. Affects only items, that begin after oldposition, so items that start before and end after old_position do not move.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    number oldposition - the position, from where the movement shall be applied to, in seconds
    number change_position_by - the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, move, position</tags>
</US_DocBloc>
]]
  
  if type(oldposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsAfter_By", "old_position", "must be a number", -1) return false end
  if type(changepositionby)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsAfter_By", "changepositionby", "must be a number", -2) return false end
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("MoveMediaItemsAfter_By", "trackstring", "must be a valid trackstring", -3) return false end
  local A,MediaItem=ultraschall.GetAllMediaItemsBetween(oldposition,reaper.GetProjectLength(),trackstring,true)
  for i=1, A do
    local ItemStart=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_POSITION")
    local ItemEnd=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_LENGTH")
    local Takes=reaper.CountTakes(MediaItem[i])
    if ItemStart+changepositionby>=0 then reaper.SetMediaItemInfo_Value(MediaItem[i], "D_POSITION", ItemStart+changepositionby)
    elseif ItemStart+changepositionby<=0 then 
      if ItemEnd+changepositionby<0 then reaper.DeleteTrackMediaItem(reaper.GetMediaItem_Track(MediaItem[i]),MediaItem[i]) --reaper.MB("","",0)
      else 
        for k=0, Takes-1 do
          local Offset=reaper.GetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS")
          reaper.SetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS", Offset-changepositionby)
        end
        reaper.SetMediaItemInfo_Value(MediaItem[i], "D_LENGTH", ItemEnd+changepositionby)
      end
    end
  end
  return true
end

--A=ultraschall.MoveMediaItemsAfter_By(reaper.GetCursorPosition(),-1,"1")

function ultraschall.MoveMediaItemsBefore_By(oldposition, changepositionby, trackstring)
--Moves all MediaItems, between projectstart and oldposition, by changepositionby, in all tracks given by trackstring
--intended for things as RippleCut
--
-- number oldposition - old position in seconds
-- number changepositionby - the difference in seconds. negative means, move toward projectstart, positive toward projectend
-- string trackstring - the tracksnumbers, beginning with 1 for first track, separated by a ,

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveMediaItemsBefore_By</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MoveMediaItemsBefore_By(number old_position, number change_position_by, string trackstring)</functioncall>
  <description>
    Moves all items before old_position by change_position_by-seconds. Affects only items, that end before oldposition, so items that start before and end after old_position do not move.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    number oldposition - the position, from where the movement shall be applied to, in seconds
    number change_position_by - the change of the position in seconds; positive - toward the end of the project, negative - toward the beginning.
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, move, position</tags>
</US_DocBloc>
]]
  
  if type(oldposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsBefore_By", "old_position", "Must be a number.", -1) return false end
  if type(changepositionby)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsBefore_By", "change_position_by", "Must be a number.", -2) return false end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("MoveMediaItemsBefore_By", "trackstring", "Must be a valid trackstring.", -3) return false end
  
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then ultraschall.AddErrorMessage("MoveMediaItemsBefore_By", "trackstring", "Must be a valid trackstring.", -3) return false end
  local A,MediaItem=ultraschall.GetAllMediaItemsBetween(0,oldposition,trackstring,true)
  for i=1, A do
    local ItemStart=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_POSITION")
    local ItemEnd=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_LENGTH")
    local Takes=reaper.CountTakes(MediaItem[i])
    if ItemStart+changepositionby>=0 then reaper.SetMediaItemInfo_Value(MediaItem[i], "D_POSITION", ItemStart+changepositionby)
    elseif ItemStart+changepositionby<=0 then 
      if ItemEnd+changepositionby<0 then reaper.DeleteTrackMediaItem(reaper.GetMediaItem_Track(MediaItem[i]),MediaItem[i]) --reaper.MB("","",0)
      else 
        for k=0, Takes-1 do
          local Offset=reaper.GetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS")
          reaper.SetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS", Offset-changepositionby)
        end
        reaper.SetMediaItemInfo_Value(MediaItem[i], "D_LENGTH", ItemEnd+changepositionby)
      end
    end
  end
  return true
end

--A=ultraschall.MoveMediaItemsBefore_By(1,1,"1")

function ultraschall.MoveMediaItemsBetween_To(startposition, endposition, newposition, trackstring, inside)
--Moves all MediaItems within sectionstart and sectionend to newposition in all tracks given by trackstring.
-- Use inside to tell, if only the items that are completely within the section, shall be moved
--intended for things as RippleCut
--
-- number sectionstart - start of the section in seconds
-- number sectionend - end of the section in seconds
-- number newposition - the new position in seconds. The first MediaItem in the selection gets this 
--                        newposition, all others are moved in relation to this first MediaItem.
-- string trackstring - the tracksnumbers, beginning with 1 for first track, separated by a ,
-- boolean inside - true: only affects items that are fully inside selection, 
--                  false: include items where at least start or end is inside selection

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveMediaItemsBetween_To</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MoveMediaItemsBetween_To(number startposition, number endposition, number newposition, string trackstring, boolean inside)</functioncall>
  <description>
    Moves the items between sectionstart and sectionend to newposition, within the tracks given by trackstring.
    If inside is set to true, only items completely within the section are moved; if set to false, also items are affected, that are just partially within the section.
    
    Items, that start after sectionstart, and therefore have an offset, will be moved to newposition+their offset. Keep that in mind.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    number startposition - begin of the item-selection in seconds
    number endposition - end of the item-selection in seconds
    number newposition - new position in seconds
    string trackstring - the tracknumbers, separated by a ,
    boolean inside - true, only items completely within the section; false, also items partially within the section
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, move, position</tags>
</US_DocBloc>
]]
-- sectionstart, sectionend, newposition, trackstring, inside
  
  if type(startposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "sectionstart", "Must be a number.", -1) return false end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "sectionend", "Must be a number.", -2) return false end
  if type(newposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "newposition", "Must be a number.", -3) return false end
  if sectionend<sectionstart then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "sectionend", "Must be bigger than sectionstart.", -4) return false end
  if ultraschall.IsValidTrackString(trackstring) then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "trackstring", "Must be a valid trackstring.", -5) return false end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("MoveMediaItemsBetween_To", "inside", "Must be a boolean.", -6) return false end  

  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return false end
  local A,MediaItem=ultraschall.GetAllMediaItemsBetween(sectionstart,sectionend,trackstring,inside)
  for i=1, A do
    local ItemStart=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_POSITION")
    local ItemEnd=reaper.GetMediaItemInfo_Value(MediaItem[i], "D_LENGTH")
    local Takes=reaper.CountTakes(MediaItem[i])
    if ItemStart+newposition>=0 then reaper.SetMediaItemInfo_Value(MediaItem[i], "D_POSITION", ItemStart+newposition)
    elseif ItemStart+newposition<=0 then 
      if ItemEnd+newposition<0 then reaper.DeleteTrackMediaItem(reaper.GetMediaItem_Track(MediaItem[i]),MediaItem[i]) --reaper.MB("","",0)
      else 
        for k=0, Takes-1 do
          local Offset=reaper.GetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS")
          reaper.SetMediaItemTakeInfo_Value(reaper.GetMediaItemTake(MediaItem[i], k), "D_STARTOFFS", Offset-newposition)
        end
        reaper.SetMediaItemInfo_Value(MediaItem[i], "D_LENGTH", ItemEnd+newposition)
      end
    end
  end
  return true
end

--A=ultraschall.MoveMediaItemsBetween_To(1, 3, 100, "", false)



function ultraschall.ChangeLengthOfMediaItems_FromArray(MediaItemArray, newlength)
-- changes width of all MediaItems in MediaItemArray to newlength
-- MediaItemArray - array with all MediaItems that shall be affected. Must not 
--                    include nil-entries, as they'll be interpreted as end of array.
-- number newlength - absolute new length of Items in seconds

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeLengthOfMediaItems_FromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ChangeLengthOfMediaItems_FromArray(array MediaItemArray, number newlength)</functioncall>
  <description>
    Changes the length of the MediaItems in MediaItemArray to newlength.
    They will all be set to the new length, regardless of their old length. If you want to change the length of the items not >to< newlength, but >by< newlength, use <a href"#ChangeDeltaLengthOfMediaItems_FromArray">ChangeDeltaLengthOfMediaItems_FromArray</a> instead.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    array MediaItemArray - an array with items to be changed. No nil entries allowed!
    number newlength - the new length of the items in seconds
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, length</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ChangeLengthOfMediaItems_FromArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return false end
  if type(newlength)~="number" then ultraschall.AddErrorMessage("ChangeLengthOfMediaItems_FromArray", "newlength", "must be a number", -2) return false end
  
  local count=1
  while MediaItemArray[count]~=nil do
    reaper.SetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH", newlength)
    count=count+1
  end
  return true
end

--A,MediaItem=ultraschall.GetAllMediaItemsBetween(0,14,"1,2",false)
--AB=ultraschall.ChangeLengthOfMediaItems_FromArray(MediaItem,l)



function ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(MediaItemArray, deltalength)
-- changes width of all MediaItems in MediaItemArray by deltalength
-- MediaItemArray - array with all MediaItems that shall be affected. Must not 
--                    include nil-entries, as they'll be interpreted as end of array.
-- number deltalength - in seconds, negative: item gets shorter, positive: item gets longer, 
--                      if item is shorter than deltalength, the length stays the same.

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeDeltaLengthOfMediaItems_FromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(array MediaItemArray, number deltalength)</functioncall>
  <description>
    Changes the length of the MediaItems in MediaItemArray by deltalength.
    If you want to change the length of the items not >by< deltalength, but >to< deltalength, use <a href"#ChangeLengthOfMediaItems_FromArray">ChangeLengthOfMediaItems_FromArray</a> instead.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    array MediaItemArray - an array with items to be changed. No nil entries allowed!
    number deltalength - the change of the length of the items in seconds, positive value - longer, negative value - shorter
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, length</tags>
</US_DocBloc>
]]

  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ChangeDeltaLengthOfMediaItems_FromArray", "MediaItemArray", "Only array with MediaItemObjects as entries is allowed.", -1) return false end
  if type(deltalength)~="number" then ultraschall.AddErrorMessage("ChangeDeltaLengthOfMediaItems_FromArray", "deltalength", "Must be a number in seconds.", -2) return false end
  local count=1
  local ItemLength
  while MediaItemArray[count]~=nil do
    ItemLength=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH")
    reaper.SetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH", ItemLength+deltalength)
    count=count+1
  end    
  return true
end

--  A,MediaItem=ultraschall.GetAllMediaItemsBetween(0,14,"1,2,3",false)
--AB=  ultraschall.ChangeDeltaLengthOfMediaItems_FromArray(MediaItem,1)

function ultraschall.ChangeOffsetOfMediaItems_FromArray(MediaItemArray, newoffset)
-- changes offset of all MediaItem_Takes of the MediaItems in MediaItemArray to newoffset
-- MediaItemArray - array with all MediaItems that shall be affected. Must not 
--                    include nil-entries, as they'll be interpreted as end of array.
-- number newoffset - in seconds

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeOffsetOfMediaItems_FromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ChangeOffsetOfMediaItems_FromArray(array MediaItemArray, number newoffset)</functioncall>
  <description>
    Changes the audio-offset of the MediaItems in MediaItemArray to newoffset.
    It affects all(!) takes that the MediaItems has.
    If you want to change the offset of the items not >to< newoffset, but >by< newoffset, use <a href"#ChangeDeltaOffsetOfMediaItems_FromArray">ChangeDeltaOffsetOfMediaItems_FromArray</a> instead.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    array MediaItemArray - an array with items to be changed. No nil entries allowed!
    number newoffset - the new offset of the items in seconds
  </parameters>
  <retvals>
    boolean retval - true, in case of success; false, in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, offset</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ChangeOffsetOfMediaItems_FromArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return false end
  if type(newoffset)~="number" then ultraschall.AddErrorMessage("ChangeOffsetOfMediaItems_FromArray", "newoffset", "must be a number", -2) return false end
  
  local count=1
  local ItemLength
  local MediaItem_Take
  while MediaItemArray[count]~=nil do
    ItemLength=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_SNAPOFFSET")
    for i=0, reaper.CountTakes(MediaItemArray[count])-1 do
      MediaItem_Take=reaper.GetMediaItemTake(MediaItemArray[count], i)
      reaper.SetMediaItemTakeInfo_Value(MediaItem_Take, "D_STARTOFFS", newoffset)
    end
    count=count+1
  end    
  return true
end

--A,MediaItem=ultraschall.GetAllMediaItemsBetween(0,14,"1,2,3",false)
--AA,AAA = ultraschall.GetMediaItemsAtPosition(13, "1,2,3")
--AB=ultraschall.ChangeOffsetOfMediaItems_FromArray(AAA, "35.09")

function ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(MediaItemArray, deltaoffset)
-- changes offset of all MediaItem_Takes of the MediaItems in MediaItemArray by deltaoffset
-- MediaItemArray - array with all MediaItems that shall be affected. Must not 
--                    include nil-entries, as they'll be interpreted as end of array.
-- number newoffset - in seconds; negative: offset gets earlier, positive: item gets later

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeDeltaOffsetOfMediaItems_FromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(array MediaItemArray, number deltaoffset)</functioncall>
  <description>
    Changes the audio-offset of the MediaItems in MediaItemArray by deltaoffset.
    It affects all(!) takes of the MediaItems have.
    If you want to change the offset of the items not >by< deltaoffset, but >to< deltaoffset, use <a href"#ChangeOffsetOfMediaItems_FromArray">ChangeOffsetOfMediaItems_FromArray</a> instead.
    
    Returns false in case of failure, true in case of success.
  </description>
  <parameters>
    array MediaItemArray - an array with items to be changed. No nil entries allowed!
    number newoffset - the new offset of the items in seconds
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of failure
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, offset</tags>
</US_DocBloc>
]]

  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ChangeDeltaOffsetOfMediaItems_FromArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return false end
  if type(delta)~="number" then ultraschall.AddErrorMessage("ChangeDeltaOffsetOfMediaItems_FromArray", "delta", "must be a number", -2) return false end
  
  local count=1
  local ItemLength, MediaItem_Take, ItemTakeOffset
  while MediaItemArray[count]~=nil do
    ItemLength=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_SNAPOFFSET")
    for i=0, reaper.CountTakes(MediaItemArray[count])-1 do
      MediaItem_Take=reaper.GetMediaItemTake(MediaItem[count], i)
      ItemTakeOffset=reaper.GetMediaItemTakeInfo_Value(MediaItem_Take, "D_STARTOFFS")
      reaper.SetMediaItemTakeInfo_Value(MediaItem_Take, "D_STARTOFFS", ItemTakeOffset+deltaoffset)
    end
    count=count+1
  end
  return true    
end

--  A,MediaItem=ultraschall.GetAllMediaItemsBetween(1,30,"1,2,3",false)
--  L=ultraschall.ChangeDeltaOffsetOfMediaItems_FromArray(MediaItem, -1.2)
--  reaper.UpdateArrange()

function ultraschall.SectionCut(startposition, endposition, trackstring, add_to_clipboard)
--cuts all items between startposition and endposition in the tracks, given with trackstring
--returns the number of deleted items as well as a table with the ItemStateChunks of all deleted Items

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SectionCut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_items, array MediaItemArray_StateChunk = ultraschall.SectionCut(number startposition, number endposition, string trackstring, boolean add_to_clipboard)</functioncall>
  <description>
    Cuts out all items between startposition and endposition in the tracks given by trackstring.
    
    Returns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    Returns -1 in case of failure.
  </description>
  <parameters>
    number startposition - the startposition of the section in seconds
    number endposition - the endposition of the section in seconds
    string trackstring - the tracknumbers, separated by ,
    boolean add_to_clipboard - true, puts the cut items into the clipboard; false, don't put into the clipboard
  </parameters>
  <retvals>
    integer number_items - the number of cut items
    array MediaItemArray_StateChunk - an array with the mediaitem-states of the cut items.
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, edit, section, cut, clipboard</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(startposition)~="number" then ultraschall.AddErrorMessage("SectionCut", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("SectionCut", "endposition", "must be a number", -2) return -1 end
  if endposition<startposition then ultraschall.AddErrorMessage("SectionCut", "endposition", "must be bigger than startposition", -3)  return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("SectionCut", "trackstring", "must be a valid trackstring", -4)  return -1 end
  if type(add_to_clipboard)~="boolean" then ultraschall.AddErrorMessage("SectionCut", "add_to_clipboard", "must be a boolean", -5) return -1 end  

  -- manage duplicates in trackstring
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)

  -- do the splitting, selecting and deleting of the items inbetween start and endposition
  local A,AA=ultraschall.SplitMediaItems_Position(startposition,trackstring, false)
  local B,BB=ultraschall.SplitMediaItems_Position(endposition,trackstring,false)
  local C,CC,CCC=ultraschall.GetAllMediaItemsBetween(startposition,endposition,trackstring,true)

  -- put the items into the clipboard  
  if add_to_clipboard==true then ultraschall.PutMediaItemsToClipboard_MediaItemArray(CC) end

  local D=ultraschall.DeleteMediaItemsFromArray(CC)
  return C, CCC
end

--H=reaper.GetCursorPosition()
--reaper.UpdateArrange()

function ultraschall.SectionCut_Inverse(startposition, endposition, trackstring, add_to_clipboard)
-- throws away everything before startpositon and after endposition in tracks defined in trackstring.
-- keeps only, what is inside selection
-- returns: 
-- number_of_cut_items_before_sectionstart
-- itemstatechunk_of_cut_items_before_sectionstart_as_table
-- number_of_cut_items_after_sectionend
-- itemstatechunk_of_cut_items_after_sectionend_as_table

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SectionCut_Inverse</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_items_beforestart, array MediaItemArray_StateChunk_beforestart, integer number_items_afterend, array MediaItemArray_StateChunk_afterend = ultraschall.SectionCut_Inverse(number startposition, number endposition, string trackstring, boolean add_to_clipboard)</functioncall>
  <description>
    Cuts out all items before(!) startposition and after(!) endposition in the tracks given by trackstring; it keeps all items inbetween startposition and endposition.
    
    Returns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    Returns -1 in case of failure.
  </description>
  <parameters>
    number startposition - the startposition of the section in seconds
    number endposition - the endposition of the section in seconds
    string trackstring - the tracknumbers, separated by ,
    boolean add_to_clipboard - true, puts the cut items into the clipboard; false, don't put into the clipboard
  </parameters>
  <retvals>
    integer number_items_beforestart - the number of cut items before startposition
    array MediaItemArray_StateChunk_beforestart - an array with the mediaitem-states of the cut items before startposition
    integer number_items_afterend - the number of cut items after endposition
    array MediaItemArray_StateChunk_afterend - an array with the mediaitem-states of the cut items after endposition
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, edit, section, inverse, cut</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(startposition)~="number" then ultraschall.AddErrorMessage("SectionCut_Inverse", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("SectionCut_Inverse", "endposition", "must be a number", -2) return -1 end
  if endposition<startposition then ultraschall.AddErrorMessage("SectionCut_Inverse", "endposition", "must be bigger than startposition", -3)  return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("SectionCut_Inverse", "trackstring", "must be a valid trackstring", -4)  return -1 end
  if type(add_to_clipboard)~="boolean" then ultraschall.AddErrorMessage("SectionCut_Inverse", "add_to_clipboard", "must be a boolean", -5) return -1 end  
  
  -- remove duplicate tracks from trackstring
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return -1 end
  
  -- do the splitting, selection of all mediaitems before first and after last split and delete them
  local A,AA=ultraschall.SplitMediaItems_Position(startposition,trackstring, false)
  local B,BB=ultraschall.SplitMediaItems_Position(endposition,trackstring,false) -- Buggy: needs to take care of autocrossfade!!
  local C,CC,CCC=ultraschall.GetAllMediaItemsBetween(0,startposition,trackstring,true)
  local C2,CC2,CCC2=ultraschall.GetAllMediaItemsBetween(endposition,reaper.GetProjectLength(),trackstring,true)
  
  -- put the items into the clipboard  
  
  if add_to_clipboard==true then 
    local COMBIC, COMBIC2=ultraschall.ConcatIntegerIndexedTables(CC, CC2)
    ultraschall.PutMediaItemsToClipboard_MediaItemArray(COMBIC2) 
  end
  
  local D=ultraschall.DeleteMediaItemsFromArray(CC)
  local D2=ultraschall.DeleteMediaItemsFromArray(CC2)
  
  -- return removed items
  return C,CCC,C2,CCC2
end

--A,AA,AAA,AAAA=ultraschall.SectionCut_Inverse(2,4,"1",true)
--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(0,5,"1",false)
--D=ultraschall.DeleteMediaItemsFromArray(CC)
--reaper.UpdateArrange()
function ultraschall.PutMediaItemsToClipboard_MediaItemArray(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>PutMediaItemsToClipboard_MediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.PutMediaItemsToClipboard_MediaItemArray(MediaItemArray MediaItemArray)</functioncall>
  <description>
    Puts the items in MediaItemArray into the clipboard.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaItemArray MediaItemArray - an array with all MediaItems, that shall be put into the clipboard
  </parameters>
  <retvals>
    boolean retval - true, if successful; false, if not
  </retvals>
  <chapter_context>
    Clipboard Functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitem, put, clipboard, set</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("PutMediaItemsToClipboard_MediaItemArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return false end
  reaper.PreventUIRefresh(1)
  local count, MediaItemArray_selected = ultraschall.GetAllSelectedMediaItems() -- get old selection
  reaper.SelectAllMediaItems(0, false) -- deselect all MediaItems
  local retval = ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray) -- select to-be-cut-MediaItems
  reaper.Main_OnCommand(40057,0) -- copy them into clipboard
  reaper.SelectAllMediaItems(0, false) -- deselect all MediaItems
  local retval = ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray_selected) -- select formerly selected MediaItems
  reaper.PreventUIRefresh(-1)
  reaper.UpdateArrange()
  return true
end

function ultraschall.RippleCut(startposition, endposition, trackstring, moveenvelopepoints, add_to_clipboard)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RippleCut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_items, array MediaItemArray_StateChunk = ultraschall.RippleCut(number startposition, number endposition, string trackstring, boolean moveenvelopepoints, boolean add_to_clipboard)</functioncall>
  <description>
    Cuts out all items between startposition and endposition in the tracks given by trackstring. After cut, it moves the remaining items after(!) endposition toward projectstart, by the difference between start and endposition.
    
    Returns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    Returns -1 in case of failure.
  </description>
  <parameters>
    number startposition - the startposition of the section in seconds
    number endposition - the endposition of the section in seconds
    string trackstring - the tracknumbers, separated by ,
    boolean moveenvelopepoints - moves envelopepoints, if existing, as well
    boolean add_to_clipboard - true, puts the cut items into the clipboard; false, don't put into the clipboard
  </parameters>
  <retvals>
    integer number_items - the number of cut items
    array MediaItemArray_StateChunk - an array with the mediaitem-states of the cut items
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, edit, ripple, clipboard</tags>
</US_DocBloc>
]]
  --trackstring=ultraschall.CreateTrackString(1,reaper.CountTracks(),1)
  --returns the number of deleted items as well as a table with the ItemStateChunks of all deleted Items  

  if type(startposition)~="number" then ultraschall.AddErrorMessage("RippleCut", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("RippleCut", "endposition", "must be a number", -2) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("RippleCut", "trackstring", "must be a valid trackstring", -3) return -1 end
  if type(add_to_clipboard)~="boolean" then ultraschall.AddErrorMessage("RippleCut", "add_to_clipboard", "must be a boolean", -4) return -1 end  
  if type(moveenvelopepoints)~="boolean" then ultraschall.AddErrorMessage("RippleCut", "moveenvelopepoints", "must be a boolean", -5) return -1 end

  local L,trackstring,A2,A3=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("RippleCut", "trackstring", "must be a valid trackstring", -6) return -1 end
  local delta=endposition-startposition
  local A,AA=ultraschall.SplitMediaItems_Position(startposition,trackstring,false)
  local B,BB=ultraschall.SplitMediaItems_Position(endposition,trackstring,false)
  local C,CC,CCC=ultraschall.GetAllMediaItemsBetween(startposition,endposition,trackstring,true)
    
  -- put the items into the clipboard  
  if add_to_clipboard==true then ultraschall.PutMediaItemsToClipboard_MediaItemArray(CC) end
  
  local D=ultraschall.DeleteMediaItemsFromArray(CC) 
  if moveenvelopepoints==true then
    local CountTracks=reaper.CountTracks()
    for i=0, CountTracks-1 do
      for a=1,A3 do
        if tonumber(A2[a])==i+1 then
          local MediaTrack=reaper.GetTrack(0,i)
          retval = ultraschall.MoveTrackEnvelopePointsBy(endposition, reaper.GetProjectLength(), -delta, MediaTrack, true) 
        end
      end
    end
  end
  
  if movemarkers==true then
    ultraschall.MoveMarkersBy(endposition, reaper.GetProjectLength(), -delta, true)
  end
  ultraschall.MoveMediaItemsAfter_By(endposition, -delta, trackstring)
  return C,CCC
end

--A,B=ultraschall.RippleCut(1,2,"1,2,3",true,true)


function ultraschall.RippleCut_Reverse(startposition, endposition, trackstring, moveenvelopepoints, add_to_clipboard)
  --trackstring=ultraschall.CreateTrackString(1,reaper.CountTracks(),1)
  --returns the number of deleted items as well as a table with the ItemStateChunks of all deleted Items  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RippleCut_Reverse</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_items, array MediaItemArray_StateChunk = ultraschall.RippleCut_Reverse(number startposition, number endposition, string trackstring, boolean moveenvelopepoints, boolean add_to_clipboard)</functioncall>
  <description>
    Cuts out all items between startposition and endposition in the tracks given by trackstring. After cut, it moves the remaining items before(!) startposition toward projectend, by the difference between start and endposition.
    
    Returns number of cut items as well as an array with the mediaitem-statechunks, which can be used with functions as <a href="#InsertMediaItem_MediaItemStateChunk">InsertMediaItem_MediaItemStateChunk</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    Returns -1 in case of failure.
  </description>
  <parameters>
    number startposition - the startposition of the section in seconds
    number endposition - the endposition of the section in seconds
    string trackstring - the tracknumbers, separated by ,
    boolean moveenvelopepoints - moves envelopepoints, if existing, as well
    boolean add_to_clipboard - true, puts the cut items into the clipboard; false, don't put into the clipboard
  </parameters>
  <retvals>
    integer number_items - the number of cut items
    array MediaItemArray_StateChunk - an array with the mediaitem-states of the cut items
  </retvals>
  <chapter_context>
    MediaItem Management
    Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, edit, ripple, reverse, clipboard</tags>
</US_DocBloc>
]]

  if type(startposition)~="number" then ultraschall.AddErrorMessage("RippleCut_Reverse", "startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("RippleCut_Reverse", "endposition", "must be a number", -2) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("RippleCut_Reverse", "trackstring", "must be a valid trackstring", -3) return -1 end
  if type(add_to_clipboard)~="boolean" then ultraschall.AddErrorMessage("RippleCut_Reverse", "add_to_clipboard", "must be a boolean", -4) return -1 end
  if type(moveenvelopepoints)~="boolean" then ultraschall.AddErrorMessage("RippleCut_Reverse", "moveenvelopepoints", "must be a boolean", -5) return -1 end
  
  local L,trackstring,A2,A3=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return -1 end
  local delta=endposition-startposition
  local A,AA=ultraschall.SplitMediaItems_Position(startposition,trackstring,false)
  local B,BB=ultraschall.SplitMediaItems_Position(endposition,trackstring,false)
  local C,CC,CCC=ultraschall.GetAllMediaItemsBetween(startposition,endposition,trackstring,true)

  -- put the items into the clipboard  
  if add_to_clipboard==true then ultraschall.PutMediaItemsToClipboard_MediaItemArray(CC) end

  local D=ultraschall.DeleteMediaItemsFromArray(CC) 
  if moveenvelopepoints==true then
    local CountTracks=reaper.CountTracks()
    for i=0, CountTracks-1 do
      for a=1,A3 do
        if tonumber(A2[a])==i+1 then
          local MediaTrack=reaper.GetTrack(0,i)
          retval = ultraschall.MoveTrackEnvelopePointsBy(0, startposition, delta, MediaTrack, true) 
        end
      end
    end
  end
  
  if movemarkers==true then
    ultraschall.MoveMarkersBy(0, startposition, delta, true)
  end

  ultraschall.MoveMediaItemsBefore_By(endposition, delta, trackstring)  
  return C,CCC
end


--A,AA=ultraschall.RippleCut_Reverse(15,21,"1,2,3", true, true)


function ultraschall.InsertMediaItem_MediaItem(position, MediaItem, MediaTrack)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertMediaItem_MediaItem</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, MediaItem MediaItem, number startposition, number endposition, number length = ultraschall.InsertMediaItem_MediaItem(number position, MediaItem MediaItem, MediaTrack MediaTrack)</functioncall>
  <description>
    Inserts MediaItem in MediaTrack at position. Returns the newly created(or better: inserted) MediaItem as well as startposition, endposition and length of the inserted item.
    
    Returns -1 in case of failure.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    MediaItem MediaItem - the MediaItem that shall be inserted into a track
    MediaTrack MediaTrack - the track, where the item shall be inserted to
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    MediaItem MediaItem - the newly created MediaItem
    number startposition - the startposition of the inserted MediaItem in seconds
    number endposition - the endposition of the inserted MediaItem in seconds
    number length - the length of the inserted MediaItem in seconds
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertMediaItem_MediaItem","position", "must be a number", -1) return -1 end
  if reaper.GetItemStateChunk(MediaItem, "", false)==false then ultraschall.AddErrorMessage("InsertMediaItem_MediaItem","MediaItem", "must be a MediaItem", -2) return -1 end
  if reaper.GetTrackStateChunk(MediaTrack, "", false)==false then ultraschall.AddErrorMessage("InsertMediaItem_MediaItem","MediaTrack", "must be a MediaTrack", -3) return -1 end
  local MediaItemNew=reaper.AddMediaItemToTrack(MediaTrack)
  local Aretval, Astr = reaper.GetItemStateChunk(MediaItem, "", true)
  Astr=Astr:match(".-POSITION ")..position..Astr:match(".-POSITION.-(%c.*)")
  local Aboolean = reaper.SetItemStateChunk(MediaItemNew, Astr, true)
  local start_position=reaper.GetMediaItemInfo_Value(MediaItemNew, "D_POSITION")
  local length=reaper.GetMediaItemInfo_Value(MediaItemNew, "D_LENGTH")
  
  return 1,MediaItemNew, start_position, start_position+length, length
end

--C,CC=ultraschall.GetAllMediaItemsBetween(0,5,"1,2,3,4,5",false)
--MT=reaper.GetTrack(0,0)
--A0,A,AA,AAA,AAAA=ultraschall.InsertMediaItem_MediaItem(42,CC[1],MT)

function ultraschall.InsertMediaItem_MediaItemStateChunk(position, MediaItemStateChunk, MediaTrack)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertMediaItem_MediaItemStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, MediaItem MediaItem, number startposition, number endposition, number length = ultraschall.InsertMediaItem_MediaItemStateChunk(number position, string MediaItemStateChunk, MediaTrack MediaTrack)</functioncall>
  <description>
    Inserts a new MediaItem in MediaTrack at position. Uses a mediaitem-state-chunk as created by functions like <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>, reaper.GetItemStateChunk and reaper.SetItemStateChunk.. Returns the newly created MediaItem.
    
    Returns -1 in case of failure.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    string MediaItemStatechunk - the Statechunk for the MediaItem, that shall be inserted into a track
    MediaTrack MediaTrack - the track, where the item shall be inserted to; nil, use the statechunk-entry ULTRASCHALL_TRACKNUMBER for the track instead.
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    MediaItem MediaItem - the newly created MediaItem
    number startposition - the startposition of the inserted MediaItem in seconds
    number endposition - the endposition of the inserted MediaItem in seconds
    number length - the length of the inserted MediaItem in seconds
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertMediaItem_MediaItemStateChunk","position", "must be a number", -1) return -1 end
  if ultraschall.IsValidMediaItemStateChunk(MediaItemStateChunk)==false then ultraschall.AddErrorMessage("InsertMediaItem_MediaItemStateChunk","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -2) return -1 end
  if MediaTrack~=nil and reaper.GetTrackStateChunk(MediaTrack, "", false)==false then ultraschall.AddErrorMessage("InsertMediaItem_MediaItem","MediaTrack", "must be a MediaTrack", -3) return -1 end
  if MediaTrack==nil and ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunk)==-1 then ultraschall.AddErrorMessage("InsertMediaItem_MediaItemStateChunk","MediaItemStateChunk", "contains no ULTRASCHALL_TRACKNUMBER entry, so I can't determine the original track", -4) return -1 end
  if MediaTrack==nil then MediaTrack=reaper.GetTrack(0,ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunk)-1) end

  local MediaItemNew=reaper.AddMediaItemToTrack(MediaTrack)
  local MediaItemStateChunk=MediaItemStateChunk:match(".-POSITION ")..position..MediaItemStateChunk:match(".-POSITION.-(%c.*)")
  local Aboolean = reaper.SetItemStateChunk(MediaItemNew, MediaItemStateChunk, true)
  local start_position=reaper.GetMediaItemInfo_Value(MediaItemNew, "D_POSITION")
  local length=reaper.GetMediaItemInfo_Value(MediaItemNew, "D_LENGTH")
    
  return 1, MediaItemNew, start_position, start_position+length, length
end

--C,CC=ultraschall.GetAllMediaItemsBetween(0,400,"1,2,3,4,5",false)
--MT=reaper.GetTrack(0,0)
--Aretval, Astr = reaper.GetItemStateChunk(reaper.GetMediaItem(0,0), "", true)
--ALABASTER,ALHula=ultraschall.InsertMediaItem_MediaItemStateChunk(1000,Astr, MT)

function ultraschall.InsertMediaItemArray(position, MediaItemArray, trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemArray = ultraschall.InsertMediaItemArray(number position, array MediaItemArray, string trackstring)</functioncall>
  <description>
    Inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring. 
    
    Returns the number of newly created items, as well as an array with the newly create MediaItems.
    Returns -1 in case of failure.
    
    Note: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.
    If you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    array MediaItemArray - an array with the MediaItems to be inserted
    string trackstring - the numbers of the tracks, separated by a ,
  </parameters>
  <retvals>
    integer number_of_items - the number of MediaItems created
    array MediaItemArray - an array with the newly created MediaItems
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert</tags>
</US_DocBloc>
]]    
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertMediaItemArray","position", "must be a number", -1) return -1 end
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("InsertMediaItemArray","MediaItemArray", "must be a valid MediaItemArray", -2) return -1 end
  --if reaper.ValidatePtr(MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("InsertMediaItemArray","MediaTrack", "must be a valid MediaTrack-object", -3) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("InsertMediaItemArray","trackstring", "must be a valid trackstring", -3) return -1 end
  
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return -1 end
  local count=1
  local i,LL

  local NewMediaItemArray={}
  local _count, individual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring) 
  local ItemStart=reaper.GetProjectLength()+1
  while MediaItemArray[count]~=nil do
    local ItemStart_temp=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    if ItemStart>ItemStart_temp then ItemStart=ItemStart_temp end
    count=count+1
  end
  count=1
  while MediaItemArray[count]~=nil do
    local ItemStart_temp=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    local MediaTrack=reaper.GetMediaItem_Track(MediaItemArray[count])
    --nur einfgen, wenn mediaitem aus nem Track stammt, der in trackstring vorkommt
    i=1
    while individual_values[i]~=nil do
      if reaper.GetTrack(0,individual_values[i]-1)==reaper.GetMediaItem_Track(MediaItemArray[count]) then 
        LL, NewMediaItemArray[count]=ultraschall.InsertMediaItem_MediaItem(position+(ItemStart_temp-ItemStart),MediaItemArray[count],MediaTrack)
      end
      i=i+1
    end
    count=count+1
  end  

  return count, NewMediaItemArray
end

--C,CC=ultraschall.GetAllMediaItemsBetween(1,60,"1,3",false)
--A,B=reaper.GetItemStateChunk(CC[1], "", true)
--reaper.ShowConsoleMsg(B)
--L,L2=ultraschall.InsertMediaItemArray(82, CC, 2)


function ultraschall.GetMediaItemStateChunksFromItems(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemStateChunksFromItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemArray_StateChunks = ultraschall.GetMediaItemStateChunksFromItems(array MediaItemArray)</functioncall>
  <description>
    Returns the MediaItem-StateChunks for all MediaItems in MediaItemArray. It returns the number of items as well as an array, with each entry one MediaItemStateChunk.
    
    StateChunks are used by the reaper-functions reaper.GetItemStateChunk and reaper.SetItemStateChunk.
    
    Returns -1 in case of failure.
  </description>
  <parameters>
    array MediaItemArray - an array with the MediaItems you want the statechunks of
  </parameters>
  <retvals>
    integer number_of_items - the number of trackstatechunks, usually the same as MediaItems in MediaItemArray
    array MediaItemArray_StateChunks - an array with the StateChunks of the MediaItems in MediaItemArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, chunk</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("GetMediaItemStateChunksFromItems", "MediaItemArray", "must be a valid MediaItemArray", -1) return -1 end
  local count=1
  local L
  local MediaItemArray_StateChunk={}
  while MediaItemArray[count]~=nil do
    L, MediaItemArray_StateChunk[count]=reaper.GetItemStateChunk(MediaItemArray[count], "", true)
    count=count+1
  end
  return count-1, MediaItemArray_StateChunk
end

--C,CC=ultraschall.GetAllMediaItemsBetween(9,60,"1",true)
--PK,BA=ultraschall.CreateMediaItemStateChunksFromItems(CC)
--ultraschall.GetMediaItemStateChunksFromItems(hsdji)

function ultraschall.RippleInsert(position, MediaItemArray, trackstring, moveenvelopepoints)
--splits the items at position and inserts MediaItemArray at that position, and moves 
--all following toward the end, accordingly.
--position - the position of the earliest item in the MediaItemArray. All others will be relative to the earliest Item
--MediaItemArray - the MediaItems to be inserted
--trackstring - only the tracks in trackstring will be affected by insert and ripple, all others stay the way they are
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RippleInsert</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemArray, number endpos_inserted_items = ultraschall.RippleInsert(number position, array MediaItemArray, string trackstring, boolean moveenvelopepoints, boolean movemarkers)</functioncall>
  <description>
    It inserts the MediaItems from MediaItemArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.
    
    Returns the number of newly created items, as well as an array with the newly created MediaItems and the endposition of the last(projectposition) inserted item into the project.
    Returns -1 in case of failure.
    
    Note: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.
    If you have a MediaItemArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    array MediaItemArray - an array with the MediaItems to be inserted
    string trackstring - the numbers of the tracks, separated by a ,
    boolean moveenvelopepoints - true, move the envelopepoints as well; false, keep the envelopepoints where they are
    boolean movemarkers - true, move markers as well; false, keep markers where they are
  </parameters>
  <retvals>
    integer number_of_items - the number of newly created items
    array MediaItemArray - an array with the newly created MediaItems
    number endpos_inserted_items - the endposition of the last newly inserted MediaItem
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert, ripple</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("RippleInsert", "startposition", "must be a number", -1) return -1 end
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("RippleInsert", "MediaItemArray", "must be a valid MediaItemArray", -2) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("RippleInsert", "trackstring", "must be a valid trackstring", -3) return -1 end
  if type(moveenvelopepoints)~="boolean" then ultraschall.AddErrorMessage("RippleInsert", "moveenvelopepoints", "must be a boolean", -4) return -1 end
  
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  --reaper.MB(trackstring,"",0)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("RippleInsert", "trackstring", "must be a valid trackstring", -6) return -1 end

-- local NumberOfItems
  local NewMediaItemArray={}
  local count=1
  local ItemStart=reaper.GetProjectLength()+1
  local ItemEnd=0
  local i
  local _count, individual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring)
  while MediaItemArray[count]~=nil do
    local ItemStart_temp=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    local ItemEnd_temp=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH")
    i=1
    while individual_values[i]~=nil do
      if reaper.GetTrack(0,individual_values[i]-1)==reaper.GetMediaItem_Track(MediaItemArray[count]) then 
        if ItemStart>ItemStart_temp then ItemStart=ItemStart_temp end
        if ItemEnd<ItemEnd_temp+ItemStart_temp then ItemEnd=ItemEnd_temp+ItemStart_temp end
      end
      i=i+1
    end
    count=count+1
  end
  
  --Create copy of the track-state-chunks
  local nums, MediaItemArray_Chunk=ultraschall.GetMediaItemStateChunksFromItems(MediaItemArray)
    
  local A,A2=ultraschall.SplitMediaItems_Position(position,trackstring,false)
--  reaper.MB(tostring(AA),"",0)

  if moveenvelopepoints==true then
    local CountTracks=reaper.CountTracks()
    for i=0, CountTracks-1 do
      for a=1,AAA do
        if tonumber(AA[a])==i+1 then
          local MediaTrack=reaper.GetTrack(0,i)
          retval = ultraschall.MoveTrackEnvelopePointsBy(position, reaper.GetProjectLength()+(ItemEnd-ItemStart), ItemEnd-ItemStart, MediaTrack, true) 
        end
      end
    end
  end
  
  if movemarkers==true then
    ultraschall.MoveMarkersBy(position, reaper.GetProjectLength()+(ItemEnd-ItemStart), ItemEnd-ItemStart, true)
  end
  ultraschall.MoveMediaItemsAfter_By(position-0.000001, ItemEnd-ItemStart, trackstring)
  L,MediaItemArray=ultraschall.OnlyMediaItemsOfTracksInTrackstring(MediaItemArray, trackstring)
  count=1
  while MediaItemArray[count]~=nil do
    local Anumber=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    count=count+1
  end
    NumberOfItems, NewMediaItemArray=ultraschall.InsertMediaItemArray(position, MediaItemArray, trackstring)
  count=1
  while MediaItemArray[count]~=nil do
    local length=MediaItemArray_Chunk[count]:match("LENGTH (.-)%c")
    reaper.SetMediaItemInfo_Value(NewMediaItemArray[count], "D_LENGTH", length)
    count=count+1
  end
  return NumberOfItems, NewMediaItemArray, position+ItemEnd
end

--C,CC=ultraschall.GetAllMediaItemsBetween(0,15,"1,2,3",false)
--D=ultraschall.DeleteMediaItemsFromArray(CC)
--track=reaper.GetMediaItem_Track(CC[1])
--PUHDERBAER, PUHDERBAER2, PUHDERBAER3=ultraschall.RippleInsert(213,CC,"1,2,3", true, true)


function ultraschall.MoveMediaItems_FromArray(MediaItemArray, newposition)
-- changes position of all MediaItems in MediaItemArray to position
-- if there are more than one mediaitems, it retains the relative-position to each 
-- other, putting the earliest item as position and the rest later, in relation to the earliest item
--
-- MediaItemArray - array with all MediaItems that shall be affected. Must not 
--                    include nil-entries, as they'll be interpreted as end of array.
-- number newposition - new position of Items
--reaper.MB(type(MediaItemArray),"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveMediaItems_FromArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, number earliest_itemtime, number latest_itemtime = ultraschall.MoveMediaItems_FromArray(array MediaItemArray, number newposition)</functioncall>
  <description>
    It changes the position of the MediaItems from MediaItemArray. It keeps the related position to each other, putting the earliest item at newposition, putting the others later, relative to their offset.
    
    Returns -1 in case of failure.
  </description>
  <parameters>
    array MediaItemArray - an array with the MediaItems to be inserted
    number newposition - the new position in seconds
  </parameters>
  <retvals>
    integer retval - -1 in case of error, else returns 1
    number earliest_itemtime - the new earliest starttime of all MediaItems moved
    number latest_itemtime - the new latest endtime of all MediaItems moved
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert, ripple</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("MoveMediaItems_FromArray", "MediaItemArray", "must be a valid MediaItemArray", -1) return -1 end
  if type(newposition)~="number" then ultraschall.AddErrorMessage("MoveMediaItems_FromArray", "newposition", "must be a number", -2) return -1 end

  local count=1
  local Earliest_time=reaper.GetProjectLength()+1
  local Latest_time=0
  local ItemStart, ItemEnd
  while MediaItemArray[count]~=nil do
    ItemStart=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    ItemEnd=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH")+ItemStart
    if ItemStart<Earliest_time then Earliest_time=ItemStart end
    if ItemEnd>Latest_time then Latest_time=ItemEnd end
    count=count+1
  end    

  count=1
  while MediaItemArray[count]~=nil do
    ItemStart=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION")
    reaper.SetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION", (ItemStart-Earliest_time)+newposition)
    count=count+1
  end    
  return 1, Earliest_time, Latest_time
end


--LCount, MIA = ultraschall.GetAllMediaItemsBetween(0,1000,"1,2",false)
--A,B,C=ultraschall.MoveMediaItems_FromArray(MIA, 4000)

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Separator</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.Separator</functioncall>
  <description>
    Contains the correct separator for your system. / on Mac, \ on Windows. Use them, if you want to create windows and mac-compliant scripts that have file operations.
  </description>
  <chapter_context>
    API-Variables
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, variable, separator</tags>
</US_DocBloc>
--]]


--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Api_Path</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.Api_Path</functioncall>
  <description>
    Contains the current path to the Ultraschall-Api-folder.
  </description>
  <chapter_context>
    API-Variables
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, variable, path, folder</tags>
</US_DocBloc>
--]]

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Api_InstallPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.Api_InstallPath</functioncall>
  <description>
    Contains the current path to the installation folder of the Ultraschall-Api(usually Resourcesfolder/UserPlugins
  </description>
  <chapter_context>
    API-Variables
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, variable, install, path, folder</tags>
</US_DocBloc>
--]]

function ultraschall.HelpSort(one,two,three)
--reaper.MB(tostring(one),"",0)
  if one==nil then return false end
  if two==nil then return false end
  --a=one
  --b=two
  temps={}
  --reaper.MB(one,two,0)
  temps[1]=one:match("<semanticcontext>%c(.-)%c")
  --reaper.MB(temp[0],"",0)
  temps[2]=two:match("<semanticcontext>%c(.-)%c")
  --reaper.MB(temp[0],temp[1],0)
  --if temp[0]==nil or temp[1]==nil then return false end
  table.sort(temps)
  --reaper.MB(tostring(temp),"",0)
  if temps[1]==one:match("<semanticcontext>%c(.-)%c") then return true
  else return false end
  --reaper.MB(a,b,0)
  --a=one
  --b=two

  --  for i=1, string.len(a) do
  --    if string.byte(a,i)==nil then return false end
  --    if string.byte(b,i)==nil then return false end
  --    if string.byte(a,i)<string.byte(b,i) then return true end
  --  end
  return false
end

--LLL=ultraschall.HelpSort("<semanticcontext>\naltraschall Helpers\n</semanticcontext>","<semanticcontext>\naltraschall Helpers\n</semanticcontext>")





-----------------------------
---- Envelope Management ----
-----------------------------





function ultraschall.CreateUSApiDocs_HTML(filename_with_path,LLL)
--!!!TODO GFX-FILES mssen auch exportiert werden!!!---

--[[
<\ApiDocBlocFunc>
  <slug>CreateUSApiDocs_HTML</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.CreateUSApiDocs_HTML(string filename_with_path, string sourcefilename_with_path)</functioncall>
  <description>
    Creates a documentation-file for the Ultraschall-Api-Functions.
  </description>
  <retvals>
    boolean retval - returns true, if help-creation worked; false if it failed
  </retvals>
  <parameters>
    string filename_with_path - filename of the newly created helpfile
    string sourcefilename_with_path - the name of the file, of which the docs shall be created from. nil - the Ultraschall Framework-Api
  </parameters>
  <chapter_context>
    Help and Documentation
    Ultraschall Api-docs
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>api, docs, documentation, html, create</tags>
<\/ApiDocBlocFunc>
]]
  local functionarray={}
  local count=1
  local counter=0
  local funcindex=""
  local funclist=""
  local A,B,C,D,E,F,G,H=reaper.get_action_context()
  local L, integer
  local apiversion,apidate,apibeta=ultraschall.GetApiVersion()
  local _retval, build = reaper.BR_Win32_GetPrivateProfileString("Ultraschall-Api-Build", "Functions-Build", "", ultraschall.Api_Path.."/IniFiles/ultraschall_api.ini")
  local slug=""
  local tempparameters=""
  local scriptpath=reaper.GetResourcePath()..ultraschall.Separator.."UserPlugins"..ultraschall.Separator.."ultraschall_api"..ultraschall.Separator
  if LLL==nil then LLL=B end--scriptpath.."ultraschall_functions_engine.lua" end
  local Path = ultraschall.GetPath(LLL, "(.*)/")
  if Path == nil then Path = ultraschall.GetPath(filename_with_path, "(.*)\\") end
  if Path == nil then Path = ultraschall.GetPath(filename_with_path, "(.*)/") end
  integer=reaper.RecursiveCreateDirectory(Path.."\\gfx", 0)
  local Functioncounter=0
  
  if reaper.GetOS() == "Win32" or reaper.GetOS() == "Win64" then
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\reaper5.40.png", Path.."gfx\\reaper5.40.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\reaper5.50.png", Path.."gfx\\reaper5.50.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\reaper5.52.png", Path.."gfx\\reaper5.52.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\reaper5.77.png", Path.."gfx\\reaper5.77.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\SWS2.8.8.png", Path.."gfx\\SWS2.8.8.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\SWS2.9.6.png", Path.."gfx\\SWS2.9.6.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\SWS2.9.7.png", Path.."gfx\\SWS2.9.7.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\Lua5.3.png", Path.."gfx\\Lua5.3.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\ultraschall4.00.png", Path.."gfx\\ultraschall4.00.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx\\us.png", Path.."gfx\\us.png")
  else
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/reaper5.40.png", Path.."gfx/reaper5.40.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/reaper5.50.png", Path.."gfx/reaper5.50.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/reaper5.52.png", Path.."gfx/reaper5.52.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/reaper5.77.png", Path.."gfx/reaper5.77.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/SWS2.8.8.png", Path.."gfx/SWS2.8.8.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/SWS2.9.6.png", Path.."gfx/SWS2.9.6.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/SWS2.9.7.png", Path.."gfx/SWS2.9.7.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/Lua5.3.png", Path.."gfx/Lua5.3.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/ultraschall4.00.png", Path.."gfx/ultraschall4.00.png")
    L=ultraschall.MakeCopyOfFile_Binary(scriptpath.."docgfx/us.png", Path.."gfx/us.png")
  end
    
  -- Read sourcefile and get all helpblocs
  reaper.ShowConsoleMsg("Creating US-Api-Files\n")
  reaper.ShowConsoleMsg("Read Function-Engine-File\n")
    infile=ultraschall.ReadFullFile(LLL,false)
--  infile=ultraschall.ReadValueFromFile(LLL, nil, false)
--  infile=ultraschall.ReadValueFromFile(B, nil, false)
  reaper.ShowConsoleMsg("Parsing Function-Engine-File\n")
  while infile~=nil do
    local temp
    functionarray[count],temp=infile:match("(<ApiDocBlocFunc>.-</ApiDocBlocFunc>)()")
--    infile=infile:match("<ApiDocBlocFunc>.-</ApiDocBlocFunc>(.*)")
    if temp~=nil then infile=infile:sub(temp,-1) end
    Functioncounter=Functioncounter+1
    if functionarray[count]==nil then infile=nil
    else
      count=count+1
    end
  end
  
--sort functions by semanticcontext
--  reaper.ShowConsoleMsg(functionarray[1])

  for i=1, count-1 do
--  reaper.MB(functionarray[i],i,0)
    if tostring(functionarray[i]:match("<semanticcontext>%c(.-)%c.-</semanticcontext>"))~=nil then 
--    if i==196 then reaper.MB(functionarray[i],i,0) end
      functionarray[i]=tostring(functionarray[i]:match("<semanticcontext>%c(.-)%c.-</semanticcontext>"))..functionarray[i]
    end
  end

  table.sort(functionarray)
  local startfile="<html><head><title>Ultraschall Framework-Lua-Api-docs "..apiversion.."</title></head><body>\n<img src=\"gfx/us.png\" alt=\"\"><h2>Ultraschall - Framework "..apiversion.."</h2>"..apibeta.." - "..apidate.." - Build: "..build.." - <a href=\"http://www.mespotine.de/Ultraschall/Framework/US_Framework4_00_beta2_6.zip\">Download Framework for Reaper</a><div style=\"padding-left:10%; width:80%;\">"

--for i=1, count-1 do
--  reaper.ShowConsoleMsg(functionarray[i]:match(".-(<functionname>.-</functionname>).-"))
--end

--creating index
  reaper.ShowConsoleMsg("create index\n")
  local funclistarray={}
  local tingle=0
  local currentindex, currentsubindex
  funcindex="<h3>The Functions Reference</h3><table style=\"font-size:10pt; width:100%;\">"
  for i=1, count-1 do
    if functionarray[i]:match("<functionname>(.-)</functionname>")~=nil or functionarray[i]:match("<chaptername>(.-)</chaptername>") then
      funclistarray[i]=functionarray[i]:match("(<semanticcontext>.-</semanticcontext>)")..functionarray[i]
    end
  end
  table.sort(funclistarray)
  count=1
  local firstrun=0
  while funclistarray[count]~=nil do
  if currentindex~=funclistarray[count]:match("<semanticcontext>%c(.-)%c.-</semanticcontext>") then
        currentindex=funclistarray[count]:match("<semanticcontext>%c(.-)%c.-</semanticcontext>")
        currentsubindex=funclistarray[count]:match("<semanticcontext>%c.-%c(.-)</semanticcontext>")
        if firstrun==1 then funcindex=funcindex.."<tr><td>&nbsp;</td></tr>" end
        if firstrun==0 then firstrun=1 end
        funcindex=funcindex.."<tr><td>&nbsp;</td></tr><tr><td><h3><u>"..currentindex.."</u></h3></td></tr><tr><td><strong>"..currentsubindex.."</strong></td></tr>"
        tingle=0
  elseif currentsubindex~=funclistarray[count]:match("<semanticcontext>%c.-%c(.-)</semanticcontext>") then
        currentsubindex=funclistarray[count]:match("<semanticcontext>%c.-%c(.-)</semanticcontext>")
        funcindex=funcindex.."<tr><td>&nbsp;</td></tr><tr><td><strong>"..currentsubindex.."</strong></td></tr>\n"
        tingle=0
  end
  tingle=tingle+1
--  reaper.MB(count,"",0)
if funclistarray[count]:match("<functionname>.-ultraschall.(.-)%(.-</functionname>")~=nil then
  funcindex=funcindex.."<td><a href=\"#"..tostring(funclistarray[count]:match("<slug>(.-)</slug>")).."\">"..tostring(funclistarray[count]:match("<functionname>.-ultraschall.(.-)%(.-</functionname>")).."</a>&nbsp;&nbsp;</td>"
elseif funclistarray[count]:match("<functionname>.-(toboolean.-)%(.-</functionname>")~=nil then 
  funcindex=funcindex.."<td><a href=\"#"..tostring(funclistarray[count]:match("<slug>(.-)</slug>")).."\">"..tostring(funclistarray[count]:match("<functionname>.-(toboolean.-)%(.-</functionname>")).."</a>&nbsp;&nbsp;</td>"
elseif funclistarray[count]:match("<functionname>.-(ultraschall..-)</functionname>")~=nil then
--reaper.MB(tostring(funclistarray[count]:match("<functionname>.-(ultraschall..-)</functionname>")),"",0)
  funcindex=funcindex.."<td><a href=\"#"..tostring(funclistarray[count]:match("<slug>(.-)</slug>")).."\">"..tostring(funclistarray[count]:match("<functionname>.-ultraschall.(.-)</functionname>")).."</a>&nbsp;&nbsp;</td>"
else
--reaper.MB("","",0)
  funcindex=funcindex.."</tr><tr><td><a href=\"#"..tostring(funclistarray[count]:match("<slug>(.-)</slug>")).."\">"..tostring(funclistarray[count]:match("<chaptername>(.-)</chaptername>")).."</a></td></tr>"
end
--  reaper.MB(tostring(funclistarray[count]:match("<slug>(.-)</slug>")),"",0)
  if tingle==4 then tingle=0 funcindex=funcindex.."</tr>\n<tr>" end
--  reaper.MB(tingle,"",0)
  count=count+1
  end

  funcindex=funcindex.."</tr></table>"

--creating entries
  reaper.ShowConsoleMsg("creating entries\n")
  for i=1, count-1 do
  local usvers,ultraschallversion,reapvers,reaperversion,swsvers,swsversion,description,luaversion,luavers
  local retvals=""  
  local parameters=""
  local tempretvals=""
  local begin=""
  tempparameters=""
    if functionarray[i]:match("<functionname>(.-)</functionname>")~=nil then
      if functionarray[i]:match("<requires>(.-)</requires>")~=nil then
        if functionarray[i]:match("<requires>.-Ultraschall=(.-)%c.-</requires>")~=nil then
            usvers=functionarray[i]:match("<requires>.-Ultraschall=(.-)%c.-</requires>")
            ultraschallversion="<img style=\"width:3%;\" src=\"gfx/ultraschall"..usvers..".png\" alt=\"Ultraschall version "..usvers.."\">"
        end
        if functionarray[i]:match("<slug>(.-)</slug>")~=nil then
          slug=functionarray[i]:match("<slug>(.-)</slug>")
--          if slug=="" then reaper.MB(slug,"",0) end
        else
          slug=""
        end
        if functionarray[i]:match("<requires>.-Reaper=(.-)%c.-</requires>")~=nil then
            reapvers=functionarray[i]:match("<requires>.-Reaper=(.-)%c.-</requires>")
            reaperversion="<img style=\"width:3%;\" src=\"gfx/reaper"..reapvers..".png\" alt=\"Reaper version "..reapvers.."\">"
        end
        if functionarray[i]:match("<requires>.-SWS=(.-)%c.-</requires>")~=nil then
            swsvers=functionarray[i]:match("<requires>.-SWS=(.-)%c.-</requires>")
            swsversion="<img style=\"width:3%;\" src=\"gfx/sws"..swsvers..".png\" alt=\"sws version "..swsvers.."\">"
        end
        if functionarray[i]:match("<requires>.-Lua=(.-)%c.-</requires>")~=nil then
            luavers=functionarray[i]:match("<requires>.-Lua=(.-)%c.-</requires>")
            luaversion="<img style=\"width:3%;\" src=\"gfx/Lua"..luavers..".png\" alt=\"lua version "..luavers.."\">"
        end
      end
      if functionarray[i]:match("<description>%c.-</description>")~=nil then
          description=tostring(functionarray[i]:match("<description>%c(.-)</description>"))        
          description=string.gsub(description, "\n", "<br>")
      elseif functionarray[i]:match("<description>.-</description>")~=nil then
          description=tostring(functionarray[i]:match("<description>(.-)</description>"))        
          description=string.gsub(description, "\n", "<br>")
      end      

      if functionarray[i]:match("<retvals>.-</retvals>")~=nil then
          tempretvals=functionarray[i]:match("<retvals>(.-</retvals>)")
--          reaper.MB(tempretvals,"",0)
--          while tempretvals~=nil do
--            retvals=retvals.."<i><div style=\"padding-left:4%;\">"..tostring(tempretvals:match("(.-)%-")).."</i>"..tostring(tempretvals:match("(%-.-)%c")).."</div>"
--            tempretvals=tostring(tempretvals:match(".-%c(.*)"))
--            if tempretvals=="" or tempretvals:match("-")==nil then tempretvals=nil end
--          end
--            tempretvals=string.gsub(tempparameters, "</retvals>", "</i>")
            tempretvals=string.gsub(tempretvals, "\n","</i><br><i>")
            tempretvals=string.gsub(tempretvals, " %- ", "</i> - ")
            tempretvals=string.gsub(tempretvals, "\n.-", "</i><br><i>")
            tempretvals=string.gsub(tempretvals, "<br><i>%-","<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
--            tempretvals=string.gsub(tempretvals, "%%%-", "-")

--            tempretvals=string.gsub(tempretvals, "\n", "</i><br><i>")
--            tempretvals=string.gsub(tempretvals, "<br><i>%-", "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
--            reaper.MB(tempretvals,"",0)
--        retvals=tempretvals
--reaper.MB(tempretvals:sub(9,-8),"",0)
            retvals=retvals.."<div style=\"padding-left:4%;\">"..tempretvals:sub(9,-11).."</i></div>"
      end      
      if functionarray[i]:match("<parameters>.-</parameters>")~=nil then
          tempparameters=functionarray[i]:match("<parameters>(.-</parameters>)")
--          reaper.MB(tempparameters,"",0)
--          tempparameters=string.gsub(tempparameters, "%c", " ")
          tempparameters=string.gsub(tempparameters, "</parameters>", "</i>")
          tempparameters=string.gsub(tempparameters, " %- ", "</i> - ")
          tempparameters=string.gsub(tempparameters, "\n.-", "</i><br><i>")
--          reaper.ShowConsoleMsg(tostring(tempparameters:match("<br><i>%-"),"",0))
          tempparameters=string.gsub(tempparameters, "<br><i>%-", "<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;")
--          reaper.ShowConsoleMsg(tostring(tempparameters:match("<br><div style"),"",0))
--          if tempparameters:match("<br><div style") then tempparameters=tempparameters.."</div>" end
--          tempparameters=string.gsub(tempparameters, "%%%-", "-")
          tempparameters=tempparameters:sub(9,-1)
--          reaper.MB(tempparameters,"",0)
--          while tempparameters~=nil do
--          reaper.MB(tempparameters,"",0)
--            parameters=parameters.."<i><div style=\"padding-left:4%;\">"..tostring(tempparameters:match("(.-)%-")).."</i>"..tostring(tempparameters:match("(%-.-)%c")).."</div>"
            parameters=parameters.."<div style=\"padding-left:4%;\">"..tempparameters.."</div>"
--            tempparameters=tostring(tempparameters:match(" .- %c(.*)"))
--            if tempparameters=="" or tempparameters:match("-")==nil then tempparameters=nil end
--          end
--          reaper.MB(parameters.."test1","",0)
      end      
      slug=functionarray[i]:match("<slug>(.-)</slug>")
      if slug==nil then slug=""
--        reaper.MB(functionarray[i]:match(".-"),"",0)
      end
      slug=string.gsub(slug, "\n", "")
      if retvals~="" then retvals="<u>Returnvalues:</u><br>"..retvals end
      if parameters~="" then parameters="<u>Parameters:</u>"..parameters end
      if swsversion==nil then swsversion="" end
      if luaversion==nil then luaversion="" end
      if reaperversion==nil then reaperversion="" end
      if ultraschallversion==nil then ultraschallversion="" end
        funclist=funclist.."<a id=\""..slug.."\"><hr><br><i></a>"..ultraschallversion..reaperversion..swsversion.." "..functionarray[i]:match("<functionname>(.-)</functionname>").."</i><br><br>"..description.."<p></p>"..retvals.."<p></p>"..parameters.."<p></p>Tags: "..functionarray[i]:match("<tags>(.-)</tags>").."<p></p>"
    end

--dok-chapters
    if functionarray[i]:match("<chaptername>(.-)</chaptername>")~=nil then
        if functionarray[i]:match("<slug>(.-)</slug>")~=nil then
          slug=functionarray[i]:match("<slug>(.-)</slug>")
        else
          slug=""
        end
      if functionarray[i]:match("<description>.-</description>")~=nil then
          description=tostring(functionarray[i]:match("<description>.-%c(.-)%c</description>"))
          description=string.gsub(description, "\n", "<br>")
      end      

      slug=functionarray[i]:match("<slug>(.-)</slug>")
      if slug==nil then slug=""
--        reaper.MB(functionarray[i]:match(".-"),"",0)
      end
      slug=string.gsub(slug, "\n", "")      
      if functionarray[i]:match("<begin></begin>")~=nil then
        begin="<hr>"
      else
        begin=""
      end
        funclist=funclist.."<a id=\""..slug.."\">"..begin.."</a><h4>"..functionarray[i]:match("<chaptername>(.-)</chaptername>").."</h4>"..description.."<p></p>"      
    end
    
  end

  --assembling helpfile
  reaper.ShowConsoleMsg("assembling helpfile\n")
  local endfile="<hr><p align=\"right\"><i>API-documentation automatically created by Ultraschall-Framework version "..ultraschall.GetApiVersion().." "..apibeta.." - "..Functioncounter.."-functions available</i></p></div></body></html>"
  local outfile=startfile..funcindex.."<p></p>"..funclist..endfile
  reaper.ShowConsoleMsg("Number of entries: "..Functioncounter.."\n")
  reaper.ShowConsoleMsg("storing helpfile\n")
  return ultraschall.WriteValueToFile(filename_with_path, outfile)  
end


--ALABAMA=ultraschall.CreateUSApiDocs_HTML("c:\\testhelp-beta1-1.html", "c:\\US-Doku-beta1.txt")
--  local A,B,C,D,E,F,G,H=reaper.get_action_context()
--ALABAMA=ultraschall.CreateUSApiDocs_HTML("c:\\testhelp-beta2hulu.html", B)
--ALABAMA=ultraschall.CreateUSApiDocs_HTML("c:\\testhelp-beta2-7-1.html")




--------------------------------------------------
------ ULTRASCHALL FRAMEWORK 4.00 BETA 2.5 -------
--------------------------------------------------

function ultraschall.SetAllTracksSelected(selected)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetAllTracksSelected</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetAllTracksSelected(boolean selected)</functioncall>
  <description>
    Sets all tracks selected(if selected is true) of unselected(if selected is false)
    
    returns -1 in case of error
  </description>
  <retvals>
    integer retval - returns -1 in case of error
  </retvals>
  <parameters>
    boolean selected - true, if all tracks shall be selected, false if all shall be deselected
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, get, selected</tags>
</US_DocBloc>
]]
  if type(selected)~="boolean" then ultraschall.AddErrorMessage("SetAllTracksSelected","selected", "must be a boolean", -1) return -1 end
  for i=0, reaper.CountTracks(0)-1 do
    local MediaTrack=reaper.GetTrack(0,i)
    reaper.SetTrackSelected(MediaTrack, selected)
  end
end

--L=ultraschall.SetAllTracksSelected(false)


function ultraschall.SetTracksSelected(trackstring, reset)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTracksSelected</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetTracksSelected(string trackstring, boolean reset)</functioncall>
  <description>
    Sets tracks in trackstring selected. If reset is set to true, then the previous selection will be discarded.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer retval - returns -1 in case of error
  </retvals>
  <parameters>
    string trackstring - a string with the tracknumbers, separated by a comma.
    boolean reset - true, any previous selection will be discarded; false, it will be kept
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, get, selected</tags>
</US_DocBloc>
]]
  if type(reset)~="boolean" then ultraschall.AddErrorMessage("SetTracksSelected", "reset", "must be boolean", -1) return -1 end
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  --reaper.MB(trackstring,"",0)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("SetTracksSelected", "trackstring", "must be a valid trackstring", -2) return -1 end
  local count, Aindividual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring)
  if reset==true then ultraschall.SetAllTracksSelected(false) end
  for i=1,count do
     if Aindividual_values[i]-1<reaper.CountTracks(0) and Aindividual_values[i]-1>=0 then
       local MediaTrack=reaper.GetTrack(0,Aindividual_values[i]-1)
       reaper.SetTrackSelected(MediaTrack, true)
     end
  end
end

--L=ultraschall.SetTracksSelected("1", true)



function ultraschall.GetItemPosition(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number position = ultraschall.GetItemPosition(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns position-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose position you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number position - the position in seconds, as set in the statechunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, position</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemPosition","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemPosition","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("POSITION( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" (.-) (.-) "))
end

--lol, sc=reaper.GetItemStateChunk(reaper.GetMediaItem(0,0),"",false)
--A,B=ultraschall.GetItemPosition(reaper.GetMediaItem(0,0), sc)


function ultraschall.GetItemLength(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number length = ultraschall.GetItemLength(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns length-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose length you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number length - the length in seconds, as set in the statechunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, length</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemLength","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemLength","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("LENGTH( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" (.-) (.-) "))
end

--A=ultraschall.GetItemLength(reaper.GetMediaItem(0,0))

function ultraschall.GetItemSnapOffset(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSnapOffset</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number snapoffset = ultraschall.GetItemSnapOffset(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns snapoffs-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose snapoffset you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number snapoffset - the snapoffset in seconds, as set in the statechunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, snap, offset</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemSnapOffset","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemSnapOffset","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("SNAPOFFS( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" (.-) (.-) "))
end


--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A=ultraschall.GetItemSnapOffset(reaper.GetMediaItem(0,0))


function ultraschall.GetItemLoop(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemLoop</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer loopstate = ultraschall.GetItemLoop(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns loopstate-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer loopstate - the loopstate, as set in the statechunk; 1, loop source; 0, don't loop source
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, loop</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemLoop","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemLoop","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("LOOP( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" (.-) (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A=ultraschall.GetItemLoop(reaper.GetMediaItem(0,0))

function ultraschall.GetItemAllTakes(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemAllTakes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer alltakes = ultraschall.GetItemAllTakes(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns alltakes-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose all-takes-playstate you want to know; nil, use parameter MediaItemStatechunk instead
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer alltakes - Play all takes(1) or don't play all takes(0)
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, alltakes, all, takes</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemAllTakes","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemAllTakes","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("ALLTAKES( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" (.-) (.-) "))
end

--A=ultraschall.GetItemAllTakes(reaper.GetMediaItem(0,0))

function ultraschall.GetItemFadeIn(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemFadeIn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string fadestate1, number fadestate2, number fadestate3, string fadestate4, integer fadestate5, number fadestate6 = ultraschall.GetItemFadeIn(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns fadein-entries of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose fadein-state you want to know; nil, use parameter MediaItemStatechunk instead
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string curvetype1 - the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype2
    number fadein - fadein in seconds
    number fadestate3 - fadeinstate entry as set in the rppxml-mediaitem-statechunk
    string curvetype2 - the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype1
    integer fadestate5 - fadeinstate entry as set in the rppxml-mediaitem-statechunk
    number curve - curve -1 to 1
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, fade in</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemFadeIn","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemFadeIn","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("FADEIN( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1",false)
--A1,A2,A3,A4,A5,A6=ultraschall.GetItemFadeIn(reaper.GetMediaItem(0,0))

function ultraschall.GetItemFadeOut(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemFadeOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string curvetype1, number fadeout_length, number fadeout_length2, string curvetype2, integer fadestate5, number curve = ultraschall.GetItemFadeOut(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns fadeout-entries of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose fadeout-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string curvetype1 - the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype2
    number fadeout_length - the current fadeout-length in seconds
    number fadeout_length2 - the fadeout-length in seconds; overrides fadeout_length and will be moved to fadeout_length when fadeout-length changes(e.g. mouse-drag); might be autocrossfade-length
    string curvetype2 - the type of the curve: 0, 1, 2, 3, 4, 5, 5.1; must be set like curvetype1
    integer fadestate5 - unknown
    number curve - curvation of the fadeout, -1 to 1
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, fade out</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemFadeOut","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemFadeOut","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("FADEOUT( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A,B,C,D,E,F,G,H,I=ultraschall.GetItemFadeOut(reaper.GetMediaItem(0,0))

function ultraschall.GetItemMute(MediaItem, statechunk)
--  reaper.MB(statechunk,"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemMute</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer mutestate = ultraschall.GetItemMute(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns mutestate-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose mute-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer mutestate - the mute-state; 1, mute is on; 0, mute is off
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, fade out</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemMute","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemMute","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("MUTE( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A=reaper.GetMediaItem(0,0)
--Amutestate = ultraschall.GetItemMute(reaper.GetMediaItem(0,0))

function ultraschall.GetItemFadeFlag(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemFadeFlag</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer autofade_state = ultraschall.GetItemFadeFlag(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns autofade-entry of a MediaItem or MediaItemStateChunk.
    It's the FADEFLAG-entry.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose fadeflag-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer autofade_state - the autofade-state; 1, autofade is off; nil, autofade is on
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, autofade</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemFadeFlag","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemFadeFlag","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("FADEFLAG( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--AL=ultraschall.GetItemFadeFlag(reaper.GetMediaItem(0,0))

function ultraschall.GetItemLock(MediaItem, statechunk)
--  reaper.MB(statechunk,"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemLock</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer lock_state = ultraschall.GetItemLock(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns itemlock-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose itemlock-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer lock_state - the lock-state; 1, item is locked; nil, item is not locked
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, lock</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemLock","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemLock","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("LOCK( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--AL=ultraschall.GetItemLock(reaper.GetMediaItem(0,0))

function ultraschall.GetItemSelected(MediaItem, statechunk)
--  reaper.MB(statechunk,"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSelected</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer selected_state = ultraschall.GetItemSelected(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns item-selected-state-entry of a MediaItem or MediaItemStateChunk.
    It's the SEL-entry.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose selection-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer selected_state - the item-selected-state; 1 - item is selected; 0 - item is not selected
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, selected</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemSelected","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemSelected","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("SEL( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--AL=ultraschall.GetItemSelected(reaper.GetMediaItem(0,0))

function ultraschall.GetItemGroup(MediaItem, statechunk)
--  reaper.MB(statechunk,"",0)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemGroup</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer item_group = ultraschall.GetItemGroup(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns group of a MediaItem or MediaItemStateChunk, where the item belongs to.
    It's the GROUP-entry
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose ItemGroup-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer item_group - the group the item belongs to; nil, if item doesn't belong to any group
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, group</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemGroup","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemGroup","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("GROUP( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A,B,C=ultraschall.GetItemGroup(reaper.GetMediaItem(0,0))


function ultraschall.GetItemIGUID(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemIGUID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string IGUID = ultraschall.GetItemIGUID(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the IGUID-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose IGUID-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string IGUID - the IGUID of the item
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, guid, iguid</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemIGUID","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemIGUID","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("IGUID( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return statechunk:match(" (.-) "), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A=ultraschall.GetItemIGUID(reaper.GetMediaItem(0,0))

function ultraschall.GetItemIID(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemIID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer IID = ultraschall.GetItemIID(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the IID-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose ItemIID-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer IID - the IID of the item; the item-id, which is basically a counter of all items created within this project. May change, so use it only as a counter. If you want to identify a specific item, use GUID and IGUID instead.
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, iid</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemIID","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemIID","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("IID( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A=ultraschall.GetItemIID(reaper.GetMediaItem(0,0))

function ultraschall.GetItemName(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemName</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string name = ultraschall.GetItemName(MediaItem MediaItem, string MediaItemStateChunk)</functioncall>
  <description>
    Returns the name-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose itemname-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string name - the name of the item
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, name</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemName","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemName","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("NAME (.-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
  local name=statechunk:match("\"(.-)\"")
  if name==nil then name=statechunk:match("(.-) ") end
  
  return name
end


--A=ultraschall.GetItemName(reaper.GetMediaItem(0,0))

--MESPOTINE

function ultraschall.GetItemVolPan(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemVolPan</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number volpan1, number pan, number volume, number volpan4 = ultraschall.GetItemVolPan(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the vol/pan-entries of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose volpan-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number volpan1 - unknown
    number pan - from -1(100%L) to 1(100%R), 0 is center
    number volume - from 0(-inf) to 3.981072(+12db), 1 is 0db; higher numbers are allowed; negative means phase inverted
    number volpan4 - unknown
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, volume, pan</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemVolPan","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemVolPan","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("VOLPAN( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A1,A2,A3,A4,A5=ultraschall.GetItemVolPan(reaper.GetMediaItem(0,0))

function ultraschall.GetItemSampleOffset(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSampleOffset</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number sampleoffset = ultraschall.GetItemSampleOffset(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the sampleoffset-entry of a MediaItem or MediaItemStateChunk.
    It's the SOFFS-entry.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose sample-offset-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number sampleoffset - sampleoffset in seconds
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, sample, offset</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemSampleOffset","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemSampleOffset","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("SOFFS( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A1,A2,A3,A4,A5=ultraschall.GetItemSampleOffset(reaper.GetMediaItem(0,0))

function ultraschall.GetItemPlayRate(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemPlayRate</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.80
    Lua=5.3
  </requires>
  <functioncall>number playbackrate, integer preserve_pitch, number pitch_adjust, integer takepitch_timestretch_mode, integer optimize_tonal_content, number stretch_marker_fadesize = ultraschall.GetItemPlayRate(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the playback-rate-entries of a MediaItem or MediaItemStateChunk.
    It's the PLAYRATE-entry.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose playback-rate-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    number playbackrate - 1 is 1x, 2 is 2x, 1.8 is 1.8x,etc
    integer preserve_pitch - preserve pitch, 1 - preserve, 0 - don't preserve
    number pitch_adjust - pitch_adjust(semitones); negative values allowed; 1.1=1.1 semitones higher, -0.3=0.3 semitones lower,etc
    integer takepitch_timestretch_mode - - the item's pitchmode - 65536 for project-default
    -      0 - Soundtouch(Default)
    -      1 - Soundtouch(High Quality)
    -      2 - Soundtouch(Fast)
    -      131072 - Simple Windowed(fast) (50ms window, 25ms fade)
    -      131073 - Simple Windowed(fast) (50ms window, 16ms fade)
    -      131074 - Simple Windowed(fast) (50ms window, 10ms fade)
    -      131075 - Simple Windowed(fast) (50ms window, 7ms fade)
    -      131076 - Simple Windowed(fast) (75ms window, 37ms fade)
    -      131077 - Simple Windowed(fast) (75ms window, 25ms fade)
    -      131078 - Simple Windowed(fast) (75ms window, 15ms fade)
    -      131079 - Simple Windowed(fast) (75ms window, 10ms fade)
    -      131080 - Simple Windowed(fast) (100ms window, 50ms fade)
    -      131081 - Simple Windowed(fast) (100ms window, 33ms fade)
    -      131082 - Simple Windowed(fast) (100ms window, 20ms fade)
    -      131083 - Simple Windowed(fast) (100ms window, 14ms fade)
    -      131084 - Simple Windowed(fast) (150ms window, 75ms fade)
    -      131085 - Simple Windowed(fast) (150ms window, 50ms fade)
    -      131086 - Simple Windowed(fast) (150ms window, 30ms fade)
    -      131087 - Simple Windowed(fast) (150ms window, 21ms fade)
    -      131088 - Simple Windowed(fast) (225ms window, 112ms fade)
    -      131089 - Simple Windowed(fast) (225ms window, 75ms fade)
    -      131090 - Simple Windowed(fast) (225ms window, 45ms fade)
    -      131091 - Simple Windowed(fast) (225ms window, 32ms fade)
    -      131092 - Simple Windowed(fast) (300ms window, 150ms fade)
    -      131093 - Simple Windowed(fast) (300ms window, 100ms fade)
    -      131094 - Simple Windowed(fast) (300ms window, 60ms fade)
    -      131095 - Simple Windowed(fast) (300ms window, 42ms fade)
    -      131096 - Simple Windowed(fast) (40ms window, 20ms fade)
    -      131097 - Simple Windowed(fast) (40ms window, 13ms fade)
    -      131098 - Simple Windowed(fast) (40ms window, 8ms fade)
    -      131099 - Simple Windowed(fast) (40ms window, 5ms fade)
    -      131100 - Simple Windowed(fast) (30ms window, 15ms fade)
    -      131101 - Simple Windowed(fast) (30ms window, 10ms fade)
    -      131102 - Simple Windowed(fast) (30ms window, 6s fade)
    -      131103 - Simple Windowed(fast) (30ms window, 4ms fade)
    -      131104 - Simple Windowed(fast) (20ms window, 10ms fade)
    -      131105 - Simple Windowed(fast) (20ms window, 6ms fade)
    -      131106 - Simple Windowed(fast) (20ms window, 4ms fade)
    -      131107 - Simple Windowed(fast) (20ms window, 2ms fade)
    -      131108 - Simple Windowed(fast) (10ms window, 5ms fade)
    -      131109 - Simple Windowed(fast) (10ms window, 3ms fade)
    -      131110 - Simple Windowed(fast) (10ms window, 2ms fade)
    -      131111 - Simple Windowed(fast) (10ms window, 1ms fade)
    -      131112 - Simple Windowed(fast) (5ms window, 2ms fade)
    -      131113 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131114 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131115 - Simple Windowed(fast) (5ms window, 1ms fade)
    -      131116 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131117 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131118 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      131119 - Simple Windowed(fast) (3ms window, 1ms fade)
    -      393216 - elastique 2.28 Pro Normal
    -      393217 - elastique 2.28 Pro Preserve Formants(Lowest Pitches)
    -      393218 - elastique 2.28 Pro Preserve Formants(Lower Pitches)
    -      393219 - elastique 2.28 Pro Preserve Formants(Low Pitches)
    -      393220 - elastique 2.28 Pro Preserve Formants(Most Pitches)
    -      393221 - elastique 2.28 Pro Preserve Formants(High Pitches)
    -      393222 - elastique 2.28 Pro Preserve Formants(Higher Pitches)
    -      393223 - elastique 2.28 Pro Preserve Formants(Highest Pitches)
    -      393224 - elastique 2.28 Pro Mid/Side
    -      393225 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      393226 - elastique 2.28 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      393227 - elastique 2.28 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      393228 - elastique 2.28 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      393229 - elastique 2.28 Pro Mid/Side, Preserve Formants(High Pitches)
    -      393230 - elastique 2.28 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      393231 - elastique 2.28 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      393232 - elastique 2.28 Pro Synchronized: Normal
    -      393233 - elastique 2.28 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      393234 - elastique 2.28 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      393235 - elastique 2.28 Pro Synchronized: Preserve Formants(Low Pitches)
    -      393236 - elastique 2.28 Pro Synchronized: Preserve Formants(Most Pitches)
    -      393237 - elastique 2.28 Pro Synchronized: Preserve Formants(High Pitches)
    -      393238 - elastique 2.28 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      393239 - elastique 2.28 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      393240 - elastique 2.28 Pro Synchronized: Mid/Side 
    -      393241 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      393242 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      393243 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      393244 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      393245 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      393246 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      393247 - elastique 2.28 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      458752 - elastique 2.28 Efficient Normal
    -      458753 - elastique 2.28 Efficient Mid/Side
    -      458754 - elastique 2.28 Efficient Synchronized: Normal
    -      458755 - elastique 2.28 Efficient Synchronized: Mid/Side
    -      524288 - elastique 2.28 Soloist Monophonic
    -      524289 - elastique 2.28 Soloist Monophonic [Mid/Side]
    -      524290 - elastique 2.28 Soloist Speech
    -      524291 - elastique 2.28 Soloist Speech [Mid/Side]
    -      589824 - elastique 3.2.3 Pro Normal
    -      589825 - elastique 3.2.3 Pro Preserve Formants(Lowest Pitches)
    -      589826 - elastique 3.2.3 Pro Preserve Formants(Lower Pitches)
    -      589827 - elastique 3.2.3 Pro Preserve Formants(Low Pitches)
    -      589828 - elastique 3.2.3 Pro Preserve Formants(Most Pitches)
    -      589829 - elastique 3.2.3 Pro Preserve Formants(High Pitches)
    -      589830 - elastique 3.2.3 Pro Preserve Formants(Higher Pitches)
    -      589831 - elastique 3.2.3 Pro Preserve Formants(Highest Pitches)
    -      589832 - elastique 3.2.3 Pro Mid/Side
    -      589833 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lowest Pitches)
    -      589834 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Lower Pitches)
    -      589835 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Low Pitches)
    -      589836 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Most Pitches)
    -      589837 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(High Pitches)
    -      589838 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Higher Pitches)
    -      589839 - elastique 3.2.3 Pro Mid/Side, Preserve Formants(Highest Pitches)
    -      589840 - elastique 3.2.3 Pro Synchronized: Normal
    -      589841 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lowest Pitches)
    -      589842 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Lower Pitches)
    -      589843 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Low Pitches)
    -      589844 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Most Pitches)
    -      589845 - elastique 3.2.3 Pro Synchronized: Preserve Formants(High Pitches)
    -      589846 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Higher Pitches)
    -      589847 - elastique 3.2.3 Pro Synchronized: Preserve Formants(Highest Pitches)
    -      589848 - elastique 3.2.3 Pro Synchronized: Mid/Side 
    -      589849 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lowest Pitches)
    -      589850 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Lower Pitches) 
    -      589851 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Low Pitches)
    -      589852 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Most Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(High Pitches)
    -      589853 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Higher Pitches)
    -      589855 - elastique 3.2.3 Pro Synchronized: Mid/Side, Preserve Formants(Highest Pitches)
    -      655360 - elastique 3.2.3 Efficient Normal
    -      655361 - elastique 3.2.3 Efficient Mid/Side
    -      655362 - elastique 3.2.3 Efficient Synchronized: Normal
    -      655363 - elastique 3.2.3 Efficient Synchronized: Mid/Side
    -      720896 - elastique 3.2.3 Soloist (Monophonic)
    -      720897 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -      720898 - elastique 3.2.3 Soloist (Speech)
    -      720898 - elastique 3.2.3 Soloist (Monophonic Mid Side)
    -
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851968 - nothing
    -      851969 - Preserve Formants
    -      851970 - Mid/Side
    -      851971 - Preserve Formants (Mid Side)
    -      851972 - Independent Phase
    -      851973 - Preserve Formants, Independent Phase
    -      851974 - Mid/Side, Independent Phase
    -      851975 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      851984 - nothing
    -      851985 - Preserve Formants
    -      851986 - Mid/Side
    -      851987 - Preserve Formants (Mid Side)
    -      851988 - Independent Phase
    -      851989 - Preserve Formants, Independent Phase
    -      851990 - Mid/Side, Independent Phase
    -      851991 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Standard
    -      852000 - nothing
    -      852001 - Preserve Formants
    -      852002 - Mid/Side
    -      852003 - Preserve Formants (Mid Side)
    -      852004 - Independent Phase
    -      852005 - Preserve Formants, Independent Phase
    -      852006 - Mid/Side, Independent Phase
    -      852007 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852016 - nothing
    -      852017 - Preserve Formants
    -      852018 - Mid/Side
    -      852019 - Preserve Formants (Mid Side)
    -      852020 - Independent Phase
    -      852021 - Preserve Formants, Independent Phase
    -      852022 - Mid/Side, Independent Phase
    -      852023 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852032 - nothing
    -      852033 - Preserve Formants
    -      852034 - Mid/Side
    -      852035 - Preserve Formants (Mid Side)
    -      852036 - Independent Phase
    -      852037 - Preserve Formants, Independent Phase
    -      852038 - Mid/Side, Independent Phase
    -      852039 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Standard
    -      852048 - nothing
    -      852049 - Preserve Formants
    -      852050 - Mid/Side
    -      852051 - Preserve Formants (Mid Side)
    -      852052 - Independent Phase
    -      852053 - Preserve Formants, Independent Phase
    -      852054 - Mid/Side, Independent Phase
    -      852055 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852064 - nothing
    -      852065 - Preserve Formants
    -      852066 - Mid/Side
    -      852067 - Preserve Formants (Mid Side)
    -      852068 - Independent Phase
    -      852069 - Preserve Formants, Independent Phase
    -      852070 - Mid/Side, Independent Phase
    -      852071 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852080 - nothing
    -      852081 - Preserve Formants
    -      852082 - Mid/Side
    -      852083 - Preserve Formants (Mid Side)
    -      852084 - Independent Phase
    -      852085 - Preserve Formants, Independent Phase
    -      852086 - Mid/Side, Independent Phase
    -      852087 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Standard
    -      852096 - nothing
    -      852097 - Preserve Formants
    -      852098 - Mid/Side
    -      852099 - Preserve Formants (Mid Side)
    -      852100 - Independent Phase
    -      852101 - Preserve Formants, Independent Phase
    -      852102 - Mid/Side, Independent Phase
    -      852103 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852112 - nothing
    -      852113 - Preserve Formants
    -      852114 - Mid/Side
    -      852115 - Preserve Formants (Mid Side)
    -      852116 - Independent Phase
    -      852117 - Preserve Formants, Independent Phase
    -      852118 - Mid/Side, Independent Phase
    -      852119 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852128 - nothing
    -      852129 - Preserve Formants
    -      852130 - Mid/Side
    -      852131 - Preserve Formants (Mid Side)
    -      852132 - Independent Phase
    -      852133 - Preserve Formants, Independent Phase
    -      852134 - Mid/Side, Independent Phase
    -      852135 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Standard
    -      852144 - nothing
    -      852145 - Preserve Formants
    -      852146 - Mid/Side
    -      852147 - Preserve Formants (Mid Side)
    -      852148 - Independent Phase
    -      852149 - Preserve Formants, Independent Phase
    -      852150 - Mid/Side, Independent Phase
    -      852151 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852160 - nothing
    -      852161 - Preserve Formants
    -      852162 - Mid/Side
    -      852163 - Preserve Formants (Mid Side)
    -      852164 - Independent Phase
    -      852165 - Preserve Formants, Independent Phase
    -      852166 - Mid/Side, Independent Phase
    -      852167 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852176 - nothing
    -      852177 - Preserve Formants
    -      852178 - Mid/Side
    -      852179 - Preserve Formants (Mid Side)
    -      852180 - Independent Phase
    -      852181 - Preserve Formants, Independent Phase
    -      852182 - Mid/Side, Independent Phase
    -      852183 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Standard
    -      852192 - nothing
    -      852193 - Preserve Formants
    -      852194 - Mid/Side
    -      852195 - Preserve Formants (Mid Side)
    -      852196 - Independent Phase
    -      852197 - Preserve Formants, Independent Phase
    -      852198 - Mid/Side, Independent Phase
    -      852199 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852208 - nothing
    -      852209 - Preserve Formants
    -      852210 - Mid/Side
    -      852211 - Preserve Formants (Mid Side)
    -      852212 - Independent Phase
    -      852213 - Preserve Formants, Independent Phase
    -      852214 - Mid/Side, Independent Phase
    -      852215 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852224 - nothing
    -      852225 - Preserve Formants
    -      852226 - Mid/Side
    -      852227 - Preserve Formants (Mid Side)
    -      852228 - Independent Phase
    -      852229 - Preserve Formants, Independent Phase
    -      852230 - Mid/Side, Independent Phase
    -      852231 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Standard
    -      852240 - nothing
    -      852241 - Preserve Formants
    -      852242 - Mid/Side
    -      852243 - Preserve Formants (Mid Side)
    -      852244 - Independent Phase
    -      852245 - Preserve Formants, Independent Phase
    -      852246 - Mid/Side, Independent Phase
    -      852247 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852256 - nothing
    -      852257 - Preserve Formants
    -      852258 - Mid/Side
    -      852259 - Preserve Formants (Mid Side)
    -      852260 - Independent Phase
    -      852261 - Preserve Formants, Independent Phase
    -      852262 - Mid/Side, Independent Phase
    -      852263 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852272 - nothing
    -      852273 - Preserve Formants
    -      852274 - Mid/Side
    -      852275 - Preserve Formants (Mid Side)
    -      852276 - Independent Phase
    -      852277 - Preserve Formants, Independent Phase
    -      852278 - Mid/Side, Independent Phase
    -      852279 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Standard
    -      852288 - nothing
    -      852289 - Preserve Formants
    -      852290 - Mid/Side
    -      852291 - Preserve Formants (Mid Side)
    -      852292 - Independent Phase
    -      852293 - Preserve Formants, Independent Phase
    -      852294 - Mid/Side, Independent Phase
    -      852295 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852304 - nothing
    -      852305 - Preserve Formants
    -      852306 - Mid/Side
    -      852307 - Preserve Formants (Mid Side)
    -      852308 - Independent Phase
    -      852309 - Preserve Formants, Independent Phase
    -      852310 - Mid/Side, Independent Phase
    -      852311 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852320 - nothing
    -      852321 - Preserve Formants
    -      852322 - Mid/Side
    -      852323 - Preserve Formants (Mid Side)
    -      852324 - Independent Phase
    -      852325 - Preserve Formants, Independent Phase
    -      852326 - Mid/Side, Independent Phase
    -      852327 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Standard
    -      852336 - nothing
    -      852337 - Preserve Formants
    -      852338 - Mid/Side
    -      852339 - Preserve Formants (Mid Side)
    -      852340 - Independent Phase
    -      852341 - Preserve Formants, Independent Phase
    -      852342 - Mid/Side, Independent Phase
    -      852343 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852352 - nothing
    -      852353 - Preserve Formants
    -      852354 - Mid/Side
    -      852355 - Preserve Formants (Mid Side)
    -      852356 - Independent Phase
    -      852357 - Preserve Formants, Independent Phase
    -      852358 - Mid/Side, Independent Phase
    -      852359 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852368 - nothing
    -      852369 - Preserve Formants
    -      852370 - Mid/Side
    -      852371 - Preserve Formants (Mid Side)
    -      852372 - Independent Phase
    -      852373 - Preserve Formants, Independent Phase
    -      852374 - Mid/Side, Independent Phase
    -      852375 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Standard
    -      852384 - nothing
    -      852385 - Preserve Formants
    -      852386 - Mid/Side
    -      852387 - Preserve Formants (Mid Side)
    -      852388 - Independent Phase
    -      852389 - Preserve Formants, Independent Phase
    -      852390 - Mid/Side, Independent Phase
    -      852391 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852400 - nothing
    -      852401 - Preserve Formants
    -      852402 - Mid/Side
    -      852403 - Preserve Formants (Mid Side)
    -      852404 - Independent Phase
    -      852405 - Preserve Formants, Independent Phase
    -      852406 - Mid/Side, Independent Phase
    -      852407 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852416 - nothing
    -      852417 - Preserve Formants
    -      852418 - Mid/Side
    -      852419 - Preserve Formants (Mid Side)
    -      852420 - Independent Phase
    -      852421 - Preserve Formants, Independent Phase
    -      852422 - Mid/Side, Independent Phase
    -      852423 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Short
    -      852432 - nothing
    -      852433 - Preserve Formants
    -      852434 - Mid/Side
    -      852435 - Preserve Formants (Mid Side)
    -      852436 - Independent Phase
    -      852437 - Preserve Formants, Independent Phase
    -      852438 - Mid/Side, Independent Phase
    -      852439 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852448 - nothing
    -      852449 - Preserve Formants
    -      852450 - Mid/Side
    -      852451 - Preserve Formants (Mid Side)
    -      852452 - Independent Phase
    -      852453 - Preserve Formants, Independent Phase
    -      852454 - Mid/Side, Independent Phase
    -      852455 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852464 - nothing
    -      852465 - Preserve Formants
    -      852466 - Mid/Side
    -      852467 - Preserve Formants (Mid Side)
    -      852468 - Independent Phase
    -      852469 - Preserve Formants, Independent Phase
    -      852470 - Mid/Side, Independent Phase
    -      852471 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Short
    -      852480 - nothing
    -      852481 - Preserve Formants
    -      852482 - Mid/Side
    -      852483 - Preserve Formants (Mid Side)
    -      852484 - Independent Phase
    -      852485 - Preserve Formants, Independent Phase
    -      852486 - Mid/Side, Independent Phase
    -      852487 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852496 - nothing
    -      852497 - Preserve Formants
    -      852498 - Mid/Side
    -      852499 - Preserve Formants (Mid Side)
    -      852500 - Independent Phase
    -      852501 - Preserve Formants, Independent Phase
    -      852502 - Mid/Side, Independent Phase
    -      852503 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852512 - nothing
    -      852513 - Preserve Formants
    -      852514 - Mid/Side
    -      852515 - Preserve Formants (Mid Side)
    -      852516 - Independent Phase
    -      852517 - Preserve Formants, Independent Phase
    -      852518 - Mid/Side, Independent Phase
    -      852519 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Short
    -      852528 - nothing
    -      852529 - Preserve Formants
    -      852530 - Mid/Side
    -      852531 - Preserve Formants (Mid Side)
    -      852532 - Independent Phase
    -      852533 - Preserve Formants, Independent Phase
    -      852534 - Mid/Side, Independent Phase
    -      852535 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852544 - nothing
    -      852545 - Preserve Formants
    -      852546 - Mid/Side
    -      852547 - Preserve Formants (Mid Side)
    -      852548 - Independent Phase
    -      852549 - Preserve Formants, Independent Phase
    -      852550 - Mid/Side, Independent Phase
    -      852551 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852560 - nothing
    -      852561 - Preserve Formants
    -      852562 - Mid/Side
    -      852563 - Preserve Formants (Mid Side)
    -      852564 - Independent Phase
    -      852565 - Preserve Formants, Independent Phase
    -      852566 - Mid/Side, Independent Phase
    -      852567 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Short
    -      852576 - nothing
    -      852577 - Preserve Formants
    -      852578 - Mid/Side
    -      852579 - Preserve Formants (Mid Side)
    -      852580 - Independent Phase
    -      852581 - Preserve Formants, Independent Phase
    -      852582 - Mid/Side, Independent Phase
    -      852583 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852592 - nothing
    -      852593 - Preserve Formants
    -      852594 - Mid/Side
    -      852595 - Preserve Formants (Mid Side)
    -      852596 - Independent Phase
    -      852597 - Preserve Formants, Independent Phase
    -      852598 - Mid/Side, Independent Phase
    -      852599 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852608 - nothing
    -      852609 - Preserve Formants
    -      852610 - Mid/Side
    -      852611 - Preserve Formants (Mid Side)
    -      852612 - Independent Phase
    -      852613 - Preserve Formants, Independent Phase
    -      852614 - Mid/Side, Independent Phase
    -      852615 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Short
    -      852624 - nothing
    -      852625 - Preserve Formants
    -      852626 - Mid/Side
    -      852627 - Preserve Formants (Mid Side)
    -      852628 - Independent Phase
    -      852629 - Preserve Formants, Independent Phase
    -      852630 - Mid/Side, Independent Phase
    -      852631 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852640 - nothing
    -      852641 - Preserve Formants
    -      852642 - Mid/Side
    -      852643 - Preserve Formants (Mid Side)
    -      852644 - Independent Phase
    -      852645 - Preserve Formants, Independent Phase
    -      852646 - Mid/Side, Independent Phase
    -      852647 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852656 - nothing
    -      852657 - Preserve Formants
    -      852658 - Mid/Side
    -      852659 - Preserve Formants (Mid Side)
    -      852660 - Independent Phase
    -      852661 - Preserve Formants, Independent Phase
    -      852662 - Mid/Side, Independent Phase
    -      852663 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Short
    -      852672 - nothing
    -      852673 - Preserve Formants
    -      852674 - Mid/Side
    -      852675 - Preserve Formants (Mid Side)
    -      852676 - Independent Phase
    -      852677 - Preserve Formants, Independent Phase
    -      852678 - Mid/Side, Independent Phase
    -      852679 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852688 - nothing
    -      852689 - Preserve Formants
    -      852690 - Mid/Side
    -      852691 - Preserve Formants (Mid Side)
    -      852692 - Independent Phase
    -      852693 - Preserve Formants, Independent Phase
    -      852694 - Mid/Side, Independent Phase
    -      852695 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852704 - nothing
    -      852705 - Preserve Formants
    -      852706 - Mid/Side
    -      852707 - Preserve Formants (Mid Side)
    -      852708 - Independent Phase
    -      852709 - Preserve Formants, Independent Phase
    -      852710 - Mid/Side, Independent Phase
    -      852711 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Short
    -      852720 - nothing
    -      852721 - Preserve Formants
    -      852722 - Mid/Side
    -      852723 - Preserve Formants (Mid Side)
    -      852724 - Independent Phase
    -      852725 - Preserve Formants, Independent Phase
    -      852726 - Mid/Side, Independent Phase
    -      852727 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852736 - nothing
    -      852737 - Preserve Formants
    -      852738 - Mid/Side
    -      852739 - Preserve Formants (Mid Side)
    -      852740 - Independent Phase
    -      852741 - Preserve Formants, Independent Phase
    -      852742 - Mid/Side, Independent Phase
    -      852743 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852752 - nothing
    -      852753 - Preserve Formants
    -      852754 - Mid/Side
    -      852755 - Preserve Formants (Mid Side)
    -      852756 - Independent Phase
    -      852757 - Preserve Formants, Independent Phase
    -      852758 - Mid/Side, Independent Phase
    -      852759 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Short
    -      852768 - nothing
    -      852769 - Preserve Formants
    -      852770 - Mid/Side
    -      852771 - Preserve Formants (Mid Side)
    -      852772 - Independent Phase
    -      852773 - Preserve Formants, Independent Phase
    -      852774 - Mid/Side, Independent Phase
    -      852775 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852784 - nothing
    -      852785 - Preserve Formants
    -      852786 - Mid/Side
    -      852787 - Preserve Formants (Mid Side)
    -      852788 - Independent Phase
    -      852789 - Preserve Formants, Independent Phase
    -      852790 - Mid/Side, Independent Phase
    -      852791 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852800 - nothing
    -      852801 - Preserve Formants
    -      852802 - Mid/Side
    -      852803 - Preserve Formants (Mid Side)
    -      852804 - Independent Phase
    -      852805 - Preserve Formants, Independent Phase
    -      852806 - Mid/Side, Independent Phase
    -      852807 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Short
    -      852816 - nothing
    -      852817 - Preserve Formants
    -      852818 - Mid/Side
    -      852819 - Preserve Formants (Mid Side)
    -      852820 - Independent Phase
    -      852821 - Preserve Formants, Independent Phase
    -      852822 - Mid/Side, Independent Phase
    -      852823 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852832 - nothing
    -      852833 - Preserve Formants
    -      852834 - Mid/Side
    -      852835 - Preserve Formants (Mid Side)
    -      852836 - Independent Phase
    -      852837 - Preserve Formants, Independent Phase
    -      852838 - Mid/Side, Independent Phase
    -      852839 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852848 - nothing
    -      852849 - Preserve Formants
    -      852850 - Mid/Side
    -      852851 - Preserve Formants (Mid Side)
    -      852852 - Independent Phase
    -      852853 - Preserve Formants, Independent Phase
    -      852854 - Mid/Side, Independent Phase
    -      852855 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Fast, Window: Long
    -      852864 - nothing
    -      852865 - Preserve Formants
    -      852866 - Mid/Side
    -      852867 - Preserve Formants (Mid Side)
    -      852868 - Independent Phase
    -      852869 - Preserve Formants, Independent Phase
    -      852870 - Mid/Side, Independent Phase
    -      852871 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852880 - nothing
    -      852881 - Preserve Formants
    -      852882 - Mid/Side
    -      852883 - Preserve Formants (Mid Side)
    -      852884 - Independent Phase
    -      852885 - Preserve Formants, Independent Phase
    -      852886 - Mid/Side, Independent Phase
    -      852887 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852896 - nothing
    -      852897 - Preserve Formants
    -      852898 - Mid/Side
    -      852899 - Preserve Formants (Mid Side)
    -      852900 - Independent Phase
    -      852901 - Preserve Formants, Independent Phase
    -      852902 - Mid/Side, Independent Phase
    -      852903 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Fast, Window: Long
    -      852912 - nothing
    -      852913 - Preserve Formants
    -      852914 - Mid/Side
    -      852915 - Preserve Formants (Mid Side)
    -      852916 - Independent Phase
    -      852917 - Preserve Formants, Independent Phase
    -      852918 - Mid/Side, Independent Phase
    -      852919 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852928 - nothing
    -      852929 - Preserve Formants
    -      852930 - Mid/Side
    -      852931 - Preserve Formants (Mid Side)
    -      852932 - Independent Phase
    -      852933 - Preserve Formants, Independent Phase
    -      852934 - Mid/Side, Independent Phase
    -      852935 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852944 - nothing
    -      852945 - Preserve Formants
    -      852946 - Mid/Side
    -      852947 - Preserve Formants (Mid Side)
    -      852948 - Independent Phase
    -      852949 - Preserve Formants, Independent Phase
    -      852950 - Mid/Side, Independent Phase
    -      852951 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Fast, Window: Long
    -      852960 - nothing
    -      852961 - Preserve Formants
    -      852962 - Mid/Side
    -      852963 - Preserve Formants (Mid Side)
    -      852964 - Independent Phase
    -      852965 - Preserve Formants, Independent Phase
    -      852966 - Mid/Side, Independent Phase
    -      852967 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852976 - nothing
    -      852977 - Preserve Formants
    -      852978 - Mid/Side
    -      852979 - Preserve Formants (Mid Side)
    -      852980 - Independent Phase
    -      852981 - Preserve Formants, Independent Phase
    -      852982 - Mid/Side, Independent Phase
    -      852983 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      852992 - nothing
    -      852993 - Preserve Formants
    -      852994 - Mid/Side
    -      852995 - Preserve Formants (Mid Side)
    -      852996 - Independent Phase
    -      852997 - Preserve Formants, Independent Phase
    -      852998 - Mid/Side, Independent Phase
    -      852999 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: HighQ, Window: Long
    -      853008 - nothing
    -      853009 - Preserve Formants
    -      853010 - Mid/Side
    -      853011 - Preserve Formants (Mid Side)
    -      853012 - Independent Phase
    -      853013 - Preserve Formants, Independent Phase
    -      853014 - Mid/Side, Independent Phase
    -      853015 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853024 - nothing
    -      853025 - Preserve Formants
    -      853026 - Mid/Side
    -      853027 - Preserve Formants (Mid Side)
    -      853028 - Independent Phase
    -      853029 - Preserve Formants, Independent Phase
    -      853030 - Mid/Side, Independent Phase
    -      853031 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853040 - nothing
    -      853041 - Preserve Formants
    -      853042 - Mid/Side
    -      853043 - Preserve Formants (Mid Side)
    -      853044 - Independent Phase
    -      853045 - Preserve Formants, Independent Phase
    -      853046 - Mid/Side, Independent Phase
    -      853047 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: HighQ, Window: Long
    -      853056 - nothing
    -      853057 - Preserve Formants
    -      853058 - Mid/Side
    -      853059 - Preserve Formants (Mid Side)
    -      853060 - Independent Phase
    -      853061 - Preserve Formants, Independent Phase
    -      853062 - Mid/Side, Independent Phase
    -      853063 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853072 - nothing
    -      853073 - Preserve Formants
    -      853074 - Mid/Side
    -      853075 - Preserve Formants (Mid Side)
    -      853076 - Independent Phase
    -      853077 - Preserve Formants, Independent Phase
    -      853078 - Mid/Side, Independent Phase
    -      853079 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853088 - nothing
    -      853089 - Preserve Formants
    -      853090 - Mid/Side
    -      853091 - Preserve Formants (Mid Side)
    -      853092 - Independent Phase
    -      853093 - Preserve Formants, Independent Phase
    -      853094 - Mid/Side, Independent Phase
    -      853095 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: HighQ, Window: Long
    -      853104 - nothing
    -      853105 - Preserve Formants
    -      853106 - Mid/Side
    -      853107 - Preserve Formants (Mid Side)
    -      853108 - Independent Phase
    -      853109 - Preserve Formants, Independent Phase
    -      853110 - Mid/Side, Independent Phase
    -      853111 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853120 - nothing
    -      853121 - Preserve Formants
    -      853122 - Mid/Side
    -      853123 - Preserve Formants (Mid Side)
    -      853124 - Independent Phase
    -      853125 - Preserve Formants, Independent Phase
    -      853126 - Mid/Side, Independent Phase
    -      853127 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853136 - nothing
    -      853137 - Preserve Formants
    -      853138 - Mid/Side
    -      853139 - Preserve Formants (Mid Side)
    -      853140 - Independent Phase
    -      853141 - Preserve Formants, Independent Phase
    -      853142 - Mid/Side, Independent Phase
    -      853143 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Compound, Pitch Mode: Consistent, Window: Long
    -      853152 - nothing
    -      853153 - Preserve Formants
    -      853154 - Mid/Side
    -      853155 - Preserve Formants (Mid Side)
    -      853156 - Independent Phase
    -      853157 - Preserve Formants, Independent Phase
    -      853158 - Mid/Side, Independent Phase
    -      853159 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853168 - nothing
    -      853169 - Preserve Formants
    -      853170 - Mid/Side
    -      853171 - Preserve Formants (Mid Side)
    -      853172 - Independent Phase
    -      853173 - Preserve Formants, Independent Phase
    -      853174 - Mid/Side, Independent Phase
    -      853175 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853184 - nothing
    -      853185 - Preserve Formants
    -      853186 - Mid/Side
    -      853187 - Preserve Formants (Mid Side)
    -      853188 - Independent Phase
    -      853189 - Preserve Formants, Independent Phase
    -      853190 - Mid/Side, Independent Phase
    -      853191 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Percussive, Pitch Mode: Consistent, Window: Long
    -      853200 - nothing
    -      853201 - Preserve Formants
    -      853202 - Mid/Side
    -      853203 - Preserve Formants (Mid Side)
    -      853204 - Independent Phase
    -      853205 - Preserve Formants, Independent Phase
    -      853206 - Mid/Side, Independent Phase
    -      853207 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Crisp, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853216 - nothing
    -      853217 - Preserve Formants
    -      853218 - Mid/Side
    -      853219 - Preserve Formants (Mid Side)
    -      853220 - Independent Phase
    -      853221 - Preserve Formants, Independent Phase
    -      853222 - Mid/Side, Independent Phase
    -      853223 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Mixed, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853232 - nothing
    -      853233 - Preserve Formants
    -      853234 - Mid/Side
    -      853235 - Preserve Formants (Mid Side)
    -      853236 - Independent Phase
    -      853237 - Preserve Formants, Independent Phase
    -      853238 - Mid/Side, Independent Phase
    -      853239 - Preserve Formants, Mid/Side, Independent Phase
    -      
    -      Rubber Band Library - Transients: Smooth, Detector: Soft, Pitch Mode: Consistent, Window: Long
    -      853248 - nothing
    -      853249 - Preserve Formants
    -      853250 - Mid/Side
    -      853251 - Preserve Formants (Mid Side)
    -      853252 - Independent Phase
    -      853253 - Preserve Formants, Independent Phase
    -      853254 - Mid/Side, Independent Phase
    -      853255 - Preserve Formants, Mid/Side, Independent Phase
    integer optimize_tonal_content - 2, checkbox for optimize-tonal-content is set on; 0, checkbox for optimize-tonal-content is set off
    number stretch_marker_fadesize - in milliseconds; negative values are allowed
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, playrate, pitch</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemPlayRate","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemPlayRate","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("PLAYRATE( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A1,A2,A3,A4,A5,A6=ultraschall.GetItemPlayRate(reaper.GetMediaItem(0,0))

function ultraschall.GetItemChanMode(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemChanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer channelmode = ultraschall.GetItemChanMode(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the channelmode-entry of a MediaItem or MediaItemStateChunk.
    It's the CHANMODE-entry
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose channelmode-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer channelmode - channelmode
    - 0 - normal
    - 1 - reverse stereo
    - 2 - Mono (Mix L+R)
    - 3 - Mono Left
    - 4 - Mono Right
    - 5 - Mono 3
    - ...
    - 66 - Mono 64
    - 67 - Stereo 1/2
    - ...
    - 129 - Stereo 63/64
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, channel, mode</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemChanMode","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemChanMode","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("CHANMODE( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,2,3",false)
--A1,A2,A3,A4,A5=ultraschall.GetItemChanMode(reaper.GetMediaItem(0,0))

function ultraschall.GetItemGUID(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemGUID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string GUID = ultraschall.GetItemGUID(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the GUID-entry of a MediaItem or MediaItemStateChunk.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose GUID-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string GUID - the GUID of the item
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, guid</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemGUID","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemGUID","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  return statechunk:match("%cGUID (.-)%c")
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,3",false)
--AL,AL2,AL3,AL4,AL5,AL6=ultraschall.GetItemGUID(reaper.GetMediaItem(0,0))

function ultraschall.GetItemRecPass(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemRecPass</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer recpass_state = ultraschall.GetItemRecPass(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the recpass-entry of a MediaItem or MediaItemStateChunk.
    It's the counter of the recorded item-takes within a project, ordered by the order of recording. Only displayed with recorded item-takes, not imported ones.
    
    It's the RECPASS-entry.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose recpass-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer recpass_state - the number of recorded mediaitem; every recorded item gets it's counting-number.
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, recpass</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemRecPass","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemRecPass","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return
  end
  -- get value and return it
  statechunk=statechunk:match("RECPASS( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A=ultraschall.GetItemRecPass(reaper.GetMediaItem(0,0))

function ultraschall.GetItemBeat(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemBeat</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer beatstate = ultraschall.GetItemBeat(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the beatstate/timebase-entry of a MediaItem or MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose beatstate/timebase-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer beatstate - the item-timebase state
    - nil - Track/project default timebase
    - 0 - Time
    - 1 - Beats (posiiton, length, rate)
    - 2 - Beats (position only)
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, beat, timebase</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemBeat","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemBeat","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return -1
  end
  -- get value and return it
  statechunk=statechunk:match("BEAT( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--C,CC,CCC=ultraschall.GetAllMediaItemsBetween(1,60,"1,3",false)
--AL,AL2,AL3,AL4,AL5,AL6=ultraschall.GetItemBeat(reaper.GetMediaItem(0,0))

function ultraschall.GetItemMixFlag(MediaItem, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemMixFlag</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer itemmix_state = ultraschall.GetItemMixFlag(MediaItem MediaItem, optional string MediaItemStateChunk)</functioncall>
  <description>
    Returns the item-mix-behavior-entry of a MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose item-mix-behavior-state you want to know; nil, use parameter MediaItemStatechunk instead
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer itemmix_state - the item-mix-behavior
    - nil - Project Default item mix behavior
    - 0 - Enclosed items replace enclosing items
    - 1 - Items always mix
    - 2 - Items always replace earlier items
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, itemmix behavior</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if MediaItem~=nil then
    if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then retval, statechunk=reaper.GetItemStateChunk(MediaItem,"",false) 
    else ultraschall.AddErrorMessage("GetItemMixFlag","MediaItem", "must be a MediaItem.", -2) return end
  elseif MediaItem==nil and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemMixFlag","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return -1
  end
  -- get value and return it
  statechunk=statechunk:match("MIXFLAG( .-)%c")
  if statechunk==nil then return nil end
  statechunk=statechunk.." "
  local O=statechunk
    
  return tonumber(statechunk:match(" (.-) ")), 
         tonumber(statechunk:match(" .- (.-) ")),
         tonumber(statechunk:match(" .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- (.-) ")),
         tonumber(statechunk:match(" .- .- .- .- .- .- .- (.-) "))
end

--A=ultraschall.GetItemMixFlag(reaper.GetMediaItem(0,0))

function ultraschall.GetItemUSTrackNumber_StateChunk(statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemUSTrackNumber_StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer tracknumber, MediaTrack track = ultraschall.GetItemUSTrackNumber_StateChunk(string MediaItemStateChunk)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns the tracknumber as well as the mediatrack-object from where the mediaitem was from, as given by a MediaItemStateChunk.
    This works only, if the StateChunk contains the entry "ULTRASCHALL_TRACKNUMBER", which holds the original tracknumber of the MediaItem.

    This entry will only be added by functions from the Ultraschall-API, like [GetAllMediaItemsBetween](#GetAllMediaItemsBetween)
    Returns -1 in case of error.
  </description>
  <parameters>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    integer tracknumber - the tracknumber, where this item came from; starts with 1 for the first track!
    MediaTrack track - the accompanying track as MediaTrack-object
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, track, tracknumber</tags>
</US_DocBloc>
]]
  -- check parameters and prepare statechunk-variable
  local retval
  if ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("GetItemUSTrackNumber_StateChunk","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return -1 end
  -- get value and return it
  tracknumber=statechunk:match("ULTRASCHALL_TRACKNUMBER (.-)%c")
  if tracknumber==nil then ultraschall.AddErrorMessage("GetItemUSTrackNumber_StateChunk","MediaItemStateChunk", "no ULTRASCHALL_TRACKNUMBER-entry found in the statechunk.", -2) return -1 end
  
  return tonumber(statechunk:match("ULTRASCHALL_TRACKNUMBER (.-)%c")), reaper.GetTrack(0,tonumber(statechunk:match("ULTRASCHALL_TRACKNUMBER (.-)%c"))-1)
end


function ultraschall.SetItemUSTrackNumber_StateChunk(statechunk, tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemUSTrackNumber_StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MediaItemStateChunk = ultraschall.SetItemUSTrackNumber_StateChunk(string MediaItemStateChunk, integer tracknumber)</functioncall>
  <description>
    Adds/Replaces the entry "ULTRASCHALL_TRACKNUMBER" in a MediaItemStateChunk, that tells other Ultraschall-Apifunctions, from which track this item originated from.
    It returns the modified MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
    integer tracknumber - the tracknumber you want to set, with 1 for track 1, 2 for track 2
  </parameters>
  <retvals>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Set MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, track, tracknumber</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("SetItemUSTrackNumber_StateChunk","MediaItemStateChunk", "must be a valid MediaItemStateChunk.", -1) return -1 end
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetItemUSTrackNumber_StateChunk","tracknumber", "must be an integer.", -2) end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetItemUSTrackNumber_StateChunk","tracknumber", "no such track.", -3) return -1 end
  if statechunk:match("ULTRASCHALL_TRACKNUMBER") then 
    statechunk="<ITEM\n"..statechunk:match(".-ULTRASCHALL_TRACKNUMBER.-%c(.*)")
  end
  
  statechunk="<ITEM\nULTRASCHALL_TRACKNUMBER "..tracknumber.."\n"..statechunk:match("<ITEM(.*)")
  return statechunk
end

function ultraschall.SetItemPosition(MediaItem, position, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MediaItemStateChunk = ultraschall.SetItemPosition(MediaItem MediaItem, integer position, optional string MediaItemStateChunk)</functioncall>
  <description>
    Sets position in a MediaItem or MediaItemStateChunk in seconds.
    It returns the modified MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose state you want to change; nil, use parameter MediaItemStateChunk instead
    integer position - position in seconds
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Set MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, position</tags>
</US_DocBloc>
]]
  -- check parameters
  local _tudelu
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then _tudelu, statechunk=reaper.GetItemStateChunk(MediaItem, "", false) 
  elseif ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("SetItemPosition", "statechunk", "Must be a valid statechunk.", -1) return nil
  end
  if type(position)~="number" then ultraschall.AddErrorMessage("SetItemPosition", "position", "Must be a number.", -2) return nil end  
  if position<0 then ultraschall.AddErrorMessage("SetItemPosition", "position", "Must bigger than or equal 0.", -3) return -1 end
  
  -- do the magic
  statechunk=statechunk:match("(<ITEM.-)POSITION").."POSITION "..position.."\n"..statechunk:match("POSITION.-%c(.*)")
  
  -- set statechunk, if MediaItem is provided, otherwise don't set it
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then reaper.SetItemStateChunk(MediaItem, statechunk, false) end
  
  -- return
  return statechunk
end

--_1, sc=reaper.GetItemStateChunk(reaper.GetMediaItem(0,0), "", false)
--L=ultraschall.SetItemPosition(nil, 10, sc)
--reaper.MB(tostring(L),"",0)
--reaper.SetItemStateChunk(reaper.GetMediaItem(0,0), L, false)


function ultraschall.SetItemLength(MediaItem, length, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MediaItemStateChunk = ultraschall.SetItemLength(MediaItem MediaItem, integer length, string MediaItemStateChunk)</functioncall>
  <description>
    Sets length in a MediaItem and MediaItemStateChunk in seconds.
    It returns the modified MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose state you want to change; nil, use parameter MediaItemStateChunk instead
    integer length - length in seconds
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Set MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, length</tags>
</US_DocBloc>
]]
  -- check parameters
  local _tudelu
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then _tudelu, statechunk=reaper.GetItemStateChunk(MediaItem, "", false) 
  elseif ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("SetItemLength", "statechunk", "Must be a valid statechunk.", -1) return nil
  end
--  reaper.MB(type(length),length,0)
  if type(length)~="number" then ultraschall.AddErrorMessage("SetItemLength", "length", "Must be a number.", -2) return nil end  
  if length<0 then ultraschall.AddErrorMessage("SetItemLength", "length", "Must bigger than or equal 0.", -3) return -1 end
  
  -- do the magic
  statechunk=statechunk:match("(<ITEM.-)LENGTH").."LENGTH "..length.."\n"..statechunk:match("LENGTH.-%c(.*)")
  
  -- set statechunk, if MediaItem is provided, otherwise don't set it
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==true then reaper.SetItemStateChunk(MediaItem, statechunk, false) end
  
  -- return
  return statechunk
end

-- MESPOTINE
--_1, sc=reaper.GetItemStateChunk(reaper.GetMediaItem(0,0), "", false)
--reaper.MB(sc,"",0)
--L=ultraschall.SetItemLength(nil, 99, sc)
--reaper.MB(L,"",0)
--O=reaper.SetItemStateChunk(reaper.GetMediaItem(0,0), L, false)

--reaper.MB(tostring(L),"",0)

function ultraschall.InsertMediaItemStateChunkArray(position, MediaItemStateChunkArray, trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertMediaItemStateChunkArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemArray = ultraschall.InsertMediaItemStateChunkArray(number position, array MediaItemStateChunkArray, string trackstring)</functioncall>
  <description>
    Inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring.
    Note:Needs ULTRASCHALL_TRACKNUMBER within the statechunks, which includes the tracknumber for each mediaitem to be included. Else it will return -1. That entry will be included automatically into the MediaItemStateChunkArray as provided by <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a>. If you need to manually insert that entry into a statechunk, use <a href="#SetItemUSTRackNumber_StateChunk">SetItemUSTRackNumber_StateChunk</a>.
    
    Returns the number of newly created items, as well as an array with the newly create MediaItems.
    Returns -1 in case of failure.
    
    Note: this inserts the items only in the tracks, where the original items came from(or the tracks set with the entry ULTRASCHALL_TRACKNUMBER). Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.
    If you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    array MediaItemStateChunkArray - an array with the statechunks of the MediaItems to be inserted
    string trackstring - the numbers of the tracks, separated by a ,
  </parameters>
  <retvals>
    integer number_of_items - the number of MediaItems created
    array MediaItemArray - an array with the newly created MediaItems
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert, statechunk</tags>
</US_DocBloc>
]]    
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertMediaItemStateChunkArray", "position", "Must be a number.", -1) return -1 end
  if ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)==false then ultraschall.AddErrorMessage("InsertMediaItemStateChunkArray", "MediaItemStateChunkArray", "Must be a valid MediaItemStateChunkArray.", -2) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("InsertMediaItemStateChunkArray", "trackstring", "Must be a valid trackstring.", -3) return -1 end

  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring==""  then return -1 end
  local count=1
  local i,LL
  local NewMediaItemArray={}
  local LL
  local _count, individual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring) 
  local ItemStart=reaper.GetProjectLength()+1
  while MediaItemStateChunkArray[count]~=nil do
    local ItemStart_temp=ultraschall.GetItemPosition(nil,MediaItemStateChunkArray[count])
    if ItemStart>ItemStart_temp then ItemStart=ItemStart_temp end
    count=count+1
  end
  count=1
  while MediaItemStateChunkArray[count]~=nil do
    local ItemStart_temp=ultraschall.GetItemPosition(nil,MediaItemStateChunkArray[count])
    local tempo,MediaTrack=ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunkArray[count])
    if tempo==nil then return -1 end
    i=1
    while individual_values[i]~=nil do
      local tempo,tempoMediaTrack=ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunkArray[count])
      if tempoMediaTrack==nil then return -1 end
      if reaper.GetTrack(0,individual_values[i]-1)==tempoMediaTrack then
        LL, NewMediaItemArray[count]=ultraschall.InsertMediaItem_MediaItemStateChunk(position+(ItemStart_temp-ItemStart), MediaItemStateChunkArray[count], MediaTrack)
      end
      i=i+1
    end
    count=count+1
  end  

  return count, NewMediaItemArray
end

--ultraschall.InsertMediaItemStateChunkArray(1,,3)

function ultraschall.OnlyMediaItemsOfTracksInTrackstring_StateChunk(MediaItemStateChunkArray, trackstring)
--Throws out all items, that are not in the tracks, as given by trackstring
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyMediaItemsOfTracksInTrackstring_StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, array MediaItemStateChunkArray = ultraschall.OnlyMediaItemsOfTracksInTrackstring_StateChunk(array MediaItemStateChunkArray, string trackstring)</functioncall>
  <description>
    Throws all MediaItems out of the MediaItemStateChunkArray, that are not within the tracks, as given with trackstring.
    Returns the "cleared" MediaItemArray; returns -1 in case of error
  </description>
  <parameters>
    array MediaItemStateChunkArray - an array with MediaItems; no nil-entries allowed, will be seen as the end of the array
    string trackstring - the tracknumbers, separated by a comma
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    array MediaItemStateChunkarray - the "cleared" array, that contains only the statechunks of MediaItems in tracks, as given by trackstring, -1 in case of error
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selection, statechunk</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)==false then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring_StateChunk", "MediaItemStateChunkArray", "Must be a valid MediaItemStateChunkArray.", -1) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring_StateChunk", "trackstring", "Must be a valid trackstring.", -2) return -1 end

  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("OnlyMediaItemsOfTracksInTrackstring_StateChunk", "trackstring", "Must be a valid trackstring.", -3) return -1 end
  
  local count=1
  local count2=1
  local i=1
  local _count, trackstring_array= ultraschall.CSV2IndividualLinesAsArray(trackstring)
  local MediaItemArray2={}
  
  while MediaItemStateChunkArray[count]~=nil do
    if MediaItemStateChunkArray[count]==nil then break end
    i=1
    while trackstring_array[i]~=nil do
      if tonumber(trackstring_array[i])==nil then return -1 end
        local Atracknumber, Atrack = ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunkArray[count])
        if reaper.GetTrack(0,trackstring_array[i]-1)==Atrack then
          MediaItemArray2[count2]=MediaItemStateChunkArray[count]
          count2=count2+1
        end
        i=i+1
    end
    count=count+1
  end
  return 1, MediaItemArray2
end


function ultraschall.RippleInsert_MediaItemStateChunks(position, MediaItemStateChunkArray, trackstring, moveenvelopepoints, movemarkers)
--splits the items at position and inserts MediaItemArray at that position, and moves 
--all following toward the end, accordingly.
--position - the position of the earliest item in the MediaItemArray. All others will be relative to the earliest Item
--MediaItemArray - the MediaItems to be inserted
--trackstring - only the tracks in trackstring will be affected by insert and ripple, all others stay the way they are

--!!! NOCH TESTEN!!!!

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RippleInsert_MediaItemStateChunks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_items, array MediaItemStateChunkArray, number endpos_inserted_items = ultraschall.RippleInsert_MediaItemStateChunks(number position, array MediaItemStateChunkArray, string trackstring, boolean moveenvelopepoints, boolean movemarkers)</functioncall>
  <description>
    It inserts the MediaItems from MediaItemStateChunkArray at position into the tracks, as given by trackstring. It moves the items, that were there before, accordingly toward the end of the project.
    
    Returns the number of newly created items, as well as an array with the newly created MediaItems as statechunks and the endposition of the last(projectposition) inserted item into the project.
    Returns -1 in case of failure.
    
    Note: this inserts the items only in the tracks, where the original items came from. Items from track 1 will be included into track 1. Trackstring only helps to include or exclude the items from inclusion into certain tracks.
    If you have a MediaItemStateChunkArray with items from track 1,2,3,4,5 and you give trackstring only the tracknumber for track 3 and 4 -> 3,4, then only the items, that were in tracks 3 and 4 originally, will be included, all the others will be ignored.
  </description>
  <parameters>
    number position - the position of the newly created mediaitem
    array MediaItemStateChunkArray - an array with the statechunks of MediaItems to be inserted
    string trackstring - the numbers of the tracks, separated by a ,
    boolean moveenvelopepoints - true, move the envelopepoints as well; false, keep the envelopepoints where they are
    boolean movemarkers - true, move markers as well; false, keep markers where they are
  </parameters>
  <retvals>
    integer number_of_items - the number of newly created items
    array MediaItemStateChunkArray - an array with the newly created MediaItems as StateChunkArray
    number endpos_inserted_items - the endposition of the last newly inserted MediaItem
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, insert, ripple</tags>
</US_DocBloc>
]]

  if type(position)~="number" then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "position", "must be a number", -1) return -1 end
  if ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)==false then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "MediaItemStateChunkArray", "must be a valid MediaItemStateChunkArray", -2) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "trackstring", "must be a valid trackstring", -3) return -1 end
  if type(moveenvelopepoints)~="boolean" then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "moveenvelopepoints", "must be a boolean", -4) return -1 end    
  if type(movemarkers)~="boolean" then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "movemarkers", "must be a boolean", -5) return -1 end
      
  local L,trackstring,AA,AAA=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if trackstring==-1 or trackstring=="" then ultraschall.AddErrorMessage("RippleInsert_MediaItemStateChunks", "trackstring", "must be a valid trackstring", -6) return -1 end

  local NumberOfItems
  local NewMediaItemArray={}
  local count=1
  local ItemStart=reaper.GetProjectLength()+1
  local ItemEnd=0
  local i
  local _count, individual_values = ultraschall.CSV2IndividualLinesAsArray(trackstring)
  while MediaItemStateChunkArray[count]~=nil do
    local ItemStart_temp=ultraschall.GetItemPosition(nil,MediaItemStateChunkArray[count]) --reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_POSITION") --Buggy
    local ItemEnd_temp=ultraschall.GetItemLength(nil, MediaItemStateChunkArray[count]) --reaper.GetMediaItemInfo_Value(MediaItemArray[count], "D_LENGTH") --Buggy
    i=1
    while individual_values[i]~=nil do
      local Atracknumber, Atrack = ultraschall.GetItemUSTrackNumber_StateChunk(MediaItemStateChunkArray[count])
      if reaper.GetTrack(0,individual_values[i]-1)==Atrack then
        if ItemStart>ItemStart_temp then ItemStart=ItemStart_temp end
        if ItemEnd<ItemEnd_temp+ItemStart_temp then ItemEnd=ItemEnd_temp+ItemStart_temp end
      end
      i=i+1
    end
    count=count+1
  end

  
  --Create copy of the track-state-chunks
  local nums, MediaItemArray_Chunk=ultraschall.GetMediaItemStateChunksFromItems(MediaItemArray)
    
  local A,A2=ultraschall.SplitMediaItems_Position(position,trackstring,false)

  if moveenvelopepoints==true then
    local CountTracks=reaper.CountTracks()
    for i=0, CountTracks-1 do
      for a=1,AAA do
        if tonumber(AA[a])==i+1 then
          local MediaTrack=reaper.GetTrack(0,i)
          retval = ultraschall.MoveTrackEnvelopePointsBy(position, reaper.GetProjectLength()+(ItemEnd-ItemStart), ItemEnd-ItemStart, MediaTrack, true) 
        end
      end
    end
  end
  
  if movemarkers==true then
    ultraschall.MoveMarkersBy(position, reaper.GetProjectLength()+(ItemEnd-ItemStart), ItemEnd-ItemStart, true)
  end
  ultraschall.MoveMediaItemsAfter_By(position-0.000001, ItemEnd-ItemStart, trackstring)

  local L,MediaItemArray=ultraschall.OnlyMediaItemsOfTracksInTrackstring_StateChunk(MediaItemStateChunkArray, trackstring) --BUGGY?
  count=1
  while MediaItemStateChunkArray[count]~=nil do
    local Anumber=ultraschall.GetItemPosition(nil, MediaItemStateChunkArray[count])
    count=count+1
  end
    local NumberOfItems, NewMediaItemArray=ultraschall.InsertMediaItemStateChunkArray(position, MediaItemStateChunkArray, trackstring)
  count=1
  
  while MediaItemStateChunkArray[count]~=nil do
    local length=MediaItemStateChunkArray[count]:match("LENGTH (.-)%c")
--    reaper.MB(length,"",0)
    NewMediaItemArray[count]=ultraschall.SetItemLength(NewMediaItemArray[count], tonumber(length))
    count=count+1
  end
  return NumberOfItems, NewMediaItemArray, position+ItemEnd
end

--A,B,C,D,E=ultraschall.GetAllMediaItemsBetween(1,20,"1,2,3",false)
--ultraschall.RippleInsert_MediaItemStateChunks(l,C,"1,2,3",true, true)

function ultraschall.IsTrackObjectTracknumber(MediaTrack, tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsTrackObjectTracknumber</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer tracknumber = ultraschall.IsTrackObjectTracknumber(MediaTrack track, integer tracknumber)</functioncall>
  <description>
    returns true, if MediaTrack has the tracknumber "tracknumber"; false if not.
    Returns nil in case of error.
  </description>
  <parameters>
    MediaTrack track - the MediaTrack of which you want to check it's number
    integer tracknumber - the tracknumber you want to check for
  </parameters>
  <retvals>
    boolean retval - true if track is tracknumber, false if not
    integer tracknumber - the number of track, so in case of false, you know it's number
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, check, tracknumber, mediatrack, object</tags>
</US_DocBloc>
]]
--returns true, if MediaTrack=tracknumber, false if not; as well as the tracknumber of MediaTrack
--returns nil in case of error
    tracknumber=tonumber(tracknumber)
    if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("IsTrackObjectTracknumber","tracknumber", "must be an integer", -1) return nil end

    if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("IsTrackObjectTracknumber","tracknumber", "no such track", -2) return nil end
    if reaper.ValidatePtr(MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("IsTrackObjectTracknumber","track", "no valid MediaTrack-object", -3) return nil end
    local number=reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER")
    if number==tracknumber then return true, number
    else return false, number
    end
end

--A=ultraschall.IsTrackObjectTracknumber(reaper.GetTrack(0,0),1)

function ultraschall.InverseTrackstring(trackstring, limit)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InverseTrackstring</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string inv_trackstring = ultraschall.InverseTrackstring(string trackstring, integer limit)</functioncall>
  <description>
    returns a newtrackstring with numbers, that are NOT in trackstring, in the range between 0 and limit
    returns -1 in case of error
  </description>
  <parameters>
    string trackstring - the tracknumbers, separated with a ,
    integer limit - the maximum tracknumber to include. Use reaper.CountTracks(0) function to use the maximum tracks in current project
  </parameters>
  <retvals>
    string inv_trackstring - the tracknumbers, that are NOT in the parameter trackstring, from 0 to limit
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, inverse, tracknumber, tracknumbers, limit</tags>
</US_DocBloc>
]]
--returns a newtrackstring with numbers, that are NOT in trackstring, from 0 to limit
  local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(trackstring) 
  if math.type(limit)~="integer" then ultraschall.AddErrorMessage("InverseTrackstring","limit", "must be an integer", -1) return -1 end
  limit=tonumber(limit)
  local newtrackstring=""
  local dingo
  if retval==-1 then ultraschall.AddErrorMessage("InverseTrackstring","trackstring", "not a valid trackstring", -2) return -1 end
  for i=1,limit do
    dingo=true
    for a=0,number_of_entries do
      if trackstringarray[a]==i then dingo=false break end
    end
    if dingo==true then newtrackstring=newtrackstring..i.."," end
  end
  return newtrackstring:sub(1,-2)
end


function ultraschall.SetTracksToLocked(trackstring, reset)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTracksToLocked</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTracksToLocked(string trackstring, boolean reset)</functioncall>
  <description>
    sets tracks in trackstring locked. 
    returns false in case or error, true in case of success
  </description>
  <parameters>
    string trackstring - the tracknumbers, separated with a ,
    boolean reset - reset lockedstate of other tracks
    -true - resets the locked-state of all tracks not included in trackstring
    -false - the lockedstate of tracks not in trackstring is retained
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
  </retvals>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, lock, lockstate, lockedstate, locked, set</tags>
</US_DocBloc>
]]
  local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if retval==-1 then ultraschall.AddErrorMessage("SetTracksToLocked","trackstring", "must be a valid trackstring", -1) return false end
  if type(reset)~="boolean" then ultraschall.AddErrorMessage("SetTracksToLocked","trackstring", "must be a boolean", -2) return false end
  for i=1,number_of_entries do
    local Aretval = ultraschall.SetTrackLockState(trackstringarray[i], 1)
  end
  if reset==true then 
    local newtrackstring=ultraschall.InverseTrackstring(trackstring,reaper.CountTracks(0))
    local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(newtrackstring)
    for i=1,number_of_entries do
      local Aretval = ultraschall.SetTrackLockState(trackstringarray[i], 0)
    end
  end
  return true
end

--ultraschall.SetTracksToLocked("1,2,3,4", true)

function ultraschall.SetTracksToUnlocked(trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTracksToUnlocked</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTracksToUnlocked(string trackstring)</functioncall>
  <description>
    sets tracks in trackstring unlocked. 
    returns false in case or error, true in case of success
  </description>
  <parameters>
    string trackstring - the tracknumbers, separated with a ,
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
  </retvals>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, lock, lockstate, lockedstate, locked, set, unlock, unlocked</tags>
</US_DocBloc>
]]
--sets tracks in trackstring unlocked.
--returns false in case or error, true in case of success
  local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if retval==-1 then ultraschall.AddErrorMessage("SetTracksToUnlocked","trackstring", "must be a valid trackstring", -1) return false end
  for i=1,number_of_entries do
    local Aretval = ultraschall.SetTrackLockState(trackstringarray[i], 0)
  end
  return true
end


function ultraschall.GetAllLockedTracks()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllLockedTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string locked_trackstring, string unlocked_trackstring = ultraschall.GetAllLockedTracks()</functioncall>
  <description>
    returns a trackstring with all tracknumbers of tracks, that are locked, as well as one with all tracknumbers of tracks, that are unlocked.
    returns an empty locked_trackstring, if none is locked, returns an empty unlocked_trackstring if all are locked.
  </description>
  <retvals>
    string locked_trackstring - the tracknumbers of all tracks, that are locked; empty string if none is locked
    string unlocked_trackstring - the tracknumbers of all tracks, that are NOT locked; empty string if all are locked
  </retvals>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, lock, lockstate, lockedstate, locked, get</tags>
</US_DocBloc>
]]
--returns a trackstring with all locked tracks; empty string if none is locked
  local trackstring=""
  for i=1, reaper.CountTracks() do
    local lockedstate = ultraschall.GetTrackLockState(i)
    if lockedstate==1 then trackstring=trackstring..i.."," end
  end
  return trackstring:sub(1,-2), ultraschall.InverseTrackstring(trackstring, reaper.CountTracks(0))
end


function ultraschall.GetAllSelectedTracks()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllSelectedTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string selected_trackstring, string unselected_trackstring = ultraschall.GetAllSelectedTracks()</functioncall>
  <description>
    returns a trackstring with all tracknumbers of tracks, that are selected, as well as one with all tracknumbers of tracks, that are unselected.
    returns an empty selected_trackstring, if none is selected, returns an empty unselected_trackstring if all are selected.
  </description>
  <retvals>
    string selected_trackstring - the tracknumbers of all tracks, that are selected; empty string if none is selected
    string unselected_trackstring - the tracknumbers of all tracks, that are NOT selected; empty string if all are selected
  </retvals>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstring, selection, unselect, select, get</tags>
</US_DocBloc>
]]

--returns a trackstring with all selected tracks, as well as a trackstring with unselected tracks

  local trackstring=""
  for i=1, reaper.CountTracks() do
    MediaTrack=reaper.GetTrack(0,i-1)
    local selected = reaper.IsTrackSelected(MediaTrack)
    if selected==true then trackstring=trackstring..i.."," end
  end
  return trackstring:sub(1,-2), ultraschall.InverseTrackstring(trackstring, reaper.CountTracks(0))
end


--A,AA=ultraschall.GetAllSelectedTracks()

function ultraschall.GetMediaItemsFromClipboard()  
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemsFromClipboard</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemStateChunkArray = ultraschall.GetMediaItemsFromClipboard()</functioncall>
  <description>
    Returns the number of mediaitems and a MediaItemStateChunkArray of the mediaitems, as stored in the clipboard.
    
    It does it by pasting the items at the end of the project, getting them and deleting them again.
    
    Use sparsely and with care, as it uses a lot of resources!
  </description>
  <retvals>
    integer count - the number of items in the clipboard
    array MediaItemStatechunkArray - the mediaitem-statechunks of the items in the clipboard. One entry for each mediaitem-statechunk.
  </retvals>
  <chapter_context>
    Clipboard Functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>copy and paste, clipboard, mediaitems, statechunk, mediaitemstatechunk</tags>
</US_DocBloc>
]]
  local trackstring_old=ultraschall.GetAllSelectedTracks()
  local Aoldmarker=reaper.GetCursorPosition()
  local Astartpos=reaper.GetProjectLength()
  reaper.SetEditCurPos(Astartpos,false,false)
  reaper.Main_OnCommand(40058,0)
  local Aendpos=reaper.GetProjectLength()
  trackstring = ultraschall.CreateTrackString(1, reaper.CountTracks(), 1)
  local Acount, MediaItemArray, MediaItemStateChunkArray = ultraschall.GetAllMediaItemsBetween(Astartpos-.0000000001, Aendpos, trackstring, true)
  reaper.SetEditCurPos(Aoldmarker,true,false)
  local retval = ultraschall.DeleteMediaItemsFromArray(MediaItemArray)
  reaper.UpdateArrange()
  return Acount, MediaItemStateChunkArray
end


function ultraschall.GetAllMediaItemsFromTrack(tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItemsFromTrack</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer itemcount, array MediaItemArray, array MediaItemStateChunkArray = ultraschall.GetAllMediaItemsFromTrack(integer tracknumber)</functioncall>
  <description>
    returns the number of items of tracknumber, as well as an array with all MediaItems and an array with all MediaItemStateChunks
    returns -1 in case of error
  </description>
  <parameters>
    integer tracknumber - the tracknumber, from where you want to get the item
  </parameters>
  <retvals>
    integer itemcount - the number of items in that track
    array MediaItemArray - an array with all MediaItems from this track
    array MediaItemStateChunkArray - an array with all MediaItemStateCunks from this track
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, get, item, mediaitem, statechunk, state, chunk</tags>
</US_DocBloc>
]]
--  tracknumber=tonumber(tracknumber) 
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetAllMediaItemsFromTrack","tracknumber", "must be an integer", -1) return -1 end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetAllMediaItemsFromTrack","tracknumber", "no such track", -2) return -1 end
  
  local count=1
  local MediaTrack=reaper.GetTrack(0,tracknumber-1)
  local MediaItemArray={}
  local MediaItemArrayStateChunk={}
  local MediaItem=""
  local temp
  local retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "", true)
  str=str:match("<ITEM.*")

  while str:match(".-%cIGUID.-")~= nil do
    local GUID=str:match(".-%cIGUID ({.-})%c")
    MediaItemArray[count]=reaper.BR_GetMediaItemByGUID(0, GUID)
    temp, MediaItemArrayStateChunk[count]=reaper.GetItemStateChunk(MediaItemArray[count],"",true)
    str=str:match(".-%cIGUID.-%c(.*)")
    if count==idx then MediaItem=reaper.BR_GetMediaItemByGUID(0, GUID) end
      count=count+1
    end
  return count-1, MediaItemArray, MediaItemArrayStateChunk
end

--A,B,C=ultraschall.GetAllMediaItemsFromTrack("")

function ultraschall.SetItemsLockState(MediaItemArray, lockstate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemsLockState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetItemsLockState(array MediaItemArray, boolean lockstate)</functioncall>
  <description>
    Sets the lockstate of the items in MediaItemArray. Set lockstate=true to set the items locked; false to set them unlocked.
    
    returns true in case of success, false in case of error
  </description>
  <parameters>
    array MediaItemArray - an array with the MediaItems to be processed
    boolean lockstate - true, to set the MediaItems to locked, false to set them to unlocked
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, lock</tags>
</US_DocBloc>
]]

  if type(lockstate)~="boolean" then ultraschall.AddErrorMessage("SetItemsLockState", "lockstate", "Must be a boolean.", -1) return false end
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("SetItemsLockState", "MediaItemArray", "No valid MediaItemArray.", -2) return false end
  count=1
  while MediaItemArray[count]~=nil do
      if lockstate==true then reaper.SetMediaItemInfo_Value(MediaItemArray[count], "C_LOCK", 1)
      elseif lockstate==false then reaper.SetMediaItemInfo_Value(MediaItemArray[count], "C_LOCK", 0)
      end
      count=count+1
  end
  return true
end


function ultraschall.AddLockStateToMediaItemStateChunk(MediaItemStateChunk, lockstate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddLockStateToMediaItemStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string changedMediaItemStateChunk = ultraschall.AddLockStateToMediaItemStateChunk(string MediaItemStateChunk, boolean lockstate)</functioncall>
  <description>
    Sets the lockstate in a MediaItemStateChunk. Set lockstate=true to set the chunk locked; false to set it unlocked.
    
    Does not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or <a href="#ApplyStateChunkToItems">ApplyStateChunkToItems</a>!
    
    returns the changed MediaItemStateChunk; -1 in case of failure
  </description>
  <parameters>
    string MediaItemStateChunk - the statechunk of the item to be processed, as returned by functions like reaper.GetItemStateChunk
    boolean lockstate - true, to set the MediaItemStateChunk to locked, false to set it to unlocked
  </parameters>
  <retvals>
    string changedMediaItemStateChunk - the lockstate-modified MediaItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, statechunk, state, chunk, lock</tags>
</US_DocBloc>
]]
  if type(lockstate)~="boolean" then ultraschall.AddErrorMessage("AddLockStateToMediaItemStateChunk", "lockstate", "Must be a boolean.", -1) return -1 end
  if ultraschall.IsValidMediaItemStateChunk(MediaItemStateChunk)==false then ultraschall.AddErrorMessage("AddLockStateToMediaItemStateChunk", "MediaItemStateChunk", "Must be a valid MediaItemStateChunk.", -2) return -1 end
  local Begin=MediaItemStateChunk:match("<ITEM.-MUTE.-%c")
  local End=MediaItemStateChunk:match("<ITEM.-(%cSEL.*)")
  if lockstate==true then return Begin.."LOCK 1"..End
  elseif lockstate==false then return Begin..End end
end

function ultraschall.AddLockStateTo_MediaItemStateChunkArray(MediaItemStateChunkArray, lockstate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddLockStateTo_MediaItemStateChunkArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array changedMediaItemStateChunkArray = ultraschall.AddLockStateTo_MediaItemStateChunkArray(array MediaItemStateChunkArray, boolean lockstate)</functioncall>
  <description>
    Sets the lockstates in a MediaItemStateChunkArray. Set lockstate=true to set the chunks locked; false to set them unlocked.
    
    Does not apply the changes to the MediaItem itself. To do that, use reaper.GetItemStateChunk or <a href="#ApplyStateChunkToItems">ApplyStateChunkToItems</a>!
    
    returns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure
  </description>
  <parameters>
    array MediaItemStateChunkArray - the statechunkarray of the items to be processed, as returned by functions like reaper.GetItemStateChunk
    boolean lockstate - true, to set the MediaItemStateChunk to locked, false to set it to unlocked
  </parameters>
  <retvals>
    integer count - the number of entries in the changed MediaItemStateChunkArray
    array changedMediaItemStateChunkArray - the lockstate-modified MediaItemStateChunkArray
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, statechunk, state, chunk, lock</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)==false then ultraschall.AddErrorMessage("AddLockStateTo_MediaItemStateChunkArray", "MediaItemStateChunkArray", "must be a valid MediaItemStateChunkArray", -1) return -1 end
  if type(lockstate)~="boolean" then ultraschall.AddErrorMessage("AddLockStateTo_MediaItemStateChunkArray", "lockstate", "must be a boolean", -2) return -1 end
  local count=1
  while MediaItemStateChunkArray[count]~=nil do
      if lockstate==true then 
        MediaItemStateChunkArray[count]=ultraschall.AddLockStateToMediaItemStateChunk(MediaItemStateChunkArray[count], true)
      elseif lockstate==false then 
        MediaItemStateChunkArray[count]=ultraschall.AddLockStateToMediaItemStateChunk(MediaItemStateChunkArray[count], false)
      end
      count=count+1
  end
  return count-1, MediaItemStateChunkArray
end

--A,B,C=ultraschall.GetAllMediaItemsBetween(1,20,"1",false)
--ultraschall.AddLockStateTo_MediaItemStateChunkArray(C,1)

function ultraschall.ApplyStateChunkToItems(MediaItemStateChunkArray, undostate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyStateChunkToItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer skippeditemscount, array skipped_MediaItemStateChunkArray = ultraschall.ApplyStateChunkToItems(array MediaItemStateChunkArray, boolean undostate)</functioncall>
  <description>
    Applies changed StateChunks to the respective items. Skips deleted items, as they can't be set.
    
    It will look into the IGUID-entry of the statechunks, to find the right corresponding MediaItem to apply the statechunk to.
    
    returns the number of entries and the altered MediaItemStateChunkArray; -1 in case of failure
  </description>
  <parameters>
    array MediaItemStateChunkArray - the statechunkarray of the items to be applied, as returned by functions like reaper.GetItemStateChunk
    boolean undostate - true, sets the changed undo-possible, false undo-impossible
  </parameters>
  <retvals>
    boolean retval - true it worked, false it didn't
    integer skippeditemscount - the number of entries that couldn't be applied
    array skipped_MediaItemStateChunkArray - the StateChunks, that couldn't be aplied
  </retvals>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, statechunk, state, chunk, apply</tags>
</US_DocBloc>
]]
  if ultraschall.CheckMediaItemStateChunkArray(MediaItemStateChunkArray)==false then ultraschall.AddErrorMessage("ApplyStateChunkToItems","MediaItemStateChunkArray", "must be a valid MediaItemStateChunkArray", -1) return false end
  if type(undostate)~="boolean" then ultraschall.AddErrorMessage("ApplyStateChunkToItems","undostate", "must be a boolean", -2) return false end
  local count=1
  local count_two=1
  local MediaItemStateChunkArray2={}
  while MediaItemStateChunkArray[count]~=nil do
    local IGUID = ultraschall.GetItemIGUID_StateChunk(MediaItemStateChunkArray[count])
    local MediaItem=reaper.BR_GetMediaItemByGUID(0, IGUID)
    if MediaItem~=nil then local Boolean=reaper.SetItemStateChunk(MediaItem, MediaItemStateChunkArray[count], undostate) 
      --reaper.MB("hula","",0)
    else
      MediaItemStateChunkArray2[count_two]=MediaItemStateChunkArray[count]
      count_two=count_two+1
    end
    count=count+1
  end
  return true, count_two-1, MediaItemStateChunkArray2
end

--ultraschall.ApplyStateChunkToItems("", "")

function ultraschall.GetAllLockedItemsFromMediaItemArray(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllLockedItemsFromMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer countlock, array locked_MediaItemArray, integer countunlock, array unlocked_MediaItemArray = ultraschall.GetAllLockedItemsFromMediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Returns the number and the items that are locked, as well as the number and the items that are NOT locked.
    The items are returned as MediaItemArrays
    returns -1 in case of failure
  </description>
  <parameters>
    array MediaItemArray - the statechunkarray of the items to be checked.
  </parameters>
  <retvals>
    integer countlock - the number of locked items. -1 in case of failure
    array locked_MediaItemArray - the locked items in a mediaitemarray
    integer countunlock - the number of un(!)locked items
    array unlocked_MediaItemArray - the un(!)locked items in a mediaitemarray
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, selection, lock, lockstate, locked state, unlock, unlocked state</tags>
</US_DocBloc>
]]
--lockedstate = true return only locked items
--            = false return only unlocked items
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("GetAllLockedItemsFromMediaItemArray", "MediaItemArray", "Only array with MediaItemObjects as entries is allowed.", -1) return -1 end
  local MediaItemArray_locked={}
  local MediaItemArray_unlocked={}
  local count=1
  local countlock=1
  local countunlock=1
  while MediaItemArray[count]~=nil do
    local number=reaper.GetMediaItemInfo_Value(MediaItemArray[count], "C_LOCK")
    if number==0 then MediaItemArray_unlocked[countunlock]=MediaItemArray[count] countunlock=countunlock+1
    elseif number==1 then MediaItemArray_locked[countlock]=MediaItemArray[count] countlock=countlock+1 
    end
    count=count+1
  end
  return countlock-1, MediaItemArray_locked, countunlock-1, MediaItemArray_unlocked
end

--C,CC,CCC=ultraschall.GetMediaItemsAtPosition(49,"1,2,3")
--P,PP,PPP,PPPP=ultraschall.GetAllLockedItemsFromMediaItemArray(CC)

function ultraschall.GetMediaItemStateChunksFromMediaItemArray(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemStateChunksFromMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemStateChunkArray = ultraschall.GetMediaItemStateChunksFromMediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Returns the number of items and statechunks of the Items in MediaItemArray. It skips items in MediaItemArray, that are deleted.
    returns -1 in case of failure
  </description>
  <parameters>
    array MediaItemArray - the statechunkarray of the items to be checked.
  </parameters>
  <retvals>
    integer count - the number of statechunks returned. -1 in case of failure
    array MediaItemStateChunkArray - the statechunks of the items in mediaitemarray
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, set, item, mediaitem, selection, chunk, statechunk, state chunk, state</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("GetMediaItemStateChunksFromMediaItemArray", "MediaItemArray", "No valid MediaItemArray", -1) return -1 end
  local MediaItemStateChunkArray={}
  local count=1
  local count2=1
  local retval
  while MediaItemArray[count]~=nil do
    if reaper.ValidatePtr(MediaItemArray[count],"MediaItem*")==true then
      retval, MediaItemStateChunkArray[count2] = reaper.GetItemStateChunk(MediaItemArray[count], "", true)
      count2=count2+1
    end
    count=count+1
  end
  return count2-1, MediaItemStateChunkArray
end
--A=ultraschall.IsValidMediaItemArray(1)
--L=ultraschall.GetMediaItemStateChunksFromMediaItemArray(1)

function ultraschall.GetTrackHWOut(tracknumber,idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackHWOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer outputchannel, integer post_pre_fader, number volume, number pan, integer mute, integer phase, integer source, number unknown, integer automationmode = ultraschall.GetTrackHWOut(integer tracknumber, integer idx)</functioncall>
  <description>
    Returns the settings of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.
    
    It's the entry HWOUT
    
    returns -1 in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose HWOut you want, 0 for Master Track
    integer idx - the id-number of the HWOut, beginning with 1 for the first HWOut-Settings
  </parameters>
  <retvals>
    integer outputchannel - outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels
    integer post_pre_fader - 0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination "Controls for Track"-dialogue
    number volume - volume, as set in the Destination "Controls for Track"-dialogue 
    number pan - pan, as set in the Destination "Controls for Track"-dialogue
    integer mute - mute, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer phase - Phase, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer source - source, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - None
    -                                     0 - Stereo Source 1/2
    -                                     4 - Stereo Source 5/6
    -                                    12 - New Channels On Sending Track Stereo Source Channel 13/14
    -                                    1024 - Mono Source 1
    -                                    1029 - Mono Source 6
    -                                    1030 - New Channels On Sending Track Mono Source Channel 7
    -                                    1032 - New Channels On Sending Track Mono Source Channel 9
    -                                    2048 - MultiChannel 4 Channels 1-4
    -                                    2050 - Multichannel 4 Channels 3-6
    -                                    3072 - Multichannel 6 Channels 1-6
    number unknown - unknown, standard set to -1
    integer automationmode - automation mode, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - Track Automation Mode
    -                                     0 - Trim/Read
    -                                     1 - Read
    -                                     2 - Touch
    -                                     3 - Write
    -                                     4 - Latch
    -                                     5 - Latch Preview
  </retvals>
  <chapter_context>
    Track Management
    Hardware Out
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, get, hwout, routing, phase, source, mute, pan, volume, post, pre, fader, channel, automation</tags>
</US_DocBloc>
]]
-- HWOUT %d %d %.14f %.14f %d %d %d %.14f:U %d
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackHWOut", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackHWOut", "tracknumber", "no such track", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetTrackHWOut", "idx", "must be an integer", -3) return -1 end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local TrackStateChunkArray={}
  local retstring
  local count=1
  while TrackStateChunk:match("HWOUT")=="HWOUT" do
    if count==idx then retstring=TrackStateChunk:match("(HWOUT.-)%c") end
    if retstring~=nil then retstring=retstring.." " end
    TrackStateChunk=TrackStateChunk:match("HWOUT.-%c(.*)")
    count=count+1
  end
  if retstring~=nil then
    return tonumber(retstring:match(" (.-) ")),
           tonumber(retstring:match(" .- (.-) ")),
           tonumber(retstring:match(" .- .- (.-) ")),
           tonumber(retstring:match(" .- .- .- (.-) ")),
           tonumber(retstring:match(" .- .- .- .- (.-) ")),
           tonumber(retstring:match(" .- .- .- .- .- (.-) ")),
           tonumber(retstring:match(" .- .- .- .- .- .- (.-) ")),
           tonumber(retstring:match(" .- .- .- .- .- .- .- (.-):U ")),
           tonumber(retstring:match(" .- .- .- .- .- .- .- .- (.-) "))
  else ultraschall.AddErrorMessage("GetTrackHWOut", "tracknumber", "no HWOuts available", -4) return -1
  end
end

--A,B,C,D,E,F,G,H,I=ultraschall.GetTrackHWOut(1,1)

function ultraschall.GetTrackAUXSendReceives(tracknumber,idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackAUXSendReceives</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer recv_tracknumber, integer post_pre_fader, number volume, number pan, integer mute, integer mono_stereo, integer phase, integer chan_src, integer snd_chan, number unknown, integer midichanflag, integer automation = ultraschall.GetTrackAUXSendReceives(integer tracknumber, integer idx)</functioncall>
  <description>
    Returns the settings of the Send/Receive, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber. There can be more than one, which you can choose with idx.
    Remember, if you want to get the sends of a track, you need to check the recv_tracknumber-returnvalues of the OTHER(!) tracks, as you can only get the receives. With the receives checked, you know, which track sends.
    
    It's the entry AUXRECV
    
    returns -1 in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose Send/Receive you want
    integer idx - the id-number of the Send/Receive, beginning with 1 for the first Send/Receive-Settings
  </parameters>
  <retvals>
    integer recv_tracknumber - Tracknumber, from where to receive the audio from
    integer post_pre_fader - 0-PostFader, 1-PreFX, 3-Pre-Fader
    number volume - Volume
    number pan - pan, as set in the Destination "Controls for Track"-dialogue; negative=left, positive=right, 0=center
    integer mute - Mute this send(1) or not(0)
    integer mono_stereo - Mono(1), Stereo(0)
    integer phase - Phase of this send on(1) or off(0)
    integer chan_src - Audio-Channel Source
    -                                        -1 - None
    -                                        0 - Stereo Source 1/2
    -                                        1 - Stereo Source 2/3
    -                                        2 - Stereo Source 3/4
    -                                        1024 - Mono Source 1
    -                                        1025 - Mono Source 2
    -                                        2048 - Multichannel Source 4 Channels 1-4
    integer snd_chan - send to channel
    -                                        0 - Stereo 1/2
    -                                        1 - Stereo 2/3
    -                                        2 - Stereo 3/4
    -                                        ...
    -                                        1024 - Mono Channel 1
    -                                        1025 - Mono Channel 2
    number unknown - unknown, default is -1
    integer midichanflag -0 - All Midi Tracks
    -                                        1 to 16 - Midi Channel 1 to 16
    -                                        32 - send to Midi Channel 1
    -                                        64 - send to MIDI Channel 2
    -                                        96 - send to MIDI Channel 3
    -                                        ...
    -                                        512 - send to MIDI Channel 16
    -                                        4194304 - send to MIDI-Bus B1
    -                                        send to MIDI-Bus B1 + send to MIDI Channel nr = MIDIBus B1 1/nr:
    -                                        16384 - BusB1
    -                                        BusB1+1 to 16 - BusB1-Channel 1 to 16
    -                                        32768 - BusB2
    -                                        BusB2+1 to 16 - BusB2-Channel 1 to 16
    -                                        49152 - BusB3
    -                                        ...
    -                                        BusB3+1 to 16 - BusB3-Channel 1 to 16
    -                                        262144 - BusB16
    -                                        BusB16+1 to 16 - BusB16-Channel 1 to 16
    -
    -                                        1024 - Add that value to switch MIDI On
    -                                        4177951 - MIDI - None
    integer automation - Automation Mode
    -                                       -1 - Track Automation Mode
    -                                        0 - Trim/Read
    -                                        1 - Read
    -                                        2 - Touch
    -                                        3 - Write
    -                                        4 - Latch
    -                                        5 - Latch Preview
  </retvals>
  <chapter_context>
    Track Management
    Send/Receive-Routing
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, get, send, receive, phase, source, mute, pan, volume, post, pre, fader, channel, automation, midi</tags>
</US_DocBloc>
]]
--AUXRECV %d %d %.14f %.14f %d %d %d %d %d %.14f:U %d %d '%s'
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackAUXSendReceives", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackAUXSendReceives", "tracknumber", "no such track", -2) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetTrackAUXSendReceives", "idx", "must be an integer", -3) return -1 end
  
  local Track=reaper.GetTrack(0,tracknumber-1)
  if Track==nil then return -1 end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local TrackStateChunkArray={}
  local count=1
  while TrackStateChunk:match("AUXRECV")=="AUXRECV" do
    if count==idx then retstring=TrackStateChunk:match("(AUXRECV.-)%c") end
    if retstring~=nil then retstring=retstring.." " end
    TrackStateChunk=TrackStateChunk:match("AUXRECV.-%c(.*)")
    count=count+1
  end
  if retstring~=nil then return tonumber(retstring:match(" (.-) ")),
                                tonumber(retstring:match(" .- (.-) ")),
                                tonumber(retstring:match(" .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- .- .- .- (.-):U ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- .- .- .- .- (.-) ")),
                                tonumber(retstring:match(" .- .- .- .- .- .- .- .- .- .- .- (.-) "))
  else return -1
  end
end

--A,B,C,D,E,F,G,H,I=ultraschall.GetTrackAUXSendReceives(0,1)


function ultraschall.CountTrackHWOuts(tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountTrackHWOuts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count_HWOuts = ultraschall.CountTrackHWOuts(integer tracknumber)</functioncall>
  <description>
    Counts and returns the number of existing HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber.
    returns -1 in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose HWOUTs you want to count. 0 for Master Track
  </parameters>
  <retvals>
    integer count_HWOuts - the number of HWOuts in tracknumber
  </retvals>
  <chapter_context>
    Track Management
    Hardware Out
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, get, count, hwout, routing</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("CountTrackHWOuts", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("CountTrackHWOuts", "tracknumber", "no such track", -2) return -1 end
  
  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  if Track==nil then return -1 end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local TrackStateChunkArray={}
  local count=1
  while TrackStateChunk:match("HWOUT")=="HWOUT" do
    TrackStateChunkArray[count]=TrackStateChunk:match("HWOUT.-%c")
    TrackStateChunk=TrackStateChunk:match("HWOUT.-%c(.*)")
    count=count+1
  end
  return count-1, TrackStateChunkArray
end

--B2,BB2=ultraschall.CountTrackHWOuts(0)

function ultraschall.CountTrackAUXSendReceives(tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountTrackAUXSendReceives</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count_SendReceives = ultraschall.CountTrackAUXSendReceives(integer tracknumber)</functioncall>
  <description>
    Counts and returns the number of existing Send/Receives/Routing-settings, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber.
    returns -1 in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose Send/Receive you want
  </parameters>
  <retvals>
    integer count_SendReceives - the number of Send/Receives-Settings in tracknumber
  </retvals>
  <chapter_context>
    Track Management
    Send/Receive-Routing
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, get, count, send, receive, routing</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("CountTrackAUXSendReceives", "tracknumber", "must be an integer", -1) return -1 end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("CountTrackAUXSendReceives", "tracknumber", "no such track", -2) return -1 end
  
  local Track=reaper.GetTrack(0,tracknumber-1)
  if Track==nil then return -1 end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local TrackStateChunkArray={}
  local count=1
  while TrackStateChunk:match("AUXRECV")=="AUXRECV" do
    TrackStateChunkArray[count]=TrackStateChunk:match("AUXRECV.-%c")
    TrackStateChunk=TrackStateChunk:match("AUXRECV.-%c(.*)")
    count=count+1
  end
  return count-1, TrackStateChunkArray
end

function ultraschall.AddTrackHWOut(tracknumber, a, b, c, d, e, f, g, h, i, undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddTrackHWOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.AddTrackHWOut(integer tracknumber, integer outputchannel, integer post_pre_fader, number volume, number pan, integer mute, integer phase, integer source, number unknown, integer automationmode, boolean undo)</functioncall>
  <description>
    Adds a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber.
    This function does not check the parameters for plausability, so check your settings twice!
    
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose HWOut you want. 0 for Master Track
    integer outputchannel - outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels
    integer post_pre_fader - 0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination "Controls for Track"-dialogue
    number volume - volume, as set in the Destination "Controls for Track"-dialogue 
    number pan - pan, as set in the Destination "Controls for Track"-dialogue
    integer mute - mute, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer phase - Phase, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer source - source, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - None
    -                                     0 - Stereo Source 1/2
    -                                     4 - Stereo Source 5/6
    -                                    12 - New Channels On Sending Track Stereo Source Channel 13/14
    -                                    1024 - Mono Source 1
    -                                    1029 - Mono Source 6
    -                                    1030 - New Channels On Sending Track Mono Source Channel 7
    -                                    1032 - New Channels On Sending Track Mono Source Channel 9
    -                                    2048 - MultiChannel 4 Channels 1-4
    -                                    2050 - Multichannel 4 Channels 3-6
    -                                    3072 - Multichannel 6 Channels 1-6
    number unknown - unknown, standard set to -1
    integer automationmode - automation mode, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - Track Automation Mode
    -                                     0 - Trim/Read
    -                                     1 - Read
    -                                     2 - Touch
    -                                     3 - Write
    -                                     4 - Latch
    -                                     5 - Latch Preview
    boolean undo - true, sets undo-state, false, doesn't set undo
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
  </retvals>
  <chapter_context>
    Track Management
    Hardware Out
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, add, hwout, routing, phase, source, mute, pan, volume, post, pre, fader, channel, automation</tags>
</US_DocBloc>
]]
--integer tracknumber, integer outputchannel, integer post_pre_fader, number volume, number pan, 
--integer mute, integer phase, integer source, number unknown, integer automationmode, boolean undo

-- tracknumber, a, b, c, d, e, f, g, h, i, undo  

  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("AddTrackHWOut", "tracknumber", "no such track", -2) return false end
  if math.type(a)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "outputchannel", "must be an integer", -3) return false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "post_pre_fader", "must be an integer", -4) return false end
  if type(c)~="number" then ultraschall.AddErrorMessage("AddTrackHWOut", "volume", "must be a number", -5) return false end
  if type(d)~="number" then ultraschall.AddErrorMessage("AddTrackHWOut", "pan", "must be a number", -6) return false end
  if math.type(e)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "mute", "must be an integer", -7) return false end
  if math.type(f)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "phase", "must be an integer", -8) return false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "source", "must be an integer", -9) return false end
  if type(h)~="number" then ultraschall.AddErrorMessage("AddTrackHWOut", "unknown", "must be a number", -10) return false end
  if math.type(i)~="integer" then ultraschall.AddErrorMessage("AddTrackHWOut", "automationmode", "must be an integer", -11) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("AddTrackHWOut", "undo", "must be a boolean", -12) return false end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackHWOuts(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-MAINSEND.-%c)")
  else Begin=TrackStateChunk:match("(.-)HWOUT.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*MAINSEND.-%c(.*)")
  else Ending=TrackStateChunk:match(".*HWOUT.-%c(.*)")
  end
  
  finalstring=Begin
  for i=1,B do
    finalstring=finalstring..C[i]
  end
  finalstring=finalstring.."HWOUT "..a.." "..b.." "..c.." "..d.." "..e.." "..f.." "..g.." "..h..":U "..i.."\n"..Ending
--  reaper.ShowConsoleMsg(finalstring)
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--A=ultraschall.AddTrackHWOut(0,1,1,1,1,1,1,1,1,1,false)

function ultraschall.AddTrackAUXSendReceives(tracknumber, a, b, c, d, e, f, g, h, i, j, k, l, undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddTrackAUXSendReceives</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.AddTrackAUXSendReceives(integer tracknumber, integer recv_tracknumber, integer post_pre_fader, number volume, number pan, integer mute, integer mono_stereo, integer phase, integer chan_src, integer snd_chan, number unknown, integer midichanflag, integer automation, boolean undo)</functioncall>
  <description>
    Adds a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber. There can be more than one.
    Remember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.
    
    Due to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the added sends/receives appear, as they might not appear!
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose Send/Receive you want
    integer recv_tracknumber - Tracknumber, from where to receive the audio from
    integer post_pre_fader - 0-PostFader, 1-PreFX, 3-Pre-Fader
    number volume - Volume
    number pan - pan, as set in the Destination "Controls for Track"-dialogue; negative=left, positive=right, 0=center
    integer mute - Mute this send(1) or not(0)
    integer mono_stereo - Mono(1), Stereo(0)
    integer phase - Phase of this send on(1) or off(0)
    integer chan_src - Audio-Channel Source
    -                                       -1 - None
    -                                        0 - Stereo Source 1/2
    -                                        1 - Stereo Source 2/3
    -                                        2 - Stereo Source 3/4
    -                                        1024 - Mono Source 1
    -                                        1025 - Mono Source 2
    -                                        2048 - Multichannel Source 4 Channels 1-4
    integer snd_chan - send to channel
    -                                        0 - Stereo 1/2
    -                                        1 - Stereo 2/3
    -                                        2 - Stereo 3/4
    -                                        ...
    -                                        1024 - Mono Channel 1
    -                                        1025 - Mono Channel 2
    number unknown - unknown, default is -1
    integer midichanflag -0 - All Midi Tracks
    -                                        1 to 16 - Midi Channel 1 to 16
    -                                        32 - send to Midi Channel 1
    -                                        64 - send to MIDI Channel 2
    -                                        96 - send to MIDI Channel 3
    -                                        ...
    -                                        512 - send to MIDI Channel 16    
    -                                        4194304 - send to MIDI-Bus B1
    -                                        send to MIDI-Bus B1 + send to MIDI Channel nr = MIDIBus B1 1/nr:
    -                                        16384 - BusB1
    -                                        BusB1+1 to 16 - BusB1-Channel 1 to 16
    -                                        32768 - BusB2
    -                                        BusB2+1 to 16 - BusB2-Channel 1 to 16
    -                                        49152 - BusB3
    -                                        ...
    -                                        BusB3+1 to 16 - BusB3-Channel 1 to 16
    -                                        262144 - BusB16
    -                                        BusB16+1 to 16 - BusB16-Channel 1 to 16
    -
    -                                        1024 - Add that value to switch MIDI On
    -                                        4177951 - MIDI - None
    integer automation - Automation Mode
    -                                       -1 - Track Automation Mode
    -                                        0 - Trim/Read
    -                                        1 - Read
    -                                        2 - Touch
    -                                        3 - Write
    -                                        4 - Latch
    -                                        5 - Latch Preview
    boolean undo - true, sets undo-state, false, doesn't set undo
  </parameters>
  <retvals>
    boolean retval - true if it worked, false if it didn't.
  </retvals>
  <chapter_context>
    Track Management
    Send/Receive-Routing
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, add, send, receive, phase, source, mute, pan, volume, post, pre, fader, channel, automation, midi</tags>
</US_DocBloc>
]]
-- integer tracknumber, integer recv_tracknumber, integer post_pre_fader, number volume, 
--                      number pan, integer mute, integer mono_stereo, integer phase, 
--                      integer chan_src, integer snd_chan, number unknown, integer midichanflag, 
--                      integer automation, boolean undo
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "tracknumber", "no such track", -2) return false end
  if math.type(a)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "recv_tracknumber", "must be an integer", -3) return false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "post_pre_fader", "must be an integer", -4) return false end
  if type(c)~="number" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "volume", "must be a number", -5) return false end
  if type(d)~="number" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "pan", "must be a number", -6) return false end
  if math.type(e)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "mute", "must be an integer", -7) return false end
  if math.type(f)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "mono_stereo", "must be an integer", -8) return false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "phase", "must be an integer", -9) return false end
  if math.type(h)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "chan_src", "must be a number", -10) return false end
  if math.type(i)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "snd_chan", "must be an integer", -11) return false end
  if type(j)~="number" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "unknown", "must be a number", -12) return false end
  if math.type(k)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "midichanflag", "must be an integer", -13) return false end
  if math.type(l)~="integer" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "automation", "must be an integer", -14) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("AddTrackAUXSendReceives", "undo", "must be a boolean", -15) return false end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackAUXSendReceives(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-PERF.-%c)")
  else Begin=TrackStateChunk:match("(.-)AUXRECV.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*PERF.-%c(.*)")
  else Ending=TrackStateChunk:match(".*AUXRECV.-%c(.*)")
  end
  
  finalstring=Begin
  for i=1,B do
    finalstring=finalstring..C[i]
  end
  finalstring=finalstring.."AUXRECV "..a.." "..b.." "..c.." "..d.." "..e.." "..f.." "..g.." "..h.." "..i.." "..j..":U "..k.." "..l.."\n"..Ending
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--ultraschall.AddTrackAUXSendReceives(1,1,1,1,1,1,1,1,1,1,1,1,1,false)

function ultraschall.DeleteTrackHWOut(tracknumber,idx,undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteTrackHWOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteTrackHWOut(integer tracknumber, integer idx, boolean undo)</functioncall>
  <description>
    Deletes the idxth HWOut-Setting of tracknumber.
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose HWOUTs you want to delete. 0 for Master Track.
    integer idx - the number of the HWOut-setting, that you want to delete
    boolean undo - shall this be set to undo(true) or not(false)
  </parameters>
  <retvals>
    boolean retval - true if it worked, false if it didn't.
  </retvals>
  <chapter_context>
    Track Management
    Hardware Out
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, delete, hwout, routing</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("DeleteTrackHWOut", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("DeleteTrackHWOut", "tracknumber", "no such track", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteTrackHWOut", "idx", "must be an integer", -3) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("DeleteTrackHWOut", "undo", "must be a boolean", -4) return false end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackHWOuts(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-MAINSEND.-%c)")
  else Begin=TrackStateChunk:match("(.-)HWOUT.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*MAINSEND.-%c(.*)")
  else Ending=TrackStateChunk:match(".*HWOUT.-%c(.*)")
  end
  
  finalstring=Begin
  for i=1,B do
    if idx~=i then 
      finalstring=finalstring..C[i] 
    end
  end
  finalstring=finalstring..Ending
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--L=ultraschall.DeleteTrackHWOut(0,1,false)

function ultraschall.DeleteTrackAUXSendReceives(tracknumber,idx,undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteTrackAUXSendReceives</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteTrackAUXSendReceives(integer tracknumber, integer idx, boolean undo)</functioncall>
  <description>
    Deletes the idxth Send/Receive-Setting of tracknumber.
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose Send/Receive you want
    integer idx - the number of the send/receive-setting, that you want to delete
    boolean undo - shall this be set to undo(true) or not(false)
  </parameters>
  <retvals>
    boolean retval - true if it worked, false if it didn't.
  </retvals>
  <chapter_context>
    Track Management
    Send/Receive-Routing
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, delete, send, receive, routing</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("DeleteTrackAUXSendReceives", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("DeleteTrackAUXSendReceives", "tracknumber", "no such track", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteTrackAUXSendReceives", "idx", "must be an integer", -3) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("DeleteTrackAUXSendReceives", "undo", "must be a boolean", -4) return false end
  
  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end  
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackAUXSendReceives(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-PERF.-%c)")
  else Begin=TrackStateChunk:match("(.-)AUXRECV.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*PERF.-%c(.*)")
  else Ending=TrackStateChunk:match(".*AUXRECV.-%c(.*)")
  end
  
  finalstring=Begin
  for i=1,B do
    if idx~=i then 
      finalstring=finalstring..C[i] 
    end
  end
  finalstring=finalstring..Ending
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--L=ultraschall.DeleteTrackAUXSendReceives(1,1,false)


function ultraschall.SetTrackHWOut(tracknumber, idx, a, b, c, d, e, f, g, h, i, undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackHWOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTrackHWOut(integer tracknumber, integer idx, integer outputchannel, integer post_pre_fader, number volume, number pan, integer mute, integer phase, integer source, number unknown, integer automationmode, boolean undo)</functioncall>
  <description>
    Sets a setting of the HWOUT-HW-destination, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber. There can be more than one, so choose the one you want to change with idx.
    To retain old-settings, use nil with the accompanying parameters.
    This function does not check the parameters for plausability, so check your settings twice, or the HWOut-setting might disappear with faulty parameters!
    
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose HWOut you want. 0 for Master Track
    integer idx - the number of the HWOut-setting, you want to change
    integer outputchannel - outputchannel, with 1024+x the individual hw-outputchannels, 0,2,4,etc stereo output channels
    integer post_pre_fader - 0-post-fader(post pan), 1-preFX, 3-pre-fader(Post-FX), as set in the Destination "Controls for Track"-dialogue
    number volume - volume, as set in the Destination "Controls for Track"-dialogue 
    number pan - pan, as set in the Destination "Controls for Track"-dialogue
    integer mute - mute, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer phase - Phase, 1-on, 0-off, as set in the Destination "Controls for Track"-dialogue
    integer source - source, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - None
    -                                     0 - Stereo Source 1/2
    -                                     4 - Stereo Source 5/6
    -                                    12 - New Channels On Sending Track Stereo Source Channel 13/14
    -                                    1024 - Mono Source 1
    -                                    1029 - Mono Source 6
    -                                    1030 - New Channels On Sending Track Mono Source Channel 7
    -                                    1032 - New Channels On Sending Track Mono Source Channel 9
    -                                    2048 - MultiChannel 4 Channels 1-4
    -                                    2050 - Multichannel 4 Channels 3-6
    -                                    3072 - Multichannel 6 Channels 1-6
    number unknown - unknown, standard set to -1
    integer automationmode - automation mode, as set in the Destination "Controls for Track"-dialogue
    -                                    -1 - Track Automation Mode
    -                                     0 - Trim/Read
    -                                     1 - Read
    -                                     2 - Touch
    -                                     3 - Write
    -                                     4 - Latch
    -                                     5 - Latch Preview
    boolean undo - true, sets undo-state, false, doesn't set undo
  </parameters>
  <retvals>
    boolean retval - true, if it worked; false if it didn't
  </retvals>
  <chapter_context>
    Track Management
    Hardware Out
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, hwout, routing, phase, source, mute, pan, volume, post, pre, fader, channel, automation</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackHWOut", "tracknumber", "no such track", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "idx", "must be an integer", -13) return false end
  if math.type(a)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "outputchannel", "must be an integer", -3) return false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "post_pre_fader", "must be an integer", -4) return false end
  if type(c)~="number" then ultraschall.AddErrorMessage("SetTrackHWOut", "volume", "must be a number", -5) return false end
  if type(d)~="number" then ultraschall.AddErrorMessage("SetTrackHWOut", "pan", "must be a number", -6) return false end
  if math.type(e)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "mute", "must be an integer", -7) return false end
  if math.type(f)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "phase", "must be an integer", -8) return false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "source", "must be an integer", -9) return false end
  if type(h)~="number" then ultraschall.AddErrorMessage("SetTrackHWOut", "unknown", "must be a number", -10) return false end
  if math.type(i)~="integer" then ultraschall.AddErrorMessage("SetTrackHWOut", "automationmode", "must be an integer", -11) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("SetTrackHWOut", "undo", "must be a boolean", -12) return false end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackHWOuts(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-MAINSEND.-%c)")
  else Begin=TrackStateChunk:match("(.-)HWOUT.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*MAINSEND.-%c(.*)")
  else Ending=TrackStateChunk:match(".*HWOUT.-%c(.*)")
  end
    
  finalstring=Begin
  for i=1,B do
    if idx~=i then 
      finalstring=finalstring..C[i]
    end
    if idx==i then
      a1, b1, c1, d1, e1, f1, g1, h1, i1 = ultraschall.GetTrackHWOut(tracknumber,idx)
      if a==nil then a=a1 end
      if b==nil then b=b1 end
      if c==nil then c=c1 end
      if d==nil then d=d1 end
      if e==nil then e=e1 end
      if f==nil then f=f1 end
      if g==nil then g=g1 end
      if h==nil then h=h1 end
      if i==nil then i=i1 end
      finalstring=finalstring.."HWOUT "..a.." "..b.." "..c.." "..d.." "..e.." "..f.." "..g.." "..h..":U "..i.."\n"
    end
  end
  finalstring=finalstring..Ending
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--L=ultraschall.SetTrackHWOut(0, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, true)


function ultraschall.SetTrackAUXSendReceives(tracknumber, idx, a, b, c, d, e, f, g, h, i, j, k, l, undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackAUXSendReceives</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTrackAUXSendReceives(integer tracknumber, integer idx, integer recv_tracknumber, integer post_pre_fader, number volume, number pan, integer mute, integer mono_stereo, integer phase, integer chan_src, integer snd_chan, number unknown, integer midichanflag, integer automation, boolean undo)</functioncall>
  <description>
    Alters a setting of Send/Receive, as set in the routing-matrix, as well as in the Destination "Controls for Track"-dialogue, of tracknumber. There can be more than one, so choose the right one with idx.
    You can keep the old-setting by using nil as a parametervalue.
    Remember, if you want to set the sends of a track, you need to add it to the track, that shall receive, not the track that sends! Set recv_tracknumber in the track that receives with the tracknumber that sends, and you've set it successfully.
    
    Due to the complexity of send/receive-settings, this function does not check, whether the parameters are plausible. So check twice, whether the change sends/receives still appear, as they might disappear with faulty settings!
    returns false in case of failure
  </description>
  <parameters>
    integer tracknumber - the number of the track, whose Send/Receive you want
    integer idx - the send/receive-setting, you want to set
    integer recv_tracknumber - Tracknumber, from where to receive the audio from
    integer post_pre_fader - 0-PostFader, 1-PreFX, 3-Pre-Fader
    number volume - Volume
    number pan - pan, as set in the Destination "Controls for Track"-dialogue; negative=left, positive=right, 0=center
    integer mute - Mute this send(1) or not(0)
    integer mono_stereo - Mono(1), Stereo(0)
    integer phase - Phase of this send on(1) or off(0)
    integer chan_src - Audio-Channel Source
    -                                        -1 - None
    -                                        0 - Stereo Source 1/2
    -                                        1 - Stereo Source 2/3
    -                                        2 - Stereo Source 3/4
    -                                        1024 - Mono Source 1
    -                                        1025 - Mono Source 2
    -                                        2048 - Multichannel Source 4 Channels 1-4
    integer snd_chan - send to channel
    -                                        0 - Stereo 1/2
    -                                        1 - Stereo 2/3
    -                                        2 - Stereo 3/4
    -                                        ...
    -                                        1024 - Mono Channel 1
    -                                        1025 - Mono Channel 2
    number unknown - unknown, default is -1
    integer midichanflag -0 - All Midi Tracks
    -                                        1 to 16 - Midi Channel 1 to 16
    -                                        32 - send to Midi Channel 1
    -                                        64 - send to MIDI Channel 2
    -                                        96 - send to MIDI Channel 3
    -                                        ...
    -                                        512 - send to MIDI Channel 16
    -                                        4194304 - send to MIDI-Bus B1
    -                                        send to MIDI-Bus B1 + send to MIDI Channel nr = MIDIBus B1 1/nr:
    -                                        16384 - BusB1
    -                                        BusB1+1 to 16 - BusB1-Channel 1 to 16
    -                                        32768 - BusB2
    -                                        BusB2+1 to 16 - BusB2-Channel 1 to 16
    -                                        49152 - BusB3
    -                                        ...
    -                                        BusB3+1 to 16 - BusB3-Channel 1 to 16
    -                                        262144 - BusB16
    -                                        BusB16+1 to 16 - BusB16-Channel 1 to 16
    -
    -                                        1024 - Add that value to switch MIDI On
    -                                        4177951 - MIDI - None
    integer automation - Automation Mode
    -                                       -1 - Track Automation Mode
    -                                        0 - Trim/Read
    -                                        1 - Read
    -                                        2 - Touch
    -                                        3 - Write
    -                                        4 - Latch
    -                                        5 - Latch Preview
    boolean undo - true, sets undo-state, false, doesn't set undo
  </parameters>
  <retvals>
    boolean retval - true if it worked, false if it didn't.
  </retvals>
  <chapter_context>
    Track Management
    Send/Receive-Routing
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, track, set, send, receive, phase, source, mute, pan, volume, post, pre, fader, channel, automation, midi</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "tracknumber", "no such track", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "idx", "must be an integer", -16) return false end
  if math.type(a)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "recv_tracknumber", "must be an integer", -3) return false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "post_pre_fader", "must be an integer", -4) return false end
  if type(c)~="number" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "volume", "must be a number", -5) return false end
  if type(d)~="number" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "pan", "must be a number", -6) return false end
  if math.type(e)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "mute", "must be an integer", -7) return false end
  if math.type(f)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "mono_stereo", "must be an integer", -8) return false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "phase", "must be an integer", -9) return false end
  if math.type(h)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "chan_src", "must be a number", -10) return false end
  if math.type(i)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "snd_chan", "must be an integer", -11) return false end
  if type(j)~="number" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "unknown", "must be a number", -12) return false end
  if math.type(k)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "midichanflag", "must be an integer", -13) return false end
  if math.type(l)~="integer" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "automation", "must be an integer", -14) return false end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("SetTrackAUXSendReceives", "undo", "must be a boolean", -15) return false end

  local Track=reaper.GetTrack(0,tracknumber-1)
  if tracknumber==0 then Track=reaper.GetMasterTrack(0) end
  local A,TrackStateChunk=ultraschall.GetTrackStateChunk(Track,"",true)
  local B,C=ultraschall.CountTrackAUXSendReceives(tracknumber)
  local finalstring=""  
  local Begin
  local Ending

  if B<=0 then Begin=TrackStateChunk:match("(.-PERF.-%c)")
  else Begin=TrackStateChunk:match("(.-)AUXRECV.-%c")
  end
  if B<=0 then Ending=TrackStateChunk:match(".*PERF.-%c(.*)")
  else Ending=TrackStateChunk:match(".*AUXRECV.-%c(.*)")
  end
    
  finalstring=Begin
  for i=1,B do
    if idx~=i then 
      finalstring=finalstring..C[i]
    end
    if idx==i then
      a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, k1, l1 = ultraschall.GetTrackAUXSendReceives(tracknumber,idx)
      if a==nil then a=a1 end
      if b==nil then b=b1 end
      if c==nil then c=c1 end
      if d==nil then d=d1 end
      if e==nil then e=e1 end
      if f==nil then f=f1 end
      if g==nil then g=g1 end
      if h==nil then h=h1 end
      if i==nil then i=i1 end
      if j==nil then j=j1 end
      if k==nil then k=k1 end
      if l==nil then l=l1 end
      
      finalstring=finalstring.."AUXRECV "..a.." "..b.." "..c.." "..d.." "..e.." "..f.." "..g.." "..h.." "..i.." "..j..":U "..k.." "..l.."\n"
    end
  end
  finalstring=finalstring..Ending
  return reaper.SetTrackStateChunk(Track, finalstring, undo)
end

--ultraschall.SetTrackAUXSendReceives(1,1,1,1,1,1,1,1,1,1,1,1,1,1,true)

function ultraschall.GetReaperWindowPosition_Left()
-- Due to Api-limitations: when the reaper-window is too small, it returns a wrong value, up to 72 pixels too high!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperWindowPosition_Left</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer leftwindowposition = ultraschall.GetReaperWindowPosition_Left()</functioncall>
  <description>
    Returns pixel-position of the left side of the main Reaper window. Due to Api-limitations, when the Reaper-window is too small, it returns a wrong value with up to +72 pixels difference!
  </description>
  <retvals>
    integer leftwindowposition - the left side of the main Reaper window in pixels
  </retvals>
  <chapter_context>
    Reaper Element Positions
    Reaper Window
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>reaper, window, left, position, pixels</tags>
</US_DocBloc>
]]

  local temp,Technopop=ultraschall.GetIniFileValue("REAPER", "leftpanewid", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")
  local temp,ElectricCafe=ultraschall.GetIniFileValue("REAPER", "dockheight_l", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")

  local C,D,E,F,G,H,I,J,K,L=reaper.my_getViewport(1,2,3,4,5,6,7,8, true)
  local A1x,A2x= reaper.GetSet_ArrangeView2(0, false, 0,0)
  local puh

  for i=-E*2,E*2 do
    local T1,T2=reaper.GetSet_ArrangeView2(0, false, i+Technopop,i+Technopop+1)
    if T1==A1x then puh=i end
  end

  return puh-tonumber(ElectricCafe)-10
end

--A,B,C=ultraschall.GetReaperWindowPosition_Left()

function ultraschall.GetReaperWindowPosition_Right()
-- Due to Api-limitations: when the reaper-window is too small, it returns a wrong value, up to 72 pixels too high!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperWindowPosition_Right</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer rightwindowposition = ultraschall.GetReaperWindowPosition_Right()</functioncall>
  <description>
    Returns pixel-position of the right side of the main Reaper window.
  </description>
  <retvals>
    integer rightwindowposition - the right side of the main Reaper window in pixels
  </retvals>
  <chapter_context>
    Reaper Element Positions
    Reaper Window
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>reaper, window, right, position, pixels</tags>
</US_DocBloc>
]]
  local temp,Technopop=ultraschall.GetIniFileValue("REAPER", "leftpanewid", "", reaper.GetResourcePath()..ultraschall.Separator.."reaper.ini")

  local C,D,E,F,G,H,I,J,K,L=reaper.my_getViewport(1,2,3,4,5,6,7,8, true)
  local A1x,A2x= reaper.GetSet_ArrangeView2(0, false, 0,0)
  local puh

  for i=-E*2,E*2 do
    local T1,T2=reaper.GetSet_ArrangeView2(0, false, i,i+1)
    if T1==A2x then puh=i end
  end

  return puh
end

function ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow(Xscreencoordinate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertScreen2ClientXCoordinate_ReaperWindow</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer Xclientcoordinate = ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow(integer Xscreencoordinate)</functioncall>
  <description>
    Converts an x-screencoordinate into a x-coordinate within the Reaper-Main-Window.
    Due to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!
    
    returns -1 in case of error
  </description>
  <parameters>
    integer Xscreencoordinate - the screen-coordinate, you want to have converted to.
  </parameters>
  <retvals>
    integer Xclientcoordinate - coordinate within the main Reaper-window. Negative, if the coordinate is left of the edge of the window; -1, in case of error
  </retvals>
  <chapter_context>
    Reaper Element Positions
    Reaper Window
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>reaper, window, position, pixels, convert, screen, client</tags>
</US_DocBloc>
]]
  if math.type(Xscreencoordinate)~="integer" then ultraschall.AddErrorMessage("ConvertScreen2ClientXCoordinate_ReaperWindow", "Xscreencoordinate", "must be an integer", -1) return -1 end
  local A=ultraschall.GetReaperWindowPosition_Left()
  local B=ultraschall.GetReaperWindowPosition_Right()
  return Xscreencoordinate-A, B-Xscreencoordinate
end

--Xclientcoordinate = ultraschall.ConvertScreen2ClientXCoordinate_ReaperWindow(9)

function ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow(Xclientcoordinate)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertClient2ScreenXCoordinate_ReaperWindow</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer Xscreencoordinate = ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow(integer Xclientcoordinate)</functioncall>
  <description>
    Converts an x-clientcoordinate from within the main Reaper-window into a x-screencoordinate.
    Due to Api-limitations, if the Reaper-window is too small, the position might be wrong up to about 74 pixels!
  </description>
  <parameters>
    integer Xclientcoordinate - the screen-coordinate, you want to have converted to. Negative, if left of the left edge of the main Reaper-window.
  </parameters>
  <retvals>
    integer Xscreencoordinate - coordinate within the screen.
  </retvals>
  <chapter_context>
    Reaper Element Positions
    Reaper Window
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>reaper, window, position, pixels, convert, screen, client</tags>
</US_DocBloc>
]]
  if math.type(Xclientcoordinate)~="integer" then ultraschall.AddErrorMessage("ConvertClient2ScreenXCoordinate_ReaperWindow", "Xclientcoordinate", "must be an integer", -1) return -1 end
  local A=ultraschall.GetReaperWindowPosition_Left()
  local B=ultraschall.GetReaperWindowPosition_Right()
  return Xclientcoordinate+A
end

--L2,L3=ultraschall.ConvertClient2ScreenXCoordinate_ReaperWindow(reaper.GetMousePosition())


function ultraschall.SplitStringAtLineFeedToArray(unsplitstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SplitStringAtLineFeedToArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array split_string = ultraschall.SplitStringAtLineFeedToArray(string unsplitstring)</functioncall>
  <description>
    Splits the string unsplitstring at linefeed/tabs/control characters and puts each of these splitpieces into an array, each splitpiece one array-entry.
    The linefeeds will not(!) be returned in the array's entries.
    Returns the number of entries in the array, as well as the array itself
    If there are no controlcharacters or linefeeds in the string, the array will have only one entry with unsplitstring in it.
    returns -1 in case of failure
  </description>
  <parameters>
    string unsplitstring - the string, that shall be split at LineFeed/Tabs/Control Characters. Nil is not allowed.
  </parameters>
  <retvals>
    integer count - number of entries in the split_string-array
    array split_string - an array with all the individual "postsplit"-pieces of the string
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>string, split, linefeed, tabs, control characters, array</tags>
</US_DocBloc>
]]
  local array={}
  local i=1
  if unsplitstring==nil then ultraschall.AddErrorMessage("SplitStringAtLineFeedToArray", "unsplitstring", "nil is not allowed as value", -1) return -1 end
  local astring=unsplitstring
  local pos
  astring=string.gsub (unsplitstring, "\r\n", "\n")
  astring=string.gsub (astring, "\n\r", "\n")
  astring=string.gsub (astring, "\r", "\n")
  astring=astring.."\n"
  while astring:match("%c") do
    array[i],pos=astring:match("(.-)\n()")
--    reaper.MB(array[i], tostring(pos),0)
    if sub~=nil then break end 
    astring=astring:sub(pos,-1)
    i=i+1
  end
  if astring~="" and astring~=nil then array[i]=astring
  else i=i-1
  end
  return i,array
end

--L,LL=ultraschall.SplitStringAtLineFeedToArray("9,9,9,9\r\nooll\n\n\n\n")
--reaper.MB(LL[1].."O.."..LL[2],"",0)


function ultraschall.GetProject_CountMarkersAndRegions(projectfilenamewithpath)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_CountMarkersAndRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer number_of_markers_and_regions, integer number_of_regions_only, integer number_of_markers_only = ultraschall.GetProject_CountMarkersAndRegions(string projectfilename_with_path)</functioncall>
  <description>
    returns the number of all markers, the number of regions and the number of markers(that are not regions) in the project.
    
    It's the entry MARKER
  </description>
  <parameters>
    string projectfilename_with_path - the projectfilename in which to count the markers
  </parameters>
  <retvals>
    integer number_of_markers_and_regions - the number of all markers and regions
    integer number_of_regions_only - the number of regions
    integer number_of_markers_only - the number of markers only
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, count, marker, regions</tags>
</US_DocBloc>
]]
  if type(projectfilenamewithpath)~="string" then ultraschall.AddErrorMessage("GetProject_CountMarkersAndRegions", "projectfilename_with_path", "Must be a string", -2)  return -1 end
  if reaper.file_exists(projectfilenamewithpath)==false then ultraschall.AddErrorMessage("GetProject_CountMarkersAndRegions", "projectfilename_with_path", "Projectfile does not exist", -1)  return -1 end
  local A=ultraschall.ReadValueFromFile(projectfilenamewithpath,"MARKER", false)
  local L,LL=ultraschall.SplitStringAtLineFeedToArray(A)
  
  local regions=0
  local marker=0
  for i=1,L do
    if LL[i]:match("MARKER .* (.) .- 1 .")=="1" then regions=regions+1  end
    if LL[i]:match("MARKER .* (.) .- 1 .")=="0" then marker=marker+1 end
  end
  
  return L,tonumber(regions)/2, tonumber(marker)
end

--ultraschall.GetProject_CountMarkersAndRegions(projectfilenamewithpath)

function ultraschall.GetProject_GetMarker(projectfilenamewithpath, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_GetMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer shownnumber, number markerposition, string markertitle, integer markercolor = ultraschall.GetProject_GetMarker(string projectfilename_with_path, integer idx)</functioncall>
  <description>
    returns the information of the marker idx in a projectfile.
    
    It's the entry MARKER
    
    returns false in case of error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfilename from where to get the marker
    integer idx - the number of the marker, you want to have the information of
  </parameters>
  <retvals>
    boolean retval - true, in case of success; false in case of failure
    integer shownnumber - the number that is shown with the marker in the arrange-view
    number markerposition - the position of the marker in seconds
    string markertitle - the name of the marker. "" if no name is given.
    integer markercolor - the colorvalue of the marker
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, marker, shown number, name, color, position</tags>
</US_DocBloc>
]]
  if projectfilenamewithpath==nil or reaper.file_exists(projectfilenamewithpath)==false then ultraschall.AddErrorMessage("GetProject_GetMarker", "projectfilenamewithpath", "Projectfile does not exist", -1)  return false end
  idx=tonumber(idx)
  if idx==nil then ultraschall.AddErrorMessage("GetProject_GetMarker", "idx", "No valid value given. Only integer numbers are allowed.", -2)  return false end
  local A,B,C=ultraschall.GetProject_CountMarkersAndRegions(projectfilenamewithpath)
  if tonumber(idx)>C then ultraschall.AddErrorMessage("GetProject_GetMarker", "idx", "Only "..C.." markers available.", -3)  return false end
  if tonumber(idx)<1 then ultraschall.AddErrorMessage("GetProject_GetMarker", "idx", "Only positive values allowed.", -4)  return false end
  local A=ultraschall.ReadValueFromFile(projectfilenamewithpath,"MARKER", false)
  local L,LL=ultraschall.SplitStringAtLineFeedToArray(A)
  
  local regions=0
  local marker=0
  for i=L,1,-1 do
    if LL[i]:match("MARKER .* (.) .- 1 .")=="1" then table.remove(LL,i) end
  end
    
  local markname
  local markid=LL[idx]:match("MARKER (.-) ")
  local markpos=LL[idx]:match("MARKER .- (.-) ")
  local marktemp=LL[idx]:match("MARKER .- .- (.*)")
  if marktemp:sub(1,1)=="\"" then markname=marktemp:match("\"(.-)\"") marktemp=marktemp:match("\".-\" (.*)")
  else markname=marktemp:match("(.-) ") marktemp=marktemp:match(".- (.*)")
  end
  local markcolor=marktemp:match(".- (.-) ")

  return true, markid, markpos, markname, markcolor
end

--A,B,C=ultraschall.GetProject_GetMarker("c:\\audiocd-codes-part1.ini",1)

function ultraschall.GetProject_GetRegion(projectfilenamewithpath, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_GetRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer shownnumber, number start_of_region, number end_of_region, string regionname, integer regioncolor = ultraschall.GetProject_GetRegion(string projectfilename_with_path, integer idx)</functioncall>
  <description>
    returns the information of the region idx in a projectfile.
    
    It's the entry MARKER
    
    returns false in case of error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfilename from where to get the region
    integer idx - the number of the marker, you want to have the information of
  </parameters>
  <retvals>
    boolean retval - true, in case of success; false in case of failure
    integer shownnumber - the number that is shown with the region in the arrange-view
    number start_of_region - the startposition of the region in seconds
    number end_of_region - the endposition of the region in seconds
    string regionname - the name of the region. "" if no name is given.
    integer regioncolor - the colorvalue of the region
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, region, shown number, name, color, position</tags>
</US_DocBloc>
]]
  if projectfilenamewithpath==nil or type(projectfilenamewithpath)~="string" then ultraschall.AddErrorMessage("GetProject_GetRegion", "projectfilename_with_path", "Must be a string", -5)  return -1 end
  if reaper.file_exists(projectfilenamewithpath)==false then ultraschall.AddErrorMessage("GetProject_GetRegion", "projectfilenamewithpath", "Projectfile does not exist", -1)  return false end
  idx=tonumber(idx)
  if idx==nil then ultraschall.AddErrorMessage("GetProject_GetRegion", "idx", "No valid value given. Only integer numbers are allowed.", -2)  return false end
  local A,B,C=ultraschall.GetProject_CountMarkersAndRegions(projectfilenamewithpath)
  if tonumber(idx)>B then ultraschall.AddErrorMessage("GetProject_GetRegion", "idx", "Only "..B.." regions available.", -3)  return false end
  if tonumber(idx)<1 then ultraschall.AddErrorMessage("GetProject_GetRegion", "idx", "Only positive values allowed.", -4)  return false end
  local A=ultraschall.ReadValueFromFile(projectfilenamewithpath,"MARKER", false)
  local L,LL=ultraschall.SplitStringAtLineFeedToArray(A)
  
  local regions=0
  local marker=0
  local marktemp, marktemp2
  local count=0
  for i=L,1,-1 do
    if LL[i]:match("MARKER .* (.) .- 1 .")=="0" then table.remove(LL,i) end
  end
  
  for i=1,B*2,2 do
    count=count+1
    if count==idx then
      marktemp=LL[i]
      marktemp2=LL[i+1]
    end
  end
    
  local markname
  local markid=marktemp:match("MARKER (.-) ")
  local markpos=marktemp:match("MARKER .- (.-) ")
  local markendpos=marktemp2:match("MARKER .- (.-) ")
  local marktemp=marktemp:match("MARKER .- .- (.*)")
  if marktemp:sub(1,1)=="\"" then markname=marktemp:match("\"(.-)\"") marktemp=marktemp:match("\".-\" (.*)")
  else markname=marktemp:match("(.-) ") marktemp=marktemp:match(".- (.*)")
  end
  local markcolor=marktemp:match(".- (.-) ")

  return true, markid, markpos, markendpos, markname, markcolor
end


function ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountItemsInTrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer countitems = ultraschall.CountItemsInTrackStateChunk(string trackstatechunk)</functioncall>
  <description>
    returns the number of items in a trackstatechunk
    
    returns -1 in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
  </parameters>
  <retvals>
    integer countitems - number of items in the trackstatechunk
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, get</tags>
</US_DocBloc>
]]

  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("CountItemsInTrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -1) return -1 end
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("CountItemsInTrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -2) return -1 end
  local count=0

  while trackstatechunk:match("<ITEM")~=nil do
    count=count+1
    trackstatechunk=trackstatechunk:match("<ITEM.-(<ITEM.*)")
    if trackstatechunk==nil then break end 
  end
  return count
end


function ultraschall.GetItemStateChunkFromTrackStateChunk(trackstatechunk, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemStateChunkFromTrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string mediaitemstatechunk = ultraschall.GetItemStateChunkFromTrackStateChunk(string trackstatechunk, integer idx)</functioncall>
  <description>
    Returns a mediaitemstatechunk of the idx'th item in trackstatechunk.
    
    returns false in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    integer idx - the number of the item you want to have returned as mediaitemstatechunk
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
    string mediaitemstatechunk - number of items in the trackstatechunk
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, get</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("GetItemStateChunkFromTrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -1) return false end
  local nums=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  if nums==-1 then ultraschall.AddErrorMessage("GetItemStateChunkFromTrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -2) return false end
  if nums<idx then ultraschall.AddErrorMessage("GetItemStateChunkFromTrackStateChunk", "idx", "only "..nums.." items in trackstatechunk", -3) return false end
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("GetItemStateChunkFromTrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -4) return false end
  local count=0
  local temptrackstatechunk=""
  while trackstatechunk:match("<ITEM")~=nil do
    count=count+1
    if count==idx then
      temptrackstatechunk=trackstatechunk:match("(<ITEM.-)<ITEM")
      if temptrackstatechunk==nil then temptrackstatechunk=trackstatechunk:match("(<ITEM.*)") end
    end
    
    trackstatechunk=trackstatechunk:match("<ITEM.-(<ITEM.*)")
    if trackstatechunk==nil then break end 
  end
  return true, temptrackstatechunk  
end




function ultraschall.AddMediaItemStateChunk_To_TrackStateChunk(trackstatechunk, mediaitemstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddMediaItemStateChunk_To_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackstatechunk = ultraschall.AddMediaItemStateChunk_To_TrackStateChunk(string trackstatechunk, string mediaitemstatechunk)</functioncall>
  <description>
    Adds the item mediaitemstatechunk into trackstatechunk and returns this altered trackstatechunk.
    
    returns nil in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    string mediaitemstatechunk - a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk
  </parameters>
  <retvals>
    string trackstatechunk - the new trackstatechunk with mediaitemstatechunk added
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, add</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("AddMediaItemStateChunk_To_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed, not "..type(trackstatechunk), -1) return nil end
  if type(mediaitemstatechunk)~="string" then ultraschall.AddErrorMessage("AddMediaItemStateChunk_To_TrackStateChunk", "mediaitemstatechunk", "only mediaitemstatechunk is allowed, not "..type(mediaitemstatechunk), -2) return nil end
  if trackstatechunk:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("AddMediaItemStateChunk_To_TrackStateChunk", "trackstatechunk", "not a valid trackstatechunk", -3) return nil end
  if mediaitemstatechunk:match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("AddMediaItemStateChunk_To_TrackStateChunk", "mediaitemstatechunk", "not a valid mediaitemstatechunk", -4) return nil end
  return trackstatechunk:match("(.*)>")..mediaitemstatechunk..">"
end



function ultraschall.RemoveMediaItem_TrackStateChunk(trackstatechunk, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RemoveMediaItem_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string trackstatechunk = ultraschall.RemoveMediaItem_TrackStateChunk(string trackstatechunk, integer idx)</functioncall>
  <description>
    Deletes the idx'th item from trackstatechunk and returns this altered trackstatechunk.
    
    returns nil in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    integer idx - the number of the item you want to delete
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
    string trackstatechunk - the new trackstatechunk with the idx'th item deleted
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, delete</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("RemoveMediaItem_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -1) return false end
  local nums=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  if nums==-1 then ultraschall.AddErrorMessage("RemoveMediaItem_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -2) return false end
  if nums<idx then ultraschall.AddErrorMessage("RemoveMediaItem_TrackStateChunk", "idx", "only "..nums.." items in trackstatechunk", -3) return false end
  if idx<1 then ultraschall.AddErrorMessage("RemoveMediaItem_TrackStateChunk", "idx", "only positive values allowed, beginning with 1", -4) return false end
  local begin=trackstatechunk:match("(.-)<ITEM.*")
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("RemoveMediaItem_TrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -5) return false end
  local count=0
  local temptrackstatechunk=""
  while trackstatechunk:match("<ITEM")~=nil do
    count=count+1
    if count~=idx then
      local temptrackstatechunk2=trackstatechunk:match("(<ITEM.-)<ITEM")
      if temptrackstatechunk2==nil then temptrackstatechunk2=trackstatechunk:match("(<ITEM.*)") end
      temptrackstatechunk=temptrackstatechunk..temptrackstatechunk2
    end
    trackstatechunk=trackstatechunk:match("<ITEM.-(<ITEM.*)")
    if trackstatechunk==nil then break end 
  end
  return true, begin..temptrackstatechunk
end


function ultraschall.RemoveMediaItemByIGUID_TrackStateChunk(trackstatechunk, IGUID)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RemoveMediaItemByIGUID_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string trackstatechunk = ultraschall.RemoveMediaItemByIGUID_TrackStateChunk(string trackstatechunk, string IGUID)</functioncall>
  <description>
    Deletes the item with the iguid IGUID from trackstatechunk and returns this altered trackstatechunk.
    
    returns nil in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    string IGUID - the IGUID of the item you want to delete
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
    string trackstatechunk - the new trackstatechunk with the IGUID-item deleted
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, delete, iguid</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("RemoveMediaItemByIGUID_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -1) return false end
  if trackstatechunk:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("RemoveMediaItemByIGUID_TrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -2) return false end
  local nums=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  local begin=trackstatechunk:match("(.-)<ITEM.*")
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("RemoveMediaItemByIGUID_TrackStateChunk", "trackstatechunk", "no items in trackstatechunk", -3) return false end
  local count=0
  local temptrackstatechunk=""
  local dada
  for i=1,nums do
    local L,M=ultraschall.GetItemStateChunkFromTrackStateChunk(trackstatechunk, i)
    if ultraschall.GetItemIGUID(M)~=IGUID then temptrackstatechunk=temptrackstatechunk..M end
  end
  local lt=ultraschall.CountCharacterInString(begin..temptrackstatechunk,"<")
  local gt=ultraschall.CountCharacterInString(begin..temptrackstatechunk,">")
  if gt<lt then dada=">\n" else dada="" end
  return true, begin..temptrackstatechunk..dada
end

function ultraschall.RemoveMediaItemByGUID_TrackStateChunk(trackstatechunk, GUID)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RemoveMediaItemByGUID_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string trackstatechunk = ultraschall.RemoveMediaItemByGUID_TrackStateChunk(string trackstatechunk, string GUID)</functioncall>
  <description>
    Deletes the item with the guid GUID from trackstatechunk and returns this altered trackstatechunk.
    
    returns nil in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    string GUID - the GUID of the item you want to delete
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
    string trackstatechunk - the new trackstatechunk with the GUID-item deleted
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, media, item, statechunk, chunk, delete, guid</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("RemoveMediaItemByGUID_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -1) return false end
  if trackstatechunk:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("RemoveMediaItemByGUID_TrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -2) return false end
  local nums=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  local begin=trackstatechunk:match("(.-)<ITEM.*")
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("RemoveMediaItemByGUID_TrackStateChunk", "trackstatechunk", "no items in trackstatechunk", -3) return false end
  local count=0
  local temptrackstatechunk=""
  local dada
  for i=1,nums do
    local L,M=ultraschall.GetItemStateChunkFromTrackStateChunk(trackstatechunk, i)
    if ultraschall.GetItemGUID(M)~=GUID then temptrackstatechunk=temptrackstatechunk..M 
    else 
    end
  end
  local lt=ultraschall.CountCharacterInString(begin..temptrackstatechunk,"<")
  local gt=ultraschall.CountCharacterInString(begin..temptrackstatechunk,">")
  if gt<lt then dada=">\n" else dada="" end
  return true, begin..temptrackstatechunk..dada
end

function ultraschall.OnlyTracksInBothTrackstrings(trackstring1, trackstring2)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyTracksInBothTrackstrings</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, string trackstring, array trackstringarray, integer number_of_entries = ultraschall.OnlyTracksInBothTrackstrings(string trackstring1, string trackstring2)</functioncall>
  <description>
    returns a new trackstring, that contains only the tracknumbers, that are in trackstring1 and trackstring2.
    
    returns -1 in case of error
  </description>
  <parameters>
    string trackstring1 - a string with the tracknumbers, separated by commas
    string trackstring2 - a string with the tracknumbers, separated by commas
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    string trackstring - the cleared trackstring, -1 in case of error
    array trackstringarray - the "cleared" trackstring as an array
    integer number_of_entries - the number of entries in the trackstring
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, trackstring, sort, order</tags>
</US_DocBloc>
]]
  if type(trackstring1)~="string" then ultraschall.AddErrorMessage("OnlyTracksInBothTrackstrings", "trackstring1", "not a valid trackstring", -1) return -1 end
  if type(trackstring2)~="string" then ultraschall.AddErrorMessage("OnlyTracksInBothTrackstrings", "trackstring2", "not a valid trackstring", -2)return -1 end
  local A,A2,A3,A4=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring1)
  local B,B2,B3,B4=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring2)
  local newtrackstring=""
  for i=1, A4 do
    for a=1, B4 do
      if A3[i]==B3[a] then newtrackstring=newtrackstring..A3[i].."," end
    end
  end
  return ultraschall.RemoveDuplicateTracksInTrackstring(newtrackstring)
end

function ultraschall.OnlyTracksInOneTrackstring(trackstring1, trackstring2)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyTracksInOneTrackstring</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, string trackstring, array trackstringarray, integer number_of_entries = ultraschall.OnlyTracksInOneTrackstring(string trackstring1, string trackstring2)</functioncall>
  <description>
    returns a new trackstring, that contains only the tracknumbers, that are in either trackstring1 or trackstring2, NOT in both!
    
    returns -1 in case of error
  </description>
  <parameters>
    string trackstring1 - a string with the tracknumbers, separated by commas
    string trackstring2 - a string with the tracknumbers, separated by commas
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
    string trackstring - the cleared trackstring, -1 in case of error
    array trackstringarray - the "cleared" trackstring as an array
    integer number_of_entries - the number of entries in the trackstring
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, trackstring, sort, order</tags>
</US_DocBloc>
]]
  if type(trackstring1)~="string" then ultraschall.AddErrorMessage("OnlyTracksInOneTrackstring", "trackstring1", "not a valid trackstring", -1) return -1 end
  if type(trackstring2)~="string" then ultraschall.AddErrorMessage("OnlyTracksInOneTrackstring", "trackstring2", "not a valid trackstring", -2) return -1 end
  local A,A2,A3,A4=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring1)
  local B,B2,B3,B4=ultraschall.RemoveDuplicateTracksInTrackstring(trackstring2)
  local newtrackstring=""
  local count=0
  for i=A4, 1, -1 do
    for a=B4, 1, -1 do
      if A3[i]==B3[a] then table.remove(A3,i) table.remove(B3,a) count=count+1 end
    end
  end

  for i=1,A4-count do
      newtrackstring=newtrackstring..A3[i]..","
  end

  for i=1,B4-count do
      newtrackstring=newtrackstring..B3[i]..","
  end
    
  return ultraschall.RemoveDuplicateTracksInTrackstring(newtrackstring)
end


function ultraschall.SetMediaItemStateChunk_in_TrackStateChunk(trackstatechunk, idx, mediaitemstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetMediaItemStateChunk_in_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string trackstatechunk = ultraschall.SetMediaItemStateChunk_in_TrackStateChunk(string trackstatechunk, integer idx, string mediaitemstatechunk)</functioncall>
  <description>
    Overwrites the idx'th item from trackstatechunk with mediaitemstatechunk and returns this altered trackstatechunk.
    
    returns nil in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by reaper's api function reaper.GetTrackStateChunk
    integer idx - the number of the item you want to delete
    string mediaitemstatechunk - a mediaitemstatechunk, as returned by reaper's api function reaper.GetItemStateChunk
  </parameters>
  <retvals>
    boolean retval - true in case of success, false in case of error
    string trackstatechunk - the new trackstatechunk with the idx'th item replaced
  </retvals>
  <chapter_context>
    MediaItem Management
    Set MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, chunk, set</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed, not "..type(trackstatechunk), -1) return false end
  if type(mediaitemstatechunk)~="string" then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "mediaitemstatechunk", "only mediaitemstatechunk is allowed, not "..type(mediaitemstatechunk), -2) return false end
  local nums=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  if nums==-1 then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "trackstatechunk", "only trackstatechunk is allowed", -3) return false end
  if nums<idx then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "idx", "only "..nums.." items in trackstatechunk", -4) return false end
  if idx<1 then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "idx", "only positive values allowed, beginning with 1", -5) return false end
  if mediaitemstatechunk:match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "mediaitemstatechunk", "not a valid mediaitemstatechunk", -6) return false end
  local begin=trackstatechunk:match("(.-)<ITEM.*")
  trackstatechunk=trackstatechunk:match("<ITEM.*")
  if trackstatechunk==nil then ultraschall.AddErrorMessage("SetMediaItemStateChunk_in_TrackStateChunk", "trackstatechunk", "no valid trackstatechunk", -7) return false end
  local count=0
  local add
  local temptrackstatechunk=""
  while trackstatechunk:match("<ITEM")~=nil do
    count=count+1
    if count~=idx then
      local temptrackstatechunk2=trackstatechunk:match("(<ITEM.-)<ITEM")
      if temptrackstatechunk2==nil then temptrackstatechunk2=trackstatechunk:match("(<ITEM.*)") end
      temptrackstatechunk=temptrackstatechunk..temptrackstatechunk2
    else
      temptrackstatechunk=temptrackstatechunk..mediaitemstatechunk
    end
    trackstatechunk=trackstatechunk:match("<ITEM.-(<ITEM.*)")
    if trackstatechunk==nil then break end 
  end
  if idx==nums then add=">" 
  else add=""
  end
  return true, begin..temptrackstatechunk..add
end



function ultraschall.GetSelectedMediaItemsAtPosition(position, trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSelectedMediaItemsAtPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemArray = ultraschall.GetSelectedMediaItemsAtPosition(number position, string trackstring)</functioncall>
  <description>
    Returns all selected items at position in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.
    
    returns -1 in case of error
  </description>
  <parameters>
    number position - position in seconds
    string trackstring - the tracknumbers, separated by commas
  </parameters>
  <retvals>
    integer count - the number of entries in the returned MediaItemArray
    array MediaItemArray - the found MediaItems returned as an array
  </retvals>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, get, selected, selection</tags>
</US_DocBloc>
]]
  if type(position)~="number" then ultraschall.AddErrorMessage("GetSelectedMediaItemsAtPosition", "position", "must be a number", -1) return -1 end
  local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if retval==-1 then ultraschall.AddErrorMessage("GetSelectedMediaItemsAtPosition", "trackstring", "not a valid value. Must be a string with numbers,separated by commas, e.g. \"1,2,4,6,8\"", -2) return -1 end
  local Number_of_items, MediaItemArray, MediaItemStateChunkArray = ultraschall.GetMediaItemsAtPosition(position, trackstring)
  if Number_of_items==-1 then ultraschall.AddErrorMessage("GetSelectedMediaItemsAtPosition", "trackstring", "not a valid value. Must be a string with numbers,separated by commas, e.g. \"1,2,4,6,8\"", -3) return -1 end
  local SelectedMediaItemArray={}
  local count=0
  for i=1,Number_of_items do
    if reaper.GetMediaItemInfo_Value(MediaItemArray[i], "B_UISEL")==1 then 
      count=count+1 
      SelectedMediaItemArray[count]=MediaItemArray[i] 
    end
  end
  return count, SelectedMediaItemArray
end

function ultraschall.GetSelectedMediaItemsBetween(startposition, endposition, trackstring, inside)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSelectedMediaItemsBetween</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemArray = ultraschall.GetSelectedMediaItemsBetween(number startposition, number endposition, string trackstring, boolean inside)</functioncall>
  <description>
    Returns all selected items between startposition and endposition in the tracks as given by trackstring, as MediaItemArray. Empty MediaItemAray if none is found.
    
    returns -1 in case of error
  </description>
  <parameters>
    number startposition - startposition in seconds
    number endposition - endposition in seconds
    string trackstring - the tracknumbers, separated by commas
    boolean inside - true, only items completely within start/endposition; false, also items, that are partially within start/endposition
  </parameters>
  <retvals>
    integer count - the number of entries in the returned MediaItemArray
    array MediaItemArray - the found MediaItems returned as an array
  </retvals>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, get, selected, selection, startposition, endposition</tags>
</US_DocBloc>
]]
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("GetSelectedMediaItemsBetween", "inside", "must be either true or false", -1) return -1 end
  if type(startposition)~="number" then ultraschall.AddErrorMessage("GetSelectedMediaItemsBetween", "startposition", "must be a number", -2) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("GetSelectedMediaItemsBetween", "endposition", "must be a number", -3) return -1 end
  local retval, trackstring, trackstringarray, number_of_entries = ultraschall.RemoveDuplicateTracksInTrackstring(trackstring)
  if retval==-1 then ultraschall.AddErrorMessage("GetSelectedMediaItemsBetween", "trackstring", "not a valid value. Must be a string with numbers,separated by commas, e.g. \"1,2,4,6,8\"", -4) return -1 end
  local Number_of_items, MediaItemArray, MediaItemStateChunkArray = ultraschall.GetAllMediaItemsBetween(startposition, endposition, trackstring, inside)
  if Number_of_items==-1 then ultraschall.AddErrorMessage("GetSelectedMediaItemsBetween", "trackstring", "not a valid value. Must be a string with numbers,separated by commas, e.g. \"1,2,4,6,8\"", -5) return -1 end
  local SelectedMediaItemArray={}
  local count=0
  for i=1,Number_of_items do
    if reaper.GetMediaItemInfo_Value(MediaItemArray[i], "B_UISEL")==1 then 
      count=count+1 
      SelectedMediaItemArray[count]=MediaItemArray[i] 
    end
  end
  return count, SelectedMediaItemArray
end


function ultraschall.DeselectMediaItems_MediaItemArray(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeselectMediaItems_MediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.DeselectMediaItems_MediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Deselects all MediaItems, that are in MediaItemArray.
    
    returns -1 in case of error
  </description>
  <parameters>
    array MediaItemArray - an array with all the MediaItemObjects, that shall be deselected
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selected, selection, deselect, unselect</tags>
</US_DocBloc>
]]
  if type(MediaItemArray)~="table" then ultraschall.AddErrorMessage("DeselectMediaItems_MediaItemArray", "MediaItemArray", "must be an array with MediaItem-objects", -1) return -1 end
  local count=1
  while MediaItemArray[count]~=nil do
    if reaper.ValidatePtr(MediaItemArray[count], "MediaItem*")==true then 
      reaper.SetMediaItemInfo_Value(MediaItemArray[count], "B_UISEL", 0)
    end
    count=count+1
  end
  return 1
end

function ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SelectMediaItems_MediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SelectMediaItems_MediaItemArray(array MediaItemArray)</functioncall>
  <description>
    Selects all MediaItems, that are in MediaItemArray.
    
    returns -1 in case of error
  </description>
  <parameters>
    array MediaItemArray - an array with all the MediaItemObjects, that shall be selected
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, selected, selection, select</tags>
</US_DocBloc>
]]
  if type(MediaItemArray)~="table" then ultraschall.AddErrorMessage("SelectMediaItems_MediaItemArray", "MediaItemArray", "must be an array with MediaItem-objects", -1) return -1 end
  local count=1
  while MediaItemArray[count]~=nil do
    if reaper.ValidatePtr(MediaItemArray[count], "MediaItem*")==true then 
      reaper.SetMediaItemInfo_Value(MediaItemArray[count], "B_UISEL", 1)
    end
    count=count+1
  end
  return 1
end


function ultraschall.GetAllMediaItemsFromTrackStateChunk(trackstatechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItemsFromTrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemStateChunkArray = ultraschall.GetAllMediaItemsFromTrackStateChunk(string trackstatechunk)</functioncall>
  <description>
    Returns a MediaItemStateChunkArray with all items in trackstatechunk.
    
    returns -1 in case of error
  </description>
  <parameters>
    string trackstatechunk - a trackstatechunk, as returned by functions like reaper.GetTrackStateChunk
  </parameters>
  <retvals>
    integer count - number of MediaItemStateChunks in the returned array. -1 in case of error
    array MediaItemStateChunkArray - an array with all MediaItemStateChunks from trackstatechunk
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, get, trackstatechunk, mediaitemstatechunk, mediaitemstatechunkarray</tags>
</US_DocBloc>
]]
  if type(trackstatechunk)~="string" or trackstatechunk:match("<TRACK.*>")==nil then ultraschall.AddErrorMessage("GetAllMediaItemsFromTrackStateChunk", "trackstatechunk", "not a valid trackstatechunk", -1) return -1 end
  local A=trackstatechunk:match("<ITEM.*>")
  if A==nil then ultraschall.AddErrorMessage("GetAllMediaItemsFromTrackStateChunk", "trackstatechunk", "no MediaItems in trackstatechunk", -2) return -1 end
  local MediaItemStateChunkArray={}
  local retval
  local count=ultraschall.CountItemsInTrackStateChunk(trackstatechunk)
  for i=1, count do
    retval, MediaItemStateChunkArray[i] = ultraschall.GetItemStateChunkFromTrackStateChunk(trackstatechunk, i) 
  end
  return count, MediaItemStateChunkArray
end


--------------------------------------------------
------ ULTRASCHALL FRAMEWORK 4.00 BETA 2.6 -------
--------------------------------------------------

function ultraschall.CreateTrackString_AllTracks()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackString_AllTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackString_AllTracks()</functioncall>
  <description>
    Returns a trackstring with all tracknumbers from the current project.
    
    Returns an empty string, if no track is available.
  </description>
  <retvals>
    string trackstring - a string with all tracknumbers, separated by commas.
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, tracks, trackstring</tags>
</US_DocBloc>
]]

  local trackstring=""
  for i=1, reaper.CountTracks(0) do
    trackstring=trackstring..i..","
  end
  return trackstring:sub(1,-2)
end

function ultraschall.GetEnvelopePoint(Tracknumber, EnvelopeName, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetEnvelopePoint</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number time, number value, integer shape, number tension, boolean selected, number dBVal, array EnvelopePointObject = ultraschall.GetEnvelopePoint(integer Tracknumber, string EnvelopeName, integer idx)</functioncall>
  <description>
    Returns the values for the idxth envelope point in Tracknumber->EnvelopeName.
    
    returns -1 in case of error
  </description>
  <parameters>
    integer Tracknumber - the number of the track, beginning with 1. Use 0 for Master Track.
    string EnvelopeName - the name of the envelope-lane
    integer idx - the number of the envelope-point, beginning with 0
  </parameters>
  <retvals>
    number time - the time of the envelope point
    number value - the raw-value of the envelope point
    integer shape - the shape of this envelope
    -0 - Linear
    -1 - Square
    -2 - Slow start/end
    -3 - Fast start
    -4 - Fast end
    -5 - Bezier
    number tension - the intensity of the tension of the shape
    boolean selected - true, if this point is selected; false if not
    number dBVal - the envelopevalue converted to dB
    array EnvelopePointObject - an array with all elements of an envelopepoint
    -[1] - TrackEnvelope-object
    -[2] - Envelope-idx
    -[3] - time
    -[4] - value
    -[5] - shape
    -[6] - tension
    -[7] - selected
    -[8] - dBValue converted from value
  </retvals>
  <chapter_context>
    Envelope Management
    Get Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, get, db, time, value, envelopepointobject</tags>
</US_DocBloc>
]]
  if math.type(Tracknumber)~="integer" then ultraschall.AddErrorMessage("GetEnvelopePoint", "track", "must be an integer", -1) return -1 end
  if type(EnvelopeName)~="string" then ultraschall.AddErrorMessage("GetEnvelopePoint", "EnvelopeName", "must be a string", -6) return -1 end
  local MediaTrack
  local EnvelopePointObject={}
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetEnvelopePoint","idx", "must be an integer", -2) return -1 end
  if Tracknumber<0 or Tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetEnvelopePoint", "track", "no such track", -3) return -1 end
  if Tracknumber==0 then 
    MediaTrack=reaper.GetMasterTrack(0)
  else
    MediaTrack=reaper.GetTrack(0,Tracknumber-1)
  end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, EnvelopeName)
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetEnvelopePoint","EnvelopeName", "no such envelope", -4) return -1 end
  local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, idx)
  if retval==false then ultraschall.AddErrorMessage("GetEnvelopePoint","idx", "no such envelopepoint", -5) return -1 end
  local dBVal=reaper.SLIDER2DB(value)
  EnvelopePointObject[1]=TrackEnvelope
  EnvelopePointObject[2]=idx
  EnvelopePointObject[3]=time
  EnvelopePointObject[4]=value
  EnvelopePointObject[5]=shape
  EnvelopePointObject[6]=tension
  EnvelopePointObject[7]=selected
  EnvelopePointObject[8]=dBVal
  return time, value, shape, tension, selected, dBVal, EnvelopePointObject
end

--ultraschall.GetEnvelopePoint(1, "Mute", 1)

function ultraschall.GetClosestEnvelopePointIDX_ByTime(Tracknumber, EnvelopeName, CheckTime)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetClosestEnvelopePointIDX_ByTime</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer idxpre, array EnvelopePointObjectPre, integer idxpost, array EnvelopePointObjectPost = ultraschall.GetClosestEnvelopePointIDX_ByTime(integer Tracknumber, string EnvelopeName, number CheckTime)</functioncall>
  <description>
    Returns the idxs and EnvelopePointObject of the envelope-points closest to timeposition CheckTime
    returns -1 in case of error
  </description>
  <parameters>
    integer Tracknumber - the number of the track, beginning with 1. Use 0 for Master Track.
    string EnvelopeName - the name of the envelope-lane
    number CheckTime - the time in seconds to check for the closest envelope-points
  </parameters>
  <retvals>
    integer idxpre - the idx of the closest envelopepoint at or before CheckTime
    array EnvelopePointObjectPre - an EnvelopePointObject of idxpre
    integer idxpost - the idx of the closest envelopepoint after CheckTime
    array EnvelopePointObjectPost - an EnvelopePointObject of idxpost
  </retvals>
  <chapter_context>
    Envelope Management
    Get Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, get, idx, closest, previous, following, envelopepointobject</tags>
</US_DocBloc>
]]
  if math.type(Tracknumber)~="integer" then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime", "Tracknumber", "must be an integer", -1) return -1 end
  if type(EnvelopeName)~="string" then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime", "EnvelopeName", "must be a string", -6) return -1 end
  if type(CheckTime)~="number" then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime", "CheckTime", "must be a number", -7) return -1 end

  local MediaTrack, IDXpre, IDXpost, ding, EnvelopePointObjectPre, EnvelopePointObjectPost, value, shape, tension, selected, dBVal, time
  
  if CheckTime<0 then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime","CheckTime", "time must be 0 or higher", -3) return -1 end
  if Tracknumber<0 or Tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime","Tracknumber", "no such track", -4) return -1 end
  if Tracknumber==0 then 
    MediaTrack=reaper.GetMasterTrack(0)
  else
    MediaTrack=reaper.GetTrack(0,Tracknumber-1)
  end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, EnvelopeName)
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetClosestEnvelopePointIDX_ByTime","EnvelopeName", "no such envelope", -5) return -1 end

  for i=0, reaper.CountEnvelopePoints(TrackEnvelope) do
    local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, i)
    IDXpre=i-1 IDXpost=i
    if time>CheckTime and ding~=true then break end
  end

  time, value, shape, tension, selected, dBVal, EnvelopePointObjectPre = ultraschall.GetEnvelopePoint(Tracknumber, EnvelopeName, IDXpre)
  if time==-1 then ultraschall.DeleteLastErrorMessage() end
  time, value, shape, tension, selected, dBVal, EnvelopePointObjectPost = ultraschall.GetEnvelopePoint(Tracknumber, EnvelopeName, IDXpost)
  if time==-1 then ultraschall.DeleteLastErrorMessage() end
  
  return IDXpre, EnvelopePointObjectPre, IDXpost, EnvelopePointObjectPost
end

--ultraschall.GetClosestEnvelopePointIDX_ByTime(1, "", 1)

function ultraschall.GetEnvelopePointIDX_Between(Tracknumber, EnvelopeName, startposition, endposition)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetEnvelopePointIDX_Between</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string EnvelopeString, array EnvelopePointArray = ultraschall.GetEnvelopePointIDX_Between(integer Tracknumber, string EnvelopeName, number startposition, number endposition)</functioncall>
  <description>
    Returns a string and an EnvelopePointArray with all idx/EnvelopePointObjects of all envelopepoints between startposition and endposition in the EnvelopeName-lane.
    returns -1 in case of error
  </description>
  <parameters>
    integer Tracknumber - the number of the track. 1 for track 1, 2 for track 2, etc. 0 for Master-track.
    string EnvelopeName - the name of the envelope-lane, where you want to have the envelope-points of.
    number startposition - the startposition of the selection in seconds. Must be bigger than or equal 0.
    number endposition - the endposition of the selection in seconds. Must be bigger than startposition.
  </parameters>
  <retvals>
    string EnvelopeString - a string with all envelope-point-idx in the selection, separated by commas.
    array EnvelopePointArray - an array with all EnvelopePointObjects of all envelope-points in selection.
  </retvals>
  <chapter_context>
    Envelope Management
    Get Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, get, idx, selection, envelopepointobject, envelopepointarray</tags>
</US_DocBloc>
]]
  if math.type(Tracknumber)~="integer" then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between", "Tracknumber", "must be an integer", -1) return -1 end
  if type(EnvelopeName)~="string" then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between", "EnvelopeName", "must be a string", -8) return -1 end
  if type(startposition)~="number" then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between", "startposition", "must be a number", -9) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between", "endposition", "must be a number", -10) return -1 end

  local MediaTrack
  local EnvelopePointObjectArray={}
  local EnvelopeString=""
  local count=1

  if startposition<0 then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between","startposition", "time must be 0 or higher", -4) return -1 end
  if endposition<=startposition then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between","endposition", "time must be equal or higher than startposition", -5) return -1 end
  if Tracknumber<0 or Tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between","Tracknumber", "no such track", -6) return -1 end
  if Tracknumber==0 then 
    MediaTrack=reaper.GetMasterTrack(0)
  else
    MediaTrack=reaper.GetTrack(0,Tracknumber-1)
  end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, EnvelopeName)
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("GetEnvelopePointIDX_Between","EnvelopeName", "no such envelope", -7) return -1 end

  for i=0, reaper.CountEnvelopePoints(TrackEnvelope) do
    local retval, time, value, shape, tension, selected = reaper.GetEnvelopePoint(TrackEnvelope, i)
    if time>=startposition and time<=endposition then 
      EnvelopePointObjectArray[count]={}
      EnvelopePointObjectArray[count][1]=TrackEnvelope
      EnvelopePointObjectArray[count][2]=i
      EnvelopePointObjectArray[count][3]=time
      EnvelopePointObjectArray[count][4]=value
      EnvelopePointObjectArray[count][5]=shape
      EnvelopePointObjectArray[count][6]=tension
      EnvelopePointObjectArray[count][7]=selected
      EnvelopePointObjectArray[count][8]=reaper.SLIDER2DB(value)
      count=count+1 
      EnvelopeString=EnvelopeString..i.."," 
    end
  end
  return EnvelopeString:sub(1,-2), EnvelopePointObjectArray
end

--ultraschall.GetEnvelopePointIDX_Between(1,"",1,1)


function ultraschall.CheckEnvelopePointObject(EnvelopePointObject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckEnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.CheckEnvelopePointObject(array EnvelopePointObject)</functioncall>
  <description>
    Checks, if EnvelopePointObject is valid or not.
  </description>
  <parameters>
    array EnvelopePointObject - an array with all information of an envelope point
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, check, envelopepointobject</tags>
</US_DocBloc>
]]

  if EnvelopePointObject==nil then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject", "no nil allowed", -1) return false end
  if type(EnvelopePointObject)~="table" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject", "no EnvelopePointObject", -2) return false end
  if reaper.ValidatePtr(EnvelopePointObject[1], "TrackEnvelope*")==false then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[1]", "contains no TrackEnvelope-object", -3) return false end
  if type(EnvelopePointObject[2])~="number" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[2]", "invalid idx-number", -4) return false end
  if type(EnvelopePointObject[3])~="number" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[3]", "invalid time", -5) return false end
  if type(EnvelopePointObject[4])~="number" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[4]", "invalid value", -6) return false end
  if type(EnvelopePointObject[5])~="number" or (EnvelopePointObject[5]<0 or EnvelopePointObject[5]>5) then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[5]", "invalid shape-value, 0-5 is allowed", -7) return false end
  if type(EnvelopePointObject[6])~="number" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[6]", "invalid tension-value, must be a number.", -8) return false end
  if type(EnvelopePointObject[7])~="boolean" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[7]", "invalid selection-value, must be boolean.", -9) return false end
  if type(EnvelopePointObject[8])~="number" then ultraschall.AddErrorMessage("CheckEnvelopePointObject","EnvelopePointObject[6]", "invalid dBvalue, must be a number.", -10) return false end
  return true
end

function ultraschall.IsValidEnvelopePointObject(EnvelopePointObject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidEnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidEnvelopePointObject(array EnvelopePointObject)</functioncall>
  <description>
    Checks, if EnvelopePointObject is valid or not.
  </description>
  <parameters>
    array EnvelopePointObject - an array with all information of an envelope point
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, check, envelopepointobject</tags>
</US_DocBloc>
]]
  local retval, errcode, functionname, parmname, errormessage, lastreadtime, err_creation_date, err_creation_timestamp, errorcounter0 = ultraschall.GetLastErrorMessage()
  local A=ultraschall.CheckEnvelopePointObject(EnvelopePointObject)
  local retval, errcode, functionname, parmname, errormessage, lastreadtime, err_creation_date, err_creation_timestamp, errorcounter = ultraschall.GetLastErrorMessage() 
  if errorcounter0~=errorcounter and functionname=="CheckEnvelopePointObject" then ultraschall.AddErrorMessage("IsValidEnvelopePointObject",parmname, errormessage, errcode) return false end
  return A
end
--A=ultraschall.IsValidEnvelopePointObject("")


function ultraschall.SetEnvelopePoints_EnvelopePointObject(EnvelopePointObject, sort_in)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetEnvelopePoints_EnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetEnvelopePoints_EnvelopePointObject(array EnvelopePointObject, boolean sort_in)</functioncall>
  <description>
    Sets an envelope-point, as defined in EnvelopePointObject.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointObject - an array with all information of an envelope point
    boolean sort_in - set true, if setting multiple points at once and call Envelope_SortPoints when done.
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, set, envelopepointobject</tags>
</US_DocBloc>
]]
  if type(sort_in)~="boolean" then ultraschall.AddErrorMessage("SetEnvelopePoints_EnvelopePointObject","sort_in", "only boolean allowed", -1) return false end
  if ultraschall.CheckEnvelopePointObject(EnvelopePointObject)==false then ultraschall.AddErrorMessage("SetEnvelopePoints_EnvelopePointObject","EnvelopePointObject", "not a valid EnvelopePointObject", -2) return false end
  return reaper.SetEnvelopePoint(EnvelopePointObject[1], EnvelopePointObject[2], EnvelopePointObject[3], EnvelopePointObject[4], EnvelopePointObject[5], EnvelopePointObject[6], EnvelopePointObject[7], sort_in)
end


function ultraschall.SetEnvelopePoints_EnvelopePointArray(EnvelopePointArray, sort_in)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetEnvelopePoints_EnvelopePointArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetEnvelopePoints_EnvelopePointArray(array EnvelopePointArray, boolean sort_in)</functioncall>
  <description>
    Sets envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointArray - an array with all EnvelopePointObjects you want to insert
    boolean sort_in - set true, if setting multiple points at once and call Envelope_SortPoints when done.
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, set, envelopepointobject, envelopepointarray</tags>
</US_DocBloc>
]]
  if type(sort_in)~="boolean" then ultraschall.AddErrorMessage("SetEnvelopePoints_EnvelopePointArray","sort_in", "only boolean allowed", -1) return false end
  if type(EnvelopePointArray)~="table" then ultraschall.AddErrorMessage("SetEnvelopePoints_EnvelopePointArray","EnvelopePointArray", "not an EnvelopePointArray", -2) return false end
  local count=1
  local falseification=true
  while EnvelopePointArray[count]~=nil do
    if ultraschall.CheckEnvelopePointObject(EnvelopePointArray[count])==false then ultraschall.AddErrorMessage("SetEnvelopePoints_EnvelopePointArray","EnvelopePointArray["..count.."]", "not an EnvelopePointObject", -3) falseification=false
    else
      reaper.SetEnvelopePoint(EnvelopePointArray[count][1], EnvelopePointArray[count][2], EnvelopePointArray[count][3], EnvelopePointArray[count][4], EnvelopePointArray[count][5], EnvelopePointArray[count][6], EnvelopePointArray[count][7], sort_in)
    end
    count=count+1
  end
  return falseification
end

function ultraschall.DeleteEnvelopePoints_EnvelopePointObject(EnvelopePointObject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteEnvelopePoints_EnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteEnvelopePoints_EnvelopePointObject(array EnvelopePointObject)</functioncall>
  <description>
    Deletes an envelope-point, as defined in EnvelopePointObject.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointObject - an array with all information of an envelope point
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, delete, envelopepointobject</tags>
</US_DocBloc>
]]
  if ultraschall.CheckEnvelopePointObject(EnvelopePointObject)==false then ultraschall.AddErrorMessage("DeleteEnvelopePoints_EnvelopePointObject","EnvelopePointObject", "not a valid EnvelopePointObject", -1) return false end
  BR_Envelope=reaper.BR_EnvAlloc(EnvelopePointObject[1], true)
  reaper.BR_EnvDeletePoint(BR_Envelope, EnvelopePointObject[2])
  return reaper.BR_EnvFree(BR_Envelope, true)
end


function ultraschall.DeleteEnvelopePoints_EnvelopePointArray(EnvelopePointArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteEnvelopePoints_EnvelopePointArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteEnvelopePoints_EnvelopePointArray(array EnvelopePointArray)</functioncall>
  <description>
    Deletes the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointArray - an array with all EnvelopePointObjects you want to insert
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, delete, envelopepointobject, envelopepointarray</tags>
</US_DocBloc>
]]
  if type(EnvelopePointArray)~="table" then ultraschall.AddErrorMessage("DeleteEnvelopePoints_EnvelopePointArray","EnvelopePointArray", "not an EnvelopePointArray", -1) return false end
  local count=1
  local falseification=true
  while EnvelopePointArray[count]~=nil do
    count=count+1
  end
  for i=count-1,1, -1 do
    if ultraschall.CheckEnvelopePointObject(EnvelopePointArray[i])==false then ultraschall.AddErrorMessage("DeleteEnvelopePoints_EnvelopePointArray","EnvelopePointArray["..i.."]", "not a valid EnvelopePointObject", -2) falseification=false
    else
      BR_Envelope=reaper.BR_EnvAlloc(EnvelopePointArray[i][1], true)
      retval1=reaper.BR_EnvDeletePoint(BR_Envelope, EnvelopePointArray[i][2])
      retval2=reaper.BR_EnvFree(BR_Envelope, true)
    end
  end
  return falseification
end


function ultraschall.AddEnvelopePoints_EnvelopePointObject(EnvelopePointObject, sort_in)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddEnvelopePoints_EnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.AddEnvelopePoints_EnvelopePointObject(array EnvelopePointObject, boolean sort_in)</functioncall>
  <description>
    Adds an envelope-point, as defined in EnvelopePointObject.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointObject - an array with all information of an envelope point
    boolean sort_in - set true, if setting multiple points at once and call Envelope_SortPoints when done.
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, add, envelopepointobject</tags>
</US_DocBloc>
]]
  if type(sort_in)~="boolean" then ultraschall.AddErrorMessage("AddEnvelopePoints_EnvelopePointObject","sort_in", "only boolean allowed", -1) return false end
  if ultraschall.CheckEnvelopePointObject(EnvelopePointObject)==false then ultraschall.AddErrorMessage("AddEnvelopePoints_EnvelopePointObject","EnvelopePointObject", "not a valid EnvelopePointObject", -2) return false end
  return reaper.InsertEnvelopePoint(EnvelopePointObject[1], EnvelopePointObject[3], EnvelopePointObject[4], EnvelopePointObject[5], EnvelopePointObject[6], EnvelopePointObject[7], sort_in)
end

function ultraschall.AddEnvelopePoints_EnvelopePointArray(EnvelopePointObjectArray, sort_in)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddEnvelopePoints_EnvelopePointArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.AddEnvelopePoints_EnvelopePointArray(array EnvelopePointArray, boolean sort_in)</functioncall>
  <description>
    Adds the envelope-points, as defined in the EnvelopePointObjects, in the EnvelopePointArray.
    returns true in case of success, false in case of failure.
  </description>
  <parameters>
    array EnvelopePointArray - an array with all EnvelopePointObjects you want to insert
    boolean sort_in - set true, if setting multiple points at once and call Envelope_SortPoints when done.
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid EnvelopePointObject; false if not
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, add, envelopepointobject, envelopepointarray</tags>
</US_DocBloc>
]]
  if type(sort_in)~="boolean" then ultraschall.AddErrorMessage("AddEnvelopePoints_EnvelopePointArray","sort_in", "only boolean allowed", -1) return false end
  count=1
  while EnvelopePointObjectArray[count]~=nil do
    if ultraschall.CheckEnvelopePointObject(EnvelopePointObjectArray)==false then 
      reaper.InsertEnvelopePoint(EnvelopePointObjectArray[count][1], EnvelopePointObjectArray[count][3], EnvelopePointObjectArray[count][4], EnvelopePointObjectArray[count][5], EnvelopePointObjectArray[count][6], EnvelopePointObjectArray[count][7], sort_in)
    end
    count=count+1
  end
end



function ultraschall.CreateEnvelopePointObject(TrackEnvelope, idx, time, value, shape, tension, selected)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateEnvelopePointObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array EnvelopePointObject = ultraschall.CreateEnvelopePointObject(TrackEnvelope TrackEnvelope, integer idx, number time, number value, integer shape, number tension, boolean selected)</functioncall>
  <description>
    Creates a new EnvelopePointObject, that can be used by other ultraschall-api-envelope-functions
    
    returns false in case of error
  </description>
  <parameters>
    TrackEnvelope env - the track-envelope, in which this EnvelopePointObject shall be
    integer idx - the number of the envelope-point, beginning with 0
    number time - the time of the envelope point in seconds
    number value - the raw-value of the envelope point
    integer shape - the shape of this envelope
    -0 - Linear
    -1 - Square
    -2 - Slow start/end
    -3 - Fast start
    -4 - Fast end
    -5 - Bezier
    number tension - the intensity of the tension of the shape
    boolean selected - true, if this point is selected; false if not
  </parameters>
  <retvals>
    boolean retval - false in case of error, true in case of success.
    array EnvelopePointObject - an array with all elements of the envelopepoint
    -[1] - TrackEnvelope-object
    -[2] - Envelope-idx
    -[3] - time
    -[4] - value
    -[5] - shape
    -[6] - tension
    -[7] - selected
    -[8] - dBValue converted from value
  </retvals>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, create, db, time, value, envelopepointobject</tags>
</US_DocBloc>
]]

  if reaper.ValidatePtr(TrackEnvelope, "TrackEnvelope*")==false then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "TrackEnvelope", "not a valid Trackenvelope.", -1) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "idx", "not a valid idx. Only integer values allowed.", -2) return false end
  if type(time)~="number" or tonumber(time)<0 then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "time", "not a valid time. Must be a number bigger or equal 0", -3) return false end
  if type(value)~="number" then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "value", "not a valid value. Must be a number.", -4) return false end
  if math.type(shape)~="integer" or (tonumber(shape)<0 or tonumber(shape)>5) then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "shape", "not a valid shape. Must be an integer between 0 and 5", -5) return false end
  if type(tension)~="number" then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "tension", "not a valid tensionvalue. Must be a number.", -6) return false end
  if type(selected)~="boolean" then ultraschall.AddErrorMessage("CreateEnvelopePointObject", "selected", "not a valid selectedvalue. Must be a boolean.", -7) return false end
  local EnvelopePointObject={}
  EnvelopePointObject[1]=TrackEnvelope  
  EnvelopePointObject[2]=idx
  EnvelopePointObject[3]=time
  EnvelopePointObject[4]=value
  EnvelopePointObject[5]=shape
  EnvelopePointObject[6]=tension
  EnvelopePointObject[7]=selected
  EnvelopePointObject[8]=reaper.SLIDER2DB(value)
  return true, EnvelopePointObject
end


function ultraschall.CountEnvelopePoints(Tracknumber, EnvelopeName)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountEnvelopePoints</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer envpoint_count = ultraschall.CountEnvelopePoints(integer Tracknumber, string EnvelopeName)</functioncall>
  <description>
    Counts and returns the number of envelope-points in track Tracknumber, envelopelane EnvelopeName.
    
    returns -1 in case of error
  </description>
  <parameters>
    integer Tracknumber - the number of the track, beginning with 1. Use 0 for Master Track.
    string EnvelopeName - the name of the envelope-lane
  </parameters>
  <retvals>
    integer envpoint_count - the number of envelope-points in requested track+envelope-lane
  </retvals>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, count</tags>
</US_DocBloc>
]]
  if math.type(Tracknumber)~="integer" then ultraschall.AddErrorMessage("CountEnvelopePoints", "track", "must be an integer", -1) return -1 end
  if type(EnvelopeName)~="string" then ultraschall.AddErrorMessage("CountEnvelopePoints", "EnvelopeName", "must be a string", -4) return -1 end
  local MediaTrack
  local EnvelopePointObject={}
  if Tracknumber<0 or Tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("CountEnvelopePoints", "track", "no such track", -2) return -1 end
  if Tracknumber==0 then 
    MediaTrack=reaper.GetMasterTrack(0)
  else
    MediaTrack=reaper.GetTrack(0,Tracknumber-1)
  end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, EnvelopeName)
  if TrackEnvelope==nil then ultraschall.AddErrorMessage("CountEnvelopePoints","EnvelopeName", "no such envelope", -3) return -1 end
  
  return reaper.CountEnvelopePoints(TrackEnvelope)
end

--A=ultraschall.CountEnvelopePoints(1, "Mute")

function ultraschall.EnumerateMediaItemsInTrack(tracknumber, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>MediaItem item, integer itemcount, array MediaItemArray = ultraschall.EnumerateMediaItemsInTrack(integer tracknumber, integer itemnumber)</functioncall>
  <description>
    returns the itemnumberth MediaItemobject in track, the number of items in tracknumber and an array with all MediaItems from this track.
    returns -1 in case of error
  </description>
  <parameters>
    integer tracknumber - the tracknumber, from where you want to get the item
    integer itemnumber - the itemnumber within that track. 1 for the first, 2 for the second, etc
  </parameters>
  <retvals>
    MediaItem item - the Mediaitem, as requested by parameter itemnumber
    integer itemcount - the number of items in that track
    array MediaItemArray - an array with all MediaItems from this track
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, get, item, mediaitem</tags>
</US_DocBloc>
]]

  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("EnumerateMediaItemsInTrack","tracknumber", "must be an integer", -1) return -1 end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("EnumerateMediaItemsInTrack","idx", "must be an integer", -2) return -1 end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("EnumerateMediaItemsInTrack","tracknumber", "no such tracknumber", -3) return -1 end
  if idx<0 then ultraschall.AddErrorMessage("EnumerateMediaItemsInTrack","idx", "must be bigger than or equal 0", -4) return -1 end
  local count=1
  local MediaTrack=reaper.GetTrack(0,tracknumber-1)
  local MediaItemArray={}
  local MediaItem=""
  local retval, str = ultraschall.GetTrackStateChunk(MediaTrack, "", true)
  str=str:match("<ITEM.*")
  
  if str==nil then ultraschall.AddErrorMessage("EnumerateMediaItemsInTrack","tracknumber", "No item in track", -5) return -1 end 
  
  while str:match(".-%cIGUID.-")~= nil do
    local GUID=str:match(".-%cIGUID ({.-})%c")
    MediaItemArray[count]=reaper.BR_GetMediaItemByGUID(0, GUID)
    str=str:match(".-%cIGUID.-%c(.*)")
    if count==idx then MediaItem=reaper.BR_GetMediaItemByGUID(0, GUID) end
      count=count+1
    end
  return MediaItem, count-1, MediaItemArray
end

--A,B,C,D,E=ultraschall.EnumerateMediaItemsInTrack(1, 1000)


function ultraschall.GetTrackLength(Tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer length = ultraschall.GetTrackLength(integer Tracknumber)</functioncall>
  <description>
    Returns the length of a track, that means, the end of the last item in track Tracknumber.
    Will return -1, in case of error
  </description>
  <parameters>
    integer Tracknumber - the tracknumber, whose length you want to know
  </parameters>
  <retvals>
    integer length - the length of the track in seconds
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement,count,length,items,end</tags>
</US_DocBloc>
]]
  if math.type(Tracknumber)~="integer" then ultraschall.AddErrorMessage("GetTrackLength", "Tracknumber", "must be an integer", -1) return -1 end

  local MediaTrack, MediaItem, num_items, Itemcount, MediaItemArray, POS, LEN
  if Tracknumber<0 or Tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("GetTrackLength", "Tracknumber", "no such track", -2) return -1 end
  if Tracknumber==0 then 
    MediaTrack=reaper.GetMasterTrack(0)
  else
    MediaTrack=reaper.GetTrack(0,Tracknumber-1)
  end
  num_items=reaper.CountTrackMediaItems(MediaTrack)
  MediaItem, Itemcount, MediaItemArray = ultraschall.EnumerateMediaItemsInTrack(Tracknumber, num_items)
  if MediaItem==-1 then ultraschall.AddErrorMessage("GetTrackLength", "Tracknumber", "no items in this track", -3) return -1 end
  POS=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
  LEN=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")
  return POS+LEN
end

--A=ultraschall.GetTrackLength(1)

function ultraschall.GetMediaItemArrayLength(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemArrayLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer start, integer end, integer length = ultraschall.GetMediaItemArrayLength(array MediaItemArray)</functioncall>
  <description>
    Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemArray.
    Will return -1, in case of error
  </description>
  <parameters>
    array MediaItemArray - an array with MediaItems, as returned by functions like <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a> or <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a> or similar.
  </parameters>
  <retvals>
    integer start - the beginning of the earliest item in the MediaItemArray in seconds
    integer end - the end of the latest item in the MediaItemArray, timewise, in seconds
    integer length - the length of the MediaItemArray in seconds
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>itemmanagement,count,length,items,end,mediaitem,item</tags>
</US_DocBloc>
]]
  local retval, count, retMediaItemArray = ultraschall.CheckMediaItemArray(MediaItemArray)
  if retval==false then ultraschall.AddErrorMessage("GetMediaItemArrayLength", "MediaItemArray", "no valid MediaItemArray", -1) return -1 end  local start=reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_POSITION")
  local endof=reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_POSITION")+reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_LENGTH")
  local delta=0
  for i=1, count do
    local tempstart=reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_POSITION")
    local tempendof=reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_POSITION")+reaper.GetMediaItemInfo_Value(retMediaItemArray[1], "D_LENGTH")
    if tempstart<start then start=tempstart end
    if tempendof>endof then endof=tempendof end
  end
  delta=endof-start
  return start, endof, delta
end


function ultraschall.GetMediaItemStateChunkArrayLength(MediaItemStateChunkArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemStateChunkArrayLength</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer start, integer end, integer length = ultraschall.GetMediaItemStateChunkArrayLength(array MediaItemStateChunkArray)</functioncall>
  <description>
    Returns the beginning of the first item, the end of the last item as well as the length between start and end of all items within the MediaItemStateChunkArray.
    Will return -1, in case of error
  </description>
  <parameters>
    array MediaItemStateChunkArray - an array with MediaItemStateChunks, as returned by functions like <a href="#GetAllMediaItemsBetween">GetAllMediaItemsBetween</a> or <a href="#GetMediaItemsAtPosition">GetMediaItemsAtPosition</a> or similar.
  </parameters>
  <retvals>
    integer start - the beginning of the earliest item in the MediaItemArray in seconds
    integer end - the end of the latest item in the MediaItemArray, timewise, in seconds
    integer length - the length of the MediaItemArray in seconds
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>itemmanagement,count,length,items,end, mediaitem, statechunk,item</tags>
</US_DocBloc>
]]
  local retval, count, retMediaItemArray = ultraschall.CheckMediaItemStateChunkArray(MediaItemStateChunkArray)
  if retval==false then ultraschall.AddErrorMessage("GetMediaItemStateChunkArrayLength", "MediaItemStateChunkArray", "no valid MediaItemStateChunkArray", -1) return -1 end
  start=retMediaItemArray[1]:match("POSITION (.-)%c")
  endof=retMediaItemArray[1]:match("POSITION (.-)%c")+retMediaItemArray[1]:match("LENGTH (.-)%c")
  local delta=0
  for i=1, count do
    local tempstart=retMediaItemArray[1]:match("POSITION (.-)%c")
    local tempendof=retMediaItemArray[1]:match("POSITION (.-)%c")+retMediaItemArray[1]:match("LENGTH (.-)%c")
    if tempstart<start then start=tempstart end
    if tempendof>endof then endof=tempendof end
  end
  delta=endof-start
  return tonumber(start), tonumber(endof), tonumber(delta)
  --]]
end


function ultraschall.ReadBinaryFile_Offset(input_filename_with_path, startoffset, numberofbytes)
--reads a binary file from offset

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReadBinaryFile_Offset</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer length, string content = ultraschall.ReadBinaryFile_Offset(string input_filename_with_path, integer startoffset, integer numberofbytes)</functioncall>
  <description>
    Returns the contents of a binary file from startoffset until startoffset+numberofbytes.
    
    When setting startoffset to a negative value, it will read from the end of the file, means: 
    -100 will start -100 characters before the end of the file and numberofbytes will read from that point on    
    
    Returns false, if file can not be opened.
  </description>
  <retvals>
    integer length - the length of the returned part of the file, might be shorter than requested, if file ends before
    string content - the content of the file, that has been read
  </retvals>
  <parameters>
    string input_filename_with_path - filename of the file to be read
    integer startoffset - the offset, at where to begin the fileread. 0 for the beginning of the file; negative values set offset from the end of the file
    integer numberofbytes - the number of bytes to read. -1 for until the end of the file. If there are fewer bytes than requested, the returned string will be shorter.
  </parameters>
  <chapter_context>
    File Management
    Read Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, read file, binary, offset</tags>
</US_DocBloc>
]]

  local temp=""
  local length, eof
  local temp2
  if input_filename_with_path==nil then ultraschall.AddErrorMessage("ReadBinaryFile_Offset", "filename_with_path", "nil not allowed as filename", -1) return false end
  if math.type(startoffset)~="integer" then ultraschall.AddErrorMessage("ReadBinaryFile_Offset", "startoffset", "no valid startoffset. Only integer allowed.", -2) return false end
  if math.type(numberofbytes)~="integer" then ultraschall.AddErrorMessage("ReadBinaryFile_Offset", "numberofbytes", "no valid value. Only integer allowed.", -3) return false end
  if numberofbytes<-1 then ultraschall.AddErrorMessage("ReadBinaryFile_Offset", "numberofbytes", "must be positive value (0 to n) or -1 for until end of file.", -4) return false end
  
  if reaper.file_exists(input_filename_with_path)==true then
    local fileread=io.open(input_filename_with_path,"rb")
    if numberofbytes==-1 then numberofbytes=fileread:seek ("end" , 0)-startoffset end
    if startoffset>=0 then fileread:seek ("set" , startoffset) else eof=fileread:seek ("end") fileread:seek ("set" , eof-1-(startoffset*-1)) end
    temp=fileread:read(numberofbytes)
    fileread:close()
    return temp:len(), temp
  else
    ultraschall.AddErrorMessage("ReadBinaryFile_Offset", "filename_with_path", "file does not exist.", -6)
    return false
  end
end


function ultraschall.GetLengthOfFile(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLengthOfFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer lengthoffile = ultraschall.GetLengthOfFile(string filename_with_path)</functioncall>
  <description>
    Returns the length of the file filename_with_path in bytes.
    Will return -1, if no such file exists.
  </description>
  <parameters>
    string filename_with_path - filename to write the value to
  </parameters>
  <retvals>
    integer lengthoffile - the length of the file in bytes. -1 in case of error
  </retvals>
  <chapter_context>
    File Management
    File Analysis
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,file,length,bytes,count</tags>
</US_DocBloc>
]]
  if filename_with_path==nil then ultraschall.AddErrorMessage("GetLengthOfFile", "filename_with_path", "nil not allowed as filename", -1) return false end
  local numberofbytes
  if reaper.file_exists(filename_with_path)==true then
    local fileread=io.open(filename_with_path,"rb")
    numberofbytes=fileread:seek ("end" , 0)
    fileread:close()
  else
    ultraschall.AddErrorMessage("GetLengthOfFile", "filename_with_path", "file does not exist.", -2)
    return -1
  end
  return numberofbytes  
end

--A=ultraschall.GetLengthOfFile("hui")


function ultraschall.SecondsToTimeString_hh_mm_ss_mss(time)
-- valid timerange from 0 to 359999.99 seconds
-- limited to maximum time of 99 hours!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SecondsToTimeString_hh_mm_ss_mss</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string timestring = ultraschall.SecondsToTimeString_hh_mm_ss_mss(number time)</functioncall>
  <description>
    Converts the parameter time into a timestring of the format hh:mm:ss.mss
    Valid timeranges are from 0 to 359999.99 seconds(about 99 hours).
    
    returns -1 in case of error
  </description>
  <parameters>
    number time - the time in seconds to be converted into the timestring
  </parameters>
  <retvals>
    string timestring - the converted timestring. It will always follow the format hh:mm:ss.mss and fill up digits with zeros, if necessary.
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>timestring, converter, seconds, string</tags>
</US_DocBloc>
]]
  if type(time)~="number" then ultraschall.AddErrorMessage("SecondsToTimeString_hh_mm_ss_mss","time", "must be a string", -1) return -1 end
  if time<0 then ultraschall.AddErrorMessage("SecondsToTimeString_hh_mm_ss_mss","time", "must be bigger or equal 0", -2) return -1 end
  local Buf2 = reaper.format_timestr_len(time, "", 0, 5)
  local Hour=Buf2:match("(.-):")
  local Ms=tostring(time):match("%.(.*)")
  if Ms==nil then Ms="0" end
  Ms=Ms.."00000"
  Ms=Ms:sub(1,3)
  local Len=string.len(Hour)
  if Len==1 then Buf2="0"..Buf2 end
  if Len>2 then ultraschall.AddErrorMessage("SecondsToTimeString_hh_mm_ss_mss","time", "must be smaller than 359999.99 seconds(about 99 hours)", -3) return -1 end --Buf2=Buf2:sub(Len-1,-1) end
  return Buf2:match("(.*):").."."..Ms
end

--A=ultraschall.SecondsToTimeString_hh_mm_ss_mss(999999)

function ultraschall.TimeStringToSeconds_hh_mm_ss_mss(timestring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>TimeStringToSeconds_hh_mm_ss_mss</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number time = ultraschall.TimeStringToSeconds_hh_mm_ss_mss(string timestring)</functioncall>
  <description>
    Converts the parameter timestring of the format hh:mm:ss.mss into seconds
    The timestring must follow strictly this format, or the function returns -1 as result.
    
    returns -1 in case of error
  </description>
  <parameters>
    string timestring - the converted timestring. It must always follow the format hh:mm:ss.mss. Fill up digits with zeros, if necessary.
  </parameters>
  <retvals>
    number time - the time in seconds to be converted into the timestring, -1 in case of an error
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>timestring, converter, seconds, string</tags>
</US_DocBloc>
]]
-- converts timestring to seconds
-- expects hh:mm:ss.mss as time, i.e. 12:23:34.456 or it returns -1 as result
  if type(timestring)~="string" then ultraschall.AddErrorMessage("TimeStringToSeconds_hh_mm_ss_mss","timestring", "must be a string", -1) return -1 end
  local Hour=timestring:match("(%d-):")
  if Hour==nil or string.len(Hour)~=2 then ultraschall.AddErrorMessage("TimeStringToSeconds_hh_mm_ss_mss","timestring", "no valid timestring", -2) return -1 end
  local Minute=timestring:match("%d%d:(%d-):")
  if Minute==nil or string.len(Minute)~=2 then ultraschall.AddErrorMessage("TimeStringToSeconds_hh_mm_ss_mss","timestring", "no valid timestring", -2) return -1 end
  local Second=timestring:match("%d%d:%d%d:(%d-)%.")
  if Second==nil or string.len(Second)~=2 then ultraschall.AddErrorMessage("TimeStringToSeconds_hh_mm_ss_mss","timestring", "no valid timestring", -2) return -1 end
  local MilliSeconds=timestring:match("%d%d:%d%d:%d%d(%.%d*)")
  if MilliSeconds==nil or string.len(MilliSeconds)~=4 then ultraschall.AddErrorMessage("TimeStringToSeconds_hh_mm_ss_mss","timestring", "no valid timestring", -2) return -1 end
  return (Hour*3600)+(Minute*60)+Second+tonumber(MilliSeconds)
end

--A=ultraschall.TimeStringToSeconds_hh_mm_ss_mss("Hula")

function ultraschall.ParseMarkerString(markerstring, strict)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ParseMarkerString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer number_of_entries, array markerarray = ultraschall.ParseMarkerString(string markerstring, boolean strict)</functioncall>
  <description>
    Parses the entries in markerstring for timestrings and markertitles.
    It returns the number of entries as well as a table with all marker-information.
    The table works as such:
    
    markertable[1][markernumber] - the timestring of the marker, -1 if no time is available
    markertable[2][markernumber] - the time, converted into position in seconds, -1 if no time is available
    markertable[3][markernumber] - the name of the marker
    
    returns -1 in case of an error
  </description>
  <parameters>
    string markerstring - a string with all markers. An entry is "timestring markertitle\n". Each marker-entry must be separated by a newline from each other.
    boolean strict - interpret the time in timestring more strict or more loosely?
    -true, the time in markerstring must follow the format hh:mm:ss.mss , e.g. 11:22:33.444
    -false, the time can be more flexible, leading to possible misinterpretation of indexnumbers as time/seconds
  </parameters>
  <retvals>
    integer number_of_entries - the number of markers in markerstring
    array markerarray - a table with all the information of a marker
    -markertable[1][markernumber] - the timestring of the marker, -1 if no time is available
    -markertable[2][markernumber] - the time, converted into position in seconds, -1 if no time is available
    -markertable[3][markernumber] - the name of the marker
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, import, parse</tags>
</US_DocBloc>
]]
-- splits the entries in markerstring into timeposition and name
-- returns the number of entries in markerstring, as well as a table with all entries in them
--
-- markertable[1][i] - the timestring, -1 if no time is available
-- markertable[2][i] - the time, converted into position in seconds, -1 if no time is available
-- markertable[3][i] - the name of the marker
--
-- the variable i above, is the number of the marker, beginning with 1
  if type(markerstring)~="string" then ultraschall.AddErrorMessage("ParseMarkerString","markerstring", "only string is allowed", -1) return -1 end
  local counter=1
  local markertable={}
  markertable[1]={}
  markertable[2]={}
  markertable[3]={}
  
  while markerstring~=nil do
    markertable[1][counter]=markerstring:match("(.-)%s")
    if strict~=true then
      markertable[2][counter]=ultraschall.TimeToSeconds(markertable[1][counter])--reaper.parse_timestr(markertable[1][counter])
    else
      markertable[2][counter]=ultraschall.TimeStringToSeconds_hh_mm_ss_mss(markertable[1][counter])--reaper.parse_timestr(markertable[1][counter])
    end
    if markertable[2][counter]==-1 then markertable[1][counter]="" end

    if markertable[1][counter]=="" then
      markertable[1][counter]=-1
      markertable[2][counter]=-1
      markertable[3][counter]=markerstring:match("(.-)\n")
      if markertable[3][counter]==nil then markertable[3][counter]=markerstring:match(".*") end
    else  
      markertable[3][counter]=markerstring:match("%s(.-)\n")
      if markertable[3][counter]==nil then markertable[3][counter]=markerstring:match("%s(.*)") end
    end
    markerstring=markerstring:match(".-\n(.*)")
    counter=counter+1
  end
  return counter-1, markertable
end



function ultraschall.RenumerateMarkers(colorvalue, startingnumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RenumerateMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.RenumerateMarkers(integer colorvalue, integer startingnumber)</functioncall>
  <description>
    Renumbers the shown numbers of markers(not regions!) in the current project, that have the color colorvalue.
    The numbering starts with the number startingnumber.
    
    The markers will be renumbered from the earliest marker in the project to the latest one.
    
    returns -1 in case of an error
  </description>
  <parameters>
    integer colorvalue - the (systemdependent)colorvalue a marker must have. -1 if you want all markers to be numbered.
    -Keep in mind, that colors are differently interpreted on Mac compared to Windows!
    integer startingnumber - the first number that shall be given.
  </parameters>
  <retvals>
    integer retval - -1 in case of error, nil in case of success
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, numerate, shown number</tags>
</US_DocBloc>
]]
-- renumerates the shown number of markers(no regions!) that have 
-- color "colorvalue", beginning with "startingnumber"
-- 
-- returns -1 in case of error
-- Parameters:
--    colorvalue - the colorvalue the marker must have
--    startingnumber - the first number that shall be given to the first marker with "colorvalue"


  if math.type(colorvalue)~="integer" then ultraschall.AddErrorMessage("RenumerateMarkers","colorvalue", "not a valid volorvalue, must be integer.", -1) return -1 end
  if math.type(startingnumber)~="integer" then ultraschall.AddErrorMessage("RenumerateMarkers","startingnumber", "not a valid starting number, must be integer", -2) return -1 end
  if startingnumber<0 then ultraschall.AddErrorMessage("RenumerateMarkers","startingnumber", "starting number must be bigger than 1", -3) return -1 end
  local counter=startingnumber
  local allmarkers, num_markers, num_regions = reaper.CountProjectMarkers(0)
  local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color
  for i=0, allmarkers-1 do
    retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==false and color==colorvalue then --0 then
      reaper.SetProjectMarkerByIndex2(0, i, isrgn, pos, rgnend, counter, name, color, 0)
      counter=counter+1
    elseif isrgn==false and colorvalue==-1 then
      reaper.SetProjectMarkerByIndex2(0, i, isrgn, pos, rgnend, counter, name, color, 0)
      counter=counter+1    
    end
  end
end

function ultraschall.SetTrackStateChunk_Tracknumber(tracknumber, trackstatechunk, undo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackStateChunk_Tracknumber</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTrackStateChunk_Tracknumber(integer tracknumber, string trackstatechunk, boolean undo)</functioncall>
  <description>
    Sets the trackstatechunk for track tracknumber. Undo flag is a performance/caching hint.
    
    returns false in case of an error
  </description>
  <parameters>
    integer tracknumber - the tracknumber, 0 for master track, 1 for track 1, 2 for track 2, etc.
    string trackstatechunk - the trackstatechunk, you want to set this track with
    boolean undo - Undo flag is a performance/caching hint.
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of error
  </retvals>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackstatechunk, set</tags>
</US_DocBloc>
]]

  tracknumber=tonumber(tracknumber)
  if type(trackstatechunk)~="string" then ultraschall.AddErrorMessage("SetTrackStateChunk_Tracknumber","trackstatechunk", "not a valid trackstatechunk", -1) return false end
  if undo==nil then undo=true end
  if type(undo)~="boolean" then ultraschall.AddErrorMessage("SetTrackStateChunk_Tracknumber","undo", "only true or false are allowed", -2) return false end
  if tracknumber==nil then ultraschall.AddErrorMessage("SetTrackStateChunk_Tracknumber","tracknumber", "not a valid tracknumber, only integer allowed", -3) return false end
  if tracknumber<0 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackStateChunk_Tracknumber","tracknumber", "only tracknumbers allowed between 0(master), 1(track1) and "..reaper.CountTracks(0).."(last track in this project)", -4) return false end
  if tracknumber==0 then Track=reaper.GetMasterTrack(0)
  else Track=reaper.GetTrack(0,tracknumber-1)
  end
  A=reaper.SetTrackStateChunk(Track, trackstatechunk, boolean)
  return A
end

function ultraschall.SetEnvelopeHeight(Height, Compacted, TrackEnvelope, TrackEnvelopeStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetEnvelopeHeight</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackEnvelopeStateChunk = ultraschall.SetEnvelopeHeight(integer Height, boolean Compacted, TrackEnvelope TrackEnvelope, string TrackEnvelopeStateChunk)</functioncall>
  <description>
    Changes the Envelope-lane-height and compactible state of TrackEnvelope or TrackEnvelopeStateChunk.
    
    returns false in case of an error
  </description>
  <parameters>
    integer Height - the height of the envelopelane in pixels when not compacted. Reaper accepts 24-443 currently. Nil keeps old value.
    boolean Compacted - shall the envelopelane be compacted(true) or not(false). Nil keeps old value.
    TrackEnvelope TrackEnvelope - the TrackEnvelope to alter, or nil to use the TrackEnvelopeStateChunk instead
    optional string TrackEnvelopeStateChunk - the TrackEnvelopeStateChunk you want to alter. Will be used only, if TrackEnvelope is set to nil
  </parameters>
  <retvals>
    boolean retval - true in case of success; false in case of error
    string TrackEnvelopeStateChunk - the altered TrackEnvelopeStateChunk
  </retvals>
  <chapter_context>
    Envelope Management
    Set Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackenvelopestatechunk, set, height, compactible</tags>
</US_DocBloc>
]]
  local str, retval, newstr
  if type(Compacted)~="boolean" and Compacted~=nil then ultraschall.AddErrorMessage("SetEnvelopeHeight","Compacted", "only true, false or nil allowed", -1) return false end
  if math.type(Height)~="integer" and Height~=nil then ultraschall.AddErrorMessage("SetEnvelopeHeight","Height", "only integer(24-443) or nil allowed", -2) return false end
  if TrackEnvelope~=nil then 
    if reaper.ValidatePtr2(0, TrackEnvelope, "TrackEnvelope*")==false then ultraschall.AddErrorMessage("SetEnvelopeHeight", "TrackEnvelope", "not a valid TrackEnvelope", -3) return false end
    retval, str = ultraschall.GetEnvelopeStateChunk(TrackEnvelope, "", false)
  else 
    if type(TrackEnvelopeStateChunk)~="string" then ultraschall.AddErrorMessage("SetEnvelopeHeight","TrackEnvelopeStateChunk", "not a valid TrackEnvelopeStateChunk", -4) return false end
    str=TrackEnvelopeStateChunk
  end
  
  local part1=str:match("(.-)LANE")
  local height=str:match("LANEHEIGHT (.-) .-%c")
  local compacted=str:match("LANEHEIGHT .- (.-)%c")
  local part2=str:match("LANEHEIGHT.-%c(.*)")
  
  if Height~=nil then height=Height end
  if Compacted==true then compacted="1"
  elseif Compacted==false then compacted="0"
  end

  newstr=part1.."LANEHEIGHT "..height.." "..compacted.."\n"..part2
  if TrackEnvelope~=nil then 
    retval, str2 = reaper.SetEnvelopeStateChunk(TrackEnvelope, newstr, false) 
  end
  return true, newstr
end

--A,B=reaper.GetTrackEnvelope(reaper.GetTrack(0,0),0)

--PUH,PUH2=ultraschall.SetEnvelopeHeight(100, true, A)
--reaper.MB(PUH2,"",0)
--reaper.UpdateArrange()


function ultraschall.GetAllTrackEnvelopes()
-- returns all TrackEnvelopes of the current project as a table, number of tracks, the first track that has an envelope, if the master track has an envelope(0) or not (-1)
-- the table works as follows:
-- TrackEnvelopeArray[Tracknumber][0] - number of envelopes for track Tracknumber
-- TrackEnvelopeArray[Tracknumber][1][Envelopenumber] - the envelope Envelopenumber of track Tracknumber
--
-- tracknumber of 0 is for the master track

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllTrackEnvelopes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>array TrackEnvelopeArray, integer number_of_tracks, integer FirstEnvelopeTrackNumber, integer FirstEnvelopeMaster = ultraschall.GetAllTrackEnvelopes()</functioncall>
  <description>
    returns all TrackEnvelopes of the current project as a table, number of tracks, the first track that has an envelope, if the master track has an envelope(0) or not (-1)
  </description>
  <retvals>
    array TrackEnvelopeArray - a table with all envelopes of the current project
    -the table works as follows:
    -TrackEnvelopeArray[Tracknumber][0] - number of envelopes for track Tracknumber
    -TrackEnvelopeArray[Tracknumber][1][Envelopenumber] - the envelope Envelopenumber of track Tracknumber
    -
    -tracknumber of 0 is for the master track
    integer number_of_tracks - the number of tracks, covered in the TrackEnvelopeArray
    integer FirstEnvelopeTrackNumber - the number of the first track to have an envelope; -1 if theres none
    integer FirstEnvelopeMaster - 0, if the master-track has an envelope, -1 if not.
  </retvals>
  <chapter_context>
    Envelope Management
    Get Envelope
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, trackenvelope, get, envelope</tags>
</US_DocBloc>
]]

  local TrackEnvelopeArray={}
  local FirstEnvelopeTrackNumber=-1
  local FirstEnvelopeMaster=-1
  local trackcount=1
  
  for i=0, reaper.CountTracks(0)-1 do
    local MediaTrack=reaper.GetTrack(0,i)
    TrackEnvelopeArray[i+1]={}
    TrackEnvelopeArray[i+1][1]={}
    
    for a=0, reaper.CountTrackEnvelopes(MediaTrack)-1 do
      TrackEnvelopeArray[i+1][1][a]=reaper.GetTrackEnvelope(MediaTrack, a)
      if FirstEnvelopeTrackNumber==-1 then FirstEnvelopeTrackNumber=i+1 end
    end
    TrackEnvelopeArray[i+1][0]=reaper.CountTrackEnvelopes(MediaTrack)-1
  end

  local MediaTrack=reaper.GetMasterTrack(0)
  TrackEnvelopeArray[0]={}
  TrackEnvelopeArray[0][1]={}
  for a=0, reaper.CountTrackEnvelopes(MediaTrack)-1 do
    TrackEnvelopeArray[0][1][a]=reaper.GetTrackEnvelope(MediaTrack, a)
    FirstEnvelopeMaster=0
  end
  TrackEnvelopeArray[0][0]=reaper.CountTrackEnvelopes(MediaTrack)-1

  
  return TrackEnvelopeArray, reaper.CountTracks(0), FirstEnvelopeTrackNumber, FirstEnvelopeMaster
end



--L,LL=ultraschall.SetEnvelopeHeight(10,true, -1, "<VOLENV\nACT 1\nVIS 1 1 1\nLANEHEIGHT 47 0\nARM 1\nDEFSHAPE 0 -1 -1\nPT 0 1 0\n>")

--A,AA=ultraschall.GetTrackStateChunk(0,"hula")
--reaper.MB(LL,"",0)
--reaper.ShowConsoleMsg(AA)


function ultraschall.CountPatternInString(sourcestring, searchstring, non_case_sensitive)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountPatternInString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer count, array positions = ultraschall.CountPatternInString(string sourcestring, string searchstring, boolean non_case_sensitive)</functioncall>
  <description>
    returns the count and an array with all positions of searchstring in sourcestring.
  </description>
  <retvals>
    integer count - the number of appearances of searchstring in sourcestring
    array positions - an array with count-entries, where every entry contains the position of searchstring in sourcestring
  </retvals>
  <parameters>
    string sourcestring - the string, you want to search through
    string searchstring - the string, you want to search for in sourcestring
    boolean non_case_sensitive - true, the search does not care about case-sensitivity; false, case of searchstring will be kept
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, string, character, check, find, count, position, numbers</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(sourcestring)~="string" then ultraschall.AddErrorMessage("CountPatternInString", "sourcestring", "must be a string", -1) return -1 end
  if type(searchstring)~="string" then ultraschall.AddErrorMessage("CountPatternInString", "searchstring", "must be a string", -2) return -1 end
  if type(non_case_sensitive)~="boolean" then ultraschall.AddErrorMessage("CountPatternInString", "non_case_sensitive", "must be a boolean", -3) return -1 end
  
  -- prepare variables
  local Position={}
  local count=1  
  
  -- if case-sensitivity doesn't matter, make the strings lowercase
  if non_case_sensitive==true then 
    sourcestring=sourcestring:lower() 
    searchstring=searchstring:lower() 
    end
    
  -- now do the searching and create a table with all appearance-positions
  while sourcestring:match(searchstring)~=nil do
    Position[count]=sourcestring:match(".*()"..searchstring)
    sourcestring=sourcestring:sub(1,Position[count]-1)
    count=count+1  
  end
  -- sort it
  table.sort(Position)
  
  -- return number of appearances and the position-table
  return count-1, Position
end

--A,AA=ultraschall.CountPatternInString("HulaLLHulaLHulaHula,HULA,HuLahUlA", "Hula", false)


function ultraschall.CountNormalMarkers_NumGap()
-- returns number of normal markers in the project
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountNormalMarkers_NumGap</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    Lua=5.3
  </requires>
  <functioncall>integer number_normal_markers = ultraschall.CountNormalMarkers_NumGap()</functioncall>
  <description>
    Returns the first "gap" in shown marker-numbers. If you have markers with numbers "1, 2, 4" it will return 3, as this is the first number missing.
    
    Normal markers are all markers, that don't include "_Shownote:" or "_Edit" in the beginning of their name, as well as markers with the color 100,255,0(planned chapter).
  </description>
  <retvals>
    integer gap_number - the number of the first "gap" in the numbering of the shown marker-numbers
  </retvals>
  <chapter_context>
    Markers
    Normal Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, marker, count, gap, position</tags>
</US_DocBloc>
]]
  local nix=""
  a,nummarkers,b=reaper.CountProjectMarkers(0)
  count=0
  for b=1, nummarkers do
    for i=0, a do
    retval, isrgn, pos, rgnend, name, markrgnindexnumber, color= reaper.EnumProjectMarkers3(0, i)
    if markrgnindexnumber==b then count=b nix="hui" break
    end
    end
    if nix=="" then break end
    nix=""
  end

  return count+1
end  

function ultraschall.CenterViewToCursor(cursortype, position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CenterViewToCursor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.52
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>ultraschall.CenterViewToCursor(integer cursortype, optional number position)</functioncall>
  <description>
    centers the arrange-view around a given cursor
  </description>
  <parameters>
    integer cursortype - the cursortype to center
    - 1 - change arrangeview with edit-cursor centered
    - 2 - change arrangeview with play-cursor centered
    - 3 - change arrangeview with mouse-cursor-position centered
    - 4 - change arrangeview with optional parameter position centered
    optional number position - the position to center the arrangeview to; only used, when cursortype=4
  </parameters>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, center, cursor, mouse, edit, play</tags>
</US_DocBloc>
]]
    if math.type(cursortype)~="integer" then ultraschall.AddErrorMessage("CenterViewToCursor","cursortype", "only integer allowed", -1) return end
    if position~=nil and type(position)~="number" then ultraschall.AddErrorMessage("CenterViewToCursor","position", "only numbers allowed", -3) return end
    local cursor_time
    if cursortype<1 or cursortype>4 then ultraschall.AddErrorMessage("CenterViewToCursor","cursortype", "no such cursortype; only 1-3 existing.", -2) return end
    if cursortype==1 then cursor_time=reaper.GetCursorPosition() end
    if cursortype==2 then cursor_time=reaper.GetPlayPosition() end
    if cursortype==3 then 
      retval, segment, details = reaper.BR_GetMouseCursorContext()
      cursor_time=reaper.BR_GetMouseCursorContext_Position()
    end
    if cursortype==4 then if position~=nil then cursor_time=position else ultraschall.AddErrorMessage("CenterViewToCursor","position", "only numbers allowed", -3) return end end
    start_time, end_time = reaper.GetSet_ArrangeView2(0, false, 0, 0)
    length=((end_time-start_time)/2)+(1/reaper.GetHZoomLevel())
    reaper.BR_SetArrangeView(0, (cursor_time-length), (cursor_time+length))
end

--ultraschall.CenterViewToCursor(4,1000000)










function toboolean(value)
    -- converts a value to boolean, or returns nil, if not convertible
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>toboolean</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = toboolean(string value)</functioncall>
  <description>
    Converts the string "value" to a boolean, if applicable; means: if it contains either true or false in it.
    If it contains both or other characters(except spaces or tabs), it will not convert.
    Works basially like Lua's own tostring() or tonumber()-functions.
    
    Returns nil, if conversion isn't possible.
    
    Note: Unlike other ultraschall-api-functions, toboolean() has no ultraschall. in it's functionname!
  </description>
  <parameters>
    string value - the value to be converted to a boolean. True and false can be upper-, lower and camelcase.
  </parameters>
  <retvals>
    boolean retval - true or false, depending on the input variable value
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, string, convert, boolean</tags>
</US_DocBloc>
--]]
    if type(value)=="boolean" then return value end
    if value==nil then ultraschall.AddErrorMessage("toboolean","value", "must contain either true or false, nothing else. Spaces and tabs are allowed.", -1) return end
    local value=value:lower()
    local truth=value:match("^\t*%s*()true\t*%s*$")
    local falseness=value:match("^\t*%s*()false\t*%s*$")
    
    if tonumber(truth)==nil and tonumber(falseness)~=nil then
      return false
    elseif tonumber(truth)~=nil and tonumber(falseness)==nil then
      return true
    end
end


function ultraschall.SetReaperWindowToSize(x,y)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetReaperWindowToSize</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.8.8
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetReaperWindowToSize(integer width, integer height)</functioncall>
  <description>
    Sets the Reaper-Window to the size of w and h. The x and y-windowposition will be retained.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    integer w - the new width of the Reaper-window in pixels
    integer h - the new height of the reaper-windows in pixels
  </parameters>
  <retvals>
    integer retval - -1 in case of error
  </retvals>
  <chapter_context>
    Reaper Element Positions
    Reaper Window
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>reaper, window, width, height, set</tags>
</US_DocBloc>
--]]
  if math.type(x)~="integer" then ultraschall.AddErrorMessage("SetReaperWindowToSize","x", "only integer-numbers are allowed", -1) return -1 end
  if math.type(y)~="integer" then ultraschall.AddErrorMessage("SetReaperWindowToSize","y", "only integer-numbers are allowed", -2) return -1 end
  ultraschall.SetIniFileValue("Reaper", "setwndsize_x", x, reaper.get_ini_file())
  ultraschall.SetIniFileValue("Reaper", "setwndsize_y", y, reaper.get_ini_file())
  ultraschall.RunCommand("_SWS_SETWINDOWSIZE")
end


function ultraschall.OpenURL(url)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OpenURL</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.OpenURL(string url)</functioncall>
  <description>
    Opens the URI with the standard-browser installed in your system.
    
    returns -1 in case of error
  </description>
<retval>
integer retval - -1 in case of error
</retval>
  <parameters>
    string url - the url to be opened in the browser; will check for :// in it for validity!
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, string, url, open, browser</tags>
</US_DocBloc>
--]]
--  if url:match(".-(://)")==nil then return false end
  if type(url)~="string" then ultraschall.AddErrorMessage("OpenURL","url", "Must be a string.", -1) return -1 end
  local OS=reaper.GetOS()
  url="\""..url.."\""
  if OS=="OSX32" or OS=="OSX64" then
    os.execute("open ".. url)
  else
    os.execute("start \"Ultraschall-URL\" /B ".. url)
  end
  return true
end

--A=ultraschall.OpenURL("ftp://www.htm")

--

function ultraschall.IsMarkerAtPosition(position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMarkerAtPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, string markersstring, array markersarray = ultraschall.IsMarkerAtPosition(number position)</functioncall>
  <description>
    returns, if markers are at position and returns the marker-numbers.
    
    The marker-numbers are numerated by order, not the shown marker-numbers!
    
  </description>
  <parameters>
    number position - the position to check for markers in seconds; only positive numbers
  </parameters>
  <retvals>
    boolean retval - true, if the function found marker(s); false, if no markers are available at position
    integer count - the count of markers at position
    string markersstring - a string with all the markernumbers, separated by a ,
    array markersarray - an array with each entry consisting a markernumber
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, marker, position</tags>
</US_DocBloc>
--]]
  if type(position)~="number" then ultraschall.AddErrorMessage("IsMarkerAtPosition","position", "only numbers are allowed", -1) return false end
  if position<0 then ultraschall.AddErrorMessage("IsMarkerAtPosition","position", "only positive numbers are allowed", -2) return false end
  
  local markersstring=""
  local markersarray={}
  local counter=1
  local yes=false
  local localcount=0
  
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==false then localcount=localcount+1 end
    if position==pos and isrgn==false then 
      markersstring=markersstring..","..localcount
      markersarray[counter]=localcount
      counter=counter+1
      yes=true
    end
  end
  return yes, counter-1, markersstring:sub(2,-1), markersarray
end

--A,B,C,D=ultraschall.IsMarkerAtPosition(-1)

function ultraschall.IsRegionAtPosition(position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsRegionAtPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer count, string regionsstring, array regionsarray = ultraschall.IsRegionAtPosition(number position)</functioncall>
  <description>
    returns, if regions are at position and returns the region-numbers.
    
    The region-numbers are numerated by order, not the shown region-numbers!
    
  </description>
  <parameters>
    number position - the position to check for regions in seconds; only positive numbers
  </parameters>
  <retvals>
    boolean retval - true, if the function found region(s); false, if no regions are available at position
    integer count - the count of regions at position
    string regionsstring - a string with all the regionnumbers, separated by a ,
    array regionsarray - an array with each entry consisting a regionnumber
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, region, position</tags>
</US_DocBloc>
--]]
  if type(position)~="number" then ultraschall.AddErrorMessage("IsRegionAtPosition","position", "only numbers are allowed", -1) return false end
  if position<0 then ultraschall.AddErrorMessage("IsRegionAtPosition","position", "only positive numbers are allowed", -2) return false end
  
  local markersstring=""
  local markersarray={}
  local counter=1
  local yes=false
  local localcount=0
  
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==true then localcount=localcount+1 end
    if position>=pos and position<=rgnend and isrgn==true then 
      markersstring=markersstring..","..localcount 
      markersarray[counter]=localcount
      counter=counter+1
      yes=true
    end
  end
  return yes, counter-1, markersstring:sub(2,-1), markersarray
end

--A,B,C,D=ultraschall.IsRegionAtPosition(14)



--A,B,C,D,E,F,G,H,I=ultraschall.GetMediafileAttributes("c:\\Derek And The Dominos - Layla.mp3")
--A,B,C,D,E,F,G,H,I=ultraschall.GetMediafileAttributes("C:\\MarkerProject.RPP")

function ultraschall.GetAllMediaItemGUIDs()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItemGUIDs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table GUID_Array, integer count_of_GUID = ultraschall.GetAllMediaItemGUIDs()</functioncall>
  <description>
    Returns an array with all MediaItem-GUIDs in order of the MediaItems-count(1 for first MediaItem, etc).
    
    Returns nil in case of an error
  </description>
  <parameters>
    table GUID_Array - an array with all GUIDs of all MediaItems
    integer count_of_GUID - the number of GUIDs(from MediaItems) in the GUID_Array
  </parameters>
  <retvals>
    table diff_array - an array with all entries from CompareArray2, that are not in Array
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, guid, mediaitem, item</tags>
</US_DocBloc>
--]]
  local GUID_Array={}
  for i=0, reaper.CountMediaItems(0)-1 do
    local item=reaper.GetMediaItem(0,i)
    GUID_Array[i+1] = reaper.BR_GetMediaItemGUID(item)
  end
  return GUID_Array, reaper.CountMediaItems(0)
end

--C1,C2=ultraschall.GetAllMediaItemGUIDs()

function ultraschall.CountEntriesInTable_Main(the_table)
-- counts only the entries in the main table; subtables are not count but returned as retval2, with the number of entries in retval
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountEntriesInTable_Main</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, table subtables, integer count_of_subtables = ultraschall.CountEntriesInTable_Main(table the_table)</functioncall>
  <description>
    Counts the number of entries in an indexed table.
    Will only count the entries from the main-table, not it's subtables. If you want to know the number of subtables, this function returns a table that includes all subtables found in the main-table,
    as well as the number of found subtables.
    
    Returns -1 if table isn't a valid table
  </description>
  <parameters>
    table table - the table, whose entries you want to count
  </parameters>
  <retvals>
    integer count - the number of entries in the table
    table subtables - if an entry of table has a table as value, that table-value will be included in this subtables-table(for recursive counting-usecases)
    integer count_of_subtables - the number of entries in the subtables-table
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, count, entries, table, array, maintable</tags>
</US_DocBloc>
--]]
  if type(the_table)~="table" then ultraschall.AddErrorMessage("CountEntriesInTable_Main","table", "Must be a table!", -1) return -1 end
  local count=1
  local SubTables={}
  local SubTablesCount=1
  while the_table[count]~=nil do
--    reaper.MB(tostring(the_table[count]),"",0)
    if type(the_table[count])=="table" then SubTables[SubTablesCount]=v SubTablesCount=SubTablesCount+1 end
    count=count+1
  end
  return count-1, SubTables, SubTablesCount-1
end

--A={}
--A[1]="tudelu"
--A["tudelu"]="More Tudelu"
--A[3]={}
--A[3][1]="oh nor"
--A[3][9]="mullewapp"

--A={}
--A[1]=1
--A[2]=2
--A[3]=3

--B={}
--B[1]=3
--B[2]=4
--B[3]=5

--LL,LL2,LL3=ultraschall.CountEntriesInTable_Main(B)

function ultraschall.CompareArrays(Array, CompareArray2)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CompareArrays</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table diff_array = ultraschall.CompareArrays(table Array, table CompareArray2)</functioncall>
  <description>
    Compares Array using parameter CompareArray2 and returns an array with all entries in CompareArray2, that are not in Array.
    The comparable arrays must be indexed by integer-numbers.
    
    Returns nil in case of an error
  </description>
  <parameters>
    table Array - the reference-array
    table CompareArray2 - the array you want to check against Array; all entries in CompareArray2 that are not in Array will be returned
  </parameters>
  <retvals>
    table diff_array - an array with all entries from CompareArray2, that are not in Array
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, check, compare, table, array, indexed</tags>
</US_DocBloc>
--]]

  if type(Array)~="table" then ultraschall.AddErrorMessage("CompareArrays","Array", "Must be a table!", -1) return nil end
  if type(CompareArray2)~="table" then ultraschall.AddErrorMessage("CompareArrays","CompareArray2", "Must be a table!", -2) return nil end
  local count, subtables, count_of_subtables = ultraschall.CountEntriesInTable_Main(Array)
  local count2, subtables2, count_of_subtables2 = ultraschall.CountEntriesInTable_Main(CompareArray2)
  local Array3={}
  local x,y,count3,check
  check=false
  count3=1
  for a=1, count2 do
    check=false
    for i=1, count do
      x=Array[i]
      y=CompareArray2[a]
      if x==y then check=true end
    end
    if check==false then Array3[count3]=y count3=count3+1 end 
  end

  return Array3, count3-1
end

--a={} 
--b={}

--a[1]=1
--a[2]=2

--b[1]=4
--b[2]=2
--b[3]=3

--C,C2=ultraschall.CompareArrays(a, b)



--A,B,C,D,E,F,G,H,I=ultraschall.InsertMediaItemFromFile("c:\\tt2.opus", 2, 10, 30, 0)

function ultraschall.GetOS()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetOS</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string operating_system, integer bits = ultraschall.GetOS()</functioncall>
  <description>
    Returns operating system and if it's a 64bit/32bit-operating system.
  </description>
  <retvals>
    string operating_system - the operating system used; usually "Win", "Mac" or "Other"(e.g. when Linux is used)
    integer bits - the number of bits of the operating-system. Either 32 or 64 bit.
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, operating system, os, mac, win, osx, linux, other, bits</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local retval=reaper.GetOS()
  local os, bits
  
  -- check for os and bits and return it
  if retval:match("Win")~=nil then os="Win" end
  if retval:match("OSX")~=nil then os="Mac" end
  if retval:match("Other")~=nil then os="Other" end
  if retval:match("32")~=nil then bits=32 end
  if retval:match("64")~=nil then bits=64 end
  return os, bits
end

function ultraschall.IsOS_Windows()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsOS_Windows</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean is_windows, integer number_of_bits = ultraschall.IsOS_Windows()</functioncall>
  <description>
    returns, if the current operating system is windows
  </description>
  <retvals>
    boolean is_windows - true, if the operating-system is windows; false if not
    integer bits - the number of bits of the operating-system. Either 32 or 64 bit; nil if is_win==false
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, operating system, os, check, win, bits</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local retval=reaper.GetOS()
  local os, bits
  
  -- check for os and bits
  if retval:match("Win")~=nil then os=true 
  else
    os=false
  end
  if os==true and retval:match("32")~=nil then bits=32 end
  if os==true and retval:match("64")~=nil then bits=64 end
  return os, bits
end

--L,LL=ultraschall.IsOS_Windows()


function ultraschall.IsOS_Mac()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsOS_Mac</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean is_mac, integer number_of_bits = ultraschall.IsOS_Mac()</functioncall>
  <description>
    returns, if the current operating system is mac-osx
  </description>
  <retvals>
    boolean is_mac - true, if the operating-system is mac-osx; false if not
    integer bits - the number of bits of the operating-system. Either 32 or 64 bit.; nil if is_mac=false
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, check, operating system, os, mac, osx, bits</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local retval=reaper.GetOS()
  local os, bits
  
  -- check for os and bits
  if retval:match("OSX")~=nil then os=true 
  else
    os=false
  end
  if os==true and retval:match("32")~=nil then bits=32 end
  if os==true and retval:match("64")~=nil then bits=64 end
  return os, bits
end


function ultraschall.IsOS_Other()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsOS_Other</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean is_other, integer number_of_bits = ultraschall.IsOS_Other()</functioncall>
  <description>
    returns, if the current operating system is neither mac or win
  </description>
  <retvals>
    boolean is_other - true, if the operating-system is neither mac or win; false if not
    integer bits - the number of bits of the operating-system. Either 32 or 64 bit.; nil if is_other=false
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, check, operating system, os, other, linux, bits</tags>
</US_DocBloc>
--]]
  -- prepare variables
  local retval=reaper.GetOS()
  local os, bits
  
  -- check for os and bits
  if retval:match("Other")~=nil then os=true 
  else
    os=false
  end
  if os==true and retval:match("32")~=nil then bits=32 end
  if os==true and retval:match("64")~=nil then bits=64 end
  return os, bits
end



function ultraschall.GetReaperAppVersion()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperAppVersion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer majorversion, integer subversion, string bits, string os, boolean portable = ultraschall.GetReaperAppVersion()</functioncall>
  <description>
    Returns operating system and if it's a 64bit/32bit-operating system.
  </description>
  <retvals>
    integer majorversion - the majorversion of Reaper. Can be used for comparisions like "if version<5 then ... end".
    integer subversion - the subversion of Reaper. Can be used for comparisions like "if subversion<96 then ... end".
    string bits - the number of bits of the reaper-app
    string os - the operating system, either "Win", "OSX" or "Other"
    boolean portable - true, if it's a portable installation; false, if it isn't a portable installation
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, appversion, reaper, version, bits, majorversion, subversion</tags>
</US_DocBloc>
--]]
  -- if exe-path and resource-path are the same, it is an portable-installation
  if reaper.GetExePath()==reaper.GetResourcePath() then portable=true else portable=false end
  -- separate the returned value from GetAppVersion
  return tonumber(reaper.GetAppVersion():match("(.-)%..-/")), tonumber(reaper.GetAppVersion():match("%.(.-)/")), reaper.GetAppVersion():match("/(.*)"), reaper.GetOS():match("(.-)%d"), portable
end


--A,B,C,D=ultraschall.GetReaperAppVersion()
--A,B,C,D,E,F,G=ultraschall.GetReaperAppVersion()

function ultraschall.GetItemSpectralConfig(itemidx, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSpectralConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer item_spectral_config = ultraschall.GetItemSpectralConfig(integer itemidx, optional string MediaItemStateChunk)</functioncall>
  <description>
    returns the item-spectral-config, which is the fft-size of the spectral view for this item.
    set itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.
    
    returns -1 in case of error or if no spectral-config exists(e.g. when no spectral-edit is applied to this item)
  </description>
  <parameters>
    integer itemidx - the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk
    optional string MediaItemStateChunk - you can give a MediaItemStateChunk to process, if itemidx is set to -1
  </parameters>
  <retvals>
    integer item_spectral_config - the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; -1, if not existing
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, item, spectral edit, fft, size</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("GetItemSpectralConfig","itemidx", "only integer allowed", -1) return -1 end
  if itemidx~=-1 and itemidx<1 or itemidx>reaper.CountMediaItems(0) then ultraschall.AddErrorMessage("GetItemSpectralConfig","itemidx", "no such item exists", -2) return -1 end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("GetItemSpectralConfig","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -5) return false end

  -- get statechunk, if necessary(itemidx~=-1)
  local _retval
  if itemidx~=-1 then 
    local MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  -- get the value of SPECTRAL_CONFIG and return it
  local retval=MediaItemStateChunk:match("SPECTRAL_CONFIG (.-)%c")
  if retval==nil then ultraschall.AddErrorMessage("GetItemSpectralConfig","", "no spectral-edit-config available", -3) return nil end
  return tonumber(retval)
end

--mi=reaper.GetMediaItem(0,1)
--_raetval, misc=reaper.GetItemStateChunk(mi,"",false)

--AAA=ultraschall.GetItemSpectralConfig(1, misc)
--reaper.MB(misc,"",0)
--reaper.MB(A,"",0)

function ultraschall.SetItemSpectralConfig(itemidx, item_spectral_config, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemSpectralConfig</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string MediaItemStateChunk = ultraschall.SetItemSpectralConfig(integer itemidx, integer item_spectral_config, optional string MediaItemStateChunk)</functioncall>
  <description>
    sets the item-spectral-config, which is the fft-size of the spectral view for this item. 
    
    returns false in case of error or if no spectral-config exists(e.g. when no spectral-edit is applied to this item)
  </description>
  <parameters>
    integer itemidx - the number of the item, with 1 for the first item, 2 for the second, etc.; -1, if you want to use the optional parameter MediaItemStateChunk
    integer item_spectral_config - the fft-size in points for the spectral-view; 16, 32, 64, 128, 256, 512, 1024(default), 2048, 4096, 8192; nil, to remove it
                                 - nil will only remove it, when SPECTRAL_EDIT is removed from item first; returned statechunk will have it removed still
    optional string MediaItemStateChunk - a MediaItemStateChunk you want to have altered; works only, if itemdidx is set to -1, otherwise it will be ignored
  </parameters>
  <retvals>
    boolean retval - true, if setting spectral-config worked; false, if not
    string MediaItemStateChunk - the altered MediaItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, set, item, spectral edit, fft, size</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralConfig","itemidx", "only integer allowed", -1) return false end
  if itemidx~=-1 and (itemidx<1 or itemidx>reaper.CountMediaItems(0)) then ultraschall.AddErrorMessage("SetItemSpectralConfig","itemidx", "no such item exists", -2) return false end
  if math.type(item_spectral_config)~="integer" and item_spectral_config~=nil then ultraschall.AddErrorMessage("SetItemSpectralConfig","item_spectral_config", "only integer or nil allowed", -3) return false end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("SetItemSpectralConfig","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -5) return false end
  -- check for valid values, but seems not neccessary with Reaper...
  --  if item_spectral_config~=16 and item_spectral_config~=32 and item_spectral_config~=64 and item_spectral_config~=128 and item_spectral_config~=256 and 
  --     item_spectral_config~=512 and item_spectral_config~=1024 and item_spectral_config~=2048 and item_spectral_config~=4096 and item_spectral_config~=8192 and 
  --     item_spectral_config~=-1 then ultraschall.AddErrorMessage("SetItemSpectralConfig","item_spectral_config", "no valid value", -4) return -1 end
  
  -- get statechunk, if necessary(itemidx isn't set to -1)
  local MediaItem, _retval
  if itemidx~=-1 then 
    MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  -- check, if SPECTRAL_CONFIG exists at all
  local retval=MediaItemStateChunk:match("SPECTRAL_CONFIG (.-)%c")
  if retval==nil then ultraschall.AddErrorMessage("SetItemSpectralConfig","itemidx", "can't set, no spectral-config available.", -6)  return false end

  -- add or delete the Spectral-Config-setting
  if item_spectral_config~=nil then MediaItemStateChunk=MediaItemStateChunk:match("(.-)SPECTRAL_CONFIG").."SPECTRAL_CONFIG "..item_spectral_config..MediaItemStateChunk:match("SPECTRAL_CONFIG.-(%c.*)") end
  if item_spectral_config==nil then MediaItemStateChunk=MediaItemStateChunk:match("(.-)SPECTRAL_CONFIG")..MediaItemStateChunk:match("SPECTRAL_CONFIG.-%c(.*)") end
  
  -- set to item, if itemidx~=-1 and return values afterwards
  if itemidx~=-1 then reaper.SetItemStateChunk(MediaItem, MediaItemStateChunk, false) end
  return true, MediaItemStateChunk
end


--mi=reaper.GetMediaItem(0,1)
--_raetval, misc=reaper.GetItemStateChunk(mi,"",false)

--L,LL=ultraschall.SetItemSpectralConfig(2, nil, misc)
--reaper.MB(LL,"",0)


function ultraschall.ConvertColorToGFX(r,g,b,a)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorToGFX</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number r, number g, number b, number a = ultraschall.ConvertColorToGFX(integer r, integer g, integer b, integer a)</functioncall>
  <description>
    converts red,green,blue,alpha-values from 0-255 range to 0-1 range, so these values can be used by Reaper-Lua's gfx.functions().
    
    supports negative-values up from -255 to +255, so you can use the function as well for subtraction of colorvalues.
    
    returns nil in case of error
  </description>
  <parameters>
    integer r - the red-color-value between -255 and +255
    integer g - the green-color-value between -255 and +255
    integer b - the blue-color-value between -255 and +255
    integer a - the alpha-color-value between -255 and +255
  </parameters>
  <retvals>
    number r - the converted red-value between -1 and +1; nil in case of error
    number g - the converted green-value between -1 and +1
    number b - the converted blue-value between -1 and +1
    number a - the converted alpha-value between -1 and +1
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, red, green, blue, alpha, color, gfx</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(r)~="integer" then ultraschall.AddErrorMessage("ConvertColorToGFX","r", "must be an integer", -1)  return end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("ConvertColorToGFX","g", "must be an integer", -2)  return end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("ConvertColorToGFX","b", "must be an integer", -3)  return end
  if math.type(a)~="integer" then ultraschall.AddErrorMessage("ConvertColorToGFX","a", "must be an integer", -4)  return end
  if r<-255 or r>255 then ultraschall.AddErrorMessage("ConvertColorToGFX","r", "must be between -255 and 255", -5)  return end
  if g<-255 or g>255 then ultraschall.AddErrorMessage("ConvertColorToGFX","g", "must be between -255 and 255", -6)  return end
  if b<-255 or b>255 then ultraschall.AddErrorMessage("ConvertColorToGFX","b", "must be between -255 and 255", -7)  return end
  if a<-255 or a>255 then ultraschall.AddErrorMessage("ConvertColorToGFX","a", "must be between -255 and 255", -8)  return end
  
  -- do the conversion
  local factor=1/255
  return ((r+1)*factor)-1/255, ((g+1)*factor)-1/255, ((b+1)*factor)-1/255, ((a+1)*factor)-1/255
end

--A,B,C,D,E=ultraschall.ConvertColorToGFX(255,255,255,-255)

function ultraschall.ConvertGFXToColor(r,g,b,a)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertGFXToColor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer r, integer g, integer b, integer a = ultraschall.ConvertGFXToColor(number r, number g, number b, number a)</functioncall>
  <description>
    converts red,green,blue,alpha-values from 0-1 range to 0-255 range, so these values can be used by Reaper's normal color-value-functions.
    
    supports negative-values up from -1 to +1, so you can use the function as well for subtraction of colorvalues.
    
    returns nil in case of error
  </description>
  <parameters>
    number r - the converted red-value between -1 and +1; nil in case of error
    number g - the converted green-value between -1 and +1
    number b - the converted blue-value between -1 and +1
    number a - the converted alpha-value between -1 and +1
  </parameters>
  <retvals>
    integer r - the red-color-value between -255 and +255
    integer g - the green-color-value between -255 and +255
    integer b - the blue-color-value between -255 and +255
    integer a - the alpha-color-value between -255 and +255
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, red, green, blue, alpha, color, gfx</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(r)~="number" then ultraschall.AddErrorMessage("ConvertGFXToColor","r", "must be a number", -1)  return nil end
  if type(g)~="number" then ultraschall.AddErrorMessage("ConvertGFXToColor","g", "must be a number", -2)  return nil end
  if type(b)~="number" then ultraschall.AddErrorMessage("ConvertGFXToColor","b", "must be a number", -3)  return nil end
  if type(a)~="number" then ultraschall.AddErrorMessage("ConvertGFXToColor","a", "must be a number", -4)  return nil end
  if r<-1 or r>1 then ultraschall.AddErrorMessage("ConvertGFXToColor","r", "must be between -1 and 1", -5)  return nil end
  if g<-1 or g>1 then ultraschall.AddErrorMessage("ConvertGFXToColor","g", "must be between -1 and 1", -6)  return nil end
  if b<-1 or b>1 then ultraschall.AddErrorMessage("ConvertGFXToColor","b", "must be between -1 and 1", -7)  return nil end
  if a<-1 or a>1 then ultraschall.AddErrorMessage("ConvertGFXToColor","a", "must be between -1 and 1", -8)  return nil end
  
  -- do the conversion
  local factor=255
  return r*factor, g*factor, b*factor, a*factor
end

--A,B,C,D=ultraschall.ConvertGFXToColor(1,1,1,0)

function ultraschall.CountItemSpectralEdits(itemidx, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountItemSpectralEdits</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count = ultraschall.CountItemSpectralEdits(integer itemidx, optional string MediaItemStateChunk)</functioncall>
  <description>
    counts the number of SPECTRAL_EDITs in a given MediaItem/MediaItemStateChunk.
    The SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.
    If itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.
    
    returns -1 in case of error
  </description>
  <parameters>
    integer itemidx - the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead
    optional string MediaItemStateChunk - if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored
  </parameters>
  <retvals>
    integer count - the number of spectral-edits available in a given MediaItem/MediaItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, count, item, spectral edit</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("CountItemSpectralEdits","itemidx", "only integer allowed", -1) return -1 end
  if itemidx~=-1 and itemidx<1 or itemidx>reaper.CountMediaItems(0) then ultraschall.AddErrorMessage("CountItemSpectralEdits","itemidx", "no such item exists", -2) return -1 end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("CountItemSpectralEdits","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -5) return -1 end

  -- get statechunk, if necessary(itemidx~=-1)
  local _retval, MediaItem
  if itemidx~=-1 then 
    MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  local offset=0
  local counter=0
  local match=""
  while MediaItemStateChunk:match("SPECTRAL_EDIT", offset)~= nil do
    match, offset=MediaItemStateChunk:match("(SPECTRAL_EDIT)()", offset+1)
    if match~=nil then counter=counter+1 end
  end
  return counter
end

--item=reaper.GetMediaItem(0,0)
--BB,B=reaper.GetItemStateChunk(item,"",false)
--A2=ultraschall.CountItemSpectralEdits(-1, B)


function ultraschall.GetItemSpectralEdit(itemidx, spectralidx, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSpectralEdit</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>number start_pos, number end_pos, number gain, number fade, number freq_fade, number freq_range_bottom, number freq_range_top, integer h, integer byp_solo, number gate_thres, number gate_floor, number comp_thresh, number comp_exp_ratio, number n, number o, number fade2, number freq_fade2 = ultraschall.GetItemSpectralEdit(integer itemidx, integer spectralidx, optional string MediaItemStateChunk)</functioncall>
  <description>
    returns the settings of a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.
    The SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.
    If itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.
    
    returns -1 in case of error
  </description>
  <parameters>
    integer itemidx - the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead
    integer spectralidx - the number of the spectral-edit to return; 1 for the first, 2 for the second, etc
    optional string MediaItemStateChunk - if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored
  </parameters>
  <retvals>
    number start_pos - the startposition of the spectral-edit-region in seconds
    number end_pos - the endposition of the spectral-edit-region in seconds
    number gain - the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB
    number fade - 0(0%)-0.5(100%); adjusting this affects also parameter fade2!
    number freq_fade - 0(0%)-0.5(100%); adjusting this affects also parameter freq_fade2!
    number freq_range_bottom - the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    number freq_range_top - the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    integer h - unknown
    integer byp_solo - sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo
    number gate_thres - sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)
    number gate_floor - sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)
    number comp_thresh - sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default
    number comp_exp_ratio - sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default
    number n - unknown
    number o - unknown
    number fade2 - negative with fade_in set; positive with fadeout-set
    number freq_fade2 - negative with low frequency-fade, positive with high-frequency-fade
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, item, spectral edit</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("GetItemSpectralEdit","itemidx", "only integer allowed", -1) return -1 end
  if itemidx~=-1 and itemidx<1 or itemidx>reaper.CountMediaItems(0) then ultraschall.AddErrorMessage("GetItemSpectralEdit","itemidx", "no such item exists", -2) return -1 end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("GetItemSpectralEdit","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -3) return -1 end

  if math.type(spectralidx)~="integer" then ultraschall.AddErrorMessage("GetItemSpectralEdit","spectralidx", "only integer allowed", -4) return -1 end
  if spectralidx<1 or spectralidx>ultraschall.CountItemSpectralEdits(itemidx, MediaItemStateChunk) then ultraschall.AddErrorMessage("GetItemSpectralEdit","spectralidx", "no such spectral-edit available, must be between 1 and maximum count of spectral-edits.", -5) return -1 end

  -- get statechunk, if necessary(itemidx~=-1)
  local _retval, MediaItem
  if itemidx~=-1 then 
    MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  -- prepare variables
  local offset=0
  local counter=-1
  local found=""
  local match=""
  
  -- look for the spectralidx-th entry
  while MediaItemStateChunk:match("SPECTRAL_EDIT", offset+1)~= nil do
    offset, match=MediaItemStateChunk:match("()(SPECTRAL_EDIT)", offset+1)
    if match~=nil then counter=counter+1 end
    if counter==spectralidx-1 then found=MediaItemStateChunk:match("(SPECTRAL_EDIT.-%c)", offset) end
  end
  
  -- convert to numbers and return
  local L1,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12,L13,L14,L15,L16,L17 = found:match("SPECTRAL_EDIT (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-)%c")
  return tonumber(L1), tonumber(L2), tonumber(L3), tonumber(L4), tonumber(L5), tonumber(L6), tonumber(L7), tonumber(L8), tonumber(L9), tonumber(L10), 
         tonumber(L11), tonumber(L12), tonumber(L13), tonumber(L14), tonumber(L15), tonumber(L16), tonumber(L17)
end

--L,L2,L3,L4,L5,L6,L7,L8,L9,L10,L11,L12,L13,L14,L15,L16,L17=ultraschall.GetItemSpectralEdit(1, 4, MediaItemStateChunk)



function ultraschall.DeleteItemSpectralEdit(itemidx, spectralidx, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteItemSpectralEdit</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string MediaItemStateChunk = ultraschall.DeleteItemSpectralEdit(integer itemidx, integer spectralidx, optional string MediaItemStateChunk)</functioncall>
  <description>
    deletes a specific SPECTRAL_EDIT in a given MediaItem/MediaItemStateChunk.
    The SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.
    If itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.
    
    returns false in case of error
  </description>
  <parameters>
    integer itemidx - the MediaItem to look in for the spectral-edit; -1, to use the parameter MediaItemStateChunk instead
    integer spectralidx - the number of the spectral-edit to delete; 1 for the first, 2 for the second, etc
    optional string MediaItemStateChunk - if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored
  </parameters>
  <retvals>
    boolean retval - true, if deleting an spectral-edit-entry was successful; false, if it was unsuccessful
    string MediaItemStateChunk - the altered MediaItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, delete, item, spectral edit</tags>
</US_DocBloc>
--]]

  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("DeleteItemSpectralEdit","itemidx", "only integer allowed", -1) return false end
  if itemidx~=-1 and itemidx<1 or itemidx>reaper.CountMediaItems(0) then ultraschall.AddErrorMessage("DeleteItemSpectralEdit","itemidx", "no such item exists", -2) return false end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("DeleteItemSpectralEdit","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -3) return false end

  if math.type(spectralidx)~="integer" then ultraschall.AddErrorMessage("DeleteItemSpectralEdit","spectralidx", "only integer allowed", -4) return false end
  if spectralidx<1 or spectralidx>ultraschall.CountItemSpectralEdits(itemidx, MediaItemStateChunk) then ultraschall.AddErrorMessage("DeleteItemSpectralEdit","spectralidx", "no such spectral-edit available, must be between 1 and maximum count of spectral-edits.", -5) return false end

  -- get statechunk, if necessary(itemidx~=-1)
  local _retval, MediaItem
  if itemidx~=-1 then 
    MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  -- prepare variables
  local offset=0
  local counter=-1
  local found=""
  local match=""
  local offset2=0
  
  -- look for the spectralidx-th entry
  while MediaItemStateChunk:match("SPECTRAL_EDIT", offset+1)~= nil do
    offset, match, offset2 = MediaItemStateChunk:match("()(SPECTRAL_EDIT.-)%c()", offset+1)
--    reaper.MB(match, offset.." "..offset2,0)
    if match~=nil then counter=counter+1 end
    if counter==spectralidx-1 then found=MediaItemStateChunk:sub(1,offset-1)..MediaItemStateChunk:match("SPECTRAL_EDIT.-%c(.*)", offset) end
  end
  
  -- set to MediaItem(if itemidx==-1) and after that return the altered statechunk
  if itemidx~=-1 then reaper.SetItemStateChunk(MediaItem, found, false) end
  return true, found
end

--L,LL=ultraschall.DeleteItemSpectralEdit(1, 1, "")
--reaper.MB(LL,"",0)

function ultraschall.SetItemSpectralVisibilityState(item, state, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemSpectralVisibilityState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MediaItemStateChunk = ultraschall.SetItemSpectralVisibilityState(integer itemidx, integer state, optional string MediaItemStateChunk)</functioncall>
  <description>
    Sets SPECTROGRAM-state in a MediaItem or MediaItemStateChunk.
    Setting it shows the spectrogram, in which you can do spectral-editing, as selected in the MediaItem-menu "Spectral-editing -> Toggle show spectrogram for selected items"
    
    It returns the modified MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    integer itemidx - the number of the item in the project; use -1 to use MediaItemStateChunk instead
    integer state - the state of the SPECTROGRAM; 0, to hide SpectralEdit; 1, to set SpectralEdit visible
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk; only read, when itemidx=-1
  </parameters>
  <retvals>
    string MediaItemStateChunk - the altered rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, spectrogram, set</tags>
</US_DocBloc>
]]
  if math.type(item)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "item", "Must be an integer; -1, to use trackstatechunk.", -1) return -1 end
  if item~=-1 and reaper.ValidatePtr2(0, reaper.GetMediaItem(0,item-1), "MediaItem*")==false then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "item", "Must be a valid MediaItem-idx or -1, when using ItemStateChunk).", -2) return -1 end
  if type(statechunk)~="string" and item==-1 then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "statechunk", "Must be a string", -3) return -1 end
  if item==-1 and ultraschall.IsValidItemStateChunk(statechunk)==false then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "statechunk", "Must be a valid MediaItemStateChunk", -4) return -1 end
  local _bool, bool
  if item~=-1 then item=reaper.GetMediaItem(0,item-1) _bool, statechunk=reaper.GetItemStateChunk(item,"",false) end
  if math.type(state)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "state", "Must be an integer", -5) return -1 end
  if state~=0 and state~=1 then ultraschall.AddErrorMessage("SetItemSpectralVisibilityState", "state", "Must be 1 or 0", -6) return -1 end
  
  if statechunk:match("SPECTROGRAM")~=nil and state==0 then 
    statechunk,temp=statechunk:match("(.-)SPECTROGRAM .-%c(.*)")
    statechunk=statechunk..temp
  elseif statechunk:match("SPECTROGRAM")==nil and state==1 then 
    statechunk, temp=statechunk:match("(.-IID.-%c).-(NAME.*)")
    statechunk=statechunk.."SPECTROGRAM 1\n"..temp
  end
  if item~=-1 then reaper.SetItemStateChunk(item,statechunk,true) end
  return statechunk
end

--item=reaper.GetMediaItem(0,0)
--a,A=reaper.GetItemStateChunk(item, "", true)
--A=ultraschall.SetItemSpectralVisibilityState(1, 1)
--reaper.MB(A,"",0)
--reaper.SetItemStateChunk(item, A, false)
--reaper.UpdateArrange()

function ultraschall.SetItemSpectralEdit(itemidx, spectralidx, start_pos, end_pos, gain, fade, freq_fade, freq_range_bottom, freq_range_top, h, byp_solo, gate_thres, gate_floor, comp_thresh, comp_exp_ratio, n, o, fade2, freq_fade2, statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemSpectralEdit</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string MediaItemStateChunk = ultraschall.SetItemSpectralEdit(integer itemidx, integer spectralidx, number start_pos, number end_pos, number gain, number fade, number freq_fade, number freq_range_bottom, number freq_range_top, integer h, integer byp_solo, number gate_thres, number gate_floor, number comp_thresh, number comp_exp_ratio, number n, number o, number fade2, number freq_fade2, optional string MediaItemStateChunk)</functioncall>
  <description>
    Sets a spectral-edit-instance in a MediaItem or MediaItemStateChunk.
    
    After committing the changed MediaItemStateChunk to a MediaItem, Reaper may change the order of the spectral-edits! Keep that in mind, when changing numerous Spectral-Edits or use MediaItemStateChunks for the setting before committing them to a MediaItem using Reaper's function reaper.SetItemStateChunk().
    
    It returns the modified MediaItemStateChunk.
    Returns -1 in case of error.
  </description>
  <parameters>
    integer itemidx - the number of the item in the project; use -1 to use MediaItemStateChunk instead
    integer spectralidx - the number of the spectral-edit-instance, that you want to set
    number start_pos - the startposition of the spectral-edit-region in seconds
    number end_pos - the endposition of the spectral-edit-region in seconds
    number gain - the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB
    number fade - 0(0%)-0.5(100%); adjusting this affects also parameter fade2!
    number freq_fade - 0(0%)-0.5(100%); adjusting this affects also parameter freq_fade2!
    number freq_range_bottom - the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    number freq_range_top - the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    integer h - unknown
    integer byp_solo - sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo
    number gate_thres - sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)
    number gate_floor - sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)
    number comp_thresh - sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default
    number comp_exp_ratio - sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default
    number n - unknown
    number o - unknown
    number fade2 - negative with fade_in set; positive with fadeout-set
    number freq_fade2 - negative with low frequency-fade, positive with high-frequency-fade
    optional string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </parameters>
  <retvals>
    string MediaItemStateChunk - an rpp-xml-statechunk, as created by reaper-api-functions like GetItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, statechunk, rppxml, state, chunk, spectraledit, edit, set</tags>
</US_DocBloc>
]]
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "itemidx", "Must be an integer; -1, to use trackstatechunk.", -1) return -1 end
  if itemidx~=-1 and reaper.ValidatePtr2(0, reaper.GetMediaItem(0,itemidx-1), "MediaItem*")==false then ultraschall.AddErrorMessage("SetItemSpectralEdit", "itemidx", "Must be a valid MediaItem-idx or -1, when using ItemStateChunk).", -2) return -1 end
  if type(statechunk)~="string" and itemidx==-1 then ultraschall.AddErrorMessage("SetItemSpectralEdit", "statechunk", "Must be a string", -3) return -1 end

  local _bool, item2, count
  item2=itemidx
  if itemidx~=-1 then itemidx=reaper.GetMediaItem(0,itemidx-1) _bool, statechunk=reaper.GetItemStateChunk(itemidx,"",false) end
  if math.type(spectralidx)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "spectralidx", "Must be an integer", -7) return -1 end
  if type(start_pos)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "start_pos", "Must be a number", -8) return -1 end
  if type(end_pos)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "end_pos", "Must be a number", -9) return -1 end
  if type(gain)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "gain", "Must be a number", -10) return -1 end
  if type(fade)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "fade", "Must be a number", -11) return -1 end
  if type(freq_fade)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "freq_fade", "Must be a number", -12) return -1 end
  if type(freq_range_bottom)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "freq_range_bottom", "Must be a number", -13) return -1 end
  if type(freq_range_top)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "freq_range_top", "Must be a number", -14) return -1 end
  if math.type(h)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "h", "Must be an integer", -15) return -1 end
  if math.type(byp_solo)~="integer" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "byp_solo", "Must be an integer", -16) return -1 end
  if type(gate_thres)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "gate_thres", "Must be a number", -17) return -1 end
  if type(gate_floor)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "gate_floor", "Must be a number", -18) return -1 end
  if type(comp_thresh)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "comp_thresh", "Must be a number", -19) return -1 end
  if type(comp_exp_ratio)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "comp_exp_ratio", "Must be a number", -20) return -1 end
  if type(n)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "n", "Must be a number", -21) return -1 end
  if type(o)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "o", "Must be a number", -22) return -1 end
  if type(fade2)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "fade2", "Must be a number", -23) return -1 end
  if type(freq_fade2)~="number" then ultraschall.AddErrorMessage("SetItemSpectralEdit", "freq_fade2", "Must be a number", -24) return -1 end

  count = ultraschall.CountItemSpectralEdits(item2, statechunk)
  if spectralidx>count then ultraschall.AddErrorMessage("SetItemSpectralEdit", "spectralidx", "No such spectral edit available", -25) return -1 end
  
  local new_entry="SPECTRAL_EDIT "..start_pos.." "..end_pos.." "..gain.." "..fade.." "..freq_fade.." "..freq_range_bottom.." "..freq_range_top.." "..h.." "..byp_solo.." "..gate_thres.." "..gate_floor.." "..comp_thresh.." "..comp_exp_ratio.." "..n.." "..o.." "..fade2.." "..freq_fade2
  local part1, part2=statechunk:match("(.-)(SPECTRAL_EDIT.*)")
  
  for i=1, spectralidx-1 do
    part1=part1..part2:match("(SPECTRAL_EDIT.-%c)")
    part2=part2:match("SPECTRAL_EDIT.-%c(.*)")
  end

  statechunk=part1..new_entry.."\n"..part2:match("SPECTRAL_EDIT.-%c(.*)")
  
  if itemidx~=-1 then reaper.SetItemStateChunk(itemidx,statechunk,true) end
  return statechunk
end

--item=reaper.GetMediaItem(0,0)
--b,sc=reaper.GetItemStateChunk(item, "", false)

--reaper.MB(sc,"",0)
--A=ultraschall.SetItemSpectralEdit(1, 2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, "")
--reaper.MB(A,"",0)


function ultraschall.LimitFractionOfFloat(number, length_of_fraction, roundit)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>LimitFractionOfFloat</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>number altered_number = ultraschall.LimitFractionOfFloat(number number, integer length_of_fraction, boolean roundit)</functioncall>
  <description>
    limits the fraction of a float-number to a specific length of fraction(digits). You can also choose to round the value or not.
    
    returns nil in case of error
  </description>
  <parameters>
    number number - the number, whose fraction shall be limited
    integer length_of_fraction - the number of digits in the fraction
    boolean roundit - false, no rounding; true, rounds the fraction. Rounding-precision is only length_of_fraction+1, all the other digits will be ignored. If length_of_fraction+1>=5, it will be rounded up, otherwise down.
  </parameters>
  <retvals>
    number altered_number - the altered number with the new fraction-length. Will be equal to parameter number, if number was integer or fraction less digits than length_of_fraction
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, limit, fraction, round, number</tags>
</US_DocBloc>
--]]
  if type(number)~="number" then ultraschall.AddErrorMessage("LimitFractionOfFloat", "number", "must be a number", -1) return end
  if math.type(length_of_fraction)~="integer" then ultraschall.AddErrorMessage("LimitFractionOfFloat", "length_of_fraction", "must be an integer", -2) return end
  if type(roundit)~="boolean" then ultraschall.AddErrorMessage("LimitFractionOfFloat", "roundit", "must be boolean", -3) return end
  if math.floor(number)==number then return number end
  number=tostring(number)
  local pos_point, pos_end_of_fraction=number:match(".-%.().*()")
  if length_of_fraction>=pos_end_of_fraction-pos_point then return tonumber(number) end

  if roundit==false then return tonumber(number:sub(1,pos_point+length_of_fraction-1))
  elseif roundit==true then 
    local int=number:sub(1,pos_point-2)
    local frac=tonumber(number:sub(pos_point,pos_point+length_of_fraction-1))
    local frac2=tonumber(number:sub(pos_point+length_of_fraction, pos_point+length_of_fraction))
    if frac2>=5 then return tonumber(int.."."..frac+1)
    else return tonumber(int.."."..frac)
    end
  end
end

--AA=ultraschall.LimitFractionOfFloat(19999.12345, 4.1, true)


function ultraschall.GetAllEntriesFromTable(table)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllEntriesFromTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count, table foundtypes, table returned_table = ultraschall.GetAllEntriesFromTable(table table)</functioncall>
  <description>
    Gets an iterable version of table. Good for analysing unknown tables.
    
    Returns the number of entries, a table(array) with the datatypes of each entry and the table with all it's entries in the same order as in the foundtypes-table.
    
    This doesn't treat table recursivley, means: each "Subtable" within the table is treated as one entry of the type "table". That means, that these tables must be analysed themselves in an extra step!
    A[1]=1
    A[2][1]=2
    A[2][2]=3.4
    will return two(!) entries, the first being of type "integer", the second being of type "table". Next step would be to run use this function to analyse A[2] as well, which would result in two entries: the first being of type "integer" and the second of type "float", etc.
    
    returns -1 in case of error
  </description>
  <parameters>
    table table - the table to get the individual entries from
  </parameters>
  <retvals>
    integer count - the number of table-entries found
    table foundtypes - a table, with count-entries, each entry having the type of each entry in the returned_table as string.
                     - The types can be "nil", "integer", "float", "string", "boolean", "table", "function", "thread", "userdata"
    table returned_table - an iterable version of table. The type of each entry can be found in the accompanying entry of foundtypes
                         - the format is returned_table[indexnr][1] - indexname/number of the original table-entry
                         -               returned_table[indexnr][2] - the value of the original table-entry
                         - the indexnr is 1 to count, while [indexnr][1] is the indexnr of the original-table-entry, which might be a string, functionname or something else as well
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, table, iterable, all entries, get</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(table)~="table" then ultraschall.AddErrorMessage("GetAllEntriesFromTable", "table", "must be a table", -1) return -1 end
  
  -- prepare variables
  local table2={}
  local table3={}
  local count=1
  
  -- get all table-entries(parts of the code from the Lua5.3-Reference-Manual)
  for i,v in pairs(table) do 
    table2[count]={}
    table2[count][1]=i
    table2[count][2]=v
    if type(v)~="number" then table3[count]=type(v)
    else table3[count]=math.type(v)
    end
    count=count+1
  end
  
  -- return found entries
  return count-1, table3, table2
end


--[[A={}
A[1]="tudelu"
A["Hutzelblutz"]="Hops"
A[3]="klo"
A[4]={}
A[4][1]="Holla"
A[4][2]="die"
A[4][3]="Waldfee"
A[5]=9
A[5]=9.9
A[6]=reaper.MB
--]]
--L,LL,LLL=ultraschall.GetAllEntriesFromTable(ultraschall)

function ultraschall.GetItemSourceFile_Take(MediaItem, take_nr)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSourceFile_Take</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string source_filename, PCM_source source, MediaItem_Take take = ultraschall.GetItemSourceFile_Take(MediaItem MediaItem, integer take_nr)</functioncall>
  <description>
    returns filename, the PCM_Source-object and the MediaItem_Take-object of a specific take. Use take_nr=0 for active take.
    
    returns nil in case of error
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem-object, in which the requested take lies
    integer take_nr - the number of the requested take; use 0 for the active take
  </parameters>
  <retvals>
    string source_filename - the filename of the requested take
    PCM_source source - the PCM_source-object of the requested take
    MediaItem_Take take - the Media-Item_Take-object of the requested take
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem-Takes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, track, get, item, mediaitem, take, pcmsource, filename</tags>
</US_DocBloc>
--]]
  -- check parameters
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")~=true then ultraschall.AddErrorMessage("GetItemSourceFile_Take", "MediaItem", "must be a MediaItem-object", -1) return nil end
  if math.type(take_nr)~="integer" then ultraschall.AddErrorMessage("GetItemSourceFile_Take", "take_nr", "must be an integer; 0 for active take", -2) return nil end
  
  -- get correct MediaItem_Take-object
  local MediaItem_Take
  if take_nr>0 then MediaItem_Take = reaper.GetMediaItemTake(MediaItem, take_nr-1)
  elseif take_nr==0 then MediaItem_Take=reaper.GetActiveTake(MediaItem)
  end
  if MediaItem_Take==nil then ultraschall.AddErrorMessage("GetItemSourceFile_Take", "take_nr", "no such take", -3) return nil end  

  -- get the pcm-source, the source-filename and return it with the MediaItem_Take-object
  local PCM_source=reaper.GetMediaItemTake_Source(MediaItem_Take)
  local filenamebuf = reaper.GetMediaSourceFileName(PCM_source, "")
  
  return filenamebuf, PCM_source, MediaItem_Take
end

--MediaItem=reaper.GetMediaItem(0,1)
--A,A2,A3 = ultraschall.GetItemSourceFile_Take(MediaItem, -1)

function ultraschall.AddItemSpectralEdit(itemidx, start_pos, end_pos, gain, fade, freq_fade, freq_range_bottom, freq_range_top, h, byp_solo, gate_thres, gate_floor, comp_thresh, comp_exp_ratio, n, o, fade2, freq_fade2, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddItemSpectralEdit</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval, MediaItemStateChunk statechunk = ultraschall.AddItemSpectralEdit(integer itemidx, number start_pos, number end_pos, number gain, number fade, number freq_fade, number freq_range_bottom, number freq_range_top, integer h, integer byp_solo, number gate_thres, number gate_floor, number comp_thresh, number comp_exp_ratio, number n, number o, number fade2, number freq_fade2, optional string MediaItemStateChunk)</functioncall>
  <description>
    Adds a new SPECTRAL_EDIT-entry in a given MediaItem/MediaItemStateChunk.
    The SPECTRAL_EDITs are the individual edit-boundary-boxes in the spectral-view.
    If itemidx is set to -1, you can give the function a MediaItemStateChunk to look in, instead.
    
    returns false in case of error
  </description>
  <parameters>
    integer itemidx - the MediaItem to add to another spectral-edit-entry; -1, to use the parameter MediaItemStateChunk instead
    number start_pos - the startposition of the spectral-edit-region in seconds
    number end_pos - the endposition of the spectral-edit-region in seconds
    number gain - the gain as slider-value; 0(-224dB) to 98350.1875(99.68dB); 1 for 0dB
    number fade - 0(0%)-0.5(100%); adjusting this affects also parameter fade2!
    number freq_fade - 0(0%)-0.5(100%); adjusting this affects also parameter freq_fade2!
    number freq_range_bottom - the bottom of the edit-region, but can be moved to be top as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    number freq_range_top - the top of the edit-region, but can be moved to be bottom as well! 0 to device-samplerate/2 (e.g 96000 for 192kHz)
    integer h - unknown
    integer byp_solo - sets the solo and bypass-state. 0, no solo, no bypass; 1, bypass only; 2, solo only; 3, bypass and solo
    number gate_thres - sets the threshold of the gate; 0(-224dB)-98786.226563(99.89dB)
    number gate_floor - sets the floor of the gate; 0(-224dB)-99802.171875(99.98dB)
    number comp_thresh - sets the threshold for the compressor; 0(-224dB)-98842.484375(99.90dB); 1(0dB)is default
    number comp_exp_ratio - sets the ratio of the compressor/expander; 0.1(1:10.0)-100(100:1.0); 1(1.0:1) is default
    number n - unknown
    number o - unknown
    number fade2 - negative with fade_in set; positive with fadeout-set
    number freq_fade2 - negative with low frequency-fade, positive with high-frequency-fade
    string MediaItemStateChunk - if itemidx is -1, this can be a MediaItemStateChunk to use, otherwise this will be ignored
  </parameters>
  <retvals>
    boolean retval - true, if adding was successful; false, if adding wasn't successful
    optional MediaItemStateChunk statechunk - the altered MediaItemStateChunk
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, add, item, spectral edit</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "itemidx", "must be an integer", -18) return false end
  if type(start_pos)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "start_pos", "must be a number", -1) return false end
  if type(end_pos)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "end_pos", "must be a number", -2) return false end
  if type(gain)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "gain", "must be a number", -3) return false end
  if type(fade)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "fade", "must be a number", -4) return false end
  if type(freq_fade)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "freq_fade", "must be a number", -5) return false end
  if type(freq_range_bottom)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "freq_range_bottom", "must be a number", -6) return false end
  if type(freq_range_top)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "freq_range_top", "must be a number", -7) return false end
  if math.type(h)~="integer" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "h", "must be an integer", -8) return false end
  if math.type(byp_solo)~="integer" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "byp_solo", "must be an integer", -9) return false end
  if type(gate_thres)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "gate_thres", "must be a number", -10) return false end
  if type(gate_floor)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "gate_floor", "must be a number", -11) return false end
  if type(comp_thresh)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "comp_thresh", "must be a number", -12) return false end
  if type(comp_exp_ratio)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "comp_exp_ratio", "must be a number", -13) return false end
  if type(n)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "n", "must be a number", -14) return false end
  if type(o)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "o", "must be a number", -15) return false end
  if type(fade2)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "fade2", "must be a number", -16) return false end
  if type(freq_fade2)~="number" then ultraschall.AddErrorMessage("AddItemSpectralEdit", "freq_fade2", "must be a number", -17) return false end
  if itemidx==-1 and (type(MediaItemStateChunk)~="string" or MediaItemStateChunk:match("<ITEM.*>")==nil) then ultraschall.AddErrorMessage("AddItemSpectralEdit", "MediaItemStateChunk", "must be a MediaItemStateChunk", -19) return false end

  -- prepare variables
  local MediaItem, _l

  -- get MediaItemStateChunk, if necessary
  if itemidx~=-1 then 
    MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _l, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem, "", false)
  end

  -- add new Spectral-Edit-entry
  MediaItemStateChunk=MediaItemStateChunk:match("(.*)>")..
                       "SPECTRAL_EDIT "..start_pos.." "..end_pos.." "..gain.." "..fade.." "..freq_fade.." "..freq_range_bottom.." "..freq_range_top.." "..h.." "..
                       byp_solo.." "..gate_thres.." "..gate_floor.." "..comp_thresh.." "..comp_exp_ratio.." "..n.." "..o.." "..fade2.." "..freq_fade2.."\n>"
                       
  -- add changed statechunk to the item, if necessary
  if itemidx~=-1 then reaper.SetItemStateChunk(MediaItem, MediaItemStateChunk, false) end
  return true, MediaItemStateChunk
end


--LL=ultraschall.AddItemSpectralEdit(1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, "<ITEM>")


function ultraschall.APIExists(functionname)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>APIExists</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.APIExists(string functionname)</functioncall>
  <description>
    returns true, if a certain function/variable exists in ultraschall.
    
    returns false if nothing has been found
  </description>
  <parameters>
    string functionname - the name of the function to check for; only the functionname without ultraschall. !
  </parameters>
  <retvals>
    boolean retval - true, if element exists; false if it doesn't exist
  </retvals>
  <chapter_context>
    Developer
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, api, exists, function, variable, developer</tags>
</US_DocBloc>
--]]
  if ultraschall[functionname]~=nil then return true end
  return false
end

function ultraschall.CountDirectoriesAndFilesInPath(path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountDirectoriesAndFilesInPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer filecount, integer dircount= ultraschall.CountDirectoriesAndFilesInPath(string path)</functioncall>
  <description>
    returns the number of files and directories in path
    
    returns -1, in case of error
  </description>
  <parameters>
    string path - the path to count the files and directories from
  </parameters>
  <retvals>
    integer filecount - the number of files found in path
    integer dircount - the number of directories found in path
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, count, directory, file, path</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(path)~="string" then ultraschall.AddErrorMessage("CountDirectoriesAndFilesInPath", "path", "must be a string", -1) return -1 end
  
  -- prepare variables
  local string=""
  local filecount=0
  local dircount=0
  
  -- count files
  while string~=nil do
    string=reaper.EnumerateFiles(path, filecount)
    if string~=nil then filecount=filecount+1 end
  end
  local string=""
  
  -- count directories
  while string~=nil do
    string=reaper.EnumerateSubdirectories(path, dircount)
    if string~=nil then dircount=dircount+1 end
  end
  
  -- return counts
  return filecount, dircount
end

--L,LL=ultraschall.CountPathAndFilesInDirectory("c:\\")

function ultraschall.GetAllFilenamesInPath(path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllFilenamesInPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer filecount, array files = ultraschall.GetAllFilenamesInPath(string path)</functioncall>
  <description>
    returns the number of files and the filenames in path
    
    returns -1, in case of error
  </description>
  <parameters>
    string path - the path to get the filenames from
  </parameters>
  <retvals>
    integer filecount - the number of files found in path
    array files - the filenames found in path
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, get, filenames, file, path</tags>
</US_DocBloc>
--]]

  -- check parameters
  if type(path)~="string" then ultraschall.AddErrorMessage("GetAllFilenamesInPath", "path", "must be a string", -1) return -1 end

  -- prepare variables
  local Files={}
  local count=1
  local string=""
  
  -- get all filenames in path
  while string~=nil do
    string=reaper.EnumerateFiles(path, count-1)
    if string~=nil then Files[count]=path..string end
    count=count+1
  end
  
  -- return results
  return count-2, Files
end

function ultraschall.GetAllDirectoriesInPath(path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllDirectoriesInPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer filecount, array directories = ultraschall.GetAllDirectoriesInPath(string path)</functioncall>
  <description>
    returns the number of directories and the directorynames in path
    
    returns -1, in case of error
  </description>
  <parameters>
    string path - the path to get the directories from
  </parameters>
  <retvals>
    integer filecount - the number of directories found in path
    array files - the directories found in path
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, get, directory, file, path</tags>
</US_DocBloc>
--]]

  -- check parameters
  if type(path)~="string" then ultraschall.AddErrorMessage("GetAllDirectoriesInPath", "path", "must be a string", -1) return -1 end
  
  -- check variables
  local Dirs={}
  local count=1
  local string=""
  
  -- get directorynames
  while string~=nil do
    string=reaper.EnumerateSubdirectories(path, count-1)
    if string~=nil then Dirs[count]=path..string end
    count=count+1
  end
  
  -- return results
  return count-2, Dirs
end

--L,LL=ultraschall.GetAllDirectoriesInPath("C:\\")


function ultraschall.GetItemSpectralVisibilityState(itemidx, MediaItemStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemSpectralVisibilityState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer spectrogram_state = ultraschall.GetItemSpectralVisibilityState(integer itemidx, optional string MediaItemStateChunk)</functioncall>
  <description>
    returns, if spectral-editing is shown in the arrange-view of item itemidx
    set itemidx to -1 to use the optional parameter MediaItemStateChunk to alter a MediaItemStateChunk instead of an item directly.
    
    returns -1 in case of error
  </description>
  <parameters>
    integer itemidx - the number of the item, with 1 for the first item, 2 for the second, etc.; -1, to use the parameter MediaItemStateChunk
    optional string MediaItemStateChunk - you can give a MediaItemStateChunk to process, if itemidx is set to -1
  </parameters>
  <retvals>
    integer item_spectral_config - 0, if spectral-config isn't shown in arrange-view; 1, if spectral-config is shown in arrange-view
  </retvals>
  <chapter_context>
    MediaItem Management
    Spectral Edit
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, item, spectral edit, spectogram, show</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(itemidx)~="integer" then ultraschall.AddErrorMessage("GetItemSpectralVisibilityState","itemidx", "only integer allowed", -1) return -1 end
  if itemidx~=-1 and itemidx<1 or itemidx>reaper.CountMediaItems(0) then ultraschall.AddErrorMessage("GetItemSpectralVisibilityState","itemidx", "no such item exists", -2) return -1 end
  if itemidx==-1 and tostring(MediaItemStateChunk):match("<ITEM.*>")==nil then ultraschall.AddErrorMessage("GetItemSpectralVisibilityState","MediaItemStateChunk", "must be a valid MediaItemStateChunk", -5) return false end

  -- get statechunk, if necessary(itemidx~=-1)
  local _retval
  if itemidx~=-1 then 
    local MediaItem=reaper.GetMediaItem(0,itemidx-1)
    _retval, MediaItemStateChunk=reaper.GetItemStateChunk(MediaItem,"",false)
  end
  
  -- get the value of SPECTROGRAM and return it
  local retval=MediaItemStateChunk:match("SPECTROGRAM (.-)%c")
  if retval==nil then retval=0 end
  return tonumber(retval)
end

--L=ultraschall.GetItemSpectralVisibilityState(-1, "<ITEM\nSPECTROGRAM 1\n>")

--L,LL,LLL=ultraschall.GetAllEntriesFromTable(ultraschall)



function ultraschall.EnumProjects(idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumProjects</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ReaProject retval, string projfn = ultraschall.EnumProjects(integer idx)</functioncall>
  <description>
    returns, ReaProject-object and projectname of a requested, opened project.
    
    Returns nil in case of an error.
  </description>
  <parameters>
    integer idx - the project to request; 1(first project-tab) to n(last project-tab), 0 for current project; -1 for currently-rendering project
  </parameters>
  <retvals>
    ReaProject retval - a ReaProject-object of the project you requested; nil, if not existing
    string projfn - the path+filename.rpp of the project. returns "" if no filename exists
    
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, projectfiles, get, filename, project, reaproject, rendering, opened</tags>
</US_DocBloc>
--]]
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("EnumProjects","idx", "must be an integer", -1) return nil end
  if idx==0 then idx=-1
  elseif idx==-1 then idx=0x40000000
  else idx=idx-1
  end
  return reaper.EnumProjects(idx,"")
end

--A=reaper.EnumProjects(-1,"")
--B=ultraschall.EnumProjects(1)

--A,AA=ultraschall.EnumProjects(2)


--L=reaper.GetTrackEnvelope(reaper.GetTrack(0,0),4)
--LL,LLL=reaper.GetEnvelopeStateChunk(L,"",false)
--O=ultraschall.IsValidEnvStateChunk(LLL)
--BB,B=reaper.GetTrackStateChunk(reaper.GetTrack(0,0),"",false)
--A=ultraschall.IsValidTrackStateChunk(B:sub(1,-2))
--A,B=reaper.GetItemStateChunk(reaper.GetMediaItem(0,1),"",false)
--L=ultraschall.IsValidItemStateChunk(nil)

function ultraschall.DeleteProjExtState_Section(section)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteProjExtState_Section</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.DeleteProjExtState_Section(string section)</functioncall>
  <description>
    Deletes all key/values from a specific section.
    
    Returns -1 in case of an error.
  </description>
  <parameters>
    string section - the section/extname, whose key/values shall be deleted
  </parameters>
  <retvals>
    integer retval - 0, in case of success; -1, in case of an error
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>metadatamanagement, project, delete, extension, state, section</tags>
</US_DocBloc>
--]]
  if type(section)~="string" then ultraschall.AddErrorMessage("DeleteProjExtState_Section","section", "must be a string", -1) return -1 end
  if reaper.EnumProjExtState(0, section, 0)==false then ultraschall.AddErrorMessage("DeleteProjExtState_Section","section", "no key/values to delete", -2) return -1 end
  return reaper.SetProjExtState(0, section, "", "")
end

function ultraschall.DeleteProjExtState_Key(section, key)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteProjExtState_Key</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.DeleteProjExtState_Key(string section, section key)</functioncall>
  <description>
    Deletes the value from a specific section -> key.
    
    Returns -1 in case of an error.
  </description>
  <parameters>
    string section - the section/extname, from whom a key/value shall be deleted
    string key - the key, whose value shall be deleted
  </parameters>
  <retvals>
    integer retval - 0, in case of success; -1, in case of an error
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>metadatamanagement, project, delete, extension, state, key</tags>
</US_DocBloc>
--]]
  if type(section)~="string" then ultraschall.AddErrorMessage("DeleteProjExtState_Key","section", "must be a string", -1) return -1 end
  if type(key)~="string" then ultraschall.AddErrorMessage("DeleteProjExtState_Key","key", "must be a string", -1) return -2 end
  if reaper.GetProjExtState(0, section, key)==0 then ultraschall.AddErrorMessage("DeleteProjExtState_Key","key", "no such key/value to delete", -3) return -1 end
  return reaper.SetProjExtState(0, section, key, "")
end

--Ainteger=reaper.SetProjExtState(0, "ultraschall", "tudelu", "uhuhuhuhuh")
--Ainteger2=reaper.SetProjExtState(0, "ultraschall", "tudelul", "uhuhuhuhuh2")
--Ainteger3=reaper.SetProjExtState(0, "ultraschall", "tudelull", "uhuhuhuhuh3")
--P=ultraschall.DeleteProjExtState_Section("ultraschall")
--P=ultraschall.DeleteProjExtState_Section("ultraschall")
--L=ultraschall.DeleteProjExtState_Key("ultraschall", "tudelu")
--retval1, val1 = reaper.GetProjExtState(0, "ultraschall", "tudelulu")
--retval2, val2 = reaper.GetProjExtState(0, "ultraschall", "tudelul")


function ultraschall.GetProjExtState_AllKeyValues(section)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProjExtState_AllKeyValues</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetProjExtState_AllKeyValues(string section)</functioncall>
  <description>
    Returns the count of all key/values in a specific section, as well as an array with all keynames and their accompanying stored values.
    The array has the format:
       AllValues[idx][1]=Key
       AllValues[idx][2]=Value
    
    Returns 0 in case of an error or if no key exists in the given section
  </description>
  <parameters>
    string section - the section/extname, from whom a key/value shall be deleted
  </parameters>
  <retvals>
    integer retval - 0, in case of success; -1, in case of an error
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>metadatamanagement, project, extension, state, get, all, key, values, section</tags>
</US_DocBloc>
--]]

  if type(section)~="string" then ultraschall.AddErrorMessage("GetProjExtState_AllKeyValues","section", "must be a string", -1) return 0 end
  if reaper.EnumProjExtState(0, section, 0)==false then ultraschall.AddErrorMessage("GetProjExtState_AllKeyValues","section", "no such section", -2) return 0 end
  local retval=true
  local count=0
  local ProjExtStateArray={}
  local _L, keyname
  
  while retval~=false do
    retval, keyname=reaper.EnumProjExtState(0, section, count)
    if retval==true then 
          ProjExtStateArray[count+1]={}
          ProjExtStateArray[count+1][1]=keyname
      _L, ProjExtStateArray[count+1][2]=reaper.GetProjExtState(0, section, keyname)
    end
    count=count+1
  end
  return count-1, ProjExtStateArray
end

--LL=ultraschall.GetProjExtState_AllKeyValues(2)

function ultraschall.IsValidGuid(guid, strict)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidGuid</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidGuid(string guid, boolean strict)</functioncall>
  <description>
    Checks, if guid is a valid guid. Can also be used for strings, that contain a guid somewhere in them(strict=false)
    
    A valid guid is a string that follows the following pattern:
    {........-....-....-....-............}
    where . is a hexadecimal value(0-F)
    
    Returns false in case of error
  </description>
  <parameters>
    string guid - the guid to check for validity
    boolean strict - true, guid must only be the valid guid; false, guid must contain a valid guid somewhere in it(means, can contain trailing or preceding characters)
  </parameters>
  <retvals>
    boolean retval - true, guid is/contains a valid guid; false, guid isn't/does not contain a valid guid
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, guid, check</tags>
</US_DocBloc>
--]]
  if type(guid)~="string" then ultraschall.AddErrorMessage("IsValidGuid","guid", "must be a string", -1) return false end
  if type(strict)~="boolean" then ultraschall.AddErrorMessage("IsValidGuid","strict", "must be a boolean", -2) return false end
  if strict==true and guid:match("^{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x%}$")~=nil then return true
  elseif strict==false and guid:match(".-{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x%}.*")~=nil then return true
  else return false
  end
end

--L=ultraschall.IsValidGuid(reaper.GetTrackGUID(reaper.GetTrack(0,0)))
--LL=reaper.genGuid("")
--L=ultraschall.IsValidGuid("U"..LL:sub(1,-2), false)
--if L==false then reaper.MB(LL,tostring(L),0) end

function ultraschall.SetGuidExtState(guid, key, value, savelocation, overwrite, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetGuidExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetGuidExtState(string guid, string key, string value, integer savelocation, boolean overwrite, boolean persists)</functioncall>
  <description>
    Sets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).
    The state can be saved as either global extension state or "local" extension-project-state(in the currently opened project)
    The guid can have additional text, but must contain a valid guid somewhere in it!
    A valid guid is a string that follows the following pattern:
    {........-....-....-....-............}
    where . is a hexadecimal value(0-F)
    
    Returns -1 in case of error
  </description>
  <parameters>
    string guid - the guid of the object, for whom you want to store a key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!
    string key - the key for this guid
    string value - the value to store into the key/value-store
    integer savelocation - 0, store as project extension state(into the currently opened project); 1, store as global extension state(when persist=true, into reaper-extstate.ini in the resourcesfolder)
    boolean overwrite - true, overwrite a previous given value; false, don't overwrite, if a value exists already
    boolean persists - true, make extension state persistent(available after Reaper-restart); false, don't make it persistent; Only with global extension states
  </parameters>
  <retvals>
    integer retval - the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States(Guid)
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>metadatamanagement, project, extension, state, set, guid, key, values</tags>
</US_DocBloc>
--]]
  if ultraschall.IsValidGuid(guid, false)==false then ultraschall.AddErrorMessage("SetGuidExtState","guid", "must be a valid guid", -1) return -1 end
  if ultraschall.IsValidGuid(guid, false)==false then ultraschall.AddErrorMessage("SetGuidExtState","key", "must be a string", -2) return -1 end
  if ultraschall.IsValidGuid(guid, false)==false then ultraschall.AddErrorMessage("SetGuidExtState","value", "must be a string", -3) return -1 end
  if type(overwrite)~="boolean" then ultraschall.AddErrorMessage("SetGuidExtState","overwrite", "must be a boolean", -4) return -1 end
  if math.type(savelocation)~="integer" then ultraschall.AddErrorMessage("SetGuidExtState","savelocation", "must be an integer", -5) return -1 end
  if tonumber(savelocation)~=0 and tonumber(savelocation)~=1 then ultraschall.AddErrorMessage("SetGuidExtState","savelocation", "only allowed 0 for project-extstate, 1 for global extension state", -6) return -1 end
  if savelocation==1 and type(persist)~="boolean" then ultraschall.AddErrorMessage("SetGuidExtState","persist", "must be a boolean", -7) return -1 end
  
  if savelocation==0 then 
    if overwrite==false and reaper.GetProjExtState(0, guid, key)>0 then ultraschall.AddErrorMessage("SetGuidExtState","extension-state", "already exist", -8) return -1 end
    return reaper.SetProjExtState(0, guid, key, value) 
  elseif savelocation==1 then 
    if overwrite==false and reaper.HasExtState(guid, key)==true then ultraschall.AddErrorMessage("SetGuidExtState","extension-state", "already exist", -9) return -1 end
    return 1, reaper.SetExtState(guid, key, value, persist)
  else ultraschall.AddErrorMessage("SetGuidExtState","savelocation", "no such location", -9) return -1
  end
end


--L,LL=ultraschall.SetGuidExtState("TRACK_"..reaper.GetTrackGUID(reaper.GetTrack(0,0)),"Hulas", "projstate-ADulass", 1, true, true)

--A=reaper.time_precise()
--for i=0, 9000 do
--end
--B=reaper.time_precise()

function ultraschall.GetGuidExtState(guid, key, savelocation)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetGuidExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval, string value = ultraschall.GetGuidExtState(string guid, string key, integer savelocation)</functioncall>
  <description>
    Gets an extension-state using a given guid. Good for storing additional metadata of objects like MediaTracks, MediaItems, MediaItem_Takes, etc(everything, that has a guid).
    The guid can have additional text, but must contain a valid guid somewhere in it!
    A valid guid is a string that follows the following pattern:
    {........-....-....-....-............}
    where . is a hexadecimal value(0-F)
    
    Returns -1 in case of error
  </description>
  <parameters>
    string guid - the guid of the object, for whom you want to get the key/value-pair; can have additional characters before and after the guid, but must contain a valid guid!
    string key - the key for this guid
    integer savelocation - 0, get as project extension state(from the currently opened project); 1, get as global extension state(when persist=true, from reaper-extstate.ini in the resourcesfolder)
  </parameters>
  <retvals>
    integer retval - the idx of the extstate(if a project extension state); 1, successful(with extension states), -1, unsuccessful
    string value - the returned value from the extstate
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States(Guid)
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>metadatamanagement, project, extension, state, get, guid, key, values</tags>
</US_DocBloc>
--]]
  if ultraschall.IsValidGuid(guid, false)==false then ultraschall.AddErrorMessage("GetGuidExtState","guid", "must be a valid guid", -1) return -1 end
  if ultraschall.IsValidGuid(guid, false)==false then ultraschall.AddErrorMessage("GetGuidExtState","key", "must be a string", -2) return -1 end
  if math.type(savelocation)~="integer" then ultraschall.AddErrorMessage("GetGuidExtState","savelocation", "must be an integer", -4) return -1 end
  if tonumber(savelocation)~=0 and tonumber(savelocation)~=1 then ultraschall.AddErrorMessage("GetGuidExtState","savelocation", "only allowed 0 for project-extstate, 1 for global extension state", -5) return -1 end
  
  if savelocation==0 then 
    local retval, string=reaper.GetProjExtState(0, guid, key)
    if retval>0 then return 1, string else return -1 end
  elseif savelocation==1 then 
    return 1, reaper.GetExtState(guid, key, value, persist)
  else ultraschall.AddErrorMessage("GetGuidExtState","savelocation", "no such location", -6) return -1
  end
end

--L,LL=ultraschall.GetGuidExtState("MEDIAITEM-{B6EB7726-CD8D-42A8-A5EF-DBA127A8D34C}","Tudel", 0)
--A,AA=reaper.GetProjExtState(0, "MEDIAITEM-{B6EB7726-CD8D-42A8-A5EF-DBA127A8D34C}","TUDEL")
--L,LL=ultraschall.GetGuidExtState("TRACK_"..reaper.GetTrackGUID(reaper.GetTrack(0,0)),"Hulas", 1, true, true)
--ultraschall.ShowLastErrorMessage()

function ultraschall.GetVZoom()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetVZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer vertical_zoom_factor = ultraschall.GetVZoom()</functioncall>
  <description>
    Returns the vertical-zoom-factor.
    
    Returns -1 in case of error
  </description>
  <retvals>
    integer vertical_zoom_factor - the current vertical zoom-factor
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, get, vertical, zoom, factor</tags>
</US_DocBloc>
--]]
  -- prepare variables and check, whether config-variable vzoom2 is still a valid one
  local vzoom=reaper.SNM_GetIntConfigVar("vzoom2",-9)
  local checkvzoom=reaper.SNM_GetIntConfigVar("vzoom2",-10)
  -- if yes, return zoomfactor
  if vzoom==checkvzoom then 
    return vzoom
  else
    ultraschall.AddErrorMessage("GetVZoom", "", "Unknown error while retrieving vertical zoom-level. Please contact the developers of the Ultraschall-Api!", -1) return -1
  end
end

--L=ultraschall.GetVZoom()

function ultraschall.SetVZoom(vertical_zoom_factor)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetVZoom</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetVZoom(integer vertical_zoom_factor)</functioncall>
  <description>
    Sets the vertical zoom factor.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    integer vertical_zoom_factor - the current vertical zoom-factor
  </parameters>
  <retvals>
    integer retval - -1, in case of error
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, set, vertical, zoom, factor</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(vertical_zoom_factor)~="integer" then ultraschall.AddErrorMessage("SetVZoom","vertical_zoom_factor", "Must be an integer", -1) return -1 end
  if vertical_zoom_factor<0 or vertical_zoom_factor>40 then ultraschall.AddErrorMessage("SetVZoom","vertical_zoom_factor", "Must be between 0 and 40", -2) return -1 end

  -- prepare variables
  local OldVzoom=reaper.SNM_GetIntConfigVar("vzoom2",-20)
  local DiffVZoom=vertical_zoom_factor-OldVzoom

  -- do the zoom  
  reaper.CSurf_OnZoom(0, DiffVZoom)
end

--L=ultraschall.SetVZoom(0)
--LL=ultraschall.GetVZoom(30)
--reaper.UpdateArrange()

function ultraschall.StoreArrangeviewSnapshot(slot, description, position, vzoom, vscroll)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>StoreArrangeviewSnapshot</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.StoreArrangeviewSnapshot(integer slot, string description, boolean position, boolean vzoom, boolean vscroll)</functioncall>
  <description>
    Stores a new Arrangeview-snapshot, that includes the position, horizontal zoom, vertical zoom and vertical scroll.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    integer slot - the slot for arrangeview-snapshot
    string description - a description for this arrangeview-snapshot
    boolean position - true, store start and endposition of the current arrangeview; false, don't store start and endposition of current arrangeview(keep old position in slot, if existing)
    boolean vzoom - true, store current vertical-zoom-factor; false, don't store current vertical-zoom-factor(keep old zoomfactor in slot, if existing)
    boolean vscroll - true, store current vertical scroll-factor; false, don't store current vertival-scroll-factor
  </parameters>
  <retvals>
    integer retval - -1, in case of error
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, set, arrangeview, snapshot</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(slot)~="integer" then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","slot", "Must be an integer", -1) return -1 end
  if slot<0 then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","slot", "Must be bigger than 0", -2) return -1 end
  if type(description)~="string" and description~=nil then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","description", "Must be a string(to set description) or nil(to keep old description)", -3) return -1 end
  if type(position)~="boolean" and position~=nil then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","position", "Must be boolean(to set with current start&end-position) or nil(to keep old start&end-position)", -4) return -1 end
  if type(vzoom)~="boolean" and vzoom~=nil then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","vzoom", "Must be boolean(to set with current vertical zoom) or nil(to keep old vertical zoom)", -6) return -1 end
  if type(vscroll)~="boolean" and vscroll~=nil then ultraschall.AddErrorMessage("StoreArrangeviewSnapshot","vscroll", "Must be boolean(to set with current vertical scroll) or nil(to keep old vertical scroll)", -7) return -1 end
  
  -- prepare variables
  local slot=tostring(slot)
  local start,ende=reaper.GetSet_ArrangeView2(0,false,0,0)
  local vzoom2=ultraschall.GetVZoom()
  local hzoom=reaper.GetHZoomLevel()

  -- store start/end-position, verticalzoom and description; position and vzoom only, if parameters position and vzoom are set to true
  if position==true then 
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_start", start)
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_end", ende)
  elseif position==nil then 
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_start", -1)
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_end", -1)
  end

  if type(description)=="string" then 
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_description", description)
  elseif description==nil then
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_description", -1)
  end

  if vzoom==true then 
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vzoom", vzoom2)
  elseif vzoom==false then
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vzoom", -1)
  end
  
  local translation = reaper.JS_Localize("trackview", "DLG_102")
  
  local retval, vscroll2 = reaper.JS_Window_GetScrollInfo(reaper.JS_Window_Find(translation, true), "SB_VERT")
  
  if vscroll==true then
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vscroll", vscroll2)
  elseif vscroll==false then
    reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vscroll", -1)  
  end
  
  reaper.SetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_hzoom", hzoom)  
end

--ultraschall.StoreArrangeviewSnapshot(1, "LSubisubisu", true, true, true, true)

function ultraschall.IsValidArrangeviewSnapshot(slot)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidArrangeviewSnapshot</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidArrangeviewSnapshot(integer slot)</functioncall>
  <description>
    Checks, if an Arrangeview-snapshot-slot is valid(means set).
    
    Returns false in case of error.
  </description>
  <parameters>
    integer slot - the slot for arrangeview-snapshot
  </parameters>
  <retvals>
    boolean retval - true, if Arrangeview-Snapshot is valid; false, if Arrangeview-Snapshot is not existing
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, check, arrangeview, snapshot</tags>
</US_DocBloc>
--]]  
  -- check parameters
  if math.type(slot)~="integer" then ultraschall.AddErrorMessage("IsValidArrangeviewSnapshot","slot", "Must be an integer", -1) return false end
  if slot<0 then ultraschall.AddErrorMessage("IsValidArrangeviewSnapshot","slot", "Must be bigger than 0", -2) return false end
  
  -- prepare variable
  slot=tostring(slot)
  
  -- check, whether there is valid information to retrieve from the Arrange-view-snapshot-slot
  if reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_start")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_end")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_description")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_hzoom")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_vzoom")~=0 or
     reaper.GetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vscroll")~="" then
     return true
  else
    return false
  end
end

--L=ultraschall.IsValidArrangeviewSnapshot(1)

function ultraschall.RetrieveArrangeviewSnapshot(slot)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RetrieveArrangeviewSnapshot</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string description, number startposition, number endposition, integer vzoomfactor, number hzoomfactor, number vertical_scroll = ultraschall.RetrieveArrangeviewSnapshot(integer slot)</functioncall>
  <description>
    Retrieves an Arrangeview-snapshot and returns the startposition, endposition and vertical and horizontal zoom-factor as well as the number vertical-scroll-factor..
    
    Returns false in case of error.
  </description>
  <parameters>
    integer slot - the slot for arrangeview-snapshot
  </parameters>
  <retvals>
    boolean retval - false, in case of error; true, in case of success
    string description - a description for this arrangeview-snapshot
    number startposition - the startposition of the arrangeview
    number endposition - the endposition of the arrangeview
    integer vzoom - the vertical-zoomfactor(0-40)
    number hzoomfactor - the horizontal zoomfactor
    number vertical_scroll - the vertical scroll-value
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, get, arrangeview, snapshot, startposition, endposition, verticalzoom, horizontal zoom, vertical scroll</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(slot)~="integer" then ultraschall.AddErrorMessage("RetrieveArrangeviewSnapshot","slot", "Must be an integer", -1) return false end
  if slot<0 then ultraschall.AddErrorMessage("RetrieveArrangeviewSnapshot","slot", "Must be bigger than 0", -2) return false end
  if ultraschall.IsValidArrangeviewSnapshot(slot)==false then ultraschall.AddErrorMessage("RetrieveArrangeviewSnapshot", "slot", "No such slot available", -3) return false end

  -- prepare variables
  slot=tostring(slot)
  local _l, start, ende, description, vzoom, hzoom
  
  -- get information from arrangeview-snapshot-slot and return it, if existing
  if reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_start")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_end")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_description")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_hzoom")~=0 or
     reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_vzoom")~=0 or
     reaper.GetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vscroll")~="" then
     
     _l, start=reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_start")
     _l, ende=reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_end")
     _l, description=reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_description")
     _l, vzoom=reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_vzoom")
     _l, hzoom=reaper.GetProjExtState(0,"Ultraschall", "ArrangeViewSnapShot_"..slot.."_hzoom")
     _l, vscroll=reaper.GetProjExtState(0, "Ultraschall", "ArrangeViewSnapShot_"..slot.."_vscroll")
     return true, description, tonumber(start), tonumber(ende), tonumber(vzoom), tonumber(hzoom), tonumber(vscroll)
  else
    return false
  end
end

--A,B,C,D,E,F,G,H,I=ultraschall.RetrieveArrangeviewSnapshot(1)

function ultraschall.RestoreArrangeviewSnapshot(slot, position, vzoom, hcentermode, verticalscroll)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RestoreArrangeviewSnapshot</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string description, number startposition, number endposition, integer vzoomfactor, number hzoomfactor, number vertical_scroll_factor = ultraschall.RestoreArrangeviewSnapshot(integer slot, optional boolean position, optional boolean vzoom, optional integer hcentermode, optional boolean verticalscroll)</functioncall>
  <description>
    Sets arrangeview to start/endposition and horizontal and vertical-zoom, as received from Arrangeview-Snapshot-slot. It returns the newly set start/endposition, vertical zoom, horizontal zoom and description of slot.
    
    Returns false in case of error.
  </description>
  <parameters>
    integer slot - the slot for arrangeview-snapshot
    optional boolean position - nil or true, set arrange to stored start and endposition(and it's horizontal-zoom); false, set only horizontal-zoom
    optional boolean vzoom - nil or true, set vertical-zoom; false, don't set vertical zoom
    optional integer hcentermode - decides, what shall be in the center of the zoomed horizontal view. Only available when position==false
                                 - The following are available:
                                 -  nil, keeps center of view in the center during zoom(default)
                                 -   -1, default selection, as set in the reaper-prefs, 
                                 -    0, edit-cursor or playcursor(if it's in the current zoomfactor of the view during playback/recording) in center,
                                 -    1, keeps edit-cursor in center of zoom
                                 -    2, keeps center of view in the center during zoom
                                 -    3, keeps in center of zoom, what is beneath the mousecursor
    optional boolean verticalscroll - true, sets vertical scroll-value as well; false, doesn't set vertical-scroll-value
  </parameters>
  <retvals>
    boolean retval - false, in case of error; true, in case of success
    string description - a description for this arrangeview-snapshot
    number startposition - the startposition of the arrangeview
    number endposition - the endposition of the arrangeview
    integer vzoom - the vertical-zoomfactor(0-40)
    number hzoomfactor - the horizontal zoomfactor
    number vertical_scroll_factor - the vertical-scroll-factor
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, set, arrangeview, snapshot, startposition, endposition, verticalzoom, horizontalzoom</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(slot)~="integer" then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","slot", "Must be an integer", -1) return false end
  if slot<0 then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","slot", "Must be bigger than 0", -2) return false end
  if ultraschall.IsValidArrangeviewSnapshot(slot)==false then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot", "slot", "No such slot available", -3) return false end
  if position~=nil and type(position)~="boolean" then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","position", "Must be nil or a boolean", -4) return false end
  if vzoom~=nil and type(vzoom)~="boolean" then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","vzoom", "Must be nil or a boolean", -5) return false end
  if vzoom==nil then vzoom=true end
  if position==false and hcentermode~=nil and math.type(hcentermode)~="integer" then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","hcentermode", "Must be nil or an integer", -6) return false end
  if hcentermode~=nil and (hcentermode<-1 or hcentermode>3) then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","hcentermode", "Must be nil or between -1 and 3", -7) return false end
  if verticalscroll~=nil and type(verticalscroll)~="boolean" then ultraschall.AddErrorMessage("RestoreArrangeviewSnapshot","verticalscroll", "Must be nil or a boolean", -8) return false end
    
  -- prepare variables by retrieving the snapshot-slot-information
  local bool, description, start, ende, vzoom3, hzoom, vscroll = ultraschall.RetrieveArrangeviewSnapshot(slot)
  local start2,ende2=reaper.GetSet_ArrangeView2(0,false,0,0)
  if start==-1 then start=start2 end
  if ende==-1 then ende=ende2 end
  
  if hcentermode==nil then hcentermode=3 end
  
  -- set arrangeview to the values
  if position==false then
    reaper.adjustZoom(hzoom, 1, true, hcentermode)
    start, ende = reaper.BR_GetArrangeView(0)
  else
    reaper.BR_SetArrangeView(0, start, ende)
  end
  
  
  if vzoom3~=-1 and vzoom==true then 
    ultraschall.SetVZoom(vzoom3)
  end  
  
  if verticalscroll==true or verticalscroll==nil then
    local translation = reaper.JS_Localize("trackview", "DLG_102")
    
    reaper.JS_Window_SetScrollPos(reaper.JS_Window_Find(translation, true), "SB_VERT", vscroll)
  end
  reaper.UpdateArrange()
  return true, description, start, ende, vzoom, hzoom, vscroll
end

--ultraschall.StoreArrangeviewSnapshot(3, "LSubisubisu", true, true, true)

--A,B,C,D,E,F=ultraschall.RestoreArrangeviewSnapshot(1,false, true, 1)
--ultraschall.SetVZoom(40)


--ultraschall.SetVZoom(29.1)

function ultraschall.SetBitfield(integer_bitfield, set_to, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetBitfield</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer new_integer_bitfield = ultraschall.SetBitfield(integer integer_bitfield, boolean set_to, integer bit_1, integer bit_2, ... integer bit_n)</functioncall>
  <description>
    Alters an integer-bitfield.
    
    Returns nil in case of error, like invalid bit-values
  </description>
  <parameters>
    integer integer_bitfield - the old integer-bitfield that you want to alter
    boolean set_to - true, set the bits to 1; false, set the bits to 0; nil, toggle the bits
    integer bit1..n - one or more parameters, that include the bitvalues toset/unset/toggle with 1 for the first bit; 2 for the second, 4 for the third, 8 for the fourth, etc
  </parameters>
  <retvals>
    integer new_integer_bitfield - the newly altered bitfield
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, bitfield, set, unset, toggle</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(integer_bitfield)~="integer" then ultraschall.AddErrorMessage("SetBitfield","integer_bitfield", "Must be an integer!", -1) return nil end
  if set_to~=nil and type(set_to)~="boolean" then ultraschall.AddErrorMessage("SetBitfield","set_to", "Must be a boolean!", -2) return nil end
  local Parameters={...}
  local count=1
  while Parameters[count]~=nil do
    -- check the bit-parameters
    if math.log(Parameters[count],2)~=math.floor(math.log(Parameters[count],2)) then ultraschall.AddErrorMessage("SetBitfield","bit", "Bit_"..count.."="..Parameters[count].." isn't a valid bitvalue!", -3) return nil end
    count=count+1
  end
  
  -- Now let's set or unset the bitvalues
  count=1
  while Parameters[count]~=nil do
    if set_to==true and integer_bitfield&Parameters[count]==0 then 
      -- setting the bits
      integer_bitfield=integer_bitfield+Parameters[count] 
    elseif set_to==false and integer_bitfield&Parameters[count]~=0 then 
      -- unsetting the bits
      integer_bitfield=integer_bitfield-Parameters[count]
    elseif set_to==nil then
      -- toggling the bits
      if integer_bitfield&Parameters[count]==0 then 
        integer_bitfield=integer_bitfield+Parameters[count] 
      elseif integer_bitfield&Parameters[count]~=0 then 
        integer_bitfield=integer_bitfield-Parameters[count] 
      end
    end
    count=count+1
  end
  return integer_bitfield
end

--A=ultraschall.SetBitfield(2, true, 2,4,16,8,8,8)

function ultraschall.Dummy()
  -- just a dummy function, if needed
end

function ultraschall.PreventCreatingUndoPoint()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>PreventCreatingUndoPoint</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.PreventCreatingUndoPoint()</functioncall>
  <description>
    Prevents creation of an Undo-point. Only useful in non-defer-scripts.
  </description>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, undo, prevent, creation, undopoint</tags>
</US_DocBloc>
--]]
  reaper.defer(ultraschall.Dummy)
end


function ultraschall.SetIntConfigVar_Bitfield(configvar, set_to, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetIntConfigVar_Bitfield</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer new_integer_bitfield = ultraschall.SetIntConfigVar_Bitfield(string configvar, boolean set_to, integer bit_1, integer bit_2, ... integer bit_n)</functioncall>
  <description>
    Alters an integer-bitfield stored by a ConfigVariable.
    
    Returns false in case of error, like invalid bit-values, etc
  </description>
  <parameters>
    string configvar - the config-variable, that is stored as an integer-bitfield, that you want to alter.
    boolean set_to - true, set the bits to 1; false, set the bits to 0; nil, toggle the bits
    integer bit1..n - one or more parameters, that include the bitvalues toset/unset/toggle with 1 for the first bit; 2 for the second, 4 for the third, 8 for the fourth, etc
  </parameters>
  <retvals>
    boolean retval - true, if altering was successful; false, if not successful
    integer new_integer_bitfield - the newly altered bitfield
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, bitfield, set, unset, toggle, configvar</tags>
</US_DocBloc>
--]]
  local integer_bitfield=reaper.SNM_GetIntConfigVar(configvar, -22)
  local integer_bitfield2=reaper.SNM_GetIntConfigVar(configvar, -23)
  if type(configvar)~="string" then ultraschall.AddErrorMessage("SetIntConfigVar_Bitfield","configvar", "Must be a string!", -1) return false end
  if integer_bitfield==-22 and integer_bitfield2==-23 then ultraschall.AddErrorMessage("SetIntConfigVar_Bitfield","configvar", "No valid config-variable!", -2) return false end
  
  -- check parameters
  if set_to~=nil and type(set_to)~="boolean" then ultraschall.AddErrorMessage("SetIntConfigVar_Bitfield","set_to", "Must be a boolean!", -3) return false end
  local Parameters={...}
  local count=1
  while Parameters[count]~=nil do
    -- check the bit-parameters
    if math.log(Parameters[count],2)~=math.floor(math.log(Parameters[count],2)) then ultraschall.AddErrorMessage("SetIntConfigVar_Bitfield","bit", "Bit_"..count.."="..Parameters[count].." isn't a valid bitvalue!", -4) return nil end
    count=count+1
  end
  
  -- Now let's set or unset the bitvalues
  count=1
  while Parameters[count]~=nil do
    if set_to==true and integer_bitfield&Parameters[count]==0 then 
      -- setting the bits
      integer_bitfield=integer_bitfield+Parameters[count] 
    elseif set_to==false and integer_bitfield&Parameters[count]~=0 then 
      -- unsetting the bits
      integer_bitfield=integer_bitfield-Parameters[count]
    elseif set_to==nil then
      -- toggling the bits
      if integer_bitfield&Parameters[count]==0 then 
        integer_bitfield=integer_bitfield+Parameters[count] 
      elseif integer_bitfield&Parameters[count]~=0 then 
        integer_bitfield=integer_bitfield-Parameters[count] 
      end
    end
    count=count+1
  end
  return reaper.SNM_SetIntConfigVar(configvar, integer_bitfield), integer_bitfield
end

--L,LL=ultraschall.SetIntConfigVar_Bitfield("mixrowflags", nil, 1,2,4,8,16,32,64,128,256)

--reaper.UpdateArrange()
--reaper.UpdateTimeline()

function ultraschall.CountMarkersAndRegions()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountMarkersAndRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count_markers, integer count_regions = ultraschall.CountMarkersAndRegions()</functioncall>
  <description>
    Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).
    Use <a href="#GetMarkerAndRegionsByIndex">GetMarkerAndRegionsByIndex</a> to enumerate markers or regions in particular.
    
    Returns -1 in case of no markers available
  </description>
  <retvals>
    integer count_markers - the number of markers available in the project
    integer count_regions - the number of regions available in the project
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, count, marker, region</tags>
</US_DocBloc>
--]]
  local retval=reaper.CountProjectMarkers(0)
  local markercount=0
  local regioncount=0
  for i=0, retval-1 do
    local retval, isrgn = reaper.EnumProjectMarkers2(0, i)
    if isrgn==false then markercount=markercount+1 
    else regioncount=regioncount+1
    end
  end
  return markercount, regioncount
end

--Markers,Regions=ultraschall.CountMarkersAndRegions()



function ultraschall.GetLastMarkerPosition()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastMarkerPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number position, integer marker_idx = ultraschall.GetLastMarkerPosition()</functioncall>
  <description>
    Returns the position of the last projectmarker in the project(no regions or time-sig-markers!).
    
    Returns -1 in case of no markers available
  </description>
  <retvals>
    number position - the position of the last marker in the project
    integer marker_idx - the idx of the last marker in the project. Not the shown number!
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, last, marker, position, markeridx</tags>
</US_DocBloc>
--]]
  local Markers=ultraschall.CountMarkersAndRegions()
  if Markers==0 then ultraschall.AddErrorMessage("GetLastMarkerPosition","", "No markers available in project!", -1) return -1 end
  local retval=reaper.CountProjectMarkers(0)
  local markeridx
  local lastpos=0
  for i=0, retval-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers2(0, i)
    if pos>lastpos and isrgn==false then lastpos=pos markeridx=retval end
  end
  return lastpos, Markers
end

--L,LL=ultraschall.GetLastMarkerPosition()

function ultraschall.GetLastRegion()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number position, number endposition, integer region_idx = ultraschall.GetLastRegion()</functioncall>
  <description>
    Returns the position of the last region in the project(no markers or time-sig-markers!).
    Note: Last region means the last ending region in the project, even if it's the first starting.
    
    Returns -1 in case of no regions available
  </description>
  <retvals>
    number startposition - the startposition of the last region in the project
    number endposition - the endposition of the last region in the project
    integer region_idx - the idx of the last region in the project. Not the shown number!
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, last, region, position, regionidx</tags>
</US_DocBloc>
--]]
  local Markers, Regions=ultraschall.CountMarkersAndRegions()
  local retval=reaper.CountProjectMarkers(0)
  local regionidx
  if Regions==0 then ultraschall.AddErrorMessage("GetLastRegion","", "No regions available in project!", -1) return -1 end
  local lastpos=0
  local startpos=0
  for i=0, retval-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber = reaper.EnumProjectMarkers2(0, i)
    if rgnend>lastpos and isrgn==true then startpos=pos lastpos=rgnend regionidx=retval end
  end
  return startpos, lastpos, Regions
end

--L,LL=ultraschall.GetLastRegionEnd()


function ultraschall.GetLastTimeSigMarkerPosition()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastTimeSigMarkerPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number position, number measureposition, number beatposition, integer timesig_idx = ultraschall.GetLastTimeSigMarkerPosition()</functioncall>
  <description>
    Returns the position of the last time-signature-marker in the project(no markers or regions!).
    
    Returns -1 in case of no time-signature-markers available
  </description>
  <retvals>
    number position - the position of the last timesig-marker in the project
    number measureposition - the measureposition of the last timesig-marker in the project
    number beatposition - the beatposition of the last timesig-marker in the project
    integer timesig_idx - the idx of the last timesig-marker in the project.
  </retvals>
  <chapter_context>
    Markers
    Time Signature Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, last, timesig, time signature, position, timesigidx, measure, beat</tags>
</US_DocBloc>
--]]
  retval=reaper.CountTempoTimeSigMarkers(0)
  if retval==0 then ultraschall.AddErrorMessage("GetLastTimeSigMarkerPosition","", "No time-signature-markers available in project!", -1) return -1 end
  local btpos, measpos, timesigidx
  local retval2, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, retval-1)
  return timepos, measurepos, beatpos, retval
end

--L,LL,LLL,LLLL=ultraschall.GetLastTimeSigMarker()

function ultraschall.DeleteArrangeviewSnapshot(slot)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteArrangeviewSnapshot</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.DeleteArrangeviewSnapshot(integer slot)</functioncall>
  <description>
    Deletes an ArrangeviewSnapshot-slot.
    
    Returns -1 if the slot is unset.
  </description>
  <parameters>
    integer slot - the slot for arrangeview-snapshot
    </parameters>            
  <retvals>
    integer retval - -1 in case of an error; 0 in case of success
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, delete, arrangeview, snapshot, startposition, endposition, verticalzoom</tags>
</US_DocBloc>
--]]
  return ultraschall.DeleteProjExtState_Section("Ultraschall", "ArrangeViewSnapShot_"..slot)
end

--ultraschall.StoreArrangeviewSnapshot(1, "LSubisubisu", true, true, true)
--A,B,C,D,E,F,G=ultraschall.RetrieveArrangeviewSnapshot(1)
--O=ultraschall.DeleteArrangeviewSnapshot(1)
--A1,B1,C1,D1,E1,F1,G1=ultraschall.RetrieveArrangeviewSnapshot(1)

--KUEL,KUEL2=ultraschall.GetProjExtState_AllKeyValues("Ultraschall")

function ultraschall.MakeCopyOfTable(table, seen, recursive) --copy an array
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MakeCopyOfTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table table_copy = ultraschall.MakeCopyOfTable(table table)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Creates a true copy of a table(not only references).
    
    adapted from Tyler Neylon's function, found at [Stack Overflow](https://stackoverflow.com/questions/640642/how-do-you-copy-a-lua-table-by-value/26367080#26367080)
    
    Returns nil if table isn't a valid table
  </description>
  <parameters>
    table table - the table to create a copy from.
  </parameters>
  <retvals>
    table table_copy - the true copy of the table; nil in case of error
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, table, copy, true copy</tags>
</US_DocBloc>
--]]
  if type(table)~="table" and recursive==true then return table elseif type(table)~="table" then ultraschall.AddErrorMessage("MakeCopyOfTable","table", "Must be a table!", -1)  return nil end
  if seen and seen[table] then return seen[table] end
  local seen_temp = seen or {}
  local res = setmetatable({}, getmetatable(table))
  seen_temp[table] = res
  for key, value in pairs(table) do 
    res[ultraschall.MakeCopyOfTable(key, seen_temp, true)] = ultraschall.MakeCopyOfTable(value, seen_temp, true) 
  end
  return res
end


--[[
A={}
A[1]=1
A[2]={}
A[2][1]=2
A[2][2]=3
A[4]=4
A[3]=nil
--]]
--B=ultraschall.MakeCopyOfTable(A)
--A[2]=99

function ultraschall.ConvertStringToAscii_Array(string)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertStringToAscii_Array</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer length, table byte_array = ultraschall.ConvertStringToAscii_Array(string string)</functioncall>
  <description>
    Converts a string into it's individual characters and numerical-representation as a table and after that returns its number of table-entries and the table.
    
    Returns -1 if string isn't a valid string
  </description>
  <parameters>
    string string - the string to be converted
  </parameters>
  <retvals>
    integer length - the number of characters in the string/entries in the returned table byte_array
    table byte_array - the ByteArray as a table, with the format
                     -     ByteArray[idx][1]="A" -- the byte itself
                     -     ByteArray[idx][2]=65  -- the numerical representation of the byte
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, string, bytevalue, numerical representation</tags>
</US_DocBloc>
--]]
  if type(string)~="string" then ultraschall.AddErrorMessage("ConvertStringToAscii_Array","string", "Must be a string!", -1) return -1 end
  local Table={}
  for i=1, string:len() do
    Table[i]={}
    Table[i][1]=string:sub(i,i)
    Table[i][2]=string.byte(string:sub(i,i))
  end
  return string:len(), Table
end

--A,B=ultraschall.ConvertStringToAscii_Array("LULA")


function ultraschall.CompareStringWithAsciiValues(string,...)
-- string - the string to compare against the ascii-code-parameters
-- ... - 0(0x0) to 255(0xFF), valid ascii-characters; -1 to skip comparison of a character
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CompareStringWithAsciiValues</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer errorposition = ultraschall.CompareStringWithAsciiValues(string string, integer bytevalue_1, integer bytevalue_2, ... integer bytevalue_n)</functioncall>
  <description>
    Compares a string with a number of byte-values(like ASCII-values).
    Bytevalues can be either decimal and hexadecimal.
    -1, if you want to skip checking of a specific position in string.
    
    Returns -1 in case of error
  </description>
  <parameters>
    string string - the string to check against the bytevalues
    integer bytevalue_1..n - one or more parameters, that include the bytevalues to check against the accompanying byte in string; -1, if you want to skip check for that position
  </parameters>
  <retvals>
    boolean retval - true, if check was successful; false, if not successful
    integer errorposition - if retval is false, this will contain the position in string, where the checking failed; nil, if retval is true
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, check, compare, string, byte, bytevalues</tags>
</US_DocBloc>
--]]
  if type(string)~="string" then ultraschall.AddErrorMessage("CompareStringWithAsciiValues","string", "Must be a string!", -1) return -1 end  
  local length, Table=ultraschall.ConvertStringToAscii_Array(string)
  local AsciiValues={...}
  local NumEntries=ultraschall.CountEntriesInTable_Main(AsciiValues)
  local count=1  
  local retval=true
  while AsciiValues[count]~=nil do
    if AsciiValues[count]==-1 then 
    elseif Table[count][2]~=AsciiValues[count] then retval=false break end
    count=count+1
  end
  if count-1==NumEntries then count=nil end
  return retval, count
end

--LLCOOLJ,LLCOOL2=ultraschall.CompareStringWithAsciivalues("ACCDENLIGHTENE",65,-1,-1,-1,-1)


function ultraschall.CheckForValidFileFormats(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckForValidFileFormats</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string fileformat, boolean supported_by_reaper, string mediatype = ultraschall.CheckForValidFileFormats(string filename_with_path)</functioncall>
  <description>
    Returns the fileformat of a Reaper-supported-file, images, audios(opus and m4a missing, though!), and video(mp4-video missing, though!).
    Note: Checks the file itself and does not check for correct file-extension. Reaper needs the correct file-extension or it can't read an otherwise valid imagefile.
          For example: if you want to import a GIF, renamed to filename.JPG, Reaper will not be able to read it. Only when the extension is the same as the file itself(filename.GIF).
    
    Returns nil in case of an error
  </description>
  <parameters>
    string filename_with_path - the file to check for it's image-fileformat
  </parameters>
  <retvals>
    string fileformat - the format of the file; JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown
    boolean supported_by_reaper - true, if importing of the fileformat is supported by Reaper; false, if not
    string mediatype - the type of the media; Image, Audio, Audio/Video, Video, Reaper
  </retvals>
  <chapter_context>
    File Management
    File Analysis
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, image, video, audio, fileformat, check</tags>
</US_DocBloc>
--]]

  -- check parameters
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("CheckForValidFileFormats","filename_with_path", "Must be a string!", -1) return nil end
  if reaper.file_exists(filename_with_path)~=true then ultraschall.AddErrorMessage("CheckForValidFileFormats","filename_with_path", "File does not exist!", -2) return nil end
  
  -- prepare variables
  local length, content = ultraschall.ReadBinaryFile_Offset(filename_with_path, 0, 100)
  
  -- check for a specific imagefile supported by Reaper
  if     content:match("JFIF")~=nil then return "JPG", true, "Image"
  elseif content:sub(2,4)=="PNG" then return "PNG", true, "Image"
  elseif content:sub(1,2)=="BM" then return "BMP", true, "Image"
  elseif content:sub(1,3)=="GIF" then return "GIF", true, "Image"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x1,0xB0,0xCE)==true then 
        local file=ultraschall.ReadFullFile(filename_with_path,true)
        local frameheader=string.char(1, 176, 206)
        local framecount=0
        while file~=nil do
          framecount=framecount+1
          file=file:match(frameheader.."(.*)")
        end
        return "LCF", true, "Image", framecount-1
  elseif ultraschall.CompareStringWithAsciiValues(content, 0,0,1,1)==true then return "ICO", true, "Image"
  
  -- audio formats
  elseif content:sub(1,4)=="OggS" then return "OGG", true, "Audio"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x52, 0x49, 0x46, 0x46, -1, -1, -1, -1, 0x57, 0x41, 0x56, 0x45)==true then return "WAV", true, "Audio"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x46, 0x4F, 0x52, 0x4D, -1, -1, -1, -1, 0x41, 0x49, 0x46, 0x46)==true then return "AIFF", true, "Audio"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C)==true then return "ASF/WMA/WMV", true, "Audio/Video"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0xFF, 0xFB)==true then return "MP3", true, "Audio"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x49, 0x44, 0x33)==true then return "MP3 - ID3TAG", true, "Audio"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x66, 0x4C, 0x61, 0x43)==true then return "FLAC", true, "Audio"
  elseif content:sub(1,4)=="MThd" then return "MID", true, "Audio"
  
  -- video formats
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x1A, 0x45, 0xDF, 0xA3)==true then return "MKV/MKA/MKS/MK3D/WEBM", true, "Video"
  elseif ultraschall.CompareStringWithAsciiValues(content, 0x52, 0x49, 0x46, 0x46, -1, -1, -1, -1, 0x41, 0x56, 0x49, 0x20)==true then return "AVI", true, "Video"
  else -- Reaper's own projectfiles
    local A,B=ultraschall.ReadBinaryFile_Offset(filename_with_path, 0, 100)
    local C,D=ultraschall.ReadBinaryFile_Offset(filename_with_path, -20, 21)
    if ultraschall.IsValidProjectStateChunk(B..D)==true then return "RPP_PROJECT", true, "Reaper" end
      
  -- other formats
  return "unknown", false, "unknown"
  end
end

--L,L2,L3=ultraschall.CheckForValidFileFormats("C:\\MarkerProject.RPP")
--L,L2=ultraschall.CheckForValidImageformat("h:\\aufrum\\Minerva-Digital_T-werk\\Videomaterial\\Source Code a.avi")
--AA=string.char(1, 176, 206)
--A=reaper.GetMediaSourceType(PCM_source source, string typebuf)
--M=string.format('%s', 65)




function ultraschall.InsertImageFile(filename_with_path, track, position, length, looped)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertImageFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval, MediaItem item = ultraschall.InsertImageFile(string filename_with_path, integer track, number position, number length, boolean looped)</functioncall>
  <description>
    Inserts a supported image-file into your project.
    Due API-limitations, it creates two undo-points(one for inserting the MediaItem and one for changing the length).
    
    Returns false in case of an error
  </description>
  <parameters>
    string filename_with_path - the file to check for it's image-fileformat
    integer track - the track, in which the image shall be inserted
    number position - the position of the inserted image in seconds
    number length - the length of the image-item in seconds; 1, for the default length of 1 second
    boolean looped - true, loop the inserted image-file; false, don't loop the inserted image-file
  </parameters>
  <retvals>
    boolean retval - true, if inserting was successful; false, if inserting was unsuccessful
    MediaItem item - the MediaItem of the newly inserted image
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, insert, mediaitem, position, mediafile, image, loop</tags>
</US_DocBloc>
--]]
  if filename_with_path==nil then ultraschall.AddErrorMessage("InsertImageFile","filename_with_path", "Must be a string!", -1) return false end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("InsertImageFile","filename_with_path", "File does not exist!", -2) return false end
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("InsertImageFile","track", "Must be an integer!", -3) return false end
  if track<1 then ultraschall.AddErrorMessage("InsertImageFile","track", "Must be bigger than 0!", -4) return false end
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertImageFile","position", "Must be a number!", -5) return false end
  if position<0 then ultraschall.AddErrorMessage("InsertImageFile","position", "Must be bigger than/equal 0!", -6) return false end
  if type(length)~="number" then ultraschall.AddErrorMessage("InsertImageFile","length", "Must be a number!", -7) return false end
  if length<0 then ultraschall.AddErrorMessage("InsertImageFile","length", "Must be bigger than/equal 0!", -8) return false end
  if type(looped)~="boolean" then ultraschall.AddErrorMessage("InsertImageFile","looped", "Must be boolean!", -9) return false end
  
  local fileext, supported, filetype = ultraschall.CheckForValidFileFormats(filename_with_path)  
  if filetype~="Image" then ultraschall.AddErrorMessage("InsertImageFile","filename_with_path", "Not a supported image-file!", -10) return false end
  local retval, item, ollength, numchannels, Samplerate, Filetype = ultraschall.InsertMediaItemFromFile(filename_with_path, track, position, length, 0)
  
--  reaper.SetMediaItemInfo_Value(item, "D_LENGTH", length)
  if looped==true then reaper.SetMediaItemInfo_Value(item, "B_LOOPSRC", 1) end
  return true, item
end

--ultraschall.InsertImageFile("c:\\us.png", 3, 20, 100, false)


function ultraschall.SetItemExtState(item, key, value, overwrite)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetItemExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetItemExtState(MediaItem item, string key, string value, boolean overwrite)</functioncall>
  <description>
    Sets a new extstate for a MediaItem.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaItem item - the Mediaitem, for which to set the extstate
    string key - the key of the extstate
    string value - the value of the extstate
    boolean overwrite - true, overwrite existing extstate; false, don't overwrite existing extstate
  </parameters>
  <retvals>
    boolean retval - true, if setting extstate was successful; false, if setting extstate was unsuccessful
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, set, extstate, item, guid, key, value, metadata</tags>
</US_DocBloc>
--]]
    if reaper.ValidatePtr2(0, item, "MediaItem*")==false then ultraschall.AddErrorMessage("SetItemExtState","item", "Must be a valid MediaItem!", -1) return false end
    if type(key)~="string" then ultraschall.AddErrorMessage("SetItemExtState","key", "Must be a string!", -2) return false end
    if type(value)~="string" then ultraschall.AddErrorMessage("SetItemExtState","value", "Must be a string!", -3) return false end
    if type(overwrite)~="boolean" then ultraschall.AddErrorMessage("SetItemExtState","overwrite", "Must be a boolean!", -4) return false end
    local guidString = reaper.BR_GetMediaItemGUID(item)
    local retval = ultraschall.SetGuidExtState("MediaItem-"..guidString, key, value, 0, overwrite, false)
    if retval==-1 then return false else return true end
end

function ultraschall.GetItemExtState(item, key)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string value = ultraschall.GetItemExtState(MediaItem item, string key)</functioncall>
  <description>
    Sets a new extstate for a MediaItem.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaItem item - the item, from which to get the extstate
    string key - the key of the extstate
  </parameters>
  <retvals>
    boolean retval - true, if getting extstate was successful; false, if getting extstate was unsuccessful
    string value - the value of this extstate; nil if not existing
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, extstate, item, guid, key, value, metadata</tags>
</US_DocBloc>
--]]
    if reaper.ValidatePtr2(0, item, "MediaItem*")==false then ultraschall.AddErrorMessage("GetItemExtState","item", "Must be a valid MediaItem!", -1) return false end
    if type(key)~="string" then ultraschall.AddErrorMessage("GetItemExtState","key", "Must be a string!", -2) return false end
    local guidString = reaper.BR_GetMediaItemGUID(item)
    local retval, retval2 = ultraschall.GetGuidExtState("MediaItem-"..guidString, key, 0)
    if retval==-1 then return false else return true, retval2 end
end


function ultraschall.SetTrackExtState(track, key, value, overwrite)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetTrackExtState(MediaTrack track, string key, string value, boolean overwrite)</functioncall>
  <description>
    Sets a new extstate for a MediaTrack.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaTrack track - the MediaTrack, for which to set the extstate
    string key - the key of the extstate
    string value - the value of the extstate
    boolean overwrite - true, overwrite existing extstate; false, don't overwrite existing extstate
  </parameters>
  <retvals>
    boolean retval - true, if setting extstate was successful; false, if setting extstate was unsuccessful
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, set, extstate, track, guid, key, value, metadata</tags>
</US_DocBloc>
--]]
    if reaper.ValidatePtr2(0, track, "MediaTrack*")==false then ultraschall.AddErrorMessage("SetTrackExtState","track", "Must be a valid MediaTrack!", -1) return false end
    if type(key)~="string" then ultraschall.AddErrorMessage("SetTrackExtState","key", "Must be a string!", -2) return false end
    if type(value)~="string" then ultraschall.AddErrorMessage("SetTrackExtState","value", "Must be a string!", -3) return false end
    if type(overwrite)~="boolean" then ultraschall.AddErrorMessage("SetTrackExtState","overwrite", "Must be a boolean!", -4) return false end
    local guidString = reaper.GetTrackGUID(track)
    local retval = ultraschall.SetGuidExtState("MediaTrack-"..guidString, key, value, 0, overwrite, false)
    if retval==-1 then return false else return true end
end

function ultraschall.GetTrackExtState(track, key)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackExtState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string value = ultraschall.GetTrackExtState(MediaTrack track, string key)</functioncall>
  <description>
    Sets a new extstate for a MediaTrack.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaTrack track - the track, from which to get the extstate
    string key - the key of the extstate
  </parameters>
  <retvals>
    boolean retval - true, if getting extstate was successful; false, if getting extstate was unsuccessful
    string value - the value of this extstate; nil if not existing
  </retvals>
  <chapter_context>
    Metadata Management
    Extension States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, extstate, track, guid, key, value, metadata</tags>
</US_DocBloc>
--]]
    if reaper.ValidatePtr2(0, track, "MediaTrack*")==false then ultraschall.AddErrorMessage("GetTrackExtState","track", "Must be a valid MediaTrack!", -1) return false end
    if type(key)~="string" then ultraschall.AddErrorMessage("GetTrackExtState","key", "Must be a string!", -2) return false end
    local guidString = reaper.GetTrackGUID(track)
    local retval, retval2 = ultraschall.GetGuidExtState("MediaTrack-"..guidString, key, 0)
    if retval==-1 then return false else return true, retval2 end
end

--item=reaper.GetTrack(0, 0)
--L=ultraschall.SetTrackExtState(item, "A", "BuddeldaddelDuB", true)

--B,BB=ultraschall.GetTrackExtState(item, "ALA", 0)

function ultraschall.ReturnsMinusOneInCaseOfError_Arzala()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReturnsMinusOneInCaseOfError_Arzala</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.ReturnsMinusOneInCaseOfError_Arzala()</functioncall>
  <description>
    Returns -1 in case of an error
  </description>
  <retvals>
    integer retval - returns -1 in case of error
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>returns, -1, in, case, of, error, arzala</tags>
</US_DocBloc>
--]]
  return 1
end

function ultraschall.CountLinesInString(String)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountLinesInString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer number_of_lines = ultraschall.CountLinesInString(string String)</functioncall>
  <description>
    Counts the lines in a string. It counts them by counting \n-newlines(not carriage returns!)
    
    Returns -1 in case of an error
  </description>
  <parameters>
    string String - the string to count the lines of
  </parameters>
  <retvals>
    integer number_of_lines - number of lines of the string
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, count, lines, string</tags>
</US_DocBloc>
--]]
  if type(String)~="string" then ultraschall.AddErrorMessage("CountLinesInString","String", "Must be a string!", -1) return -1 end
  local Count=1
  for w in string.gmatch(String, "\n") do
    Count=Count+1
  end
  return Count
end

function ultraschall.SetIDEFontSize(fontsize)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetIDEFontSize</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetIDEFontSize(integer fontsize)</functioncall>
  <description>
    Sets the fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)
    New fontsize is valid for all IDE's opened after calling this function.
    
    Returns false in case of an error
  </description>
  <parameters>
    integer fontsize - the new font-size for Reaper's IDEs
  </parameters>
  <retvals>
    boolean retval - true, if setting was successful; false, if not
  </retvals>
  <chapter_context>
    User Interface
    Miscellaneous
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, ide, fontsize, set</tags>
</US_DocBloc>
--]]
  if math.type(fontsize)~="integer" then ultraschall.AddErrorMessage("SetIDEFontSize","fontsize", "Must be an integer!", -1) return false end
  if fontsize<=-1 then ultraschall.AddErrorMessage("SetIDEFontSize","fontsize", "Must be bigger or equal 0!", -2) return false end
  return reaper.SNM_SetIntConfigVar("edit_fontsize", fontsize)
end

--ultraschall.SetIDEFontSize(16)

function ultraschall.GetIDEFontSize()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetIDEFontSize</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetIDEFontSize()</functioncall>
  <description>
    Returns the current fontsize of Reaper's IDE (ReaScript/Video Processor/JSFX)
  </description>
  <retvals>
    integer fontsize - the currently set fontsize within Reaper's IDEs
  </retvals>
  <chapter_context>
    User Interface
    Miscellaneous
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, ide, fontsize, get</tags>
</US_DocBloc>
--]]
  local A=reaper.SNM_GetIntConfigVar("edit_fontsize", -1)
  local B=reaper.SNM_GetIntConfigVar("edit_fontsize", -2)
  if A==B then return A else return 16 end
end

--L=ultraschall.GetIDEFontSize()


function progresscounter_old(state)
  local A=ultraschall.ReadFullFile(ultraschall.Api_Path.."/ultraschall_functions_engine.lua")
  local A=A.."function ultraschall."
  
  local functioncounter_done=10
  local functioncounter_todo=-9
  local i=0
  
  local todostring=""
  
  while A:match("function ultraschall%.")~=nil do
  --for i=0, 130 do
    local B,C=A:match("(function ultraschall%..-<ApiDocBlocFunc>.-)()function ultraschall%.")
--    if B~=nil and B:match("<slug>\n(.-)\n</slug>")=="CountSectionsByPattern" then reaper.MB(i,tostring(B:match("(ultraschall.AddErrorMessage%(\")")),0) end
  --  reaper.MB(B,C,0)
    if B==nil then break end
    i=i+1
    if state~=false then reaper.ShowConsoleMsg(i.." - "..B:match("ultraschall%..-%)").."\n") end
    if B:match("ultraschall%..-%(%)")~=nil then functioncounter_done=functioncounter_done+1 if i==186 then reaper.ShowConsoleMsg("TEST\n"..B:match("ultraschall%..-%(%)"),"",0) end
    elseif B:match("(ultraschall.AddErrorMessage%(\")")~=nil then functioncounter_done=functioncounter_done+1 if i=="a186" then reaper.ShowConsoleMsg(B,"",0) end--reaper.MB(B:match("(ultraschall.AddErrorMessage%(\")"),"",0)
    else functioncounter_todo=functioncounter_todo+1 todostring=todostring..B:match("<slug>\n*(.-)\n*</slug>").."\n"
    end
    A=A:sub(C,-1)
  end
  
  local L=functioncounter_done+functioncounter_todo
  local M=100/L
  local N=functioncounter_done*M
  
  reaper.CF_SetClipboard(todostring)
  reaper.MB("Du hast schon "..functioncounter_done.." von ".. functioncounter_done+functioncounter_todo.." Funktionen fertig. \nDas sind schon "..N.." Prozent. \nFehlen noch "..functioncounter_todo.." Funktionen.\n\nNicht schlecht :D", "Hui!", 0)  
end

--progresscounter(false)

function progresscounter(state)
  A=ultraschall.ReadFullFile(ultraschall.Api_Path.."/ultraschall_functions_engine.lua")
  A=A..ultraschall.ReadFullFile(ultraschall.Api_Path.."/ultraschall_functions_engine_beta.lua")
  A=A.."function ultraschall."
  A=A:match("function ultraschall%..*")
--  reaper.MB(tostring(A:sub(1,400)),"",0)
  i=0
  done=15
  todo=-16
  todostring=""
  funclist=""
  donestring=""
    
  while A~=nil do
  i=i+1
    B=A:match("(function.-)function ultraschall%.")
    if B==nil then break end
    func=B:match(".-%c")
    if state~=false then reaper.ShowConsoleMsg(i.." - "..func.."\n") end
    funclist=funclist..tostring(func:match("ultraschall.(.-)%(")).."\n"
    func_no_parms=func:match("%(%)")
    docblock=B:match("US_DocBloc")
    adderror=B:match("US_DocBloc.-(ultraschall%.AddErrorMessage)")
--    if func:match("DeleteArrangeviewSnapshot") then reaper.ShowConsoleMsg(i.." "..B,"",0) end
--    if i==547 then reaper.ShowConsoleMsg(i.." "..B,"",0) end

    if func==nil then break end
    if func_no_parms==nil and adderror==nil and docblock~=nil then todo=todo+1 todostring=todostring..tostring(func:match("ultraschall.(.-)%(")).."\n"
    elseif docblock~=nil then
      done=done+1
      donestring=donestring..tostring(func:match("ultraschall.(.-)%(")).."\n"
    end
--    if func_no_parms~=nil then reaper.MB(tostring(func).." "..tostring(func_no_parms).." "..tostring(adderror),"",0) end
    
    A=A:sub(B:len(),-1)
--    A=A:sub(5,-1)
--    A=A:match("function ultraschall%..*")
  end
--  reaper.ShowConsoleMsg(todostring)

  local L=done+todo
  local M=100/L
  local N=done*M
    
  --reaper.CF_SetClipboard(todostring)
--  reaper.CF_SetClipboard(donestring)

  if state~=false then reaper.MB("Du hast schon "..done.." von ".. done+todo.." Funktionen fertig. \nDas sind schon "..N.." Prozent. \nFehlen noch "..todo.." Funktionen.\n\nNicht schlecht :D", "Hui!", 0) end
  return done
end
--progresscounter(false)






--LOL=ultraschall.GetProject_Tabs()


function ultraschall.CheckForChangedProjectTabs(update)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CheckForChangedProjectTabs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer countReorderedProj, array reorderedProj, integer countNewProj, array newProj, integer countClosedProj, array closedProj = ultraschall.CheckForChangedProjectTabs(boolean update)</functioncall>
  <description>
    Returns if projecttabs have been changed due reordering, new projects or closed projects, since last calling this function.
    Set update=true to update Ultraschall's internal project-monitoring-list or it will only return the changes since starting the API in this script or since the last time you used this function with parameter update set to true!
    
    Returns false, -1 in case of error.
  </description>
  <retvals>
    boolean retval - false, no changes in the projecttabs at all; true, either order, newprojects or closed project-changes
    integer countReorderedProj - the number of reordered projects
    array reorderedProj - ReaProjects, who got reordered within the tabs
    integer countNewProj - the number of new projects
    array newProj - the new projects as ReaProjects
    integer countClosedProj - the number of closed projects
    array closedProj - the closed projects as ReaProjects
  </retvals>
  <parameters>
    boolean update - true, update Ultraschall's internal projecttab-monitoring-list to the current state of all tabs
                   - false, don't update the internal projecttab-monitoring-list, so it will keep the "old" project-tab-state as checking-reference
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, projectfiles, check, projecttab, change, order, new, closed, close</tags>
</US_DocBloc>
]]
  if type(update)~="boolean" then ultraschall.AddErrorMessage("CheckForChangedProjectTabs","update", "Must be a boolean!", -1) return false, -1 end
  local Count, Projects = ultraschall.GetProject_Tabs()

  if ultraschall.ProjectList==nil then 
    if update==true then ultraschall.ProjectList=Projects ultraschall.ProjectCount=Count end
    return false
  end
  
  -- check the order
  local OrderRetValProj={}
  local ordercount=0
  local tempproj
  local tempproj2
  
  for a=1, ultraschall.ProjectCount do
    tempproj=ultraschall.ProjectList[a][1]
    if Projects[a]==nil then break end
    tempproj2=Projects[a][1]
    if tempproj~=tempproj2 then 
        ordercount=ordercount+1
        OrderRetValProj[ordercount]=tempproj2
    end
  end
  
  -- check for new projects
  local NewRetValProj={}
  local newprojcount=0
  local found=false
  
  for i=1, Count do
    for a=1, ultraschall.ProjectCount do
      if ultraschall.ProjectList[a][1]==Projects[i][1] then 
        found=true         
        break
      end
    end
    if found==false then 
      newprojcount=newprojcount+1
      NewRetValProj[newprojcount]=Projects[i][1]
    end
    found=false
  end

  -- check for closed projects
  local ClosedRetValProj={}
  local closedprojcount=0
  local found=false
  
  for i=1, ultraschall.ProjectCount do
    for a=1, Count do
      if ultraschall.ProjectList[i][1]==Projects[a][1] then 
        found=true         
        break
      end
    end
    if found==false then 
      closedprojcount=closedprojcount+1
      ClosedRetValProj[closedprojcount]=ultraschall.ProjectList[i][1]
    end
    found=false
  end
      
  if update==true then ultraschall.ProjectList=Projects ultraschall.ProjectCount=Count end
  if ordercount>0 or newprojcount>0 or closedprojcount>0 then     
    return true, ordercount, OrderRetValProj, newprojcount, NewRetValProj, closedprojcount, ClosedRetValProj
  end
  return false
end


--function main()
--  ARetval,Borderc,Corderta,Dnewproc,Enewprta,Fclosedc,Gclosedta=ultraschall.CheckForChangedProjectTabs(true)
--  reaper.defer(main)
--end
--main()


--progresscounter()

function ultraschall.GetAllSelectedMediaItems()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllSelectedMediaItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemArray = ultraschall.GetAllSelectedMediaItems()</functioncall>
  <description>
    Returns all selected items in the project as MediaItemArray. Empty MediaItemAray if none is found.
  </description>
  <retvals>
    integer count - the number of entries in the returned MediaItemArray
    array MediaItemArray - all selected MediaItems returned as an array
  </retvals>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, get, all, selected, selection</tags>
</US_DocBloc>
]]
  -- prepare variables
  local selitemcount=reaper.CountSelectedMediaItems(0)
  local selitemarray={}
  
  -- get all selected mediaitems and put them into the array
  for i=0, selitemcount-1 do
    selitemarray[i+1]=reaper.GetSelectedMediaItem(0, i)
  end
  return selitemcount, selitemarray
end

--A,B=ultraschall.GetAllSelectedMediaItems()

function ultraschall.SetMediaItemsSelected_TimeSelection()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetMediaItemsSelected_TimeSelection</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>ultraschall.SetMediaItemsSelected_TimeSelection()</functioncall>
  <description>
    Sets all MediaItems selected, that are within the time-selection.
  </description>
  <chapter_context>
    MediaItem Management
    Selected Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, set, selected, item, mediaitem, timeselection</tags>
</US_DocBloc>
]]
  reaper.Main_OnCommand(40717,0)
end

function ultraschall.GetParentTrack_MediaItem(MediaItem)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetParentTrack_MediaItem</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer tracknumber, MediaTrack mediatrack = ultraschall.GetParentTrack_MediaItem(MediaItem MediaItem)</functioncall>
  <description>
    Returns the tracknumber and the MediaTrack-object of the track in which the MediaItem is placed.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer tracknumber - the tracknumber of the track, in which the MediaItem is placed; 1 for track 1, 2 for track 2, etc
    MediaTrack mediatrack - the MediaTrack-object of the track, in which the MediaItem is placed
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, of which you want to know the track is is placed in
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, parent, track, item, mediaitem, mediatrack</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("GetParentTrack_MediaItem","MediaItem", "Must be a MediaItem!", -1) return -1 end
  
  local MediaTrack = reaper.GetMediaItemTake_Track(reaper.GetMediaItemTake(MediaItem,0))
  
  return reaper.GetMediaTrackInfo_Value(MediaTrack, "IP_TRACKNUMBER"), MediaTrack
end

--A,B=ultraschall.GetParentTrack_MediaItem(reaper.GetMediaItem(0,1))

function ultraschall.IsItemInTrack2(MediaItem, tracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsItemInTrack2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer tracknumber = ultraschall.IsItemInTrack2(MediaItem MediaItem, integer tracknumber)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Checks, whether a MediaItem is in track with tracknumber.
    
    see [IsItemInTrack](#IsItemInTrack) to use itemidx instead of the MediaItem-object.
    see [IsItemInTrack3](#IsItemInTrack3) to check against multiple tracks at once using a trackstring.
    
    returns nil in case of error
  </description>
  <retvals>
    boolean retval - true, if item is in track; false, if not
    integer tracknumber - the tracknumber of the track, in which the item lies
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, of which you want to know the track is is placed in
    integer tracknumber - the tracknumber to check the parent track of the MediaItem against, with 1 for track 1, etc
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, check, item, track</tags>
</US_DocBloc>
]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("IsItemInTrack2","tracknumber", "Must be an integer!", -1) return end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("IsItemInTrack2","tracknumber", "No such track!", -2) return end
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("IsItemInTrack2","MediaItem", "Must be a MediaItem!", -3) return end
  
  -- prepare vaiable
  local itemtracknumber=ultraschall.GetParentTrack_MediaItem(MediaItem)
  
  -- check if item is in track
  if tracknumber==itemtracknumber then return true, itemtracknumber
  else return false, itemtracknumber
  end
end

--A,B=ultraschall.IsItemInTrack2(reaper.GetMediaItem(0,0),1)

function ultraschall.ReturnTypeOfReaperObject(object)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReturnTypeOfReaperObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string objecttype = ultraschall.ReturnTypeOfReaperObject(Reaperobject object)</functioncall>
  <description>
    returns the type of a Reaper-object.
  </description>
  <retvals>
    string objecttype - the type of the parameter of object
                      - the following types can be returned: 
                      - ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source, None
  </retvals>
  <parameters>
    Reaperobject object - a Reaper-object of the following types:
                        - ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
                        - returns None if the object isn't a valid Reaper-object
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, check, type, reaper, object, project, track, item, take, envelope, pcmsource</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, object, "ReaProject*")==true then return "ReaProject" end
  if reaper.ValidatePtr2(0, object, "MediaTrack*")==true then return "MediaTrack" end
  if reaper.ValidatePtr2(0, object, "MediaItem*")==true then return "MediaItem" end
  if reaper.ValidatePtr2(0, object, "MediaItem_Take*")==true then return "MediaItem_Take" end
  if reaper.ValidatePtr2(0, object, "TrackEnvelope*")==true then return "TrackEnvelope" end
  if reaper.ValidatePtr2(0, object, "PCM_source*")==true then return "PCM_source" end
  return "None"
end

function ultraschall.IsObjectValidReaperObject(object)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsObjectValidReaperObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string objecttype = ultraschall.IsObjectValidReaperObject(Reaperobject object)</functioncall>
  <description>
    checks, if object is a valid Reaper-object. It also returns the type of that Reaper-object.
  </description>
  <retvals>
    boolean retval - true, if it's a valid Reaper-object; false, if not
    string objecttype - the type of the parameter of object
                      - the following types can be returned: 
                      - ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source, None
  </retvals>
  <parameters>
    Reaperobject object - a Reaper-object of the following types:
                        - ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
                        - returns None if the object isn't a valid Reaper-object
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, check, type, reaper, object, project, track, item, take, envelope, pcmsource</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, object, "ReaProject*")==true then return true, "ReaProject" end
  if reaper.ValidatePtr2(0, object, "MediaTrack*")==true then return true, "MediaTrack" end
  if reaper.ValidatePtr2(0, object, "MediaItem*")==true then return true, "MediaItem" end
  if reaper.ValidatePtr2(0, object, "MediaItem_Take*")==true then return true, "MediaItem_Take" end
  if reaper.ValidatePtr2(0, object, "TrackEnvelope*")==true then return true, "TrackEnvelope" end
  if reaper.ValidatePtr2(0, object, "PCM_source*")==true then return true, "PCM_source" end
  return false, "None"
end

--A,B=ultraschall.IsObjectValidReaperObject(reaper.GetMediaItem(0,0))


function ultraschall.KeepTableEntriesOfType(worktable, keeptype)
-- supports
-- boolean, integer, float, number, string, ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>KeepTableEntriesOfType</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table alteredtable = ultraschall.KeepTableEntriesOfType(table worktable, string keeptype)</functioncall>
  <description>
    Removes all entries from worktable, that are not of the datatype as given by keeptype.
    
    returns nil in case of error
  </description>
  <retvals>
    table alteredtable - the table, that contains only the entries of the type as given by parameter keeptype
  </retvals>
  <parameters>
    table worktable - the unaltered source-table for processing
    string keeptype - the type that shall remain in table
                    - allowed are boolean, integer, float, number, table, string, userdata, thread, ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, keep, alter, table, types</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(worktable)~="table" then ultraschall.AddErrorMessage("KeepTableEntriesOfType","worktable", "Must be a table!", -1) return end
  if type(keeptype)~="string" then ultraschall.AddErrorMessage("KeepTableEntriesOfType","keeptype", "Must be a string!", -2) return end
  
  -- prepare variable
  local NewTable={}
  
  -- throw out all entries, that are not of type keeptype
  for k,v in pairs(worktable) do 
    if type(v)==keeptype or math.type(v)==keeptype then
      NewTable[k]=v
    elseif ultraschall.ReturnTypeOfReaperObject(v)~=ultraschall.ReturnTypeOfReaperObject(keeptype) then
      NewTable[k]=v
    end
  end
  return NewTable
end


function ultraschall.RemoveTableEntriesOfType(worktable, removetype)
-- supports
-- boolean, integer, float, number, string, ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RemoveTableEntriesOfType</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table alteredtable = ultraschall.RemoveTableEntriesOfType(table worktable, string removetype)</functioncall>
  <description>
    Removes all entries from worktable, that are of the datatype as given by removetype.
    
    returns nil in case of error
  </description>
  <retvals>
    table alteredtable - the table, that contains only the entries that are nt of the type as given by parameter removetype
  </retvals>
  <parameters>
    table worktable - the unaltered source-table for processing
    string removetype - the type that shall be removed from table
                    - allowed are boolean, integer, float, number, table, string, userdata, ReaProject, MediaTrack, MediaItem, MediaItem_Take, TrackEnvelope, PCM_source
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, remove, alter, table, types</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(worktable)~="table" then ultraschall.AddErrorMessage("RemoveTableEntriesOfType","worktable", "Must be a table!", -1) return end
  if type(removetype)~="string" then ultraschall.AddErrorMessage("RemoveTableEntriesOfType","removetype", "Must be a string!", -2) return end
  
  -- prepare variables
  local NewTable={}
  
  -- remove table-entries, that are of type removetype
  for k,v in pairs(worktable) do 
    if type(v)==removetype or math.type(v)==removetype or ultraschall.ReturnTypeOfReaperObject(v)==ultraschall.ReturnTypeOfReaperObject(removetype) then
      NewTable[k]=v
    end
  end
  return NewTable
end

--[[A={}
A[1]=99
A[2]="tudelu"
A[3]=true
A[9]=9.987
A[7]=reaper.GetTrack(0,0)
A["HollaDieWaldfee"]=false
L,LL=ultraschall.RemoveTableEntriesOfType(A, "MediaTrack")--]]



function ultraschall.IsItemInTrack3(MediaItem, trackstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsItemInTrack3</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsItemInTrack3(MediaItem MediaItem, string trackstring)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Checks, whether a MediaItem is in any of the tracks, given by trackstring.
    
    see [IsItemInTrack](#IsItemInTrack) to use itemidx instead of the MediaItem-object.
    see [IsItemInTrack2](#IsItemInTrack2) to check against only one track.
    
    returns nil in case of error
  </description>
  <retvals>
    boolean retval - true, if item is in track; false, if not
    string trackstring - a string with all tracknumbers, separated by commas; 1 for track 1, 2 for track 2, etc
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, of which you want to know the track is is placed in
    string trackstring - a string with all tracknumbers, separated by commas; 1 for track 1, 2 for track 2, etc
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, check, item, track, trackstring</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(trackstring)~="string" then ultraschall.AddErrorMessage("IsItemInTrack3","trackstring", "Must be a string!", -1) return end
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("IsItemInTrack3","MediaItem", "Must be a MediaItem!", -2) return end
  local retval, count, individual_values=ultraschall.IsValidTrackString(trackstring)
  
  -- check, if item is in any of the tracks in trackstring
  for i=1, count do
    if individual_values[i]==ultraschall.GetParentTrack_MediaItem(MediaItem) then return true end
  end
  return false
end

--L=ultraschall.IsItemInTrack3(reaper.GetMediaItem(0,0), "1,2,3")

function ultraschall.IsItemInTimerange(MediaItem, startposition, endposition, inside)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsItemInTimerange</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsItemInTimerange(MediaItem MediaItem, number startposiiton, number endposition, boolean inside)</functioncall>
  <description>
    checks, whether a given MediaItem is within startposition and endposition and returns the result.
    
    returns nil in case of an error
  </description>
  <retvals>
    boolean retval - true, item is in timerange; false, item isn't in timerange
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem to check for, if it's within the timerange
    number startposition - the starttime of the timerange, in which the MediaItem must be, in seconds
    number endposition - the endtime of the timerange, in which the MediaItem must be, in seconds
    boolean inside - true, MediaItem must be fully within timerange; false, MediaItem can be partially inside timerange
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, check, timerange, tracks, mediaitems</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(startposition)~="number" then ultraschall.AddErrorMessage("IsItemInTimerange","startposition", "Must be a number!", -1) return end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("IsItemInTimerange","endposition", "Must be a number!", -2) return end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("IsItemInTimerange","inside", "Must be a boolean!", -3) return end
  if startposition>endposition then ultraschall.AddErrorMessage("IsItemInTimerange","startposition", "Must be smaller or equal endposition!", -4) return end
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("IsItemInTimerange","MediaItem", "Must be a MediaItem!", -5) return end  
  
  -- prepare variables
  local itemstartposition=reaper.GetMediaItemInfo_Value(MediaItem, "D_POSITION")
  local itemendposition=reaper.GetMediaItemInfo_Value(MediaItem, "D_LENGTH")+itemstartposition
  
  -- check, if the item is in tiumerange
  if inside==true then -- if fully within timerange
    if itemstartposition>=startposition and itemendposition<=endposition then return true else return false end
  else -- if also partially within timerange
    if itemstartposition>endposition or itemendposition<startposition then return false
    else return true
    end
  end
end

--start, ende = reaper.GetSet_LoopTimeRange(false, false, 0, 0, false)

--A,B=ultraschall.IsItemInTimerange(reaper.GetMediaItem(0,0), start, ende, false)

function ultraschall.OnlyItemsInTracksAndTimerange(MediaItemArray, trackstring, starttime, endtime, inside)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyItemsInTracksAndTimerange</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer count, MediaItemArray MediaItemArray = ultraschall.OnlyItemsInTracksAndTimerange(MediaItemArray MediaItemArray, string trackstring, number starttime, number endtime, boolean inside)</functioncall>
  <description>
    Removes all items from MediaItemArray, that aren't in tracks, as given by trackstring and are outside the timerange(starttime to endtime).
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer count - the number of items that fit the requested tracks and timerange
    MediaItemArray MediaItemArray - the altered MediaItemArray, that has only the MediaItems from tracks as requested by trackstring and from within timerange
  </retvals>
  <parameters>
    MediaItemArray MediaItemArray - an array with all MediaItems, that shall be checked for trackexistence and timerange
    string trackstring - a string with all requested tracknumbers in which the MediaItem must be, separated by commas; 1 for track 1, 2 for track 2, etc
    number starttime - the starttime of the timerange, in which the MediaItem must be, in seconds
    number endtime - the endtime of the timerange, in which the MediaItem must be, in seconds
    boolean inside - true, only MediaItems are returned, that are fully within starttime and endtime; false, return also MediaItems partially in timerange
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, check, alter, timerange, tracks, mediaitem, mediaitemarray</tags>
</US_DocBloc>
]]
  -- check parameters
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("OnlyItemsInTracksAndTimerange","MediaItemArray", "No valid MediaItemArray!", -1) return -1 end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("OnlyItemsInTracksAndTimerange","trackstring", "No valid trackstring!", -2) return -1 end
  if type(starttime)~="number" then ultraschall.AddErrorMessage("OnlyItemsInTracksAndTimerange","starttime", "Must be a number!", -3) return -1 end
  if type(endtime)~="number" then ultraschall.AddErrorMessage("OnlyItemsInTracksAndTimerange","endtime", "Must be a number!", -4) return -1 end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("OnlyItemsInTracksAndTimerange","inside", "Must be a boolean!", -5) return -1 end
  
  -- prepare variables
  local count=1
  local count2=0
  local NewMediaItemArray={}
  
  -- check if the MediaItems are within tracks and timerange and put the "valid" ones into NewMediaItemArray
  while MediaItemArray[count]~=nil do
    if ultraschall.IsItemInTrack3(MediaItemArray[count], trackstring)==true 
      and ultraschall.IsItemInTimerange(MediaItemArray[count], starttime, endtime, inside)==true 
      then 
      count2=count2+1
      NewMediaItemArray[count2]=MediaItemArray[count]    
    end
    count=count+1
  end
  return count2, NewMediaItemArray
end

--start, ende = reaper.GetSet_LoopTimeRange(false, false, 0, 0, false)
--L,L2=ultraschall.GetAllMediaItemsBetween(start,ende,"1,2,3",false)

--M,M2=ultraschall.OnlyItemsInTracksAndTimerange(L2, "2", start, ende, false)


function ultraschall.ApplyActionToMediaItem(MediaItem, actioncommandid, repeat_action, midi, MIDI_hwnd)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyActionToMediaItem</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyActionToMediaItem(MediaItem MediaItem, string actioncommandid, integer repeat_action, boolean midi, optional HWND MIDI_hwnd)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Applies an action to a MediaItem, in either main or MIDI-Editor section-context.
    The action given must support applying itself to selected items.    
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running the action was successful; false, if not or an error occured
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, to whom the action shall be applied to
    string actioncommandid - the commandid-number or ActionCommandID, that shall be run.
    integer repeat_action - the number of times this action shall be applied to each item; minimum value is 1
    boolean midi - true, run an action from MIDI-Editor-section-context; false, run an action from the main section
    optional HWND MIDI_hwnd - the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, run, action, midi, main, midieditor, item, mediaitem</tags>
</US_DocBloc>
]]
  -- check parameters
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("ApplyActionToMediaItem","MediaItem", "Must be a MediaItem!", -1) return false end
  if ultraschall.CheckActionCommandIDFormat2(actioncommandid)==false then ultraschall.AddErrorMessage("ApplyActionToMediaItem","actioncommandid", "No such action registered!", -2) return false end
  if type(midi)~="boolean" then ultraschall.AddErrorMessage("ApplyActionToMediaItem","midi", "Must be boolean!", -3) return false end
  if math.type(repeat_action)~="integer" then ultraschall.AddErrorMessage("ApplyActionToMediaItem","repeat_action", "Must be an integer!", -4) return false end
  if repeat_action<1 then ultraschall.AddErrorMessage("ApplyActionToMediaItem","repeat_action", "Must be bigger than 0!", -5) return false end

  -- get old item-selection, delete item selection, select MediaItem
  reaper.PreventUIRefresh(1)
  local oldcount, oldselection = ultraschall.GetAllSelectedMediaItems()
  reaper.SelectAllMediaItems(0, false)
  reaper.SetMediaItemSelected(MediaItem, true)
  if type(actioncommandid)=="string" then actioncommandid=reaper.NamedCommandLookup(actioncommandid) end -- get command-id-number from named actioncommandid

  -- run the action for repeat_action-times
  for i=1, repeat_action do
    if midi==true then 
      reaper.MIDIEditor_OnCommand(MIDI_hwnd, actioncommandid)
    else
      reaper.Main_OnCommand(actioncommandid, 0)
    end
  end
  -- restore old item-selection
  reaper.SelectAllMediaItems(0, false)
  ultraschall.SelectMediaItems_MediaItemArray(oldselection)
  reaper.PreventUIRefresh(-1)
  reaper.UpdateArrange()
  return true
end

--MediaItem=reaper.GetMediaItem(0,0)
--ultraschall.ApplyActionToMediaItem(MediaItem, "_XENAKIOS_MOVEITEMSLEFTBYLEN", 2, false, reaper.MIDIEditor_GetActive())

function ultraschall.ZoomVertical_MidiEditor(zoomamt, HWND)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ZoomVertical_MidiEditor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ZoomVertical_MidiEditor(integer zoomamt, optional HWND midieditor_hwnd)</functioncall>
  <description>
    Zooms within the Midi-Editor vertically.
  </description>
  <retvals>
    boolean retval - true, if zooming was successful; false, if not
  </retvals>
  <parameters>
    integer zoomamt - the zoom-factor; positive values, zoom in; negative values, zoom out
    optional HWND midieditor_hwnd - the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor
  </parameters>
  <chapter_context>
    MIDI Management
    MIDI Editor
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>midimanagement, zoom, midieditor, vertically</tags>
</US_DocBloc>
]]
  -- check parameters and prepare correct zoom-actioncommandid
  if HWND==nil then HWND=reaper.MIDIEditor_GetActive() end
  if math.type(zoomamt)~="integer" then ultraschall.AddErrorMessage("ZoomVertical_MidiEditor","zoomamt", "Must be an integer!", -1) return false end
  if zoomamt>0 then actioncommandid=40111 -- zoom in
  elseif zoomamt<0 then actioncommandid=40112 -- zoom out
  else actioncommandid=65535 -- do nothing, when 0 is given as zoom-value
  end
  
  -- Now, do the zooming
  if zoomamt<0 then zoomamt=zoomamt*-1 end
  for i=1, zoomamt do
    reaper.MIDIEditor_OnCommand(HWND, actioncommandid)
  end
end

--ultraschall.ZoomVertical_MidiEditor(HWND, 5)

function ultraschall.ZoomHorizontal_MidiEditor(zoomamt, HWND)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ZoomHorizontal_MidiEditor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ZoomHorizontal_MidiEditor(integer zoomamt, optional HWND midieditor_hwnd)</functioncall>
  <description>
    Zooms within the Midi-Editor horizontally.
  </description>
  <retvals>
    boolean retval - true, if zooming was successful; false, if not
  </retvals>
  <parameters>
    integer zoomamt - the zoom-factor; positive values, zoom in; negative values, zoom out
    optional HWND midieditor_hwnd - the HWND of the MIDI-Editor, in which you want to zoom; nil, uses active MIDI-Editor
  </parameters>
  <chapter_context>
    MIDI Management
    MIDI Editor
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>midimanagement, zoom, midieditor, horizontally</tags>
</US_DocBloc>
]]
  -- check parameters and prepare correct zoom-actioncommandid
  if HWND==nil then HWND=reaper.MIDIEditor_GetActive() end
  if math.type(zoomamt)~="integer" then ultraschall.AddErrorMessage("ZoomHorizontal_MidiEditor","zoomamt", "Must be an integer!", -1) return false end
  if zoomamt>0 then actioncommandid=1012 -- zoomin
  elseif zoomamt<0 then actioncommandid=1011 -- zoomout
  else actioncommandid=65535 -- nothing, when 0 is given
  end
  
  -- do the zooming
  if zoomamt<0 then zoomamt=zoomamt*-1 end -- 
  for i=1, zoomamt do
    reaper.MIDIEditor_OnCommand(HWND, actioncommandid)
  end
  return true
end

--ultraschall.ZoomHorizontal_MidiEditor(HWND, 5)


function ultraschall.OpenItemInMidiEditor(MediaItem)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OpenItemInMidiEditor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.OpenItemInMidiEditor(MediaItem MediaItem)</functioncall>
  <description>
    opens a given MediaItem in the MIDI-Editor
  </description>
  <retvals>
    boolean retval - true, if opening was successful; false, if not
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem to be opened in the MIDI-Editor
  </parameters>
  <chapter_context>
    MIDI Management
    MIDI Editor
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>midimanagement, open, item, midieditor</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("OpenItemInMidiEditor","MediaItem", "Must be a MediaItem!", -1) return false end
  ultraschall.ApplyActionToMediaItem(MediaItem, 40153, 1, false)
  return true
end

--MediaItem=reaper.GetMediaItem(0,0)
--ultraschall.OpenItemInMidiEditor(MediaItem)

function ultraschall.ApplyActionToMediaItemArray(MediaItemArray, actioncommandid, repeat_action, midi, MIDI_hwnd)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyActionToMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyActionToMediaItemArray(MediaItemArray MediaItemArray, string actioncommandid, integer repeat_action, boolean midi, optional HWND MIDI_hwnd)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context
    The action given must support applying itself to selected items.
    
    This function applies the action to each MediaItem individually. To apply the action to all MediaItems in MediaItemArray at once, see <a href="#ApplyActionToMediaItemArray2">ApplyActionToMediaItemArray2</a>.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running the action was successful; false, if not or an error occured
  </retvals>
  <parameters>
    MediaItemArray MediaItemArray - an array with all MediaItems, to whom the action shall be applied to
    string actioncommandid - the commandid-number or ActionCommandID, that shall be run.
    integer repeat_action - the number of times this action shall be applied to each item; minimum value is 1
    boolean midi - true, run an action from MIDI-Editor-section-context; false, run an action from the main section
    optional HWND MIDI_hwnd - the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, run, action, midi, main, midieditor, item, mediaitemarray</tags>
</US_DocBloc>
]]
  -- check parameters
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray","MediaItemArray", "No valid MediaItemArray!", -1) return false end
  if ultraschall.CheckActionCommandIDFormat2(actioncommandid)==false then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray","actioncommandid", "No such action registered!", -2) return false end
  if type(midi)~="boolean" then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray","midi", "Must be boolean!", -3) return false end
  if math.type(repeat_action)~="integer" then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray","repeat_action", "Must be an integer!", -4) return false end
  if repeat_action<1 then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray","repeat_action", "Must be bigger than 0!", -5) return false end
  
  -- prepare variable
  local count=1
  
  -- apply action to every MediaItem in MediaItemAray repeat_action times
  while MediaItemArray[count]~=nil do
    for i=1, repeat_action do
      ultraschall.ApplyActionToMediaItem(MediaItemArray[count], actioncommandid, repeat_action, midi, MIDI_hwnd)
    end
    count=count+1
  end
  return true
end


--A,B=ultraschall.GetAllMediaItemsBetween(1,40000,"1,2",true)
--ultraschall.ApplyActionToMediaItemArray(B, 40123, 10, false, MIDI_hwnd)


function ultraschall.ApplyActionToTrack(trackstring, actioncommandid)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyActionToTrack</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyActionToTrack(string trackstring, string/number actioncommandid)</functioncall>
  <description>
    Applies action to the tracks, given by trackstring
    The action given must support applying itself to selected tracks.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, running action was successful; false, running the action was unsuccessful
  </retvals>
  <parameters>
    string trackstring - a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, run, command, track</tags>
</US_DocBloc>
]]
  -- check parameters
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("ApplyActionToTrack","trackstring", "Must be a valid trackstring!", -1) return false end
  if ultraschall.CheckActionCommandIDFormat2(actioncommandid)==false then ultraschall.AddErrorMessage("ApplyActionToTrack","actioncommandid", "No valid actioncommandid!", -2) return false end
  
  -- store current track-selection, make new track-selection, run the action and restore old track-selection
  reaper.PreventUIRefresh(1)
  local selTrackstring=ultraschall.CreateTrackString_SelectedTracks() 
  ultraschall.SetTracksSelected(trackstring, true)
  ultraschall.RunCommand(actioncommandid)
  ultraschall.SetTracksSelected(selTrackstring, true)
  reaper.PreventUIRefresh(-1)
  return true
end

--ultraschall.ApplyActionToTrack("2,3,5", 6)

function ultraschall.GetAllMediaItemsInTimeSelection(trackstring, inside)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItemsInTimeSelection</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count, array MediaItemArray = ultraschall.GetAllMediaItemsInTimeSelection(string trackstring, boolean inside)</functioncall>
  <description>
    Gets all MediaItems from within a time-selection
    
    Returns -1 in case of an error
  </description>
  <retvals>
    integer count - the number of items found in time-selection
    array MediaItemArray - an array with all MediaItems found within time-selection
  </retvals>
  <parameters>
    string trackstring - a string with all tracknumbers, separated by a comma; 1 for the first track, 2 for the second
  </parameters>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, items, time, selection</tags>
</US_DocBloc>
]]
  -- check parameters
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("GetAllMediaItemsInTimeSelection","trackstring", "Must be a valid trackstring!", -1) return -1 end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("GetAllMediaItemsInTimeSelection","inside", "Must be boolean!", -2) return -1 end
  
  -- prepare variables
  local oldcount, oldselection = ultraschall.GetAllSelectedMediaItems()
  local starttime, endtime = reaper.GetSet_LoopTimeRange(false, false, 0, 0, false)
  
  -- Do the selection
  reaper.PreventUIRefresh(1)
  reaper.SelectAllMediaItems(0, false) -- deselect all
  ultraschall.SetMediaItemsSelected_TimeSelection() -- select only within time-selection
  local count, MediaItemArray=ultraschall.GetAllSelectedMediaItems() -- get all selected items
  local count2
  if MediaItemArray[1]== nil then count2=0 
  else   
    -- check, whether the item is in a track, as demanded by trackstring
    for i=count, 1, -1 do
      if ultraschall.IsItemInTrack3(MediaItemArray[i], trackstring)==false then table.remove(MediaItemArray, i) count=count-1 end
    end
    
    -- remove all items, that aren't properly within time-selection(like items partially in selection)
    if MediaItemArray[1]==nil then count2=0 
    else count2, MediaItemArray=ultraschall.OnlyItemsInTracksAndTimerange(MediaItemArray, trackstring, starttime, endtime, inside) 
    end
  end
    
  -- reset old selection, redraw arrange and return what has been found
  reaper.SelectAllMediaItems(0, false)
  ultraschall.SelectMediaItems_MediaItemArray(oldselection)
  reaper.PreventUIRefresh(-1)
  reaper.UpdateArrange()
  return count2, MediaItemArray
end

--A,B=ultraschall.GetAllMediaItemsInTimeSelection("2", false)

function ultraschall.NormalizeItems(MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>NormalizeItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.NormalizeItems(array MediaItemArray)</functioncall>
  <description>
    Normalizes all items in MediaItemArray.
    
    Returns -1 in case of an error
  </description>
  <retvals>
    integer retval - -1, in case of an error
  </retvals>
  <parameters>
    array MediaItemArray - an array with all MediaItems, that shall be normalized
  </parameters>
  <chapter_context>
    MediaItem Management
    Manipulate
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, normalize, items</tags>
</US_DocBloc>
]]
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("NormalizeItems","MediaItemArray", "No valid MediaItemArray!", -1) return -1 end
  ultraschall.ApplyActionToMediaItemArray(MediaItemArray, 40108, 1, false)
end

--A,B=ultraschall.GetAllMediaItemsInTimeSelection("1,2", false)
--ultraschall.NormalizeItems(B)

function ultraschall.GetOutputFormat_RenderCfg(Renderstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetOutputFormat_RenderCfg</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string outputformat = ultraschall.GetOutputFormat_RenderCfg(string Renderstring)</functioncall>
  <description>
    Returns the output-format set in a render-cfg-string, as stored in rpp-files and the render-presets file reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string outputformat - the outputformat, set in the render-cfg-string
    - The following are valid: 
    - AIFF, AUDIOCD-IMAGE, WAV, WAVPACK, DDP, FLAC, MP3, M4A, OPUS Reaper5.941 and earlier, OPUS Reaper5.95+, OGG, Video WebM, Video MKV, Video MP4, Video AVI, Video GIF, Video LCF
  </retvals>
  <parameters>
    string Renderstring - the render-cfg-string from a rpp-projectfile or the reaper-render.ini
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, get, render, outputformat</tags>
</US_DocBloc>
]]
--[[
AIFF:     ZmZpY    12
AUDIOCD:  IG9za    32
WAV:      ZXZhd    12
WAVPACK:  a3B2dw   28
DDP:      IHBkZA=
FLAC:     Y2FsZh   16
MP3:      bDNwbc   44
OPUS:     U2dnTwAA 20
OGG:      dmdnb    36
Video
  WebM    UE1GRgY  60
  MKV     UE1GRgQ  60
  MP4     UE1GRgM  60
  AVI     UE1GRgA  60
GIF:      IEZJR    24
LCF:      IEZDT    108
--]]
  -- check parameter
  if type(Renderstring)~="string" then ultraschall.AddErrorMessage("GetOutputFormat_RenderCfg", "Renderstring", "Must be a string!", -1) return nil end

  -- get rid of anything else than printable characters
  local A2,B=Renderstring:match("%s*()[%g%=]*()")
  Renderstring=Renderstring:sub(A2,B-1)
  
  -- return the proper value
  if Renderstring:sub(1,5)=="ZmZpY"    and Renderstring:len()==12 then return "AIFF"    end
  if Renderstring:sub(1,5)=="IG9za"    and Renderstring:len()==32 then return "AUDIOCD-IMAGE" end
  if Renderstring:sub(1,5)=="ZXZhd"    and Renderstring:len()==12 then return "WAV"     end
  if Renderstring:sub(1,6)=="a3B2dw"   and Renderstring:len()==28 then return "WAVPACK" end
  if Renderstring         =="IHBkZA="                             then return "DDP"  end
  if Renderstring:sub(1,6)=="Y2FsZh"   and Renderstring:len()==16 then return "FLAC" end
  if Renderstring:sub(1,5)=="bDNwb"    and Renderstring:len()==44 then return "MP3"  end
  if Renderstring:sub(1,6)=="U2dnTw" and Renderstring:len()==20 then return "OPUS Reaper5.941 and earlier" end
  if Renderstring:sub(1,6)=="U2dnTw" and Renderstring:len()==24 then return "OPUS Reaper5.95+" end
  if Renderstring:sub(1,5)=="dmdnb"    and Renderstring:len()==36 then return "OGG"  end
  if Renderstring:sub(1,4)=="RlZB"     and Renderstring:len()==60 then return "M4A"  end
  if Renderstring:sub(1,7)=="UE1GRgY"  and Renderstring:len()==60 then return "Video WebM" end
  if Renderstring:sub(1,7)=="UE1GRgQ"  and Renderstring:len()==60 then return "Video MKV"  end
  if Renderstring:sub(1,7)=="UE1GRgM"  and Renderstring:len()==60 then return "Video MP4"  end
  if Renderstring:sub(1,7)=="UE1GRgA"  and Renderstring:len()==60 then return "Video AVI"  end
  if Renderstring:sub(1,5)=="IEZJR"    and Renderstring:len()==24 then return "Video GIF"  end
  if Renderstring:sub(1,5)=="IEZDT"    and Renderstring:len()==108 then return "Video LCF" end
  return "Unknown"
end


--B=ultraschall.GetOutputFormat_RenderString(A)


function ultraschall.CreateRenderCFG_Opus(Mode, Kbps, Complexity)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_Opus</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_Opus(integer Mode, integer Kbps, integer Complexity)</functioncall>
  <description>
    Returns the render-cfg-string for the Opus-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected Opus-settings
  </retvals>
  <parameters>
    integer Mode - the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR
    integer Kbps - the kbps of the opus-file; Ultraschall-Api supports between 1 and 256
    integer Complexity - the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding)
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, opus</tags>
</US_DocBloc>
]]

  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  if reaper.file_exists(ini_file)==false then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Ooops", "external render-code-ini-file does not exist. Reinstall Ultraschall-API again, please!", -1) return nil end
  if math.type(Kbps)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Kbps", "Must be an integer!", -2) return nil end
  if math.type(Mode)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Mode", "Must be an integer!", -3) return nil end
  if math.type(Complexity)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Complexity", "Must be an integer!", -4) return nil end
  if Kbps<1 or Kbps>256 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Kbps", "Ultraschall-API supports only kbps-values between 1 to 256, sorry.", -5) return nil end
  if Mode<0 or Mode>2 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Mode", "must be between 0 and 2", -6) return nil end
  if Complexity<0 or Complexity>10 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus", "Complexity", "must be between 0 and 10", -7) return nil end
  
  if Mode==0 then Mode="VBR"
  elseif Mode==1 then Mode="CVBR"
  elseif Mode==2 then Mode="HARDCBR"
  end
  local _temp, renderstring=ultraschall.GetIniFileExternalState("OPUS", "Renderstring", ini_file)  
  local _temp, renderkbps=ultraschall.GetIniFileExternalState("OPUS", "KBPS_"..Kbps, ini_file)
  local _temp, rendermode=ultraschall.GetIniFileExternalState("OPUS", "MODE_"..Mode, ini_file)
  local _temp, rendercomplexity=ultraschall.GetIniFileExternalState("OPUS", "Complexity_"..Complexity, ini_file)

  renderstring=string.gsub(renderstring, "%[KBPS%]", renderkbps)
  renderstring=string.gsub(renderstring, "%[MODE%]", rendermode)
  renderstring=string.gsub(renderstring, "%[Complexity%]", rendercomplexity)
  return renderstring
end

--A=ultraschall.CreateRenderCFG_Opus(0, 24, 5)


function ultraschall.CreateRenderCFG_Opus2(Mode, Kbps, Complexity, channel_audio, per_channel)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_Opus2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_Opus2(integer Mode, integer Kbps, integer Complexity, boolean channel_audio, boolean per_channel)</functioncall>
  <description>
    Returns the render-cfg-string for the Opus-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Only for Reaper-versions 5.95 and higher. For render-strings compatible with earlier versions of Reaper, use <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>. If you use CreateRenderCFG_Opus2-created render string, you will loose the multichannel-settings when saving the project in an earlier version of Reaper.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected Opus-settings
  </retvals>
  <parameters>
    integer Mode - the Mode for the Opus-file; 0, VBR; 1, CVBR; 2, HARDCBR
    integer Kbps - the kbps of the opus-file; Ultraschall-Api supports between 1 and 256
    integer Complexity - the complexity-setting between 0(lowest quality) and 10(highest quality, slow encoding)
    boolean channel_audio - true, Encode 3-8 channel audio as 2.1-7.1(LFE); false, DON'T Encode 3-8 channel audio as 2.1-7.1(LFE)
    boolean per_channel - true, kbps per channel (6-256); false, kbps combined for all channels
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, opus, multichannel</tags>
</US_DocBloc>
]]

  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  local encode
  if reaper.file_exists(ini_file)==false then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Ooops", "external render-code-ini-file does not exist. Reinstall Ultraschall-API again, please!", -1) return nil end
  if math.type(Kbps)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Kbps", "Must be an integer!", -2) return nil end
  if math.type(Mode)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Mode", "Must be an integer!", -3) return nil end
  if math.type(Complexity)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Complexity", "Must be an integer!", -4) return nil end
  if Kbps<1 or Kbps>256 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Kbps", "Ultraschall-API supports only kbps-values between 1 to 256, sorry.", -5) return nil end
  if Mode<0 or Mode>2 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Mode", "must be between 0 and 2", -6) return nil end
  if Complexity<0 or Complexity>10 then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "Complexity", "must be between 0 and 10", -7) return nil end
  if type(channel_audio)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "channel_audio", "must be a boolean", -8) return nil end
  if type(per_channel)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_Opus2", "per_channel", "must be a boolean", -9) return nil end
  
  if channel_audio==false and per_channel==false then encode="A"
  elseif channel_audio==false and per_channel==true then encode="I"
  elseif channel_audio==true and per_channel==false then encode="E"
  elseif channel_audio==true and per_channel==true then encode="M"
  end
  
  if Mode==0 then Mode="VBR"
  elseif Mode==1 then Mode="CVBR"
  elseif Mode==2 then Mode="HARDCBR"
  end
  local _temp, renderstring=ultraschall.GetIniFileExternalState("Opus_Reaper_5_95", "Renderstring", ini_file)  
  local _temp, renderkbps=ultraschall.GetIniFileExternalState("Opus_Reaper_5_95", "KBPS_"..Kbps, ini_file)
  local _temp, rendermode=ultraschall.GetIniFileExternalState("Opus_Reaper_5_95", "MODE_"..Mode, ini_file)
  local _temp, rendercomplexity=ultraschall.GetIniFileExternalState("Opus_Reaper_5_95", "Complexity_"..Complexity, ini_file)

  renderstring=string.gsub(renderstring, "%[KBPS%]", renderkbps)
  renderstring=string.gsub(renderstring, "%[MODE%]", rendermode)
  renderstring=string.gsub(renderstring, "%[Encode%]", encode)
  renderstring=string.gsub(renderstring, "%[Complexity%]", rendercomplexity)
  return renderstring
end

--A=ultraschall.CreateRenderCFG_Opus2(0, 1, 0, false, false)
--B = ultraschall.GetProject_RenderCFG("c:\\opustest.rpp")




function ultraschall.CreateRenderCFG_OGG(Mode, VBR_Quality, CBR_KBPS, ABR_KBPS, ABR_KBPS_MIN, ABR_KBPS_MAX)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_OGG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_OGG(integer Mode, number VBR_Quality, integer CBR_KBPS, integer ABR_KBPS, integer ABR_KBPS_MIN, integer ABR_KBPS_MAX)</functioncall>
  <description>
    Returns the render-cfg-string for the OGG-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    For all mode-settings that you don't need(kbps or quality), you can safely set them to 1.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected OGG-settings
  </retvals>
  <parameters>
    integer Mode - the mode for the ogg-file; 0, VBR; 1, CBR; 2, ABR
    number VBR_Quality - the quality for VBR-mode; a floating-value between 0 and 1
    integer CBR_KBPS - the bitrate for CBR-mode; 0 to 2048
    integer ABR_KBPS - the bitrate for ABR-mode; 0 to 2048
    integer ABR_KBPS_MIN - the minimum-bitrate for ABR-mode; 0 to 2048
    integer ABR_KBPS_MAX - the maximum-bitrate for ABR-mode; 0 to 2048
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, ogg</tags>
</US_DocBloc>
]]

--(Mode, VBR_Quality, CBR_KBPS, ABR_KBPS, ABR_KBPS_MIN, ABR_KBPS_MAX)
  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  if reaper.file_exists(ini_file)==false then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "Ooops", "external render-code-ini-file does not exist. Reinstall Ultraschall-API again, please!", -1) return nil end
  if math.type(Mode)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "Kbps", "Must be an integer!", -2) return nil end
  if math.type(VBR_Quality)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "VBR_Quality", "Must be a float!", -3) return nil end
  if math.type(CBR_KBPS)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "CBR_KBPS", "Must be an integer!", -4) return nil end
  if math.type(ABR_KBPS)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS", "Must be an integer!", -5) return nil end
  if math.type(ABR_KBPS_MIN)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS_MIN", "Must be an integer!", -6) return nil end
  if math.type(ABR_KBPS_MAX)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS_MAX", "Must be an integer!", -7) return nil end
  if Mode<0 or Mode>2 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "Mode", "must be between 0 and 2", -8) return nil end
  if VBR_Quality<0 or VBR_Quality>1.0 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "VBR_Quality", "must be a float-value between 0 and 1", -9) return nil end
  if CBR_KBPS<0 or CBR_KBPS>2048 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "CBR_KBPS", "must be between 0 and 2048", -10) return nil end  
  if ABR_KBPS<0 or ABR_KBPS>2048 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS", "must be between 0 and 2048", -11) return nil end  
  if ABR_KBPS_MIN<0 or ABR_KBPS_MIN>2048 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS_MIN", "must be between 0 and 2048", -12) return nil end  
  if ABR_KBPS_MAX<0 or ABR_KBPS_MAX>2048 then ultraschall.AddErrorMessage("CreateRenderCFG_OGG", "ABR_KBPS_MAX", "must be between 0 and 2048", -13) return nil end  

  if Mode==0 then Mode="VBR"
  elseif Mode==1 then Mode="CBR"
  elseif Mode==2 then Mode="ABR"
  end

  local _temp, renderstring, rendermode, rendervbrquality, rendercbrkbps, renderabrkbps, renderabrkbps_min, renderabrkbps_max
  _temp, renderstring=ultraschall.GetIniFileExternalState("OGG", "Renderstring", ini_file)  
  _temp, rendermode=ultraschall.GetIniFileExternalState("OGG", "MODE_"..Mode, ini_file)
  _temp, rendervbrquality=ultraschall.GetIniFileExternalState("OGG", "VBR_quality_"..VBR_Quality+0.0, ini_file)
  _temp, rendercbrkbps=ultraschall.GetIniFileExternalState("OGG", "CBR_KBPS_"..CBR_KBPS, ini_file)
  _temp, renderabrkbps=ultraschall.GetIniFileExternalState("OGG", "ABR_KBPS_"..ABR_KBPS, ini_file)
  _temp, renderabrkbps_min=ultraschall.GetIniFileExternalState("OGG", "ABR_KBPS_MIN_"..ABR_KBPS_MIN, ini_file)
  _temp, renderabrkbps_max=ultraschall.GetIniFileExternalState("OGG", "ABR_KBPS_MAX_"..ABR_KBPS_MAX, ini_file)

  renderstring=string.gsub(renderstring, "%[MODE%]", rendermode)
  renderstring=string.gsub(renderstring, "%[VBR_quality%]", rendervbrquality)
  renderstring=string.gsub(renderstring, "%[CBR_KBPS%]", rendercbrkbps)
  renderstring=string.gsub(renderstring, "%[ABR_KBPS%]", renderabrkbps)
  renderstring=string.gsub(renderstring, "%[ABR_KBPS_MIN%]", renderabrkbps_min)
  renderstring=string.gsub(renderstring, "%[ABR_KBPS_MAX%]", renderabrkbps_max)

  return renderstring
end
--A=ultraschall.CreateRenderCFG_OGG(1,1,3,4,5,600)

function ultraschall.CreateRenderCFG_DDP()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_DDP</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_DDP()</functioncall>
  <description>
    Returns the render-cfg-string for the DDP-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected DDP-settings
  </retvals>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, ddp</tags>
</US_DocBloc>
]]
  return "IHBkZA="
end

--A=ultraschall.CreateRenderCFG_DDP()



function ultraschall.CreateRenderCFG_FLAC(Bitrate, EncSpeed)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_FLAC</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_FLAC(integer Bitrate, integer EncSpeed)</functioncall>
  <description>
    Returns the render-cfg-string for the FLAC-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected FLAC-settings
  </retvals>
  <parameters>
    integer Bitrate - the bitrate of the flac-file; 
                    - 0, 24 bit
                    - 1, 23/24 bit
                    - 2, 22/24 bit
                    - 3, 21/24 bit
                    - 4, 20/24 bit
                    - 5, 19/24 bit
                    - 6, 18/24 bit
                    - 7, 17/24 bit
                    - 8, 16 bit
    integer EncSpeed - the encoding speed; 0(fastest) to 8(slowest); 5(default)
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, flac</tags>
</US_DocBloc>
]]
  if math.type(Bitrate)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_FLAC", "Bitrate", "must be an integer", -1) return nil end
  if math.type(EncSpeed)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_FLAC", "EncSpeed", "must be an integer", -2) return nil end
  if Bitrate<0 or Bitrate>8 then ultraschall.AddErrorMessage("CreateRenderCFG_FLAC", "Bitrate", "must be between 0(24 Bit) and 8(16 Bit)", -3) return nil end
  if EncSpeed<0 or EncSpeed>8 then ultraschall.AddErrorMessage("CreateRenderCFG_FLAC", "EncSpeed", "must be between 0(fastest speed) and 8(slowest speed)", -3) return nil end

  local renderstring="Y2FsZh[BITRATE]AAAA[ENCSPEED]AAAA"
  if Bitrate==0 then Bitrate="g"      -- 24 Bit
  elseif Bitrate==1 then Bitrate="c"  -- 23/24 Bit
  elseif Bitrate==2 then Bitrate="Y"  -- 22/24 Bit
  elseif Bitrate==3 then Bitrate="U"  -- 21/24 Bit
  elseif Bitrate==4 then Bitrate="Q"  -- 20/24 Bit
  elseif Bitrate==5 then Bitrate="M"  -- 19/24 Bit
  elseif Bitrate==6 then Bitrate="I"  -- 18/24 Bit
  elseif Bitrate==7 then Bitrate="E"  -- 17/24 Bit
  elseif Bitrate==8 then Bitrate="A"  -- 16 Bit  
  end
  
  if EncSpeed==0 then EncSpeed="A"     -- 0 - fastest
  elseif EncSpeed==1 then EncSpeed="B" -- 1
  elseif EncSpeed==2 then EncSpeed="C" -- 2
  elseif EncSpeed==3 then EncSpeed="D" -- 3
  elseif EncSpeed==4 then EncSpeed="E" -- 4
  elseif EncSpeed==5 then EncSpeed="F" -- 5 - default setting
  elseif EncSpeed==6 then EncSpeed="G" -- 6
  elseif EncSpeed==7 then EncSpeed="H" -- 7
  elseif EncSpeed==8 then EncSpeed="I" -- 8 - slowest speed
  end
  
  renderstring=string.gsub(renderstring, "%[BITRATE%]", Bitrate)
  renderstring=string.gsub(renderstring, "%[ENCSPEED%]", EncSpeed)
  return renderstring
end

--A=ultraschall.CreateRenderCFG_FLAC(1,1)

function ultraschall.CreateRenderCFG_WAVPACK(Mode, Bitdepth, Writemarkers, WriteBWFChunk, IncludeFilenameBWF)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_WAVPACK</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_WAVPACK(integer Mode, integer Bitdepth, integer Writemarkers, boolean WriteBWFChunk, boolean IncludeFilenameBWF)</functioncall>
  <description>
    Returns the render-cfg-string for the WAVPACK-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected WAVPACK-settings
  </retvals>
  <parameters>
    integer Mode - 0, Normal; 1, Fast; 2, High; 3, Very High(slowest)
    integer Bitdepth - the bitdepth of the WAVPACK-file
                     -   0(16Bit)
                     -   1(24Bit)
                     -   2(32Bit integer)
                     -   3(32Bit floating point)
                     -   4(23/24 Bit)
                     -   5(22/24 Bit)
                     -   6(21/24 Bit)
                     -   7(20/24 Bit)
                     -   8(19/24 Bit)
                     -   9(18/24 Bit)
                     -   10(17/24 Bit)
                     -   11(32 bit floating point -144dB floor)
                     -   12(32 bit floating point -120dB floor)
                     -   13(32 bit floating point -96dB floor)
    integer Writemarkers - Write markers as cues-checkboxes
                         - 0, nothing checked
                         - 1, Write markers as cues->checked
                         - 2, Write markers as cues and Only write markers starting with #->checked
    boolean WriteBWFChunk - the Write BWF chunk-checkbox; true, checked; false, unchecked
    boolean IncludeFilenameBWF - the include project filename in BWF data-checkbox; true, checked; false, unchecked
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, wavpack</tags>
</US_DocBloc>
]]
  if math.type(Mode)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Mode", "must be an integer", -1) return nil end
  if math.type(Bitdepth)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Bitdepth", "must be an integer", -2) return nil end
  if math.type(Writemarkers)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Writemarkers", "must be an integer", -3) return nil end
  if type(WriteBWFChunk)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "WriteBWFChunk", "must be a boolean", -4) return nil end
  if type(IncludeFilenameBWF)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "IncludeFilenameBWF", "must be a boolean", -5) return nil end
  
  if Mode<0 or Mode>3 then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Mode", "must be between 0(Normal) and 3(Very High - slowest)", -6) return nil end
  if Bitdepth<0 or Bitdepth>13 then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Bitdepth", "must be between 0 and 13", -7) return nil end
  if Writemarkers<0 or Writemarkers>2 then ultraschall.AddErrorMessage("CreateRenderCFG_WAVPACK", "Writemarkers", "must be between 0 and 2", -8) return nil end


  local renderstring="a3B2dw[MODE]AAAA[BITDEPTH]AAAAA[WRITEMARKERS]AAAA[BWFCHUNK]AAAA="
  local BWFCHUNK
  if Mode==0 then Mode="A"      -- Normal
  elseif Mode==1 then Mode="E"  -- Fast
  elseif Mode==2 then Mode="M"  -- High
  elseif Mode==3 then Mode="Q"  -- Very High (slowest)
  end
  
  if Bitdepth==0 then Bitdepth="A"      -- 16 Bit
  elseif Bitdepth==1 then Bitdepth="B"  -- 24 Bit
  elseif Bitdepth==2 then Bitdepth="C"  -- 32 Bit integer
  elseif Bitdepth==3 then Bitdepth="D"  -- 32 Bit floating point
  elseif Bitdepth==4 then Bitdepth="E"  -- 23/24 Bit
  elseif Bitdepth==5 then Bitdepth="F"  -- 22/24 Bit
  elseif Bitdepth==6 then Bitdepth="G"  -- 21/24 Bit
  elseif Bitdepth==7 then Bitdepth="H"  -- 20/24 Bit
  elseif Bitdepth==8 then Bitdepth="I"  -- 19/24 Bit
  elseif Bitdepth==9 then Bitdepth="J"  -- 18/24 Bit
  elseif Bitdepth==10 then Bitdepth="K" -- 17/24 Bit
  elseif Bitdepth==11 then Bitdepth="L" -- 32 Bit floating point - -144dB floor
  elseif Bitdepth==12 then Bitdepth="M" -- 32 Bit floating point - -120dB floor
  elseif Bitdepth==13 then Bitdepth="N" -- 32 Bit floating point - -96dB floor
  end
  
  if Writemarkers==0 then Writemarkers="A"     -- nothing checked
  elseif Writemarkers==1 then Writemarkers="g" -- Write markers as cues->checked
  elseif Writemarkers==2 then Writemarkers="Q" -- Write markers as cues and Only write markers starting with #->checked
  end

  if WriteBWFChunk==false and IncludeFilenameBWF==false then BWFCHUNK="A"     -- nothing checked
  elseif WriteBWFChunk==true and IncludeFilenameBWF==false then BWFCHUNK="E"  -- Only write BWF-chunk
  elseif WriteBWFChunk==false and IncludeFilenameBWF==true then BWFCHUNK="I"  -- Only include project-filename in BWF-data
  elseif WriteBWFChunk==true and IncludeFilenameBWF==true then BWFCHUNK="M"   -- Write BWF-chunk and Include project filename in BWF data
  end
  
  renderstring=string.gsub(renderstring, "%[MODE%]", Mode)
  renderstring=string.gsub(renderstring, "%[BITDEPTH%]", Bitdepth)
  renderstring=string.gsub(renderstring, "%[WRITEMARKERS%]", Writemarkers)
  renderstring=string.gsub(renderstring, "%[BWFCHUNK%]", BWFCHUNK)
  
  return renderstring
end

--A=ultraschall.CreateRenderCFG_WAVPACK(0, 0, 2, true, true)

function ultraschall.CreateRenderCFG_WebMVideo(VIDKBPS, AUDKBPS, WIDTH, HEIGHT, FPS, AspectRatio)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_WebMVideo</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_WebMVideo(integer VIDKBPS, integer AUDKBPS, integer WIDTH, integer HEIGHT, integer FPS, boolean AspectRatio)</functioncall>
  <description>
    Returns the render-cfg-string for the WebM-Video-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected WebM-Video-settings
  </retvals>
  <parameters>
    integer VIDKBPS - the video-bitrate of the video in kbps; 1 to 18571
    integer AUDKBPS - the audio-bitrate of the video in kbps; 1 to 18571
    integer WIDTH - the width of the video in pixels; 1 to 18571
    integer HEIGHT - the height of the video in pixels; 1 to 18571
    integer FPS - the fps of the video; must be a double-precision-float value (9.09 or 25.00)
    boolean AspectRatio - the aspect-ratio; true, keep source aspect ratio; false, don't keep source aspect ratio
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, webm</tags>
</US_DocBloc>
]]
  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  if reaper.file_exists(ini_file)==false then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "Ooops", "external render-code-ini-file does not exist. Reinstall Ultraschall-API again, please!", -1) return nil end
  if math.type(VIDKBPS)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "VIDKBPS", "Must be an integer!", -2) return nil end
  if math.type(AUDKBPS)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "AUDKBPS", "Must be an integer!", -3) return nil end
  if math.type(WIDTH)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "WIDTH", "Must be an integer!", -4) return nil end
  if math.type(HEIGHT)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "HEIGHT", "Must be an integer!", -5) return nil end
  if type(FPS)~="number" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "FPS", "Must be a float-value with two digit precision (e.g. 29.97 or 25.00)!", -6) return nil end
  if type(AspectRatio)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "AspectRatio", "Must be a boolean!", -7) return nil end
  if VIDKBPS<1 or VIDKBPS>18571 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "VIDKBPS", "Ultraschall-API supports only kbps-values between 1 and 18571, sorry.", -8) return nil end
  if AUDKBPS<1 or AUDKBPS>18571 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "AUDKBPS", "Ultraschall-API supports only kbps-values between 1 and 18571, sorry.", -9) return nil end
  if WIDTH<1 or WIDTH>18571 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "WIDTH", "Ultraschall-API supports only width-values between 1 and 18571, sorry.", -10) return nil end
  if HEIGHT<1 or HEIGHT>18571 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "HEIGHT", "Ultraschall-API supports only height-values between 1 and 18571, sorry.", -11) return nil end
  if FPS<0.1 or FPS>150.5 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "FPS", "Ultraschall-API supports only fps-values between 1 and 150.5, sorry.", -12) return nil end

  
  local VideoContainer="Y"
  local VideoFormat="A"
  local AudioFormat="A"
  local MJPEG="AE"
 
  local _temp, renderstring=ultraschall.GetIniFileExternalState("VIDEO", "Renderstring", ini_file)  
  local _temp, rendervidkbps=ultraschall.GetIniFileExternalState("VIDEO", "WEBM_VID_KBPS_"..VIDKBPS, ini_file)
  local _temp, renderaudkbps=ultraschall.GetIniFileExternalState("VIDEO", "WEBM_AUDKBPS_"..AUDKBPS, ini_file)
  local _temp, renderwidth=ultraschall.GetIniFileExternalState("VIDEO", "WIDTH_"..WIDTH, ini_file)
  local _temp, renderheight=ultraschall.GetIniFileExternalState("VIDEO", "HEIGHT_"..HEIGHT, ini_file)
  local _temp, renderfps=ultraschall.GetIniFileExternalState("VIDEO", "FPS_"..FPS+0.00, ini_file)
  local _temp, renderaspect=ultraschall.GetIniFileExternalState("VIDEO", "ASPECT_RATIO_"..tostring(AspectRatio):upper(), ini_file)

  renderstring=string.gsub(renderstring, "%[VideoContainer%]", VideoContainer)
  renderstring=string.gsub(renderstring, "%[VideoFormat%]", VideoFormat)
  renderstring=string.gsub(renderstring, "%[AudioFormat%]", AudioFormat)
  renderstring=string.gsub(renderstring, "%[MJPEG%]", MJPEG)
  renderstring=string.gsub(renderstring, "%[WEBM_VID_KBPS%]", rendervidkbps)
  renderstring=string.gsub(renderstring, "%[WEBM_AUDKBPS%]", renderaudkbps)
  renderstring=string.gsub(renderstring, "%[WIDTH%]", renderwidth)
  renderstring=string.gsub(renderstring, "%[HEIGHT%]", renderheight)
  renderstring=string.gsub(renderstring, "%[FPS%]", renderfps)
  renderstring=string.gsub(renderstring, "%[ASPECT_RATIO%]", renderaspect)
  
  if renderstring:len()~=60 then ultraschall.AddErrorMessage("CreateRenderCFG_WebMVideo", "FPS", "Must be a float-value with two digit precision (e.g. 29.97 or 25.00)!", -6) return nil end
  return renderstring
end


--A=ultraschall.CreateRenderCFG_WebM(21, 22, 23, 24, 11.99, true)

--reaper.CF_SetClipboard(A)
--reaper.MB(tostring(A),"",0)

function ultraschall.SaveProjectAs(projectfilename_with_path, createsubdir, copy_media, move_media, overwrite, reload)
-- BUGGY!! Can't find it's mediafiles, when project is stored in different folder and is reloaded. 
--         Probably due an relative-path-problem
--         Maybe, I need to work with an additional function SourceFileArray=GetAllMediaSourceFiles(), in which I 
--         replace all old paths with new ones, corresponding to the new path, OR:
--         I use it, to recreate the folder-structure, copying the files to the new location, OR:
--         both(probably the best idea)

-- parameters: boolean createsubdir - true, like the Create subdirectory for project-checkbox
--             boolean copy_media - true, like the copy all media into project directory
--             integer move_media - 0, don't move; 1, move all media into projdir; 2, copy, rather than move source-media if not in old project media path-checkboxes
--             
--[[
<//ApiDocBlocFunc>
  <slug>SaveProjectAs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SaveProjectAs(string projectfilename_with_path, boolean overwrite, boolean reload)</functioncall>
  <description>
    Saves a project under a given name.
    
    Returns -1 in case of an error
  </description>
  <retvals>
    integer retval - 1, in case of success; -1, in case of error
  </retvals>
  <parameters>
    string projectfilename_with_path - the new projectfilename under which you want to save it, including path
    boolean overwrite - true, overwrites an existing file; false, does not overwrite an existing file
    boolean reload - true, reload the project under the new name; false, keep the old project opened
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, save, saveas</tags>
<//ApiDocBlocFunc>
]]
  if type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("SaveProjectAs", "projectfilename_with_path", "Must be a string.", -1) return -1 end
  if type(overwrite)~="boolean" then ultraschall.AddErrorMessage("SaveProjectAs", "overwrite", "Must be a boolean.", -2) return -1 end
  if type(reload)~="boolean" then ultraschall.AddErrorMessage("SaveProjectAs", "reload", "Must be a boolean.", -3) return -1 end
  if overwrite==false and reaper.file_exists(projectfilename_with_path)==true then ultraschall.AddErrorMessage("SaveProjectAs", "projectfilename_with_path", "File already exists", -4) return -1 end
  local A,B=reaper.EnumProjects(-1,"")
  local RPPTempfilename = ultraschall.CreateValidTempFile(projectfilename_with_path, true, "", true)
  if RPPTempfilename==nil then ultraschall.AddErrorMessage("SaveProjectAs", "projectfilename_with_path", "Can't create file.", -5) return -1 end
  local Tempfilename = ultraschall.CreateValidTempFile(B, false, "", true)
--reaper.MB(Tempfilename,B,0)
  os.remove(RPPTempfilename)
  os.rename(B, Tempfilename)
  reaper.Main_SaveProject(0,false)
  os.rename(B, projectfilename_with_path)
  os.rename(Tempfilename, B)
  os.remove(Tempfilename)
  if reload==true and B~=projectfilename_with_path then
    reaper.Main_OnCommand(40023,0)
    reaper.Main_openProject(projectfilename_with_path)
  end
  return 1  
end

--O=ultraschall.SaveProjectAs("c:\\temp/Achgotterl999836874668.rpp", true, true)

function ultraschall.ChangePathInSource(PCM_source, NewPath)
  local Filenamebuf = reaper.GetMediaSourceFileName(PCM_source, "")
  local filename=Filenamebuf:match(".*/(.*)")
  if filename==nil then filename=Filenamebuf:match(".*\\(.*)") end
  filename=NewPath.."/"..filename
  return reaper.PCM_Source_CreateFromFile(filename)
end

--NewSource=ultraschall.ChangePathInSource(reaper.GetMediaItemTake_Source(reaper.GetMediaItemTake(reaper.GetMediaItem(0,0),0)), "c:\\temp")

function ultraschall.GetAllMediaItems()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllMediaItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer itemcount, MediaItemArray MediaItemArray = ultraschall.GetAllMediaItems()</functioncall>
  <description>
    Returns a MediaItemArray with all MediaItems in the current project
  </description>
  <retvals>
    integer itemcount - the number of items in the MediaItemArray
    MediaItemArray MediaItemArray - an array with all MediaItems from the current project
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItems
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, all, mediaitems, mediaitemarray</tags>
</US_DocBloc>
--]]
  local MediaItemArray={}
  for i=0, reaper.CountMediaItems(0) do
    MediaItemArray[i+1]=reaper.GetMediaItem(0,i)
  end
  return reaper.CountMediaItems(0), MediaItemArray
end


--A,B=ultraschall.GetAllMediaItems()

function ultraschall.CreateRenderCFG_MP3MaxQuality()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_MP3MaxQuality</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_MP3MaxQuality()</functioncall>
  <description>
    Returns the render-cfg-string for the MP3-format with highest quality-settings. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
  </description>
  <retvals>
    string render_cfg_string - the renderstring for MP3 with maximum quality
  </retvals>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, mp3 high quality, mp3</tags>
</US_DocBloc>
]]
  return "bDNwbUABAAABAAAACgAAAP////8EAAAAQAEAAAAAAAA="
end


function ultraschall.CreateRenderCFG_MP3VBR(quality, encoding_speed)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_MP3VBR</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_MP3VBR(integer quality, integer encoding_speed)</functioncall>
  <description>
    Returns the render-cfg-string for the MP3-format with variable bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected MP3-VBR-settings
  </retvals>
  <parameters>
    integer quality - the variable-bitrate quality; 1(for 10%) to 10(for 100%)
    integer encoding_speed - the encoding speed for the mp3
                           - 0, Maximum
                           - 1, Better
                           - 2, Normal
                           - 3, FastEncode
                           - 4, FastestEncode
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, mp3 vbr, mp3</tags>
</US_DocBloc>
]]
  if math.type(quality)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3VBR", "quality", "Must be an integer.", -1) return nil end
  if math.type(encoding_speed)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3VBR", "encoding_speed", "Must be an integer.", -2) return nil end
  if quality<1 or quality>10 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3VBR", "quality", "Must be between 1 and 10.", -3) return nil end
  if encoding_speed<0 or encoding_speed>4 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3VBR", "encoding_speed", "Must be between 0 and 4.", -3) return nil end
  
  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  
  if encoding_speed==0 then encoding_speed="Maximum"
  elseif encoding_speed==1 then encoding_speed="Better"
  elseif encoding_speed==2 then encoding_speed="Normal"
  elseif encoding_speed==3 then encoding_speed="FastEncode"
  elseif encoding_speed==4 then encoding_speed="FastestEncode"
  end
  
  local _temp, renderstring=ultraschall.GetIniFileExternalState("MP3", "VBR", ini_file)
  local _temp, vbrquality=ultraschall.GetIniFileExternalState("MP3", "VBRQUALITY_"..quality*10, ini_file)
  local _temp, encspeed=ultraschall.GetIniFileExternalState("MP3", "ENCSPEED_"..encoding_speed, ini_file)
  
  renderstring=string.gsub(renderstring, "%[ENCSPEED%]", encspeed)
  renderstring=string.gsub(renderstring, "%[VBRQUALITY%]", vbrquality)
  
  return renderstring
end

--A=ultraschall.CreateRenderCFG_MP3VBR(1, 0)


function ultraschall.CreateRenderCFG_MP3ABR(quality, encoding_speed)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_MP3ABR</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_MP3ABR(integer quality, integer encoding_speed)</functioncall>
  <description>
    Returns the render-cfg-string for the MP3-format with average bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected MP3-ABR-settings
  </retvals>
  <parameters>
    integer quality - the encoding quality for the mp3
                    - 0, 8 kbps
                    - 1, 16 kbps
                    - 2, 24 kbps
                    - 3, 32 kbps
                    - 4, 40 kbps
                    - 5, 48 kbps
                    - 6, 56 kbps
                    - 7, 64 kbps
                    - 8, 80 kbps
                    - 9, 96 kbps
                    - 10, 112 kbps
                    - 11, 128 kbps
                    - 12, 160 kbps
                    - 13, 192 kbps
                    - 14, 224 kbps
                    - 15, 256 kbps
                    - 16, 320 kbps
    integer encoding_speed - the encoding speed for the mp3
                           - 0, Maximum
                           - 1, Better
                           - 2, Normal
                           - 3, FastEncode
                           - 4, FastestEncode
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, mp3 abr, mp3</tags>
</US_DocBloc>
]]
  if math.type(quality)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3ABR", "quality", "Must be an integer.", -1) return nil end
  if math.type(encoding_speed)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3ABR", "encoding_speed", "Must be an integer.", -2) return nil end
  if quality<0 or quality>16 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3ABR", "quality", "Must be between 1 and 16.", -3) return nil end
  if encoding_speed<0 or encoding_speed>4 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3ABR", "encoding_speed", "Must be between 0 and 4.", -3) return nil end

  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  
  if encoding_speed==0 then encoding_speed="Maximum"
  elseif encoding_speed==1 then encoding_speed="Better"
  elseif encoding_speed==2 then encoding_speed="Normal"
  elseif encoding_speed==3 then encoding_speed="FastEncode"
  elseif encoding_speed==4 then encoding_speed="FastestEncode"
  end
  
  if quality==0 then quality=8
  elseif quality==1 then quality=16
  elseif quality==2 then quality=24
  elseif quality==3 then quality=32
  elseif quality==4 then quality=40
  elseif quality==5 then quality=48
  elseif quality==6 then quality=56
  elseif quality==7 then quality=64
  elseif quality==8 then quality=80
  elseif quality==9 then quality=96
  elseif quality==10 then quality=112
  elseif quality==11 then quality=128
  elseif quality==12 then quality=160
  elseif quality==13 then quality=192
  elseif quality==14 then quality=224
  elseif quality==15 then quality=256
  elseif quality==16 then quality=320
  end
  
  local _temp, renderstring=ultraschall.GetIniFileExternalState("MP3", "ABR", ini_file)
  local _temp, abrquality=ultraschall.GetIniFileExternalState("MP3", "KBPS_ABR_"..quality, ini_file)
  local _temp, encspeed=ultraschall.GetIniFileExternalState("MP3", "ENCSPEED_"..encoding_speed, ini_file)
  
  renderstring=string.gsub(renderstring, "%[ENCSPEED%]", encspeed)
  renderstring=string.gsub(renderstring, "%[KBPS_ABR%]", abrquality)
  
  return renderstring
end

--A=ultraschall.CreateRenderCFG_MP3ABR(1, 0)

function ultraschall.CreateRenderCFG_MP3CBR(quality, encoding_speed)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_MP3CBR</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_MP3CBR(integer quality, integer encoding_speed)</functioncall>
  <description>
    Returns the render-cfg-string for the MP3-format with constant bitrate. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected MP3-CBR-settings
  </retvals>
  <parameters>
    integer quality - the encoding quality for the mp3
                    - 0, 8 kbps
                    - 1, 16 kbps
                    - 2, 24 kbps
                    - 3, 32 kbps
                    - 4, 40 kbps
                    - 5, 48 kbps
                    - 6, 56 kbps
                    - 7, 64 kbps
                    - 8, 80 kbps
                    - 9, 96 kbps
                    - 10, 112 kbps
                    - 11, 128 kbps
                    - 12, 160 kbps
                    - 13, 192 kbps
                    - 14, 224 kbps
                    - 15, 256 kbps
                    - 16, 320 kbps
    integer encoding_speed - the encoding speed for the mp3
                           - 0, Maximum
                           - 1, Better
                           - 2, Normal
                           - 3, FastEncode
                           - 4, FastestEncode
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, mp3 cbr, mp3</tags>
</US_DocBloc>
]]
  if math.type(quality)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3CBR", "quality", "Must be an integer.", -1) return nil end
  if math.type(encoding_speed)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_MP3CBR", "encoding_speed", "Must be an integer.", -2) return nil end
  if quality<0 or quality>16 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3CBR", "quality", "Must be between 1 and 16.", -3) return nil end
  if encoding_speed<0 or encoding_speed>4 then ultraschall.AddErrorMessage("CreateRenderCFG_MP3CBR", "encoding_speed", "Must be between 0 and 4.", -3) return nil end

  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes.ini"
  
  if encoding_speed==0 then encoding_speed="Maximum"
  elseif encoding_speed==1 then encoding_speed="Better"
  elseif encoding_speed==2 then encoding_speed="Normal"
  elseif encoding_speed==3 then encoding_speed="FastEncode"
  elseif encoding_speed==4 then encoding_speed="FastestEncode"
  end
  
  if quality==0 then quality=8
  elseif quality==1 then quality=16
  elseif quality==2 then quality=24
  elseif quality==3 then quality=32
  elseif quality==4 then quality=40
  elseif quality==5 then quality=48
  elseif quality==6 then quality=56
  elseif quality==7 then quality=64
  elseif quality==8 then quality=80
  elseif quality==9 then quality=96
  elseif quality==10 then quality=112
  elseif quality==11 then quality=128
  elseif quality==12 then quality=160
  elseif quality==13 then quality=192
  elseif quality==14 then quality=224
  elseif quality==15 then quality=256
  elseif quality==16 then quality=320
  end
  
  local _temp, renderstring=ultraschall.GetIniFileExternalState("MP3", "CBR", ini_file)
  local _temp, cbrquality=ultraschall.GetIniFileExternalState("MP3", "KBPS_CBR_"..quality, ini_file)
  local _temp, cbr2quality=ultraschall.GetIniFileExternalState("MP3", "KBPS_CBR2_"..quality, ini_file)
  local _temp, encspeed=ultraschall.GetIniFileExternalState("MP3", "ENCSPEED_"..encoding_speed, ini_file)
  
  renderstring=string.gsub(renderstring, "%[ENCSPEED%]", encspeed)
  renderstring=string.gsub(renderstring, "%[KBPS_CBR%]", cbrquality)
  renderstring=string.gsub(renderstring, "%[KBPS_CBR2%]", cbr2quality)
  
  return renderstring
end
--A=ultraschall.CreateRenderCFG_MP3CBR(1, 1)


function ultraschall.CreateRenderCFG_WAV(BitDepth, LargeFiles, BWFChunk, IncludeMarkers, EmbedProjectTempo)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_WAV</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_WAV(integer BitDepth, integer LargeFiles, integer BWFChunk, integer IncludeMarkers, boolean EmbedProjectTempo)</functioncall>
  <description>
    Returns the render-cfg-string for the WAV-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected WAV-settings
  </retvals>
  <parameters>
    integer BitDepth - the bitdepth of the WAV-file
                     - 0, 8 Bit PCM
                     - 1, 16 Bit PCM
                     - 2, 24 Bit PCM
                     - 3, 32 Bit FP
                     - 4, 64 Bit FP
                     - 5, 4 Bit IMA ADPCM
                     - 6, 2 Bit cADPCM
    integer LargeFiles - how shall Reaper treat large WAV-files
                       - 0, Auto WAV/Wave64
                       - 1, Auto Wav/RF64
                       - 2, Force WAV
                       - 3, Force Wave64
                       - 4, Force RF64
    integer BWFChunk - Write BWF ('bext') chunk and Include project filename in BWF data - checkboxes
                     - 0, unchecked - unchecked
                     - 1, checked - unchecked
                     - 2, unchecked - checked
                     - 3, checked - checked
    integer IncludeMarkers - The include markerlist-dropdownlist
                           - 0, Do not include markers and regions
                           - 1, Markers + regions
                           - 2, Markers + regions starting with #
                           - 3, Markers only
                           - 4, Markers starting with # only
                           - 5, Regions only
                           - 6, Regions starting with # only
    boolean EmbedProjectTempo - Embed project tempo (use with care)-checkbox; true, checked; false, unchecked
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, wav</tags>
</US_DocBloc>
]]
  if math.type(BitDepth)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "BitDepth", "Must be an integer.", -1) return nil end
  if math.type(LargeFiles)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "LargeFiles", "Must be an integer.", -2) return nil end
  if math.type(BWFChunk)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "BWFChunk", "Must be an integer.", -3) return nil end
  if math.type(IncludeMarkers)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "IncludeMarkers", "Must be an integer.", -4) return nil end
  if type(EmbedProjectTempo)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "EmbedProjectTempo", "Must be a boolean.", -5) return nil end
  
  if BitDepth<0 or BitDepth>6 then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "Bitdepth", "Must be between 0 and 6.", -6) return nil end
  if LargeFiles<0 or LargeFiles>4 then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "LargeFiles", "Must be between 0 and 4.", -7) return nil end
  if BWFChunk<0 or BWFChunk>3 then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "BWFChunk", "Must be between 0 and 3.", -8) return nil end
  if IncludeMarkers<0 or IncludeMarkers>6 then ultraschall.AddErrorMessage("CreateRenderCFG_WAV", "IncludeMarkers", "Must be between 0 and 6.", -9) return nil end

  -- Header
  local WavHeader="ZXZhd"
  local A0, A, B, C
  
  -- Bitdepth
  if BitDepth==0 then BitDepth="w" A0="g"     -- 8 Bit PCM
  elseif BitDepth==1 then BitDepth="x" A0="A" -- 16 Bit PCM
  elseif BitDepth==2 then BitDepth="x" A0="g" -- 24 Bit PCM
  elseif BitDepth==3 then BitDepth="y" A0="A" -- 32 Bit FP
  elseif BitDepth==4 then BitDepth="0" A0="A" -- 64 Bit FP
  elseif BitDepth==5 then BitDepth="w" A0="Q" -- 4 Bit IMA ADPCM
  elseif BitDepth==6 then BitDepth="w" A0="I" -- 2 Bit cADPCM
  else return nil 
  end
  
  -- Large Files  
  if LargeFiles==0 then A="B" B="A" C="A"     -- Auto WAV/Wave64
  elseif LargeFiles==1 then A="B" B="A" C="Q" -- Auto Wav/RF64
  elseif LargeFiles==2 then A="D" B="A" C="A" -- Force WAV
  elseif LargeFiles==3 then A="B" B="A" C="g" -- Force Wave64
  elseif LargeFiles==4 then A="B" B="A" C="w" -- Force RF64
  else return nil
  end
  
  -- Write BWF ('bext') chunk and Include project filename in BWF data - checkboxes
  if BWFChunk==0 then        -- unchecked unchecked
  elseif BWFChunk==1 then A=ultraschall.AddIntToChar(A, -1)   -- checked unchecked
  elseif BWFChunk==2 then A=ultraschall.AddIntToChar(A, 4)   -- unchecked checked
  elseif BWFChunk==3 then A=ultraschall.AddIntToChar(A, -1+4)   -- checked checked
  end
  
  -- The include markerlist-dropdownlist
  if IncludeMarkers==0 then                                       -- Do not include markers or regions
  elseif IncludeMarkers==1 then A=ultraschall.AddIntToChar(A, 8)    -- Markers + regions
  elseif IncludeMarkers==2 then A=ultraschall.AddIntToChar(A, 30)   -- Markers + regions starting with #
  elseif IncludeMarkers==3 then A0=ultraschall.AddIntToChar(A0, 1) A=ultraschall.AddIntToChar(A, 8) -- Markers only 
  elseif IncludeMarkers==4 then A0=ultraschall.AddIntToChar(A0, 1) A=ultraschall.AddIntToChar(A, 30) -- Markers starting with # only 
  elseif IncludeMarkers==5 then A0=ultraschall.AddIntToChar(A0, 2) A=ultraschall.AddIntToChar(A, 8) -- Regions only 
  elseif IncludeMarkers==6 then A0=ultraschall.AddIntToChar(A0, 2) A=ultraschall.AddIntToChar(A, 30) -- Regions starting with # only 
  end  
  
  -- The Embed project tempo (use with care) - checkbox
  -- Depending on the chosen setting in IncludeMarkers, you must either add 38 or subtract 43 from value A!
  -- This is for all options that have "starting with #" in them.
  -- Yes, it's confusing....
  if EmbedProjectTempo==true and IncludeMarkers<2 then A=ultraschall.AddIntToChar(A, 38)
  elseif EmbedProjectTempo==true and IncludeMarkers==2 then A=ultraschall.AddIntToChar(A, -43) 
  elseif EmbedProjectTempo==true and IncludeMarkers==3 then A=ultraschall.AddIntToChar(A, 38)
  elseif EmbedProjectTempo==true and IncludeMarkers==4 then A=ultraschall.AddIntToChar(A, -43)
  elseif EmbedProjectTempo==true and IncludeMarkers==5 then A=ultraschall.AddIntToChar(A, 38)
  elseif EmbedProjectTempo==true and IncludeMarkers==6 then A=ultraschall.AddIntToChar(A, -43)
  end
  
  local WavEnder="=="
  return WavHeader..BitDepth..A0..A..B..C..WavEnder  
end
-- -----..----- Wav bit depth: wg(8 bit PCM), xA(16 bit PCM), xg(24 bit PCM), yA(32 bit FP), 
--                             0A(64 bit FP), wQ(4 bit IMA ADPCM), wI(2 bit cADPCM)
--CreateRenderCFG_WAV(BitDepth, LargeFiles, BWFChunk, IncludeMarkers, EmbedProjectTempo)
--reaper.Main_SaveProject(0,false)
--ALABAMA_Function=ultraschall.CreateRenderCFG_WAV(0,0,0,0,true)
--ALABAMA_Project=ultraschall.GetProject_RenderCFG("c:\\rendercode-project.rpp")
--if ALABAMA_Function~=ALABAMA_Project then ALABAM_33="UNGLEICH!" end
--reaper.CF_SetClipboard(ALABAMA)

--retval, count, retMediaItemStateChunkArray = ultraschall.IsValidMediaItemStateChunkArray(MediaItemStateChunkArray)


function ultraschall.DirectoryExists(path, directory)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DirectoryExists</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DirectoryExists(string path, string directory)</functioncall>
  <description>
    Checks, if a directory exists in path.
    
    On Linux: path and directory are case-sensitive!
    
    Returns false in case of error.
  </description>
  <retvals>
    boolean retval - true, directory exists; false, directory does not exist
  </retvals>
  <parameters>
    string path - the path, in which to look for the existence of parameter directory
    string directory - the name of the directory to check for in path
  </parameters>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, directory, check, exists</tags>
</US_DocBloc>
]]
  if type(path)~="string" then ultraschall.AddErrorMessage("DirectoryExists", "path", "Must be a string", -1) return false end
  if type(directory)~="string" then ultraschall.AddErrorMessage("DirectoryExists", "directory", "Must be a string", -2) return false end
  local index=0
  local found=false
  if ultraschall.IsOS_Other()==false then path=path:lower() directory=directory:lower() end
  while reaper.EnumerateSubdirectories(path,index)~=nil do
--  reaper.ShowConsoleMsg(reaper.EnumerateSubdirectories(path, index).."\n")
    if reaper.EnumerateSubdirectories(path, index):lower()==directory then found=true break end
    index=index+1
  end
  return found
end

--L=ultraschall.DirectoryExists("c:/windows/", "system32")
--L=ultraschall.DirectoryExists("", "")



--A=ultraschall.CreateRenderCFG_MP3CBR(1, 4, 10)
--B=ultraschall.CreateRenderCFG_MP3CBR(1, 10, 10)
--L=ultraschall.RenderProject_RenderCFG(nil, "c:\\Reaper-Internal-Docs.mp3", 0, 10, false, true, true,A)
--L=reaper.IsProjectDirty(0)
  

  

function ultraschall.AddIntToChar(char, int)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddIntToChar</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string new_character = ultraschall.AddIntToChar(string character, integer int)</functioncall>
  <description>
    Adds/subtracts int to/from the numeric representation of character. It will return the new character.
    It will not(!) include "overflows" into the adding/subtraction. That said, if you want to add a value resulting in a character above ASCII-code 255, it will fail!
    
    Returns nil in case of an error
  </description>
  <retvals>
    string new_character - the new character, after parameter int has been added/subtracted from/to character
  </retvals>
  <parameters>
    string character - the character, onto which you want to add/subtract parameter int; only single character allowed
    integer int - the value, that you want to add to the numerical representation of parameter character
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, add, character, value</tags>
</US_DocBloc>
]]
  if type(char)~="string" then ultraschall.AddErrorMessage("AddIntToChar", "char", "must be a string with one character" , -1) return nil end
  if char:len()~=1 then ultraschall.AddErrorMessage("AddIntToChar", "char", "must be a string with one character" , -2) return nil end
  if math.type(int)~="integer" then ultraschall.AddErrorMessage("AddIntToChar", "int", "must be an integer" , -3) return nil end
  if string.byte(char)+int>255 or string.byte(char)+int<0 then ultraschall.AddErrorMessage("AddIntToChar", "char + int", "calculated value is out of range of ASCII" , -4) return nil end
  local charcode=string.byte(char)
  local newchar=string.char(charcode+int)
  return newchar
end

--A,B=ultraschall.AddIntToChar("A", 191)

function ultraschall.PreviewMediaItem(MediaItem, Previewtype)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>PreviewMediaItem</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.PreviewMediaItem(MediaItem MediaItem, integer Previewtype)</functioncall>
  <description>
    Will play a preview a given MediaItem.
    You can just play one preview at a time, except when previewing additionally through the MediaExplorer.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - false, in case of error; true, in case of success
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, of which you want to play a preview
    integer Previewtype - the type of the preview
                        - 0, Preview the MediaItem in the Media Explorer
                        - 1, Preview the MediaItem
                        - 2, Preview the MediaItem at track fader volume of the track, in which it lies
                        - 3, Preview the MediaItem through the track, in which it lies(including FX-settings)
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, preview, audio, mediaitem, track, mediaexplorer</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0,MediaItem,"MediaItem*")==false then ultraschall.AddErrorMessage("PreviewMediaItem", "MediaItem", "Must be a valid MediaItem.", -1) return false end
  if math.type(Previewtype)~="integer" then ultraschall.AddErrorMessage("PreviewMediaItem", "Previewtype", "Must be an integer.", -2) return false end
  if Previewtype<0 or Previewtype>3 then ultraschall.AddErrorMessage("PreviewMediaItem", "Previewtype", "Must be between 0 and 3.", -3) return false end
  if Previewtype==0 then Previewtype=41623 -- Media explorer: Preview media item source media
  elseif Previewtype==1 then Previewtype="_XENAKIOS_ITEMASPCM1" -- Xenakios/SWS: Preview selected media item
  elseif Previewtype==2 then Previewtype="_SWS_PREVIEWFADER" -- Xenakios/SWS: Preview selected media item at track fader volume
  elseif Previewtype==3 then Previewtype="_SWS_PREVIEWTRACK" -- Xenakios/SWS: Preview selected media item through track
  end
  
  return ultraschall.ApplyActionToMediaItem(MediaItem, Previewtype, 1, false) 
end

--MediaItem1=reaper.GetMediaItem(0,0)
--ultraschall.PreviewMediaItem(MediaItem1, 0)

function ultraschall.StopAnyPreview()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>StopAnyPreview</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>ultraschall.StopAnyPreview()</functioncall>
  <description>
    Stops any playing preview of a MediaItem.
  </description>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, stop, preview, audio, mediaitem, track, mediaexplorer</tags>
</US_DocBloc>
]]
  ultraschall.RunCommand("_SWS_STOPPREVIEW") -- Xenakios/SWS: Stop current media item/take preview
  ultraschall.PreviewMediaFile(ultraschall.Api_Path.."/misc/silence.flac")
  --ultraschall.StopAnyPreview()
end


function ultraschall.InsertTrackAtIndex(index, number_of_tracks, wantdefaults)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertTrackAtIndex</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string trackarray, integer new_track_count, array trackarray_newtracks = ultraschall.InsertTrackAtIndex(integer index, integer number_of_tracks, boolean wantdefaults)</functioncall>
  <description>
    Inserts one or more tracks at index.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string trackstring - a trackstring with all newly created tracknumbers
    integer new_track_count - the number of newly created tracks
    array trackarray_newtracks - an array with the MediaTrack-objects of all newly created tracks
  </retvals>
  <parameters>
    integer index - the index, at which to include the new tracks; 0, for including before the first track
    integer number_of_tracks - the number of tracks that you want to create; 0 for including before track 1; number of tracks+1, include new tracks after last track
    boolean wantdefaults - true, set the tracks with default settings/fx/etc; false, create new track without any defaults
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, insert, new, track</tags>
</US_DocBloc>
]]
  if math.type(index)~="integer" then ultraschall.AddErrorMessage("InsertTrackAtIndex", "index", "Must be an integer.", -1) return end
  if math.type(number_of_tracks)~="integer" then ultraschall.AddErrorMessage("InsertTrackAtIndex", "number_of_tracks", "Must be an integer.", -2) return end
  if type(wantdefaults)~="boolean" then ultraschall.AddErrorMessage("InsertTrackAtIndex", "wantdefaults", "Must be a boolean.", -3) return end
  if index<0 or index>reaper.CountTracks(0) then ultraschall.AddErrorMessage("InsertTrackAtIndex", "index", "No such index. Must be 0 to tracknumber+1", -4) return end
  if number_of_tracks<0 then ultraschall.AddErrorMessage("InsertTrackAtIndex", "number_of_tracks", "Must be bigger than 0", -5) return end
  local TrackArray={}
  local count=reaper.CountTracks(0)-1
  local found
  for i=0, reaper.CountTracks(0)-1 do
    TrackArray[i+1]={}
    TrackArray[i+1][1]=reaper.GetTrack(0,i)
    TrackArray[i+1][2]=reaper.IsTrackSelected(TrackArray[i+1][1])
  end
  ultraschall.SetTracksSelected(tostring(index), true)
  for i=1, number_of_tracks do
    reaper.InsertTrackAtIndex(index, wantdefaults)
  end
  ultraschall.SetAllTracksSelected(false) 

  for i=1, count do
    reaper.SetTrackSelected(TrackArray[i+1][1], TrackArray[i+1][2])
  end
  
  local trackstring2=""
  local Trackarray2={}
  local newcount=0
  for i=0, reaper.CountTracks(0)-1 do
    for a=1, count do
      if reaper.GetTrack(0,i)==TrackArray[a+1][1] then found=true end
    end
    if found==false then trackstring2=trackstring2..i.."," newcount=newcount+1 Trackarray2[newcount]=reaper.GetTrack(0,i) end
    found=false
  end
  return trackstring2:sub(1,-2), newcount, Trackarray2
end

--A,B,C=ultraschall.InsertTrackAtIndex(1, 1, false)

function ultraschall.MoveTracks(trackstring, targetindex, makepreviousfolder)
-- Reaper 5.92 !!!
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.MoveTracks(string trackstring, integer targetindex, integer makepreviousfolder)</functioncall>
  <description>
    Moves tracks in trackstring to position targetindex. You can also set, if the tracks shall become folders.
    Multiple tracks in trackstring will be put together, so track 2, 4, 6 would become 1, 2, 3, when moved above the first track!
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, moving was successful; false, moving wasn't successful
  </retvals>
  <parameters>
    string trackstring - a string with all tracknumbers of the tracks you want to move, separated by commas
    integer targetindex - the index, to which to move the tracks; 0, move tracks before track 1; number of tracks+1, move after the last track
    integer makepreviousfolder - make tracks a folder or not
                               - 0, for normal, 
                               - 1, as child of track preceding track specified by makepreviousfolder
                               - 2, if track preceding track specified by makepreviousfolder is last track in folder, extend folder
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, move, track, tracks, folder</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("MoveTracks", "trackstring", "Must be a valid trackstring.", -1) return false end
  if math.type(targetindex)~="integer" then ultraschall.AddErrorMessage("MoveTracks", "targetindex", "Must be an integer.", -2) return false end
  if math.type(makepreviousfolder)~="integer" then ultraschall.AddErrorMessage("MoveTracks", "makepreviousfolder", "Must be an integer.", -3) return false end
  if targetindex<0 or targetindex>reaper.CountTracks(0)+1 then ultraschall.AddErrorMessage("MoveTracks", "targetindex", "No such track.", -4) return false end
  if makepreviousfolder<0 or makepreviousfolder>2 then ultraschall.AddErrorMessage("MoveTracks", "makepreviousfolder", "Must be between 0 and 2.", -5) return false end
  reaper.PreventUIRefresh(1)
  local TrackArray={}
  
  for i=0, reaper.CountTracks(0)-1 do
    TrackArray[i+1]={}
    TrackArray[i+1][1]=reaper.GetTrack(0,i)
    TrackArray[i+1][2]=reaper.IsTrackSelected(TrackArray[i+1][1])
  end
  ultraschall.SetTracksSelected(trackstring, true)
  
  local retval=reaper.ReorderSelectedTracks(targetindex, makepreviousfolder)
  
  for i=0, reaper.CountTracks(0)-1 do
    reaper.SetTrackSelected(TrackArray[i+1][1], TrackArray[i+1][2])
  end
  reaper.PreventUIRefresh(-1)
  return retval
end

--L=ultraschall.MoveTracks("2,3,5", 8, 1)


function ultraschall.PreviewMediaFileA(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>PreviewMediaFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.PreviewMediaFile(string filename_with_path)</functioncall>
  <description>
    Plays a preview of a media-file.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, starting preview was successful; false, starting preview wasn't successful
  </retvals>
  <parameters>
    string filename_with_path - the filename with path of the media-file to play
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, preview, play, audio, file</tags>
</US_DocBloc>
]]

  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("PreviewMediaItem", "filename_with_path", "Must be a string.", -1) return false end
  if reaper.file_exists(filename_with_path)== false then ultraschall.AddErrorMessage("PreviewMediaItem", "filename_with_path", "File does not exist.", -2) return false end
  local oldstate=reaper.SNM_GetIntConfigVar("showpeaksbuild",-99)
  if oldstate==1 then reaper.SNM_SetIntConfigVar("showpeaksbuild", 0) end
  local count, MediaItemArray = ultraschall.GetAllSelectedMediaItems()
  reaper.PreventUIRefresh(1)
  local retval, MediaItem, length, numchannels, Samplerate, Filetype = ultraschall.InsertMediaItemFromFile(filename_with_path, 0, reaper.GetProjectLength(), -1, 0)
  local B=reaper.GetTrack(0, reaper.CountTracks(0)-1)
  ultraschall.DeselectMediaItems_MediaItemArray(MediaItemArray)
  reaper.SetMediaItemSelected(MediaItem, true)
  ultraschall.RunCommand("_XENAKIOS_ITEMASPCM1")
  ultraschall.DeleteMediaItem(MediaItem)
  ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray)
  reaper.DeleteTrack(B)
  reaper.SNM_SetIntConfigVar("showpeaksbuild", oldstate)
  reaper.PreventUIRefresh(-1)
  if retval==-1 then return false else return true end
end

function ultraschall.PreviewMediaFile(filename_with_path, undo)
  local id=reaper.time_precise()
  if undo~=false then reaper.Undo_BeginBlock() end
  reaper.PreventUIRefresh(1)  
  local A=ultraschall.PreviewMediaFileA(filename_with_path)
  if undo~=false then 
    reaper.Undo_EndBlock("ultraschall_undo"..id, 0)
    local B=reaper.Undo_CanUndo2(0)  
    if B=="ultraschall_undo"..id then reaper.Undo_DoUndo2(0) end
  end
  reaper.PreventUIRefresh(1)
end

--A=ultraschall.PreviewMediaFile("c:\\Users\\meo\\Desktop\\The Beatles - Baby Youre A Rich Man (Remastered 2009).mp3")
--ultraschall.StopAnyPreview()

--B=reaper.Undo_DoUndo2(0)
--B=reaper.Undo_DoUndo2(0)

--C=ultraschall.PreviewMediaFile("c:\\Users\\meo\\Desktop\\Base64 encode_decode for Codea (Lua).html")
--ultraschall.StopAnyPreview()

--  local retval, MediaItem, length, numchannels, Samplerate, Filetype = ultraschall.InsertMediaItemFromFile("c:\\Users\\meo\\Desktop\\Steppenwolf - Magic Carpet Ride (Version 1969).mp3", 5, reaper.GetProjectLength(), -1, 0)

function ultraschall.MakeFunctionUndoable(Func, UndoMessage, Flag, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MakeFunctionUndoable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string current_UndoMessage, retvals_1, ..., retvals_2 = ultraschall.MakeFunctionUndoable(function Func, string UndoMessage, integer Flag, Func_parameters_1,  ... Func_parameters_n)</functioncall>
  <description>
    Run the function Func and create an undopoint for this function. You can also give an UndoMessage and a flag for Reaper to use.
    All parameters needed by Func follow after parameter Flag, as if it would be the normal parameters.
    This should make creating undo-points much much easier...
    
    Note: Reaper will use the undo-point only for functions, who do "undo"-able things. If you don't have something of that kind(no creating a track or something), Reaper will not create an undo-point.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, undoing was successful; false, undoing wasn't successful
    string current_UndoMessage - the current UndoMessage for the last action done by Reaper. Use this so see, if getting an undo-point was successful
    retvals_1 ... retvals_2 - the returnvalues, as returned by function Func
  </retvals>
  <parameters>
    function Func - the function, that you want to create an undo-point for
    string UndoMessage - the undo-message to be displayed by Reaper in the Undo-history
    integer Flag - you can set a flag, if you want, for this undo-point
    Func_parameters_1,  ... Func_parameters_n - the parameters, as needed by the function Func; will be given to Func as provided by you
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, undo, create, undopoint, function</tags>
</US_DocBloc>
]]
  if type(Func)~="function" then ultraschall.AddErrorMessage("MakeFunctionUndoable", "Func", "Must be a function.", -1) return false end
  if type(UndoMessage)~="string" then ultraschall.AddErrorMessage("MakeFunctionUndoable", "UndoMessage", "Must be a string.", -2) return false end
  if math.type(Flag)~="integer" then ultraschall.AddErrorMessage("MakeFunctionUndoable", "Func", "Must be an integer.", -3) return false end
  reaper.Undo_BeginBlock()
  local O={Func(...)}
  reaper.Undo_EndBlock(UndoMessage, Flag)
  local B=reaper.Undo_CanUndo2(0)
  if B~=UndoMessage then UndoMessage=B end
  return true, UndoMessage, table.unpack(O)
end


function ultraschall.GetMediaItemTake(MediaItem, TakeNr)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediaItemTake</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>MediaItem_Take Take, integer TakeCount = ultraschall.GetMediaItemTake(MediaItem MediaItem, integer TakeNr)</functioncall>
  <description>
    Returns the requested MediaItem-Take of MediaItem. Use TakeNr=0 for the active take(!)
    
    Returns nil in case of an error
  </description>
  <retvals>
    MediaItem_Take Take - the requested take of a MediaItem
    integer TakeCount - the number of takes available within this Mediaitem
  </retvals>
  <parameters>
    MediaItem MediaItem - the MediaItem, of whom you want to request a certain take.
    integer TakeNr - the take that you want to request; 1 for the first; 2 for the second, etc; 0, for the current active take
  </parameters>
  <chapter_context>
    MediaItem Management
    Get MediaItem-Takes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, take, get, take, active</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, MediaItem, "MediaItem*")==false then ultraschall.AddErrorMessage("GetMediaItemTake", "MediaItem", "must be a valid MediaItem-object", -1) return nil end
  if math.type(TakeNr)~="integer" then ultraschall.AddErrorMessage("GetMediaItemTake", "TakeNr", "must be an integer", -2) return nil end
  if TakeNr<0 or TakeNr>reaper.CountTakes(MediaItem) then ultraschall.AddErrorMessage("GetMediaItemTake", "TakeNr", "No such take in MediaItem", -3) return -1 end
  
  if TakeNr==0 then return reaper.GetActiveTake(MediaItem), reaper.CountTakes(MediaItem)
  else return reaper.GetMediaItemTake(MediaItem, TakeNr-1), reaper.CountTakes(MediaItem) end
end


--A, B=ultraschall.GetMediaItemTake(reaper.GetMediaItem(99999999,0),9)
--A2, B2=ultraschall.GetMediaItemTake(reaper.GetMediaItem(0,0),1)
--A3, B3=ultraschall.GetMediaItemTake(reaper.GetMediaItem(0,0),2)

function ultraschall.ReturnTableAsIndividualValues(Table)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReturnTableAsIndividualValues</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>retval1, retval2, retval3, ... , retval64 = ultraschall.ReturnTableAsIndividualValues(table Table)</functioncall>
  <description>
    Returns the first 64 entries of an numerical-indexed table as returnvalues
  </description>
  <retvals>
    retval1 ... retval64 - the values from Table returned
  </retvals>
  <parameters>
    table Table - the table, whose values you want to return. It will only return values with index 1...64!
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, table, return, values, indexed</tags>
</US_DocBloc>
]]  
  
  if type(Table)~="table" then Table={} end
  return Table[1], Table[2], Table[3], Table[4], Table[5], Table[6], Table[7], Table[8], Table[9], Table[10],
         Table[11], Table[12], Table[13], Table[14], Table[15], Table[16], Table[17], Table[18], Table[19], Table[20],
         Table[21], Table[22], Table[23], Table[24], Table[25], Table[26], Table[27], Table[28], Table[29], Table[30],
         Table[31], Table[32], Table[33], Table[34], Table[35], Table[36], Table[37], Table[38], Table[39], Table[40],
         Table[41], Table[42], Table[43], Table[44], Table[45], Table[46], Table[47], Table[48], Table[49], Table[50],
         Table[51], Table[52], Table[53], Table[54], Table[55], Table[56], Table[57], Table[58], Table[59], Table[60],
         Table[61], Table[62], Table[63], Table[64]
end

--L,M,N,O,P=ultraschall.ReturnTableAsIndividualValues(nil)

function ultraschall.ApplyFunctionToMediaItemArray(MediaItemArray, functionname, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyFunctionToMediaItemArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.92
    Lua=5.3
  </requires>
  <functioncall>table returnvalues  = ultraschall.ApplyFunctionToMediaItemArray(MediaItemArray MediaItemArray, function functionname, functionparameters1, ..., functionparametersn)</functioncall>
  <description>
    Applies function "functionname" on all items in MediaItemArray. Parameter ... is all parameters used for function "functionname", where you should use nil in place of the parameter that shall hold a MediaItem.
    
    Returns a table with a boolean(did the function run without an error) and all returnvalues returned by function "functionname".
    
    Returns nil in case of an error. Will NOT(!) stop execution, if function "functionname" produces an error(see table returnvalues for more details)
  </description>
  <retvals>
    table returnvalues - a table with all returnvalues of the following structure:
                       -    returnvalues[1]=boolean - true, running the function succeeded; false, running the function did not succeed
                       -    returnvalues[2]=optional(!) string - the errormessage, if returnvalues[1]=false; will be omitted if returnvalues[1]=true
                       - all other tableentries contain the returnvalues, as returned by function "functionname"
  </retvals>
  <parameters>
    MediaItemArray MediaItemArray - an array with all MediaItems, who you want to apply functionname to.
    function functionname - the name of the function to apply to every MediaItem in MediaItemArray
    functionparameters1...n - the parameters needed for function "functionname". Important: the function-parameter that is intended for the MediaItem, must be nil. 
                            - This nil-parameter will be filled with the appropriate MediaItem by ApplyFunctionToMediaItemArray automatically
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, apply, function, mediaitem, mediaitemarray</tags>
</US_DocBloc>
]]  
  if type(functionname)~="function" then ultraschall.AddErrorMessage("ApplyFunctionToMediaItemArray", "functionname", "Must be a function.", -1) return nil end
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ApplyFunctionToMediaItemArray", "functionname", "Must be a function.", -1) return nil end
  local L={...}
  local RetValTable={}
  local index=-1
  local max, i
  for i=1, 255 do 
    v=L[i]
    if v==nil and index==-1 then index=i
    elseif v==nil and index~=-1 then max=i break end
  end
  i=1
  while MediaItemArray[i]~=nil do
    L[index]=MediaItemArray[i]
    A={pcall(functionname, ultraschall.ReturnTableAsIndividualValues(L))}
    RetValTable[i]=A    
    i=i+1
  end
  return i, RetValTable
end

--A1,B2,C,D,E,F,G=ultraschall.GetAllMediaItemsBetween(0,100,"1,2,3",true)
--L,L2=ultraschall.ApplyFunctionToMediaItemArray(B2,reaper.SetMediaItemSelected,nil,false)
--reaper.UpdateArrange()


function ultraschall.GetProject_MarkersAndRegions(projectfilename_with_path, ProjectStateChunk)
-- return Reaper-Version and TimeStamp
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MarkersAndRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer markerregioncount, integer NumMarker, integer Numregions, array Markertable = ultraschall.GetProject_MarkersAndRegions(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the markers and regions from an RPP-Projectfile or a ProjectStateChunk.
    Doe not return TimeSignature-markers(!)
    Returns nil in case of error or if no such entry exists.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    integer markerregioncount - the number of markers and regions in the projectfile/ProjectStateChunk
    array markertable - an array with all elements of markers/regions
                      - markertable has the following entries:
                      - markertable[id][1]=boolean isrgn - true, marker is a region; false, marker is a normal marker
                      - markertable[id][2]=number pos    - the startposition of the marker/region
                      - markertable[id][3]=number rgnend - the endposition of a region; 0, if it's a marker
                      - markertable[id][4]=string name   - the name of the marker/region
                      - markertable[id][5]=integer markrgnindexnumber - the shown number of the region/marker
                      - markertable[id][6]=integer color - the color-value of the marker
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, marker, regions</tags>
</US_DocBloc>
]]
--[[
MARKER integer shownnumber number position string name integer isrgn integer color integer unknown string R
    an entry for a marker or a region
    regions have multiple entries with the first one being the start and the following(!) one the end of the region(with isrgn=1)
      if the following one is not a region one(isrgn=1) then the previous one will be treated as normal marker by Reaper.
    normal markers are never inbetween start- and end-markerentries of regions

integer shownnumber - the number displayed in the marker
number position - the position of the marker
string name - the name of the marker; will be put in doublequotes, when it contains spaces; will be "" if it's the end of a region
integer isrgn - 0, normal marker; 1, a region.
integer color - the colorvalue of the marker
integer unknown - unknown
string R - a simple R, whose purpose is unknown
--]]

  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MarkersAndRegions","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MarkersAndRegions","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MarkersAndRegions","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MarkersAndRegions", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the values and return them
  local MarkerArray={}
  local MarkerCount=0
  local NumMarker=0
  local NumRegions=0
  local Markerlist=ProjectStateChunk:match("MARKER.*%<PROJBAY.-\n")
  local endposition=0
  local Offset
  if Markerlist~=nil then Markerlist=Markerlist.."  MARKER" end
  
  while Markerlist~=nil do
    Marker, Offset=Markerlist:match("(MARKER.-\n)()")
    if Offset~=nil then Markerlist=Markerlist:sub(Offset,-1) end
    if Marker==nil then break end
    MarkerCount=MarkerCount+1
--    reaper.MB(Markerlist, Marker,0)
    local shownnumber, position, name, isrgn, color, unknown, unknown2=Marker:match("MARKER (.-) (.-) \"(.-)\" (.-) (.-) (.-) (.*)")
    if name==nil then shownnumber, position, name, isrgn, color, unknown, unknown2=Marker:match("MARKER (.-) (.-) (.-) (.-) (.-) (.-) (.*)") end
    if isrgn=="1" then 
      endposition, Markerlist=Markerlist:match("MARKER .- (.-) .-(MARKER.*)") 
    else 
      endposition=0.0 
    end
    
    MarkerArray[MarkerCount]={}
    if tonumber(isrgn)==1 then 
      MarkerArray[MarkerCount][1]=true 
      NumRegions=NumRegions+1 
    else 
      MarkerArray[MarkerCount][1]=false 
      NumMarker=NumMarker+1 
    end
--reaper.MB(tostring(endposition).." "..tostring(position),Marker,0)
    MarkerArray[MarkerCount][2]=tonumber(position)
    MarkerArray[MarkerCount][3]=tonumber(endposition)
    MarkerArray[MarkerCount][4]=name
    MarkerArray[MarkerCount][5]=tonumber(shownnumber)
    MarkerArray[MarkerCount][6]=tonumber(color)
  end
  return MarkerCount, NumMarker, NumRegions, MarkerArray
end


--A,AA=ultraschall.GetProject_ReaperVersion("c:\\tt.rpp","<REAPER_PROJECT 0.1 \"5.77/x64\" 1529100928\n>")
--A,AA,AAA,AAAA=ultraschall.GetProject_MarkersAndRegions("c:\\Users/Meo/Desktop/Lula/lula.rpp","")
--A,AA,AAA,AAAA=ultraschall.GetProject_MarkersAndRegions("c:\\rendercode-project-dupl.RPP","")
--reaper.MB(A,"",0)

--Rendercfg = ultraschall.CreateRenderCFG_FLAC(1,1)

--A=ultraschall.GetOutputFormat_RenderCfg(Rendercfg)

--A, AA=ultraschall.RenderProjectRegions_RenderCFG("c:\\MarkerProject.rpp", "c:\\Tudelu-test", 2, false, true, true, true, Rendercfg)

function ultraschall.GetGapsBetweenItems(MediaTrack)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetGapsBetweenItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer number_of_gaps, array gaptable = ultraschall.GetGapsBetweenItems(MediaTrack MediaTrack)</functioncall>
  <description>
    Returns a table with all gaps between items in MediaTrack.
    
    Returns -1 in case of an error
  </description>
  <retvals>
    integer number_of_gaps - the number of gaps found between items; -1, in case of error
    array gaptable - an array with all gappositions found
                   - gaptable[idx][1]=startposition of gap
                   - gaptable[idx][2]=endposition of gap
  </retvals>
  <parameters>
    MediaTrack MediaTrack - the track, of which you want to have the gaps between items
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, gaps, between, items, item, mediaitem</tags>
</US_DocBloc>
]]
  if reaper.ValidatePtr2(0, MediaTrack, "MediaTrack*")==false then ultraschall.AddErrorMessage("GetGapsBetweenItems", "MediaTrack", "Must be a valid MediaTrack-object", -1) return -1 end
  if reaper.GetTrackMediaItem(MediaTrack, 0)==nil then ultraschall.AddErrorMessage("GetGapsBetweenItems", "MediaTrack", "No MediaItem in track", -2) return -1 end
  local GapTable={}
  local counter2=0
  local MediaItemArray={}
  local counter=0
  local Iterator, pos1, pos2, end1, end2
  
  -- create MediaItemArray with all items in track
  MediaItemArray[counter]=0
  while MediaItemArray[counter]~=nil do
    counter=counter+1
    MediaItemArray[counter]=reaper.GetTrackMediaItem(MediaTrack, counter-1)
  end
  counter=counter-1
  
  -- throw out all items, that are within/underneath other items
  for i=counter, 2, -1 do
    pos1=reaper.GetMediaItemInfo_Value(MediaItemArray[i], "D_POSITION")
    end1=reaper.GetMediaItemInfo_Value(MediaItemArray[i], "D_LENGTH")+pos1
    pos2=reaper.GetMediaItemInfo_Value(MediaItemArray[i-1], "D_POSITION")
    end2=reaper.GetMediaItemInfo_Value(MediaItemArray[i-1], "D_LENGTH")+pos2
    if pos1>pos2 and end1<end2 then 
      table.remove(MediaItemArray,i) 
      counter=counter-1 
    end
  end
  
  -- see, if there's a gap between projectstart and first item, if yes, add it to GapTable
  if reaper.GetMediaItemInfo_Value(MediaItemArray[1], "D_POSITION")>0 then 
    Iterator=1
    GapTable[1]={}
    GapTable[1][1]=0
    GapTable[1][2]=reaper.GetMediaItemInfo_Value(MediaItemArray[1], "D_POSITION")
  else
    Iterator=0
  end
  
  -- create a table with all Gaps between items  
  for i=1, counter-1 do
    GapTable[i+Iterator]={}
    GapTable[i+Iterator][1]=reaper.GetMediaItemInfo_Value(MediaItemArray[i], "D_POSITION")+reaper.GetMediaItemInfo_Value(MediaItemArray[i], "D_LENGTH")
    GapTable[i+Iterator][2]=reaper.GetMediaItemInfo_Value(MediaItemArray[i+1], "D_POSITION")
    counter2=counter2+1
  end

  -- remove all gaps, that are gaps of length 0 or "gaps" of overlapping items(which aren't gaps because of that)
  for i=counter2+Iterator, 1, -1 do
    if GapTable[i][1]>=GapTable[i][2] then 
      table.remove(GapTable,i) 
      counter2=counter2-1
    end
  end
  
  return counter2+Iterator, GapTable
end


--A,B=ultraschall.GetGapsBetweenItems(reaper.GetTrack(0,0))

function ultraschall.IsValidReaProject(ReaProject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidReaProject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidReaProject(ReaProject ReaProject)</functioncall>
  <description>
    Returns, if parameter ReaProject is a valid ReaProject(means, an existing opened project) or not.
  </description>
  <retvals>
    boolean retval - true, if parameter ReaProject is a valid ReaProject; false, if parameter ReaProject isn't a valid ReaProject
  </retvals>
  <parameters>
    ReaProject ReaProject - the object that you want to check for being a valid ReaProject
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, check, reaproject, project, object, valid</tags>
</US_DocBloc>
]]
  if ReaProject==nil or type(ReaProject)=="number" then return false end
  local count=0
  while reaper.EnumProjects(count,"")~=nil do
    if reaper.EnumProjects(count,"")==ReaProject then return true end
    count=count+1
  end
  return false
end

--K=ultraschall.IsValidReaProject(reaper.EnumProjects(0,""))


function ultraschall.type(object)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>type</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string type_of_object = ultraschall.type(identifier object)</functioncall>
  <description>
    Returns the type of the object.
    Supported types are Lua's own datatypes as well as Reaper's own datatypes.
    
    Due API-limitations, SWS-specific datatypes are not supported in this function!
  </description>
  <retvals>
    string type_of_object - the type of the object; the following are valid:
                          - nil, number: integer, number: float, boolean, string, function, table, thread, userdata, 
                          - ReaProject, MediaItem, MediaItem_Take, MediaTrack, TrackEnvelope, AudioAccessor, joystick_device, PCM_source
                          - userdata will be shown, if object isn't of any known type
  </retvals>
  <parameters>
    identifier object - the object, whose type you want to know
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, check, datatype, reaper-objects, lua, return</tags>
</US_DocBloc>
]]
  if     object==nil then return "nil"
  elseif math.type(object)=="integer" then return "number: integer"
  elseif math.type(object)=="float" then return "number: float"
  elseif type(object)=="boolean" then return "boolean"
  elseif type(object)=="string" then return "string"
  elseif type(object)=="function" then return "function"
  elseif type(object)=="table" then return "table"
  elseif type(object)=="thread" then return "thread"
  elseif ultraschall.IsValidReaProject(object)==true then return "ReaProject"
  elseif pcall(reaper.CreateTakeAudioAccessor,object)==true then return "MediaItem_Take"
  elseif pcall(reaper.CountTrackMediaItems,object)==true then return "MediaTrack"
  elseif pcall(reaper.CountTakes,object)==true then return "MediaItem"
  elseif reaper.ValidatePtr(object, "TrackEnvelope*")==true then return "TrackEnvelope"
  elseif pcall(reaper.AudioAccessorValidateState, object)==true then return "AudioAccessor"
  elseif pcall(reaper.joystick_getaxis,object, 0)==true then return "joystick_device"
  elseif pcall(reaper.GetMediaSourceFileName,object, "")==true then return "PCM_source"
  
-- SWS-related types: need more research, as they seem to be identical to MediaTrack and maybe other types
-- probably should get their own type-function
--  elseif pcall(reaper.FNG_CountMidiNotes,object)==true then return "RprMidiTake"
--  elseif pcall(reaper.FNG_GetMidiNoteIntProperty,object,"")==true then return "RprMidiNote"
--  elseif pcall(reaper.BR_EnvCountPoints, object)==true then return "BR_Envelope"
--  

  elseif type(object)=="userdata" then return "userdata"
  end
end

--[[
track=reaper.GetTrack(0,0)
env=reaper.GetTrackEnvelope(track,0)
item=reaper.GetMediaItem(0,0)
take=reaper.GetMediaItemTake(item,0)
A,B=reaper.EnumProjects(0,"")
PA=reaper.PCM_Source_CreateFromType("WAVE")
acc=reaper.CreateTakeAudioAccessor(take)
--reaper.SNM_GetFastString(WDL_FastString)

L=reaper.SNM_CreateFastString("Hula")

jsd=reaper.joystick_create("tzui")
--]]


--O=ultraschall.type()

--[[
Project=reaper.EnumProjects(0,"")
-- these should create an errormessage "TrackEnvelope expected", 
-- but in fact, they accept a ReaProject as TrackEnvelope, even if
-- they return nonsense-values
A=reaper.CountAutomationItems(Project)
B=reaper.CountEnvelopePoints(Project)
C=reaper.CountEnvelopePointsEx(Project, 0)
D=reaper.Envelope_FormatValue(Project,0)
E,F,G=reaper.Envelope_GetParentTake(Project)
--]]

function ultraschall.SetTrackGroupFlagsState(tracknumber, groups_bitfield_table, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackGroupFlagsState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackGroupFlagsState(integer tracknumber, array groups_bitfield_table, optional string TrackStateChunk)</functioncall>
  <description>
    Set the GroupFlags-state of a track or trackstatechunk.
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to set Volume Master(table entry 1) to checked in Group 1(2^0=1) and 3(2^2=4):
      groups_bitfield_table[1]=groups_bitfield_table[1]+1+4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    This function will work only for Groups 1 to 32. To set Groups 33 to 64, use <a href="#SetTrackGroupFlags_HighState">SetTrackGroupFlags_HighState</a> instead!
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    array groups_bitfield_table - an array with all bitfields with all groupflag-settings
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, groupflag, group, set, state, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "tracknumber", "no such track in the project", -2) return false end
  if type(groups_bitfield_table)~="table" then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "groups_bitfield_table", "must be a table", -3) return false end
  local str="GROUP_FLAGS"
  for i=1, 23 do
    if groups_bitfield_table[i]==nil then break end
    if math.type(groups_bitfield_table[i])~="integer" then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "groups_bitfield_table", "every entry must be an integer", -5) return false end
    str=str.." "..groups_bitfield_table[i]
  end
  tracknumber=tonumber(tracknumber)
  
  -- create state-entry
--  local str="GROUP_FLAGS "..groups_bitfield
  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "tracknumber", "must be an integer", -6) return false end
  if tracknumber~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackGroupFlagsState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1, B3
  B1=AA:match("(.-)%cGROUP_FLAGS")
  B3=AA:match("GROUP_FLAGS.-%c(.*)")
  if B1==nil then 
    B1=AA:match("(.*)%c.-TRACKHEIGHT")
    B3=AA:match("(TRACKHEIGHT.*)")
  end

  -- set trackstatechunk and include new-state
  if tonumber(tracknumber)~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3

end

--A=ultraschall.SetTrackGroupFlagsState(-1, {1,2,3,4,5}, TrackStateChunk)

function ultraschall.SetTrackGroupFlags_HighState(tracknumber, groups_bitfield_table, TrackStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackGroupFlags_HighState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string TrackStateChunk = ultraschall.SetTrackGroupFlags_HighState(integer tracknumber, array groups_bitfield_table, optional string TrackStateChunk)</functioncall>
  <description>
    Set the GroupFlags-state of a track or trackstatechunk.
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table can contain up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to set Volume Master(table entry 1) to checked in Group 33(2^0=1) and 35(2^2=4):
      groups_bitfield_table[1]=groups_bitfield_table[1]+1+4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    This function will work only for Groups 33(2^0) to 64(2^31). To set Groups 1 to 32, use <a href="#SetTrackGroupFlagsState">SetTrackGroupFlagsState</a> instead!
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval  - true, if successful, false if unsuccessful
    string TrackStateChunk - the altered TrackStateChunk
  </retvals>
  <parameters>
    integer tracknumber - number of the track, beginning with 1; 0 for master-track; -1 if you want to use parameter TrackStateChunk
    array groups_bitfield_table - an array with all bitfields with all groupflag-settings
    optional string TrackStateChunk - use a trackstatechunk instead of a track; only used when tracknumber is -1
  </parameters>
  <chapter_context>
    Track Management
    Set Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, groupflag, group, set, state, track, trackstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("SetTrackGroupFlags_HighState", "tracknumber", "must be an integer", -1) return false end
  if tracknumber<-1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("SetTrackGroupFlags_HighState", "tracknumber", "no such track in the project", -2) return false end
  if type(groups_bitfield_table)~="table" then ultraschall.AddErrorMessage("SetTrackGroupFlags_HighState", "groups_bitfield_table", "must be a table", -3) return false end
  local str="GROUP_FLAGS_HIGH "
  for i=1, 23 do
    if groups_bitfield_table[i]==nil then break end
    if math.type(groups_bitfield_table[i])~="integer" then ultraschall.AddErrorMessage("SetTrackGroupFlags_HighState", "groups_bitfield_table", "every entry must be an integer", -5) return false end
    str=str.." "..groups_bitfield_table[i]
  end
  tracknumber=tonumber(tracknumber)

  
  -- get trackstatechunk
  local Mediatrack, A, AA, B
  if tonumber(tracknumber)~=-1 then
    if tracknumber==0 then Mediatrack=reaper.GetMasterTrack(0)
    else
      Mediatrack=reaper.GetTrack(0,tracknumber-1)
    end
    A,AA=ultraschall.GetTrackStateChunk(Mediatrack,str,false)
  else
    if type(TrackStateChunk)~="string" then ultraschall.AddErrorMessage("SetTrackGroupFlags_HighState", "TrackStateChunk", "must be a string", -4) return false end
    AA=TrackStateChunk
  end
  
  -- remove old state from trackstatechunk
  local B1, B3
  B1=AA:match("(.-)%cGROUP_FLAGS_HIGH ")
  B3=AA:match("GROUP_FLAGS_HIGH .-%c(.*)")
  if B1==nil then 
    B1=AA:match("(.*)%c.-TRACKHEIGHT")
    B3=AA:match("(TRACKHEIGHT.*)")
  end

  -- set trackstatechunk and include new-state
  if tonumber(tracknumber)~=-1 then
    B=reaper.SetTrackStateChunk(Mediatrack,B1.."\n"..str.."\n"..B3,false)
  else
    B=true
  end
  return B, B1.."\n"..str.."\n"..B3

end

--A=ultraschall.SetTrackGroupFlags_HighState(1, {1,2,3,4,5}, TrackStateChunk)

--G={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}
--A,B22=ultraschall.GetTrackStateChunk_Tracknumber(1)
--L,LL=ultraschall.SetTrackGroupFlags_HighState(-1, G, B22)
--L,LL=ultraschall.SetTrackGroupFlagsState(-1, G, B22)
--L,LL=ultraschall.GetTrackGroupFlagsState(-1,B22)
--reaper.ShowConsoleMsg(B22:match("GROUP.-\n.-\n"),"",0)
--if LL==nil then LL="" end
--reaper.ShowConsoleMsg(tostring(LL:match(".-\n.-GROUP.-\n.-\n.-\n.-\n")),"",0)

function ultraschall.NewProjectTab(switch_to_new_tab)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>NewProjectTab</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>ReaProject newproject = ultraschall.NewProjectTab(boolean switch_to_new_tab)</functioncall>
  <description>
    Opens a new projecttab and optionally switches to it. Returns the newly created ReaProject.
    
    returns nil in case of an error
  </description>
  <retvals>
    ReaProject newproject - the newly created project-object of the projecttab
  </retvals>
  <parameters>
    boolean switch_to_new_tab - true, switch to the newly created project-tab; false, stay in the "old" project-tab
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, new, project, tab, switch, select</tags>
</US_DocBloc>
--]]
  if type(switch_to_new_tab)~="boolean" then ultraschall.AddErrorMessage("NewProjectTab", "switch_to_new_tab", "Must be a boolean", -1) return end
  reaper.PreventUIRefresh(1)
  local currentProj=reaper.EnumProjects(-1,"")
  reaper.Main_OnCommand(40859,0)
  local newProj=reaper.EnumProjects(-1,"")
  if switch_to_new_tab==false then reaper.SelectProjectInstance(currentProj) end
  reaper.PreventUIRefresh(-1)
  return newProj
end

--L=ultraschall.OpenNewProjectTab(false)

function ultraschall.GetCurrentTimeLengthOfFrame(ReaProject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetCurrentTimeLengthOfFrame</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>number length = ultraschall.GetCurrentTimeLengthOfFrame(ReaProject ReaProject)</functioncall>
  <description>
    Returns a project's length of a frame in seconds. Depends on the fps set in the Project's settings of ReaProject.
    
    Returns -1 in case of an error
  </description>
  <retvals>
    number length - the current length of a frame of ReaProject in seconds
  </retvals>
  <parameters>
    ReaProject ReaProject - the project to check for; use nil or 0 for the current project
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, new, project, tab, switch, select</tags>
</US_DocBloc>
--]]
  if ReaProject~=nil and ReaProject~=0 and ultraschall.IsValidReaProject(ReaProject)==false then ultraschall.AddErrorMessage("GetCurrentTimeLengthOfFrame", "ReaProject", "Must be valid ReaProject", -1) return -1 end  
  if ReaProject==nil then ReaProject=0 end
  
  return 1/reaper.TimeMap_curFrameRate(ReaProject)
end

--A=ultraschall.GetCurrentTimeLengthOfFrame(reaper.EnumProjects(2,""))

function ultraschall.GetLengthOfFrames(frames, ReaProject)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLengthOfFrames</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>number length = ultraschall.GetLengthOfFrames(integer frames, ReaProject ReaProject)</functioncall>
  <description>
    Returns the length of a number of frames of a ReaProject. Depends on the fps set in the Project's settings of ReaProject.
    
    Returns -1 in case of an error
  </description>
  <retvals>
    number length - the current length of frames of ReaProject in seconds
  </retvals>
  <parameters>
    integer frames - the number of frames, whose length you would love to know
    ReaProject ReaProject - the project to check for; use nil or 0 for the current project
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, new, project, tab, switch, select</tags>
</US_DocBloc>
--]]
  if math.type(frames)~="integer" then ultraschall.AddErrorMessage("GetLengthOfFrames", "frames", "Must be an integer", -2) return -1 end  
  if ReaProject~=nil and ReaProject~=0 and ultraschall.IsValidReaProject(ReaProject)==false then ultraschall.AddErrorMessage("GetLengthOfFrames", "ReaProject", "Must be valid ReaProject", -1) return -1 end
  if ReaProject==nil then ReaProject=0 end
  
  return frames*(1/reaper.TimeMap_curFrameRate(ReaProject))
end

--A=ultraschall.GetLengthOfFrames(200, 0)


function ultraschall.GetStartNewFileRecSizeState()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetStartNewFileRecSizeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean start_new_files, boolean offset_file_switches, integer max_rec_size = ultraschall.GetStartNewFileRecSizeState()</functioncall>
  <description>
    Returns, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.
    
    see <a href="#SetStartNewFileRecSizeState">SetStartNewFileRecSizeState</a> for setting the current settings.
  </description>
  <retvals>
    boolean start_new_files - true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops
    boolean offset_file_switches - true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches
    integer max_rec_size - the maximum length of a recorded file in MegaBytes, before Reaper shall start a new file; only applied when When recording multiple tracks, offset file switches for better performance=true
  </retvals>
  <chapter_context>
    Recording
    Configuration
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>recordingmanagement, maximum, file, size, file, switch, offset, restart, recording, get</tags>
</US_DocBloc>
--]]
  local maxrecsize=reaper.SNM_GetIntConfigVar("maxrecsize", -1)
  local maxrecsize_use=reaper.SNM_GetIntConfigVar("maxrecsize_use", -1)
  local start_new_files, offset_file_switched
  if maxrecsize_use&1==0 then start_new_files=false else start_new_files=true end
  if maxrecsize_use&2==0 then offset_file_switches=false else offset_file_switches=true end
  return start_new_files, offset_file_switches, maxrecsize
end

--A,B,C,D,E,F,G=ultraschall.GetStartNewFileRecSizeState()

function ultraschall.SetStartNewFileRecSizeState(start_new_files, offset_file_switches, maxrecsize, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetStartNewFileRecSizeState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetStartNewFileRecSizeState(boolean start_new_files, boolean offset_file_switches, integer maxrecsize, boolean persist)</functioncall>
  <description>
    Sets, if Reaper shall start a file after a specified amount of MegaBytes as well, if the fileswitches shall be offset when multitrack-recording and the maximum filesize before starting a new file.
    
    see <a href="#GetStartNewFileRecSizeState">GetStartNewFileRecSizeState</a> for getting the current settings.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, setting was successful; false, setting was unsuccessful
  </retvals>
  <parameters>
    boolean start_new_files - true, Reaper starts a new file, when a recorded file reaches max_rec_size; false, files are as long until recording stops
    boolean offset_file_switches - true, When recording multiple tracks, offset file switches for better performance; false, don't offset file-switches
    integer max_rec_size - the maximum length of a recorded file in MegaBytes, before Reaper shall start a new file; only applied when When recording multiple tracks, offset file switches for better performance=true
    boolean persist - true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted
  </parameters>
  <chapter_context>
    Recording
    Configuration
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>recordingmanagement, maximum, file, size, file, switch, offset, restart, recording, set</tags>
</US_DocBloc>
--]]
  if type(start_new_files)~="boolean" then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "start_new_files", "Must be a boolean", -1) return false end
  if type(offset_file_switches)~="boolean" then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "offset_file_switches", "Must be a boolean", -2) return false end
  if math.type(maxrecsize)~="integer" then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "maxrecsize", "Must be an integer", -3) return false end
  if maxrecsize<0 or maxrecsize>2147483647 then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "maxrecsize", "Must be between 0 and 2147483647", -4) return false end
  if type(persist)~="boolean" then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "persist", "Must be a boolean", -5) return false end
  
  local maxrecsize_use=0
  if start_new_files==true then maxrecsize_use=maxrecsize_use+1 end
  if offset_file_switches==true then maxrecsize_use=maxrecsize_use+2 end
  local maxrecsize2=reaper.SNM_SetIntConfigVar("maxrecsize", maxrecsize)
  local maxrecsize_use2=reaper.SNM_SetIntConfigVar("maxrecsize_use", maxrecsize_use)
  
  if maxrecsize2==false then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "maxrecsize", "Couldn't set maxrecsize, contact Ultraschall-Api-developers for this...", -6) return false end
  if maxrecsize_use2==false then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "start_new_files or offset_file_switches", "Couldn't set new value, contact Ultraschall-Api-developers for this...", -7) return false end
  
  if persist==true then
    local A=ultraschall.SetIniFileValue("REAPER", "maxrecsize", tostring(maxrecsize), reaper.get_ini_file())
    local B=ultraschall.SetIniFileValue("REAPER", "maxrecsize_use", tostring(maxrecsize_use), reaper.get_ini_file())
    if A==false or B==false then ultraschall.AddErrorMessage("SetStartNewFileRecSizeState", "persist", "Couldn't set changed config to persist. Maybe a problem with accessing reaper.ini.", -8) return false end
  end
  return true    
end

--ultraschall.SetStartNewFileRecSizeState(true, false, 613, false)

function ultraschall.GetPlayCursorWidth()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPlayCursorWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer play_cursor_width = ultraschall.GetPlayCursorWidth()</functioncall>
  <description>
    Returns the width of the playcursor in pixels
    
    see <a href="#SetPlayCursorWidth">SetPlayCursorWidth</a> for setting the playcursor-width.
  </description>
  <retvals>
    integer play_cursor_width - the width of the playcursor in pixels
  </retvals>
  <chapter_context>
    User Interface
    Transport
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, get, playcursor, width</tags>
</US_DocBloc>
--]]
  local playcursormode=reaper.SNM_GetIntConfigVar("playcursormode", -1)
  return playcursormode
end

--A,B,C,D,E,F,G=ultraschall.GetPlayCursorWidth()

function ultraschall.SetPlayCursorWidth(play_cursor_width, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetPlayCursorWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetPlayCursorWidth(integer play_cursor_width, boolean persist)</functioncall>
  <description>
    Sets a new playcursor-width.
    
    see <a href="#GetPlayCursorWidth">GetPlayCursorWidth</a> for getting the playcursor-width.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, setting was successful; false, setting was unsuccessful
  </retvals>
  <parameters>
    integer play_cursor_width - the new width of the playcursor
    boolean persist - true, set the setting to reaper.ini so it persists after restarting Reaper; false, set it only for the time, until Reaper is restarted
  </parameters>
  <chapter_context>
    User Interface
    Transport
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, set, playcursor, width</tags>
</US_DocBloc>
--]]
  if math.type(play_cursor_width)~="integer" then ultraschall.AddErrorMessage("SetPlayCursorWidth", "play_cursor_width", "Must be an integer", -1) return false end
  if play_cursor_width<0 or play_cursor_width>2147483647 then ultraschall.AddErrorMessage("SetPlayCursorWidth", "play_cursor_width", "Must be between 0 and 2147483647", -2) return false end
  if type(persist)~="boolean" then ultraschall.AddErrorMessage("SetPlayCursorWidth", "persist", "Must be a boolean", -3) return false end
  
  local playcursormode=reaper.SNM_SetIntConfigVar("playcursormode", play_cursor_width)
  
  if playcursormode==false then ultraschall.AddErrorMessage("SetPlayCursorWidth", "playcursormode", "Couldn't set playcursormode, contact Ultraschall-Api-developers for this...", -4) return false end
  
  if persist==true then
    local A=ultraschall.SetIniFileValue("REAPER", "playcursormode", tostring(play_cursor_width), reaper.get_ini_file())
    if A==false then ultraschall.AddErrorMessage("SetPlayCursorWidth", "persist", "Couldn't set changed config to persist. Maybe a problem with accessing reaper.ini.", -5) return false end
  end
  return true    
end

--A=ultraschall.SetPlayCursorWidth(2,true)
--ultraschall.SetStartNewFileRecSizeState(true, false, 613, false)


function ultraschall.CreateTrackString_ArmedTracks()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackString_ArmedTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackString_ArmedTracks()</functioncall>
  <description>
    Gets a trackstring with tracknumbers of all armed tracks in it.
    
    Returns "" if no track is armed.
  </description>
  <retvals>
    string trackstring - a trackstring with the tracknumbers of all armed tracks as comma separated csv-string, eg: "1,3,4,7"
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, tracks, armed, trackstring</tags>
</US_DocBloc>
--]]
  local trackstring=""
  for i=0, reaper.CountTracks(0)-1 do
    local MediaTrack=reaper.GetTrack(0,i)
    if reaper.GetMediaTrackInfo_Value(MediaTrack, "I_RECARM")==1 then trackstring=trackstring..(i+1).."," end
  end
  return trackstring:sub(1,-2)
end

function ultraschall.CreateTrackString_UnarmedTracks()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackString_UnarmedTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackString_UnarmedTracks()</functioncall>
  <description>
    Gets a trackstring with tracknumbers of all unarmed tracks in it.
    
    Returns "" if all tracks are armed.
  </description>
  <retvals>
    string trackstring - a trackstring with the tracknumbers of all unarmed tracks as comma separated csv-string, eg: "1,3,4,7"
  </retvals>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, tracks, unarmed, trackstring</tags>
</US_DocBloc>
--]]
  local trackstring=""
  for i=0, reaper.CountTracks(0)-1 do
    local MediaTrack=reaper.GetTrack(0,i)
    if reaper.GetMediaTrackInfo_Value(MediaTrack, "I_RECARM")==0 then trackstring=trackstring..(i+1).."," end
  end
  return trackstring:sub(1,-2)
end

--L=ultraschall.CreateTrackString_UnarmedTracks()

function ultraschall.IsValidEnvelopePointArray(EnvelopePointArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidEnvelopePointArray</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidEnvelopePointArray(EnvelopePointArray EnvelopePointArray)</functioncall>
  <description>
    Checks, if an EnvelopePointArray is a valid one.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, EnvelopePointArray is a valid one; false, EnvelopePointArray isn't valid
  </retvals>
  <parameters>
    EnvelopePointArray EnvelopePointArray - the EnvelopePointArray to check for it's validity
  </parameters>
  <chapter_context>
    Envelope Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>envelopemanagement, envelope, point, envelope point, check, envelopepointarray</tags>
</US_DocBloc>
--]]
  if type(EnvelopePointArray)~="table" then ultraschall.AddErrorMessage("IsValidEnvelopePointArray", "EnvelopePointArray", "Must be a table", -1) return false end
  local counter=1
  while EnvelopePointArray[counter]~=nil do
    if ultraschall.IsValidEnvelopePointObject(EnvelopePointArray[counter])==false then return false end
    counter=counter+1
  end
  return true
end

--EnvelopeString, EnvelopePointArray = ultraschall.GetEnvelopePointIDX_Between(1, "Mute", 1, 100) 
--EnvelopePointArray[4]=true
--A=ultraschall.IsValidEnvelopePointArray(EnvelopePointArray)

function ultraschall.ConvertOldProjectToCurrentReaperVersion(filename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertOldProjectToCurrentReaperVersion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ConvertOldProjectToCurrentReaperVersion(string filename_with_path)</functioncall>
  <description>
    Convert an old Reaper-project to the current Reaper-version.
    It creates a backup-copy of the old version of the project.rpp to project.rpp~0
    After that, it will open the project and save it again, so it is saved with the newest version of Reaper.
    
    Maybe helpful, when you want to use the Ultraschall-API Get/SetProject-State-functions on older projects, where some states were saved differently.
    Just create a "new" version of it and use the aforementioned functions on the new project-version.
    
    Returns false in case of an error.
  </description>
  <retvals>
    boolean retval - true, conversion was successfull; false, conversion wasn't successful(file doesn't exist or a copy can't be created)
  </retvals>
  <parameters>
    string filename_with_path - the filename with path of the rpp-projectfile to be converted.
  </parameters>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, convert, old, project, rpp, current, reaper version</tags>
</US_DocBloc>
--]]
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("ConvertOldProjectToCurrentReaperVersion", "filename_with_path", "Must be a string", -1) return false end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("ConvertOldProjectToCurrentReaperVersion", "filename_with_path", "File does not exist", -2)  return false end
  local tempname = ultraschall.CreateValidTempFile(filename_with_path, true, "", false)
  local A = ultraschall.MakeCopyOfFile(filename_with_path, tempname)
  if A==false then ultraschall.AddErrorMessage("ConvertOldProjectToCurrentReaperVersion", "filename_with_path", "Can't create backup-copy", -3)  return false end
  ultraschall.NewProjectTab(true)
  reaper.Main_openProject(filename_with_path)
  reaper.Main_SaveProject(0,false)
  reaper.Main_OnCommand(40860,0)  
end

--AA=ultraschall.ConvertOldProjectToCurrentReaperVersion("c:\\Users\\meo\\Desktop\\TRSS\\ChristmasInJuly\\SquarryShow-Rec1\\SquarryShow-Rec1.RPP")


function ultraschall.GetMarkerUpdateCounter()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMarkerUpdateCounter</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer marker_update_counter = ultraschall.GetMarkerUpdateCounter()</functioncall>
  <description>
    returns the number of times, a marker in any project has been updated since Reaper started.
    Counts up, if a marker is added, set, moved, deleted from any project opened in Reaper.
    
    This counter includes already closed projects as well
  </description>
  <retvals>
    integer marker_update_counter - the number of times a marker in any project in Reaper has been updated
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markers, update, counter, get</tags>
</US_DocBloc>
--]]
  return reaper.SNM_GetIntConfigVar("g_markerlist_updcnt", -33)
end

--A=ultraschall.GetMarkerUpdateCounter()

function ultraschall.GetSetConfigAcidImport(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAcidImport</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAcidImport(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "When importing media"-dropdownlist, as set in the Media with embedded tempo information-section in Preferences -> Video/REX/Misc
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "acidimport", as well as the reaper.ini-entry "REAPER -> acidimport"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                   - -1, an error occured
                   -  0, Adjust media to project tempo
                   -  1, Import media at source tempo
                   -  2, Always prompt when importing media with embedded tempo
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                   - -1, an error occured
                   -  0, Adjust media to project tempo
                   -  1, Import media at source tempo
                   -  2, Always prompt when importing media with embedded tempo
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Video/REX/Misc
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, tempo, get, set, persist, tempo, import, media</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAcidImport", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAcidImport", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAcidImport", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>2 then ultraschall.AddErrorMessage("GetSetConfigAcidImport", "setting", "must be between 0 and 2", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("acidimport", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("acidimport", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "acidimport", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetAcidImport(true, 0, true)

function ultraschall.GetSetConfigActionMenu(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigActionMenu</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigActionMenu(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Show recent actions"-entry, as set in the Actions-menu.
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "actionmenu", as well as the reaper.ini-entry "REAPER -> actionmenu"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                   - 0, don't show recent actions - unchecked
                   - 1, show recent actions - checked
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                    - 0, don't show recent actions - unchecked
                    - 1, show recent actions - checked
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Menus
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, actions, menu</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigActionMenu", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigActionMenu", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigActionMenu", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigActionMenu", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("actionmenu", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("actionmenu", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "actionmenu", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetActionMenu(true, 1, false)

function ultraschall.GetSetConfigAdjRecLat(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAdjRecLat</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAdjRecLat(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Use audio driver reported latency"-checkbox, as set in Preferences -> Recording
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "adjreclat", as well as the reaper.ini-entry "REAPER -> adjreclat"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                    - 0, don't use audio driver reported latency(off) - unchecked
                    - 1, don't use audio driver reported latency(on) - checked
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                    - 0, don't use audio driver reported latency(off) - unchecked
                    - 1, don't use audio driver reported latency(on) - checked
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Recording
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, recording, adjreclat, audio, driver, latency</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecLat", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecLat", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAdjRecLat", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAdjRecLat", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("adjreclat", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("adjreclat", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "adjreclat", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetAdjRecLat(true, 1, true)

function ultraschall.GetSetConfigAdjRecManLat(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAdjRecManLat</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAdjRecManLat(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Output manual offset-samples"-inputbox, as set in Preferences -> Recording
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "adjrecmanlat", as well as the reaper.ini-entry "REAPER -> adjrecmanlat"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value; 0 to 2147483647; in samples
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value; 0 to 2147483647; in samples
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Recording
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, recording, adjrecmanlat, manual, output, offset, samples</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLat", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLat", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLat", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>2147483647 then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLat", "setting", "must be between 0 and 2147483647", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("adjrecmanlat", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("adjrecmanlat", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "adjrecmanlat", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetAdjRecManLat(false, 0, true)

function ultraschall.GetSetConfigAfxCfg(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAfxCfg</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAfxCfg(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of the audioformat for "Apply FX, Glue, Freeze, etc", as set in the Project Settings->Media-dialog
    Only sets the format, not the individual format-settings(like bitrate, etc)!
    To keep the setting for new projects as standard-setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "afxcfg", as well as the reaper.ini-entry "REAPER -> afxcfg"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/newly set audioformat 
                   - 0, not set yet
                   - 1179012432, Video (ffmpeg/libav encoder)
                   - 1195984416, Video (GIF)
                   - 1279477280, Video (LCF)
                   - 1332176723, OGG Opus
                   - 1634297446, AIFF
                   - 1684303904, DDP
                   - 1718378851, FLAC
                   - 1769172768, Audio CD Image(CUE/BIN format)
                   - 1836069740, MP3 (encoder by LAME project)
                   - 1869047670, OGG Vorbis
                   - 2002876005, WAV
                   - 2004250731, WavPack lossless compressor
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the new set audioformat
                    - 1179012432, Video (ffmpeg/libav encoder)
                    - 1195984416, Video (GIF)
                    - 1279477280, Video (LCF)
                    - 1332176723, OGG Opus
                    - 1634297446, AIFF
                    - 1684303904, DDP
                    - 1718378851, FLAC
                    - 1769172768, Audio CD Image(CUE/BIN format)
                    - 1836069740, MP3 (encoder by LAME project)
                    - 1869047670, OGG Vorbis
                    - 2002876005, WAV
                    - 2004250731, WavPack lossless compressor
    boolean persist - true, this setting will be standard-setting for new projects after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Project Settings: Media
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, project settings, media, apply fx glue freeze</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAfxCfg", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAfxCfg", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAfxCfg", "setting", "must be an integer", -3) return -1 end
  if     setting==1179012432 then -- 1179012432, Video (ffmpeg/libav encoder)
  elseif setting==1195984416 then -- 1195984416, Video (GIF)
  elseif setting==1279477280 then -- 1279477280, Video (LCF)
  elseif setting==1332176723 then -- 1332176723, OGG Opus
  elseif setting==1634297446 then -- 1634297446, AIFF
  elseif setting==1684303904 then -- 1684303904, DDP
  elseif setting==1718378851 then -- 1718378851, FLAC
  elseif setting==1769172768 then -- 1769172768, Audio CD Image(CUE/BIN format)
  elseif setting==1836069740 then -- 1836069740, MP3 (encoder by LAME project)
  elseif setting==1869047670 then -- 1869047670, OGG Vorbis
  elseif setting==2002876005 then -- 2002876005, WAV
  elseif setting==2004250731 then -- 2004250731, WavPack lossless compressor
  else
    ultraschall.AddErrorMessage("GetSetConfigAfxCfg", "setting", "no such format", -4) return -1
  end
  if set==false then return reaper.SNM_GetIntConfigVar("afxcfg", 0)
  else 
    local temp=reaper.SNM_SetIntConfigVar("afxcfg", setting)
    if temp==false then ultraschall.AddErrorMessage("GetSetConfigAfxCfg", "setting", "Can't be set on runtime, yet. Project-Settings -> Media -> Format for Apply FX, Glue, Freeze, etc must be set to Custom first.", -5) return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "afxcfg", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--Temp2=reaper.SNM_SetIntConfigVar("projrecforopencopy", 2)
--Temp=reaper.SNM_GetIntConfigVar("projrecforopencopy", 0)
--A=ultraschall.GetSetAfxCfg(true, 1684303904, false)

function ultraschall.GetSetConfigAllStereoPairs(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAllStereoPairs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAllStereoPairs(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Show non-standard stereo channel pairs(i.e Input2/Input3 etc)"-checkbox in the Channel naming/mapping-section, as set in Preferences -> Audio
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "allstereopairs", as well as the reaper.ini-entry "REAPER -> allstereopairs"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                   - 0, don't show non standard stereo channel pairs(off) - unchecked
                   - 1, show non standard stereo channel pairs(on) - checked
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                    - 0, don't show non standard stereo channel pairs(off) - unchecked
                    - 1, show non standard stereo channel pairs(on) - checked
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Audio
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, audio, stereo, pairs</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAllStereoPairs", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAllStereoPairs", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAllStereoPairs", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAllStereoPairs", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("allstereopairs", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("allstereopairs", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "allstereopairs", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAllStereoPairs(true, 0, true)

function ultraschall.CreateTrackStringByGUID(guid_csv_string)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackStringByGUID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackStringByGUID(string guid_csv_string)</functioncall>
  <description>
    returns a trackstring with all tracks, as given by the GUIDs in the comma-separated-csv-string guid_csv_string.
    
    returns "" in case of an error, like no track available or an invalid string
  </description>
  <retvals>
    string trackstring - a string with all the tracknumbers of the tracks given as GUIDs in guid_csv_string
  </retvals>
  <parameters>
    string guid_csv_string - a comma-separated csv-string, that includes all GUIDs of all track to be included in the trackstring.
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackstring, track, create, guid</tags>
</US_DocBloc>
--]]
  if type(guid_csv_string)~="string" then ultraschall.AddErrorMessage("CreateTrackStringByGUID", "guid_csv_string", "Must be a string", -1) return "" end
  local Trackstring=""
  local A,B=ultraschall.CSV2IndividualLinesAsArray(guid_csv_string)
  for i=1, A do
    local Track=reaper.BR_GetMediaTrackByGUID(0, B[i])
    if Track~=nil then Trackstring=Trackstring..","..math.ceil(reaper.GetMediaTrackInfo_Value(Track, "IP_TRACKNUMBER")) end
  end
  local retval, Trackstring = ultraschall.RemoveDuplicateTracksInTrackstring(Trackstring)
  return Trackstring
end

--D,E=ultraschall.CreateTrackStringByGUID(reaper.GetTrackGUID(reaper.GetTrack(0,0)))
--D,E=ultraschall.CreateTrackStringByGUID("tudelu")

function ultraschall.CreateTrackStringByTracknames(tracknames_csv_string)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackStringByTracknames</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackStringByTracknames(string tracknames_csv_string)</functioncall>
  <description>
    returns a trackstring with all tracks, as given by the tracknames in the newline(!)-separated-csv-string guid_csv_string.
    
    returns "" in case of an error, like no track available or an invalid string
  </description>
  <retvals>
    string trackstring - a string with all the tracknumbers of the tracks given as tracknames in tracknames_csv_string
  </retvals>
  <parameters>
    string tracknames_csv_string - a newline(!)-separated csv-string, that includes all tracknames of all track to be included in the trackstring. Tracknames are case sensitive!
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackstring, track, create, tracknames</tags>
</US_DocBloc>
--]]
  if type(tracknames_csv_string)~="string" then ultraschall.AddErrorMessage("CreateTrackStringByTracknames", "tracknames_csv_string", "Must be a string", -1) return "" end
  local Trackstring=""
  local A,B=ultraschall.CSV2IndividualLinesAsArray(tracknames_csv_string, "\n")
  for a=0, reaper.CountTracks(0)-1 do    
    local Track=reaper.GetTrack(0,a)
    for i=1,A do
      local retval, Name=reaper.GetTrackName(Track,"")
      if Name==B[i] then Trackstring=Trackstring..","..(a+1) break end
    end
  end
  local retval, Trackstring = ultraschall.RemoveDuplicateTracksInTrackstring(Trackstring)
  return Trackstring
end

--D,E=ultraschall.CreateTrackStringByGUID(reaper.GetTrackGUID(reaper.GetTrack(0,0)))
--D,E=ultraschall.CreateTrackStringByTracknames("tude\ntudelu")

function ultraschall.CreateTrackStringByMediaTracks(MediaTrackArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTrackStringByMediaTracks</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string trackstring = ultraschall.CreateTrackStringByMediaTracks(array MediaTrackArray)</functioncall>
  <description>
    returns a trackstring with all tracks, as given in the array MediaTrackArray
    
    returns "" in case of an error, like no track available or an invalid string
  </description>
  <retvals>
    string trackstring - a string with all the tracknumbers of the MediaTrack-objects given in parameter MediaTrackArray
  </retvals>
  <parameters>
    array MediaTrackArray - an array, that includes all MediaTrack-objects to be included in the trackstring; a nil-entry is seen as the end of the array
  </parameters>
  <chapter_context>
    Track Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackstring, track, create, mediatrack, mediatracks</tags>
</US_DocBloc>
--]]
  if type(MediaTrackArray)~="table" then ultraschall.AddErrorMessage("CreateTrackStringByMediaTracks", "MediaTrackArray", "Must be an array", -1) return "" end
  local Trackstring=""

  local count=1
  while MediaTrackArray[count]~=nil do
    if ultraschall.type(MediaTrackArray[count])=="MediaTrack" then
      Trackstring=Trackstring..","..math.ceil(reaper.GetMediaTrackInfo_Value(MediaTrackArray[count], "IP_TRACKNUMBER"))
    end
    count=count+1
  end
  local retval, Trackstring = ultraschall.RemoveDuplicateTracksInTrackstring(Trackstring)
  return Trackstring
end

--D,E=ultraschall.CreateTrackStringByGUID(reaper.GetTrackGUID(reaper.GetTrack(0,0)))
--AA={reaper.GetTrack(0,0),reaper.GetTrack(0,1),reaper.GetMediaItem(0,4),reaper.GetTrack(0,3)}
--D,E=ultraschall.CreateTrackStringByMediaTracks(AA)

function ultraschall.GetScreenWidth(want_workarea)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScreenWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer width = ultraschall.GetScreenWidth(optional boolean want_workarea)</functioncall>
  <description>
    returns the width of the screen in pixels.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer width - the width of the screen in pixels
  </retvals>
  <parameters>
    optional boolean want_workarea - true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true
  </parameters>
  <chapter_context>
    User Interface
    Screen Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, get, screen, width</tags>
</US_DocBloc>
--]]
  if want_workarea~=nil and type(want_workarea)~="boolean" then ultraschall.AddErrorMessage("GetScreenWidth", "want_workarea", "Must be a boolean", -1) return -1 end  
  if want_workarea==nil then want_workarea=true end
  local left, top, right, bottom = reaper.my_getViewport(0,0,0,0,0,0,0,0, want_workarea)
  return right
end


function ultraschall.GetScreenHeight(want_workarea)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScreenHeight</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer height = ultraschall.GetScreenHeight(optional boolean want_workarea)</functioncall>
  <description>
    returns the height of the screen in pixels.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer width - the height of the screen in pixels
  </retvals>
  <parameters>
    optional boolean want_workarea - true, returns workspace only; false, full monitor coordinates of the returned viewport; nil, will be seen as true
  </parameters>
  <chapter_context>
    User Interface
    Screen Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, get, screen, height</tags>
</US_DocBloc>
--]]
  if want_workarea~=nil and type(want_workarea)~="boolean" then ultraschall.AddErrorMessage("GetScreenHeight", "want_workarea", "Must be a boolean", -1) return -1 end  
  if want_workarea==nil then want_workarea=true end
  local left, top, right, bottom = reaper.my_getViewport(0,0,0,0,0,0,0,0, want_workarea)
  return bottom  
end

--A=ultraschall.GetScreenHeight()

function ultraschall.pause_follow_one_cycle()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>pause_follow_one_cycle</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>ultraschall.pause_follow_one_cycle()</functioncall>
  <description>
    Skips auto-follow-off-checking-script for one cycle.
    FollowMode in Ultraschall turns on Autoscrolling in a useable way. In addition, under certain circumstances, followmode will be turned off automatically. 
    If you experience this but want to avoid the follow-off-functionality, use this function.
    
    This function is only relevant, if you want to develop scripts that work perfectly within the Ultraschall.fm-extension.
  </description>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, follow, off, followmode, turn off one cycle</tags>
</US_DocBloc>
--]]
  local follow_actionnumber = reaper.NamedCommandLookup("_Ultraschall_Toggle_Follow")
  if reaper.GetToggleCommandState(follow_actionnumber)==1 then
    reaper.SetExtState("follow", "skip", "true", false)
  end
end 


function ultraschall.DeleteMediaItemsBetween(startposition, endposition,  trackstring, inside)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMediaItems_Position</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, array MediaItemStateChunkArray = ultraschall.DeleteMediaItems_Between(number startposition, number endposition, string trackstring, boolean inside)</functioncall>
  <description>
    Delete the MediaItems between start- and endposition, from the tracks as given by trackstring.
    Returns also a MediaItemStateChunkArray, that contains the statechunks of all deleted MediaItem
  </description>
  <parameters>
    number startposition - the startposition in seconds
    number endposition - the endposition in seconds
    string trackstring - the tracknumbers, separated by a comma
    boolean inside - true, delete only MediaItems that are completely within start and endposition; false, also include MediaItems partially within start and endposition
  </parameters>
  <retvals>
    boolean retval - true, delete was successful; false was unsuccessful
    array MediaItemStateChunkArray - and array with all statechunks of all deleted MediaItems; 
                                   - each statechunk contains an additional entry "ULTRASCHALL_TRACKNUMBER" which holds the tracknumber, in which the deleted MediaItem was located
  </retvals>
  <chapter_context>
    MediaItem Management
    Delete
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, tracks, media, item, delete, between</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("DeleteMediaItemsBetween", "startposition", "must be a number", -1) return false end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("DeleteMediaItemsBetween", "endposition", "must be a number", -2) return false end
  if type(inside)~="boolean" then ultraschall.AddErrorMessage("DeleteMediaItemsBetween", "inside", "must be a boolean", -3) return false end
  if startposition>endposition then ultraschall.AddErrorMessage("DeleteMediaItemsBetween", "endposition", "must be bigger than startposition", -4) return false end
  if ultraschall.IsValidTrackString(trackstring)==false then ultraschall.AddErrorMessage("DeleteMediaItemsBetween", "trackstring", "must be a valid trackstring", -5) return false end
  
  local count=0
  local MediaItemArray
  count, MediaItemArray = ultraschall.GetAllMediaItemsBetween(startposition, endposition, trackstring, inside)
  return ultraschall.DeleteMediaItemsFromArray(MediaItemArray)
end

--A,AA,AAA=ultraschall.DeleteMediaItemsBetween(1000, 250, "1,2,3", false)








-- TODO:

----------------------
---- Color Picker ----
----------------------

function ultraschall.CreateColorTable(startr, startg, startb, endr, endg, endb, number_of_steps)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateColorTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>array ColorTable = ultraschall.CreateColorTable(integer startr, integer startg, integer startb, integer endr, integer endg, integer endb, integer number_of_steps)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns a colortable to be used by color-graphics-functions.
    
    The colorvalue for start and end can be 0 to 255 or the other way round 255 to 0
    
    Can be used by [ApplyColorTableToTrackColors](#ApplyColorTableToTrackColors)
  </description>
  <parameters>
    integer startr - start redvalue, between 0 and 255
    integer startg - start greenvalue, between 0 and 255 
    integer startb - start bluevalue, between 0 and 255
    integer endr - end redvalue, between 0 and 255
    integer endg - end greenvalue, between 0 and 255
    integer endb - end bluevalue, between 0 and 255
    integer number_of_steps - the number of steps from the lowest to the highest r,g,b-color start/end-values
  </parameters>
  <retvals>
    array ColorTable - a colortable for the colors with the number of steps of your choice; 
                     - each indexentry holds entries "r"(0-255), "g"(0-255), "b"(0-255), "nativecolor" and "gfxr"(0-1), "gfxg"(0-1), "gfxb"(0-1).
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, create, colortable</tags>
</US_DocBloc>
]]
  if ultraschall.type(number_of_steps)~="number: integer" or number_of_steps==0 then ultraschall.AddErrorMessage("CreateColorTable", "number_of_steps", "must be a positive or negative integer, no 0 allowed", -1) return nil end
  if ultraschall.type(startr)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "startr", "must be an integer", -2) return nil end
  if ultraschall.type(startg)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "startg", "must be an integer", -3) return nil end
  if ultraschall.type(startb)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "startb", "must be an integer", -4) return nil end
  if ultraschall.type(endr)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "endr", "must be an integer", -5) return nil end
  if ultraschall.type(endg)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "endg", "must be an integer", -6) return nil end
  if ultraschall.type(endb)~="number: integer" then ultraschall.AddErrorMessage("CreateColorTable", "endb", "must be an integer", -7) return nil end

  if startr<0 or startr>255 then ultraschall.AddErrorMessage("CreateColorTable", "startr", "must be between 0 and 255", -8) return nil end
  if startg<0 or startg>255 then ultraschall.AddErrorMessage("CreateColorTable", "startg", "must be between 0 and 255", -9) return nil end
  if startb<0 or startb>255 then ultraschall.AddErrorMessage("CreateColorTable", "startb", "must be between 0 and 255", -10) return nil end
  
  if endr<0 or endr>255 then ultraschall.AddErrorMessage("CreateColorTable", "endr", "must be between 0 and 255", -11) return nil end
  if endg<0 or endg>255 then ultraschall.AddErrorMessage("CreateColorTable", "endg", "must be between 0 and 255", -12) return nil end
  if endb<0 or endb>255 then ultraschall.AddErrorMessage("CreateColorTable", "endb", "must be between 0 and 255", -13) return nil end
  
  local start, stepr, stepg, stepb, steps, stop
  local colortable={}
  if number_of_steps>0 then start=1 stop=number_of_steps steps=1 else start=number_of_steps*-1 stop=1 steps=-1 end
  
  if startr<endr then stepr=(endr-startr)/number_of_steps else stepr=((startr-endr)/number_of_steps)*-1 end
  if startg<endg then stepg=(endg-startg)/number_of_steps else stepg=((startg-endg)/number_of_steps)*-1 end
  if startb<endb then stepb=(endb-startb)/number_of_steps else stepb=((startb-endb)/number_of_steps)*-1 end
  
  if number_of_steps>0 then
    for i=1, number_of_steps do
      colortable[i]={}
      -- standard colors
      colortable[i]["r"]=math.ceil(startr+(i*stepr))
      colortable[i]["g"]=math.ceil(startg+(i*stepg))
      colortable[i]["b"]=math.ceil(startb+(i*stepb))
      
      -- gfx-color-settings
      colortable[i]["gfxr"]=math.ceil(startr+(i*stepr))/255
      colortable[i]["gfxg"]=math.ceil(startg+(i*stepg))/255
      colortable[i]["gfxb"]=math.ceil(startb+(i*stepb))/255
      
      -- native color
      colortable[i]["nativecolor"]=ultraschall.ConvertColor(colortable[i]["r"], colortable[i]["g"], colortable[i]["b"])
    end
  end
  return colortable
end

--A=ultraschall.CreateColorTable(1, 1, 1, 255, 0, 255, 6)
--B=ultraschall.CreateColorTable(255, 255, 0, 1, 1, 1, -7)
--A=ultraschall.CreateColorTable(0, 0, 0,  255, 0, 0,  10)
--B=ultraschall.CreateColorTable(255, 0, 0,  0, 0, 0, 10)


function ultraschall.CreateSonicRainboomColorTable()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateSonicRainboomColorTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>array ColorTable = ultraschall.CreateSonicRainboomColorTable()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns a colortable in Ultraschall's standard-trackcolor-setting "Sonic Rainboom"-style.
    
    Can be used by [ApplyColorTableToTrackColors](#ApplyColorTableToTrackColors)
  </description>
  <retvals>
    array ColorTable - a colortable with all values for Ultraschall's track-color "Sonic Rainboom"
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, create, colortable, sonic rainboom</tags>
</US_DocBloc>
]]
  local group={}
  group[0]=16753246
  group[1]=15774556
  group[2]=15451994
  group[3]=15129178
  group[4]=14016600
  group[5]=12245846
  group[6]=9098835
  group[7]=6082898
  group[8]=4837750
  group[9]=2806183
  group[10]=4120575
  group[11]=4100351
  group[12]=5073919
  group[13]=4803058
  group[14]=7555570
  group[15]=11225586
  group[16]=15878614
  group[17]=16741328
  group[18]=16741270
  group[19]=16747136
  group[20]=12615680
  group[21]=32960
  group[22]=12583040
  local group2={}
  for i=1, 20 do
    group2[i]={}
    group2[i]["nativecolor"]=group[i-1]
    group2[i]["r"], group2[i]["g"], group2[i]["b"] = ultraschall.ConvertColorReverse(group2[i]["nativecolor"])
    -- gfx-color-settings
    group2[i]["gfxr"]=group2[i]["r"]/255
    group2[i]["gfxg"]=group2[i]["g"]/255
    group2[i]["gfxb"]=group2[i]["b"]/255
  end
  return group2
end

--L=ultraschall.CreateSonicRainboomColorTable()

function ultraschall.IsValidColorTable(ColorTable)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidColorTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidColorTable(array ColorTable)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Checks for valid color-tables.
  </description>
  <parameters>
    array ColorTable - a table to check for being a valid ColorTable
  </parameters>
  <retvals>
    boolean retval - true, if it's a valid ColorTable; false, if it's not a valid ColorTable
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, check, colortable</tags>
</US_DocBloc>
]]
  if type(ColorTable)~="table" then ultraschall.AddErrorMessage("CreateColorTable", "ColorTable", "must be a table", -1) return false end
  local Count1 = ultraschall.CountEntriesInTable_Main(ColorTable)
  if Count1==-1 then return false end
  if ColorTable[1]~=nil and
     (ultraschall.type(ColorTable[1]["r"])~="number: integer" or 
     ultraschall.type(ColorTable[1]["g"])~="number: integer" or 
     ultraschall.type(ColorTable[1]["b"])~="number: integer" or 
     ultraschall.type(ColorTable[1]["nativecolor"])~="number: integer") then
     return false
  end
  for i=2, Count1 do
    if ColorTable[1]~=nil and
      (ultraschall.type(ColorTable[i]["r"])~="number: integer" or 
       ultraschall.type(ColorTable[i]["g"])~="number: integer" or 
       ultraschall.type(ColorTable[i]["b"])~="number: integer" or 
       ultraschall.type(ColorTable[i]["nativecolor"])~="number: integer") then
       return false
    end
  end
  return true
end

function ultraschall.ConcatIntegerIndexedTables(table1, table2)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConcatIntegerIndexedTables</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer numentries, array concatenated_table = ultraschall.ConcatIntegerIndexedTables(array table1, array table2)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Concatenates the entries of two tables into one table. The entries of each table must be indexed by integers
    
    The new table still has the same references as the old table, means: if you remove the old tables/entries in the old tables, the concatenated table/accompanying entries will loose elements.
    To get a "true"-concatenated copy, you should first create new copies of the tables, using [MakeCopyOfTable](#MakeCopyOfTable).
  </description>
  <parameters>
    array table1 - the first table to be concatenated; the entries must be indexed by integer-numbers!
    array table2 - the second table to be concatenated; the entries must be indexed by integer-numbers!
  </parameters>
  <retvals>
    integer numentries - the number of entries in the new table
    array concatenated_table - the new concatenated table
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, concatenate, concat, table, tables</tags>
</US_DocBloc>
]]
  local Count1 = ultraschall.CountEntriesInTable_Main(table1)
  local Count2 = ultraschall.CountEntriesInTable_Main(table2)
  local NewTable={}
  local TableCount=1
  for i=1, Count1 do
    NewTable[TableCount]=table1[i]
    TableCount=TableCount+1
  end
  for i=1, Count2 do
    NewTable[TableCount]=table2[i]
    TableCount=TableCount+1
  end
  return Count1+Count2, NewTable
end

--C,A0=ultraschall.ConcatIntegerIndexedTables(B, A)


function ultraschall.ApplyColorTableToTrackColors(ColorTable, Spread, StartTrack, EndTrack)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyColorTableToTrackColors</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyColorTableToTrackColors(array ColorTable, integer Spread, integer StartTrack, integer EndTrack)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Apply a ColorTable to Tracks, to colorize MediaTracks
    
    ColorTables can be created by [CreateColorTable](#CreateColorTable)
  </description>
  <parameters>
    array ColorTable - the ColorTable to apply to the MediaTrackColors
    integer Spread - 0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than tracks in the project
                   - nil or 1, repeat the colors from the ColorTable over and over again over the tracks; means: if you have 10 tracks and 5 colors, the colors will fill track 1 to 5 and then again track 6 to 10
                   - 2, spread the colors from the ColorTable over all tracks equally
    integer StartTrack - the first track to colorize; nil, to use the first track in project
    integer EndTrack - the last track to colorize; nil, to use the last track in project
  </parameters>
  <retvals>
    boolean retval - true, adjusting track-colors was successful; false, adjusting track-colors was unsuccessful
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, apply, colortable, colorize, mediatracks</tags>
</US_DocBloc>
]]
  local Count1 = ultraschall.CountEntriesInTable_Main(ColorTable)
  local Count2 = 1
  local step=1
  if ultraschall.IsValidColorTable(ColorTable)==false or Count1<Count2 then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "Colortable", "Must be a valid ColorTable with at least on entry", -1) return false end
  if Spread==nil then Spread=1 end
  if Spread~=nil and math.type(Spread)~="integer" then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "Spread", "must be an integer", -2) return false end
  if Spread<0 or Spread>2 then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "Spread", "must be between 0 and 2", -3) return false end
  if Spread==0 and Count1<reaper.CountTracks(0) then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "ColorTable", "Not enough colors in Colortable for the current number of tracks", -4) return false end
  if Spread==1 then step=1 end
  if Spread==2 then step=Count1/reaper.CountTracks(0) end
  if math.type(StartTrack)==nil and reaper.CountTracks(0)>0 then StartTrack=1 end
  if math.type(EndTrack)==nil and reaper.CountTracks(0)>0 then EndTrack=reaper.CountTracks(0) end
  if math.type(StartTrack)~="integer" then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "StartTrack", "Must be an integer", -5) return false end
  if math.type(EndTrack)~="integer" then ultraschall.AddErrorMessage("ApplyColorTableToTrackColors", "EndTrack", "Must be an integer", -6) return false end

  for i=StartTrack, EndTrack do
--  reaper.MB(Count2.." "..math.floor(Count2),StartTrack.." "..EndTrack,0)
    local MediaTrack=reaper.GetTrack(0,i-1)
    if Count2>Count1 then Count2=1 end
    reaper.SetTrackColor(MediaTrack, ColorTable[math.ceil(Count2)]["nativecolor"])
    Count2=Count2+step
  end
  return true
end


--ultraschall.ApplyColorTableToTrackColors(L, 2, 2, 6)


function ultraschall.ApplyColorTableToItemColors(ColorTable, Spread, MediaItemArray)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyColorTableToItemColors</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyColorTableToItemColors(array ColorTable, integer Spread, MediaItemArray MediaItemArray)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Apply a ColorTable to MediaItems in a MediaItemArray, to colorize MediaItems
    
    ColorTables can be created by [CreateColorTable](#CreateColorTable)
  </description>
  <parameters>
    array ColorTable - the ColorTable to apply to the MediaItemColors
    integer Spread - 0, apply ColorTable once; will return false, if fewer colors are in ColorTable available than items in the MediaItemArray
                   - nil or 1, repeat the colors from the ColorTable over and over again over the item; means: if you have 10 items and 5 colors, the colors will fill items 1 to 5 and then again items 6 to 10
                   - 2, spread the colors from the ColorTable over all items equally
    MediaItemArray MediaItemArray - an array with all the MediaItems to colorize
  </parameters>
  <retvals>
    boolean retval - true, adjusting item-colors was successful; false, adjusting item-colors was unsuccessful
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, apply, colortable, mediaitems, colorize</tags>
</US_DocBloc>
]]
  local Count1 = ultraschall.CountEntriesInTable_Main(ColorTable)
  local Count3 = ultraschall.CountEntriesInTable_Main(MediaItemArray)
  local Count2 = 1
  local step=1
  if ultraschall.IsValidColorTable(ColorTable)==false or Count1<Count2 then ultraschall.AddErrorMessage("ApplyColorTableToItemColors", "Colortable", "Must be a valid ColorTable with at least on entry", -1) return false end
  if ultraschall.IsValidMediaItemArray(MediaItemArray)==false or Count1<Count2 then ultraschall.AddErrorMessage("ApplyColorTableToItemColors", "MediaItemArray", "Must be a valid MediaItemArray", -2) return false end
  if Spread==nil then Spread=1 end
  if Spread~=nil and math.type(Spread)~="integer" then ultraschall.AddErrorMessage("ApplyColorTableToItemColors", "Spread", "must be an integer", -3) return false end
  if Spread<0 or Spread>2 then ultraschall.AddErrorMessage("ApplyColorTableToItemColors", "Spread", "must be between 0 and 2", -4) return false end
  if Spread==0 and Count1<Count3 then ultraschall.AddErrorMessage("ApplyColorTableToItemColors", "ColorTable", "Not enough colors in Colortable for the number of Items in MediaItemArray", -5) return false end
  if Spread==1 then step=1 end
  if Spread==2 then step=(Count1-1)/(Count3-1) end

  for i=1, Count3-1 do
    local col=ColorTable[math.ceil(Count2)]["nativecolor"]
    local retval = reaper.SetMediaItemInfo_Value(MediaItemArray[i],"I_CUSTOMCOLOR", -col|0x100000)
    Count2=Count2+step
    if Count2>Count1 then Count2=1 end
  end
  return true
end

--L=ultraschall.CreateSonicRainboomColorTable()
--A,B,C,D,E=ultraschall.GetAllMediaItemsBetween(0,10,"1,2,3,4,5,6",false)
--ultraschall.ApplyColorTableToItemColors(L, 2, B)
--reaper.UpdateArrange()


function ultraschall.ReverseTable(the_table)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReverseTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>table reversed_table, integer entry_count = ultraschall.ReverseTable(table the_table)</functioncall>
  <description>
    reversed the order of the entries of a table, means, the last entry will become the first, the first become the last, etc.
    The table must be indexed by integers.
    
    Returns nil if table isn't a valid table
  </description>
  <parameters>
    table table - the table, whose entries you want to reverse
  </parameters>
  <retvals>
    table reversed_table - the resulting table with the reversed order of all entries
    integer entry_count - the number of entries in the reversed_table
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, reverse, entries, table, array, maintable</tags>
</US_DocBloc>
--]]
  if type(the_table)~="table" then ultraschall.AddErrorMessage("ReverseTable", "the_table", "Must be a table.", -1) return nil end
  local count=ultraschall.CountEntriesInTable_Main(the_table)
  local table2={}
  local count2=1
  for i=count, 1, -1 do
    table2[count2]=the_table[i]
    count2=count2+1
  end
  return table2, count2-1
end

-- DDD={1,2,3,4,5,6,7,8,9,10}
--A,B=ultraschall.ReverseTable(DDD)


function ultraschall.TracksToColorPattern(colorpattern, startingcolor, direction)
end

--A=reaper.GetTrackColor(reaper.GetTrack(0,0))



function ultraschall.ChangeColorBrightness(r, g, b, bright_r, bright_g, bright_b)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeColorBrightness</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer red, integer green, integer blue, boolean retval = ultraschall.ChangeColorBrightness(integer r, integer g, integer b, integer bright_r, optional integer bright_g, optional integer bright_b)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Changes brightness of a colorvalue. If you only set bright_r without setting bright_g and bright_b, then the value for bright_r will affect g and b as well.
    
    If a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.
    
    returns color-value 0,0,0 and retval=false in case of an error
  </description>
  <parameters>
    integer r - the red-value to be changed
    integer g - the green-value to be changed
    integer b - the blue-value to be changed
    integer bright_r - the change in brightness for the red-color; positive, brighter; negative, darker
    optional integer bright_g - the change in brightness for the green-color; positive, brighter; negative, darker; if nil, value in bright_r will be used
    optional integer bright_b - the change in brightness for the blue-color; positive, brighter; negative, darker; if nil, value in bright_r will be used
  </parameters>
  <retvals>
    integer red - the new red-value
    integer green - the new green-value
    integer blue - the new blue-value
    boolean retval - true, color-calculation was successful; false, color-calculation was unsuccessful
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, change, color, brightness</tags>
</US_DocBloc>
]]
  if math.type(r)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "r", "must be an integer", -1) return 0, 0, 0, false end
  if r<0 or r>255 then  ultraschall.AddErrorMessage("ChangeColorBrightness", "r", "must be between 0 and 255", -2) return 0, 0, 0, false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "g", "must be an integer", -3) return 0, 0, 0, false end
  if g<0 or g>255 then  ultraschall.AddErrorMessage("ChangeColorBrightness", "g", "must be between 0 and 255", -4) return 0, 0, 0, false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "b", "must be an integer", -5) return 0, 0, 0, false end
  if b<0 or b>255 then  ultraschall.AddErrorMessage("ChangeColorBrightness", "b", "must be between 0 and 255", -6) return 0, 0, 0, false end

  if math.type(bright_r)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_r", "must be an integer", -7) return 0, 0, 0, false end
  if bright_r~=nil and (bright_r<-256 or bright_r>255) then  ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_r", "must be between 0 and 255", -8) return 0, 0, 0, false end
  if bright_g~=nil and math.type(bright_g)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_g", "must be either nil or an integer", -9) return 0, 0, 0, false end
  if bright_g~=nil and (bright_g<-256 or bright_g>255) then ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_g", "must be between 0 and 255", -10) return 0, 0, 0, false end  
  if bright_b~=nil and math.type(bright_b)~="integer" then ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_b", "must be either nil or an integer", -11) return 0, 0, 0, false end
  if bright_b~=nil and (bright_b<-256 or bright_b>255) then ultraschall.AddErrorMessage("ChangeColorBrightness", "bright_b", "must be between 0 and 255", -12) return 0, 0, 0, false end  
  
  if bright_g==nil then bright_g=bright_r end
  if bright_b==nil then bright_b=bright_r end
  
  r=r+bright_r
  g=g+bright_g
  b=b+bright_b

  if r>255 then r=255 end
  if g>255 then g=255 end
  if b>255 then b=255 end
  if r<0 then r=0 end
  if g<0 then g=0 end
  if b<0 then b=0 end
  return r,g,b, true
end

--A1, B1, C1, D1 = ultraschall.ChangeColorBrightness(A0, B0, C0, -10,1,9)
--reaper.SetTrackColor(reaper.GetTrack(0,0), ultraschall.ConvertColor(A1,B1,C1))

function ultraschall.ChangeColorContrast(r, g, b, Minimum_r, Maximum_r, Minimum_g, Maximum_g, Minimum_b, Maximum_b)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeColorContrast</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer red, integer green, integer blue, boolean retval = ultraschall.ChangeColorContrast(integer r, integer g, integer b, integer Minimum_r, optional integer Maximum_r, optional integer Minimum_g, optional integer Maximum_g, optional integer Minimum_b, optional integer Maximum_b)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Changes contrast of a colorvalue.
    
    Minimum will set the new minimal, Maximum will set the new maximum-brightness-level.
    If you set Minimum to 0 and Maximum to 255, contrast will not change.
    
    The lower you set Minimum/Maximum, the darker it becomes; the higher, the brighter it becomes.
    The farther away Minimum is from Maximum, the stronger the contrast becomes; the closer Minimum is to Maximum, the weaker the contrast becomes.
    
    If you only set Minimum_r and Maximum_r, then these values will be applied to g and b too.
    
    If you omit/set to nil a Maximum-value; it's default value will be 255.
    
    If a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.
    
    returns color-value 0,0,0 and retval=false in case of an error
  </description>
  <parameters>
    integer r - the red-value to be changed
    integer g - the green-value to be changed
    integer b - the blue-value to be changed
    integer Minimum_r - the new minimum brightness of the contrast-range of the red-color
    optional integer Maximum_r - the new maximum brightness of the contrast-range of the red-color; if nil, it will be seen as 255
    optional integer Minimum_g - the new minimum brightness of the contrast-range of the green-color; if nil, it will use the value of Minimum_r
    optional integer Maximum_g - the new maximum brightness of the contrast-range of the green-color; if nil, it will be seen as 255
    optional integer Minimum_b - the new minimum brightness of the contrast-range of the blue-color; if nil, it will use the value of Minimum_r
    optional integer Maximum_b - the new maximum brightness of the contrast-range of the blue-color; if nil, it will be seen as 255
  </parameters>
  <retvals>
    integer red - the new red-value
    integer green - the new green-value
    integer blue - the new blue-value
    boolean retval - true, color-calculation was successful; false, color-calculation was unsuccessful
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, change, color, brightness</tags>
</US_DocBloc>
]]
  if Minimum_g==nil then Minimum_g=Minimum_r end
  if Minimum_b==nil then Minimum_b=Minimum_r end
  if Maximum_g==nil then Maximum_g=Maximum_r end
  if Maximum_b==nil then Maximum_b=Maximum_r end
  local ding

  if math.type(r)~="integer" then ultraschall.AddErrorMessage("ChangeColorContrast", "r", "must be an integer", -1) return 0, 0, 0, false end
  if r<0 or r>255 then  ultraschall.AddErrorMessage("ChangeColorContrast", "r", "must be between 0 and 255", -2) return 0, 0, 0, false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("ChangeColorContrast", "g", "must be an integer", -3) return 0, 0, 0, false end
  if g<0 or g>255 then  ultraschall.AddErrorMessage("ChangeColorContrast", "g", "must be between 0 and 255", -4) return 0, 0, 0, false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("ChangeColorContrast", "b", "must be an integer", -5) return 0, 0, 0, false end
  if b<0 or b>255 then  ultraschall.AddErrorMessage("ChangeColorContrast", "b", "must be between 0 and 255", -6) return 0, 0, 0, false end

  if math.type(Minimum_r)~="integer" then ultraschall.AddErrorMessage("ChangeColorContrast", "Minimum_r", "must be an integer", -7) return 0, 0, 0, false end
  if Minimum_g~=nil and math.type(Minimum_g)~="integer"then ultraschall.AddErrorMessage("ChangeColorContrast", "Minimum_g", "must be either nil or an integer", -8) return 0, 0, 0, false end
  if Minimum_b~=nil and math.type(Minimum_b)~="integer" then ultraschall.AddErrorMessage("ChangeColorContrast", "Minimum_b", "must be either nil or an integer", -9) return 0, 0, 0, false end

  if Maximum_r~=nil and math.type(Maximum_r)~="integer"then ultraschall.AddErrorMessage("ChangeColorContrast", "Maximum_r", "must be either nil or an integer", -10) return 0, 0, 0, false end
  if Maximum_g~=nil and math.type(Maximum_g)~="integer"then ultraschall.AddErrorMessage("ChangeColorContrast", "Maximum_g", "must be either nil or an integer", -11) return 0, 0, 0, false end
  if Maximum_b~=nil and math.type(Maximum_b)~="integer"then ultraschall.AddErrorMessage("ChangeColorContrast", "Maximum_b", "must be either nil or an integer", -12) return 0, 0, 0, false end

  if Maximum_r==nil then Maximum_r=255 ding=true end
  if ding==true and Minimum_r>0 then Maximum_r=Maximum_r-Minimum_r end
  local Dyn_r=Maximum_r-Minimum_r
  ding=false

  if Maximum_g==nil then Maximum_g=255 ding=true end
  if ding==true and Minimum_g>0 then Maximum_g=Maximum_g-Minimum_g end
  local Dyn_g=Maximum_g-Minimum_g
  ding=false

  if Maximum_b==nil then Maximum_b=255 ding=true end
  if ding==true and Minimum_b>0 then Maximum_b=Maximum_b-Minimum_b end
  local Dyn_b=Maximum_b-Minimum_b
  ding=false
  
  r=r/255*Dyn_r
  r=r+Minimum_r

  g=g/255*Dyn_g
  g=g+Minimum_g
  
  b=b/255*Dyn_b
  b=b+Minimum_b
  
  if r>255 then r=255 end
  if g>255 then g=255 end
  if b>255 then b=255 end
  if r<0 then r=0 end
  if g<0 then g=0 end
  if b<0 then b=0 end
  return math.floor(r), math.floor(g), math.floor(b), true
end

--A1, B1, C1 = ultraschall.ChangeColorContrast(10, 100, 200, 100, 255, 100, 255, 100, 255)


function ultraschall.ChangeColorSaturation(r,g,b,delta)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ChangeColorSaturation</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer red, integer green, integer blue, number median, boolean retval = ultraschall.ChangeColorSaturation(integer r, integer g, integer b, integer delta)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Changes saturation of a colorvalue by delta.
    
    If a color-value becomes >255 or <0, it will be set to 255 or 0 respectively.
    
    returns color-value 0,0,0 and retval=false in case of an error
  </description>
  <parameters>
    integer r - the red-value to be changed
    integer g - the green-value to be changed
    integer b - the blue-value to be changed
    integer delta - the saturation/desaturation-value; negative, desaturates color; positive, saturates color
  </parameters>
  <retvals>
    integer red - the new red-value
    integer green - the new green-value
    integer blue - the new blue-value
    number median - the median-value, calculated from the the old red, green and blue, values (red+green+blue)/3, which is the basis for the brightness of the unsaturated value
    boolean retval - true, color-calculation was successful; false, color-calculation was unsuccessful
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, change, color, saturation</tags>
</US_DocBloc>
]]
  if math.type(r)~="integer" then ultraschall.AddErrorMessage("ChangeColorSaturation", "r", "must be an integer", -1) return 0, 0, 0, 0, false end
  if r<0 or r>255 then  ultraschall.AddErrorMessage("ChangeColorSaturation", "r", "must be between 0 and 255", -2) return 0, 0, 0, 0, false end
  if math.type(g)~="integer" then ultraschall.AddErrorMessage("ChangeColorSaturation", "g", "must be an integer", -3) return 0, 0, 0, 0, false end
  if g<0 or g>255 then  ultraschall.AddErrorMessage("ChangeColorSaturation", "g", "must be between 0 and 255", -4) return 0, 0, 0, 0, false end
  if math.type(b)~="integer" then ultraschall.AddErrorMessage("ChangeColorSaturation", "b", "must be an integer", -5) return 0, 0, 0, 0, false end
  if b<0 or b>255 then  ultraschall.AddErrorMessage("ChangeColorSaturation", "b", "must be between 0 and 255", -6) return 0, 0, 0, 0, false end

  if math.type(delta)~="integer" then ultraschall.AddErrorMessage("ChangeColorSaturation", "delta", "must be an integer", -7) return 0, 0, 0, 0, false end
  
  local Median=(r+g+b)/3
  delta=delta*-1
  
  if r>Median then r=r-delta if r<Median then r=Median end elseif r<Median then r=r+delta if r>Median then r=Median end end
  if g>Median then g=g-delta if g<Median then g=Median end elseif g<Median then g=g+delta if g>Median then g=Median end end
  if b>Median then b=b-delta if b<Median then b=Median end elseif b<Median then b=b+delta if b>Median then b=Median end end

  if r>255 then r=255 end
  if g>255 then g=255 end
  if b>255 then b=255 end
  if r<0 then r=0 end
  if g<0 then g=0 end
  if b<0 then b=0 end
    
  return math.floor(r),math.floor(g),math.floor(b), Median, true
end
--ultraschall.ToggleIDE_Errormessages()
--A,B,C,D=ultraschall.ChangeColorSaturation(1,100,200,10)

--for i=0, reaper.CountTracks()-1 do
--  A0, B0, C0 = ultraschall.ConvertColorReverse(reaper.GetTrackColor(reaper.GetTrack(0,i)))
--  A,B,C,D=ultraschall.ChangeColorSaturation(A0, B0, C0, 10)
--  reaper.SetTrackColor(reaper.GetTrack(0,i), ultraschall.ConvertColor(A,B,C))
--end

---------------------------
---- Routing Snapshots ----
---------------------------

function ultraschall.SetRoutingSnapshot(snapshot_nr)
end

function ultraschall.RecallRoutingSnapshot(snapshot_nr)
end

function ultraschall.ClearRoutingSnapshot(snapshot_nr)
end

-----------------------
---- Render Export ----
-----------------------


function ultraschall.RippleDragSection_StartOffset(position,trackstring)
end

function ultraschall.RippleDrag_End(position,trackstring)

end

function ultraschall.RippleDragSection_End(position,trackstring)
end



--ultraschall.ShowLastErrorMessage()

function ultraschall.GetProjectReWireSlave(projectfilename_with_path)
--To Do
-- ProjectSettings->Advanced->Rewire Slave Settings
end

function ultraschall.GetLastEnvelopePoint(Envelopeobject)
end

function ultraschall.GetAllTrackEnvelopes_EnvelopePointArray(tracknumber)
--returns all track-envelopes from tracknumber as EnvelopePointArray
end

function ultraschall.GetAllTrackEnvelopes_EnvelopePointArray2(MediaTrack)
--returns all track-envelopes from MediaTrack as EnvelopePointArray
end



function ultraschall.OnlyMediaItemsInBothMediaItemArrays()
end

function ultraschall.OnlyMediaItemsInOneMediaItemArray()
end

function ultraschall.GetMediaItemTake_StateChunk(MediaItem, idx)
--returns an rppxml-statechunk for a MediaItemTake (not existing yet in Reaper!), for the idx'th take of MediaItem

--number reaper.GetMediaItemTakeInfo_Value(MediaItem_Take take, string parmname)
--MediaItem reaper.GetMediaItemTake_Item(MediaItem_Take take)

--[[Get parent item of media item take

integer reaper.GetMediaItemTake_Peaks(MediaItem_Take take, number peakrate, number starttime, integer numchannels, integer numsamplesperchannel, integer want_extra_type, reaper.array buf)
Gets block of peak samples to buf. Note that the peak samples are interleaved, but in two or three blocks (maximums, then minimums, then extra). Return value has 20 bits of returned sample count, then 4 bits of output_mode (0xf00000), then a bit to signify whether extra_type was available (0x1000000). extra_type can be 115 ('s') for spectral information, which will return peak samples as integers with the low 15 bits frequency, next 14 bits tonality.

PCM_source reaper.GetMediaItemTake_Source(MediaItem_Take take)
Get media source of media item take

MediaTrack reaper.GetMediaItemTake_Track(MediaItem_Take take)
Get parent track of media item take


MediaItem_Take reaper.GetMediaItemTakeByGUID(ReaProject project, string guidGUID)
--]]
end

function ultraschall.GetAllMediaItemTake_StateChunks(MediaItem)
--returns an array with all rppxml-statechunk for all MediaItemTakes of a MediaItem.
end


function ultraschall.GetItemStateChunk(MediaItem, AddTracknumber)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetItemStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string MediaItemStateChunk = ultraschall.GetItemStateChunk(MediaItem MediaItem, boolean AddTracknumber)</functioncall>
  <description>
    Returns the statechunk of MediaItem. Parameter AddTracknumber allows you to set, whether the tracknumber of the MediaItem shall be inserted to the statechunk as well, by the new entry "ULTRASCHALL_TRACKNUMBER".
    
    returns false in case of an error
  </description>
  <parameters>
    MediaItem MediaItem - the MediaItem, whose statechunk you want to have
    boolean AddTracknumber - nil or true; add the tracknumber, where the MediaItem lies, as additional entry entry "ULTRASCHALL_TRACKNUMBER" to the statechunk; false, just return the original statechunk.
  </parameters>
  <retvals>
    boolean retval - true, if getting the statechunk was successful; false, if not
    string MediaItemStateChunk - the statechunk of the MediaItem
  </retvals>
  <chapter_context>
    MediaItem Management
    Get MediaItem States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, get, statechunk, tracknumber</tags>
</US_DocBloc>
]]
  if ultraschall.type(MediaItem)~="MediaItem" then ultraschall.AddErrorMessage("GetItemStateChunk","MediaItem", "must be a MediaItem", -1) return false end
  if AddTracknumber~=nil and ultraschall.type(AddTracknumber)~="boolean" then ultraschall.AddErrorMessage("GetItemStateChunk","AddTracknumber", "must be a boolean", -1) return false end
  _temp, statechunk=reaper.GetItemStateChunk(MediaItem, "", false)
  if AddTracknumber~=false then statechunk=ultraschall.SetItemUSTrackNumber_StateChunk(statechunk, math.floor(reaper.GetMediaItemInfo_Value(MediaItem, "P_TRACK"))+1) end
  return true, statechunk
end

--MediaItem = reaper.GetMediaItem(0,0)
--temp, dstatechunk = ultraschall.GetItemStateChunk(MediaItem, false)
--reaper.MB(dstatechunk,"",0)

--A,AA=ultraschall.SectionCut(24,60,"1,2,3,4")
--number_items, MediaItemArray_StateChunk = ultraschall.RippleCut(20, 50, "1,4,5,7", false, true)

--reaper.MB(MediaItemArray_StateChunk[1],"",0)



function ultraschall.GetDuplicatesFromArrays(array1, array2)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetDuplicatesFromArrays</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer duplicate_count, array duplicate_array, integer originalscount_array1, array originals_array1, integer originalscount_array2, array originals_array2  = ultraschall.GetDuplicatesFromArrays(array array1, array array2)</functioncall>
  <description>
    Returns the duplicates and the originals(entries only in one of the arrays) of two arrays. It will also return the number of entries.
    
    This works only on arrays with integer-indexed entries; index must start with index 1!
    
    returns -1 in case of an error
  </description>
  <parameters>
    array array1 - the first array to check for duplicates and "original"-entries
    array array2 - the second array to check for duplicates and "original"-entries
  </parameters>
  <retvals>
    integer duplicate_count - the number of entries in both arrays
    array duplicate_array - the entries in both arrays
    integer originalscount_array1 - the number of entries only in array1
    array originals_array1 - the entries that are only existing in array1
    integer originalscount_array2 - the number of entries only in array2
    array originals_array2 - the entries that are only existing in array2
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helperfunctions, get, duplicates, originals, arrays</tags>
</US_DocBloc>
]]
  if type(array1)~="table" then ultraschall.AddErrorMessage("GetDuplicatesFromArrays", "array1", "must be a table", -1) return -1 end
  if type(array2)~="table" then ultraschall.AddErrorMessage("GetDuplicatesFromArrays", "array2", "must be a table", -2) return -1 end
  local count1 = ultraschall.CountEntriesInTable_Main(array1)
  local count2 = ultraschall.CountEntriesInTable_Main(array2)
  local duplicates={}
  local originals1={}
  local originals2={}
  local dupcount=0
  local orgcount1=0
  local orgcount2=0
  local found=false
  
  for i=1, count2 do
    for a=1, count1 do
      if array2[i]==array1[a] then 
        dupcount=dupcount+1
        duplicates[dupcount]=array2[i]
        found=true
      end
    end
    if found==false then orgcount2=orgcount2+1 originals2[orgcount2]=array2[i] end
    found=false
  end

  for i=1, count1 do
    for a=1, count2 do
      if array1[i]==array2[a] then 
        found=true
      end
    end
    if found==false then orgcount1=orgcount1+1 originals1[orgcount1]=array1[i] end
    found=false
  end
  
  return dupcount, duplicates, orgcount1, originals1, orgcount2, originals2
end

--function main()
--  filecount2, files2 = ultraschall.GetAllFilesnamesInPath("c:\\Tudelu\\")
--  A, A1, B, B1, C, C1 = ultraschall.GetDuplicatesFromArrays(files, files2)
--  reaper.defer(main)
--end


--filecount, files = ultraschall.GetAllFilesnamesInPath("c:\\Tudelu\\")


function ultraschall.OnlyFilesOfCertainType(filearray, filetype)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>OnlyFilesOfCertainType</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer foundfilecount, array foundfilearray = ultraschall.OnlyFilesOfCertainType(array filearray, string filetype)</functioncall>
  <description>
    Returns the filenames_with_path from a filearray, that are of a certain filetype
    
    returns -1 in case of an error
  </description>
  <parameters>
    array filearray - an array with files to check for; index is 1-based
    string fileformat - the format of the file; JPG, PNG, GIF, LCF, ICO, WAV, AIFF, ASF/WMA/WMV, MP3, MP3 -ID3TAG, FLAC, MKV/MKA/MKS/MK3D/WEBM, AVI, RPP_PROJECT, unknown
  </parameters>
  <retvals>
    integer foundfilecount - the number of files that contain the right filetype
    array foundfilearray - an array with all the files that contain the right filetype
  </retvals>
  <chapter_context>
    File Management
    File Analysis
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, get, filetype</tags>
</US_DocBloc>
]]
  if type(filearray)~="table" then ultraschall.AddErrorMessage("OnlyFilesOfCertainType", "filearray", "must be a table", -1) return -1 end
  if type(filetype)~="string" then ultraschall.AddErrorMessage("OnlyFilesOfCertainType", "filetype", "must be a string", -2) return -1 end
  local foundfiles={}
  local count=1
  local foundcount=0
  while filearray[count]~=nil do
    local foundfiletype=ultraschall.CheckForValidFileFormats(filearray[count])
    if foundfiletype==filetype then foundcount=foundcount+1 foundfiles[foundcount]=filearray[count] end
    count=count+1
  end
  return foundcount, foundfiles
end

--local A={"C:\\MarkerProject.RPP","C:\\tudel.aif"}
--A={"C:\\MarkerProject.RPP","C:\\Reaper-Internal-Docs.wav"}
--B,C=ultraschall.OnlyFilesOfCertainType(A,"RPP_PROJECT")

function ultraschall.GetReaperWorkDir()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperWorkDir</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string current_workdir = ultraschall.GetReaperWorkDir()</functioncall>
  <description>
    returns the current workdir, which is the directory. If you create a file without giving a path, this file will be created in this work-dir.
  </description>
  <retvals>
    string current_workdir - the current workdir of Reaper
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, get, current workdir of reaper</tags>
</US_DocBloc>
]]
  local temp, dir = ultraschall.GetIniFileValue("REAPER", "lastcwd", "", reaper.get_ini_file())
  return dir
end

--A,B=ultraschall.GetCurrentReaperWorkDir()

function ultraschall.DirectoryExists2(Path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DirectoryExists2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DirectoryExists2(string Path)</functioncall>
  <description>
    returns, if Path is an existing path.

    returns false in case of an error
  </description>
  <parameters>
    string Path - the path to check for
  </parameters>
  <retvals>
    boolean retval - true, if path exists; false, if not
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, check, directory, existence</tags>
</US_DocBloc>
]]
  if ultraschall.type(Path)~="string" then ultraschall.AddErrorMessage("DirectoryExists2", "path", "must be a string", -1) return false end
  if Path:len()==0 then return false end
  if Path:sub(-1,-1)=="\\" or Path:sub(-1,-1)=="/" then Path=Path:sub(1,-2) end

  local Path0=string.gsub(Path,"\\","/")
  Path=string.gsub(Path,"/","\\")
  local Path1, Path2 = Path0:match("(.*)/(.*)")

  if ultraschall.IsOS_Windows()==true then 
    local LL2=tonumber(reaper.ExecProcess("cmd.exe /Q /C cd "..Path, 1000):match("(.-)\n"))
    if LL2==1 then return false else return true end
  else
    return ultraschall.DirectoryExists(Path1, Path2)
  end
end

--L=os.tmpname("C:\\B\\tudelu")

--Path="C:\\"
--L=Path:sub(2,2)

--A,B=ultraschall.DirectoryExists2("c://")

function ultraschall.SetReaperWorkDir(path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetReaperWorkDir</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetReaperWorkDir(string Path)</functioncall>
  <description>
    sets a new current working directory for Reaper. This requires a restart of Reaper to take effect, due API-limitations!
                            
    returns false in case of an error
  </description>
  <parameters>
    string Path - the path to set as new current working directory
  </parameters>
  <retvals>
    boolean retval - true, if path could be set; false, if not
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, set, new workdir of reaper</tags>
</US_DocBloc>
]]
  if ultraschall.type(path)~="string" then ultraschall.AddErrorMessage("SetReaperWorkDir", "path", "must be a string", -1) return false end
  if ultraschall.DirectoryExists2(path)==false then ultraschall.AddErrorMessage("SetReaperWorkDir", "path", "no such path exists", -2) return false end
  return ultraschall.SetIniFileValue("REAPER", "lastcwd", path, reaper.get_ini_file())
end

--A=ultraschall.SetReaperWorkDir("C:\\Tudelu\\Tudelu")
--B=ultraschall.GetCurrentReaperWorkDir()

function ultraschall.GetScriptFilenameFromActionCommandID(action_command_id)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScriptFilenameFromActionCommandID</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>string scriptfilename_with_path = ultraschall.GetScriptFilenameFromActionCommandID(string action_command_id)</functioncall>
  <description>
    returns the filename with path of a script, associated to a ReaScript.
    Command-ID-numbers do not work!
                            
    returns false in case of an error
  </description>
  <parameters>
    string Path - the path to set as new current working directory
  </parameters>
  <retvals>
    string scriptfilename_with_path - the scriptfilename with path associated with this ActionCommandID
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, get, scriptfilename, actioncommandid</tags>
</US_DocBloc>
]]
  if ultraschall.type(action_command_id)~="string" then ultraschall.AddErrorMessage("GetScriptFilenameFromActionCommandID", "action_command_id", "must be a string", -1) return end
  if ultraschall.CheckActionCommandIDFormat2(action_command_id)==false then ultraschall.AddErrorMessage("GetScriptFilenameFromActionCommandID", "action_command_id", "no such action-command-id", -2) return end
  local kb_ini_path = ultraschall.GetKBIniFilepath()
  local kb_ini_file = ultraschall.ReadFullFile(kb_ini_path)
  if action_command_id:sub(1,1)=="_" then action_command_id=action_command_id:sub(2,-1) end
  local L=kb_ini_file:match("( "..action_command_id..".-)\n")
  if L==nil then ultraschall.AddErrorMessage("GetScriptFilenameFromActionCommandID", "action_command_id", "no such action_command_id associated to a script", -1) return end
  L=L:match(".*%s(.*)")
  if L:sub(1,2)==".." then return reaper.GetResourcePath().."/"..L end
  return L
end

--LLL=ultraschall.GetScriptfilenameFromActionCommandID("_Ultraschall_Delete_Items_After_Editcursor_ArmedTracks_And_Preview_Audio_Before_RecordingLOLOLO")
--LLLL=ultraschall.GetScriptfilenameFromActionCommandID("_RSfd39b105f6a58a4074a3bfb9a4dd16efdde3bc91")
--LLLLL=ultraschall.GetScriptfilenameFromActionCommandID("_ALABAMA3")
--filecount, files = ultraschall.GetAllFilesnamesInPath("c:\\Tudelu\\")
--A,B=ultraschall.OnlyFilesOfCertainType(files, "JPG")

function ultraschall.GetProject_CountAutomationItems(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_CountAutomationItems</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer automation_items_count = ultraschall.GetProject_CountAutomationItems(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the number of automation-items available in a ProjectStateChunk.

    It's the entry &lt;POOLEDENV
                            
    returns -1 in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the automation-item-count; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file; only used, when projectfilename_with_path=nil
  </parameters>
  <retvals>
    integer automation_items_count - the number of automation-items
  </retvals>
  <chapter_context>
    Automation Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>automationitems, count, automation, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_CountAutomationItems","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CountAutomationItems","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_CountAutomationItems","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CountAutomationItems", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  
  local count=0
  while ProjectStateChunk:find("  <POOLEDENV")~=nil do
    count=count+1    
    ProjectStateChunk=ProjectStateChunk:match("  <POOLEDENV(.*)")
  end
  return count
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")

--A=ultraschall.ReadFullFile("c:\\00_master-002.flac.RPP")

--C=ultraschall.CountAutomItems_ProjectStateChunk(nil,A)

function ultraschall.GetProject_AutomationItemStateChunk(projectfilename_with_path, idx, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_AutomationItemStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string AutomationItemStateChunk = ultraschall.GetProject_AutomationItemStateChunk(string projectfilename_with_path, integer idx, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the idx'th automation-item from a ProjectStateChunk.
    
    It's the entry &lt;POOLEDENV
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the automation-item-statechunk; nil to use ProjectStateChunk
    integer idx - the number of the requested automation-item from the ProjectStateChunk with 1 for the first AutomItem.
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string AutomationItemStateChunk - the statechunk of the idx'th automation-item
  </retvals>
  <chapter_context>
    Automation Items
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>automationitems, get, automation, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_AutomationItemStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AutomationItemStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_AutomationItemStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_AutomationItemStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local count=0
  while ProjectStateChunk:find("  <POOLEDENV")~=nil do
    count=count+1    
    local AutomStateChunk, offset=ProjectStateChunk:match("  (<POOLEDENV.-  >)()")
    if count==idx then return AutomStateChunk end
    ProjectStateChunk=ProjectStateChunk:sub(offset,-1)
  end
  ultraschall.AddErrorMessage("GetProject_AutomationItemStateChunk", "idx", "no such automation item", -5)
  return nil
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_AutomationItemStateChunk("C:\\rendercode-project.rpp",1,A)

function ultraschall.GetProject_ProjectBay(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_ProjectBay</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string ProjectBayStateChunk = ultraschall.GetProject_ProjectBay(string ProjectStateChunk, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the ProjectBay-StateChunk, that holds MediaItems, that shall be retained in the "background" of the project, even if they are deleted from the project.
    These MediaItems can be seen and set to retain from within the ProjectBay-window.

    It's the entry &lt;PROJBAY ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the projectbay-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string ProjectBayStateChunk - the statechunk of the ProjectBay
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, projectbay, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_ProjectBay","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ProjectBay","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_ProjectBay","projectfilename_with_path", "File does not exist!", -3) return nil
    end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_ProjectBay", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<PROJBAY.-  >")
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_ProjectBay("c:\\automitem\\automitem.rpp")

--reaper.MB(B,"",0)
--main()


function ultraschall.GetProject_Metronome(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Metronome</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MetronomeStateChunk = ultraschall.GetProject_Metronome(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Metronome-StateChunk, that holds metronome-settings.
    
    It's the entry &lt;METRONOME ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the metronome-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MetronomeStateChunk - the statechunk of the Metronome
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, metronome, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Metronome","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Metronome","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Metronome","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Metronome", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<METRONOME.-  >")
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_Metronome("c:\\automitem\\automitem.rpp",A)

--reaper.MB(B,"",0)

function ultraschall.GetProject_MasterPlayspeed(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterPlayspeed</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterPlayspeedStateChunk = ultraschall.GetProject_MasterPlayspeed(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-Playspeed-StateChunk, that holds Playspeed-settings of the master.
    
    It's the entry &lt;MASTERPLAYSPEEDENV ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-playspeed-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterPlayspeedStateChunk - the statechunk of the MasterPlaySpeed
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master playspeed, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterPlayspeed","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPlayspeed","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterPlayspeed","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPlayspeed", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERPLAYSPEEDENV.-  >")
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProjectMasterPlaysp_ProjectStateChunk(nil, A)

--reaper.MB(B,"",0)

function ultraschall.GetProject_TempoEnvEx(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TempoEnvEx</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string TempoStateChunk = ultraschall.GetProject_TempoEnvEx(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Tempo-StateChunk, that holds tempo-settings of the master.
    
    It's the entry &lt;TEMPOENVEX ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the tempo-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string TempoStateChunk - the statechunk of the Tempo
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, tempo, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Tempo","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Tempo","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Tempo","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Tempo", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<TEMPOENVEX.-  >")
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_Tempo("c:\\automitem\\automitem.rpp",A)

--reaper.MB("TUDELU"..B.."TUDELU","",0)

function ultraschall.GetProject_Extensions(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Extensions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string ExtensionsStateChunk = ultraschall.GetProject_Extensions(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Extensions-settings-StateChunk, that holds tempo-settings of the master.
    
    It's the entry &lt;EXTENSIONS ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the extension-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string ExtensionsStateChunk - the statechunk of the Extensions-settings
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, extensions, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Extensions","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Extensions","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Extensions","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Extensions", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<EXTENSIONS.-\n  >")
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_Extensions("c:\\automitem\\automitem.rpp",A)

function ultraschall.GetProject_Lock(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Lock</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer lock_state = ultraschall.GetProject_Lock(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the individual lock-settings of the project, as set in menu Options -> Locking -> Locking Settings
    
    It's the entry LOCK 
    It is the one before(!) any <TRACK-tags !
    
    It is a bitfield, containing numerous settings.
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the lock-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer lock_state - the lock-state, which is a bitfield
                      - &1     - Time selection
                      - &2     - Items (full)
                      - &4     - Track envelopes
                      - &8     - Markers
                      - &16    - Regions
                      - &32    - Time signature markers
                      - &64    - Items (prevent left/right movement)
                      - &128   - Items (prevent up/down movement)
                      - &256   - Item edges
                      - &512   - Item fade/volume handles
                      - &1024  - Loop points locked
                      - &2048  - Item envelopes
                      - &4096  - Item stretch markers
                      - &16384 - Enable locking
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, lock, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Lock","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Lock","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Lock","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Lock", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return tonumber(ProjectStateChunk:match("\n  LOCK (.-)\n"))
end

--reaper.Main_SaveProject(0, false)
--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_Lock("c:\\automitem\\automitem.rpp",A)
--reaper.CF_SetClipboard(B)
--reaper.Main_OnCommand(40277,0)


--reaper.MB(B,"",0)

function ultraschall.GetProject_GlobalAuto(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_GlobalAuto</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer globalauto_state = ultraschall.GetProject_GlobalAuto(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the global-automation-settings of the project.
    
    It's the entry GLOBAL_AUTO
    
    returns nil in case of an error or if the setting isn't existing
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the global-automation-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer globalauto_state - the global automation override-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, global automation, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_GlobalAuto","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GlobalAuto","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_GlobalAuto","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GlobalAuto", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return tonumber(ProjectStateChunk:match("\n  GLOBAL_AUTO (.-)\n"))
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B=ultraschall.GetProject_Lock("c:\\automitem\\audiocd-codes.RPP",A)
--reaper.CF_SetClipboard(B)
--reaper.Main_OnCommand(40277,0)
--reaper.MB(B,"",0)

function ultraschall.GetProject_Tempo(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Tempo</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number bpm, integer beat, integer denominator = ultraschall.GetProject_Tempo(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab
    
    It's the entry TEMPO
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the tempo-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    number bpm - the tempo of the project in bpm
    integer beat - the beat of the project
    integer denominator - the denominator for the beat
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, beat, tempo, denominator, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Tempo","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Tempo","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Tempo","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Tempo", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c=ProjectStateChunk:match("TEMPO (.-) (.-) (.-)\n")
  return tonumber(a), tonumber(b), tonumber(c)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3=ultraschall.GetProject_Tempo("c:\\automitem\\automitem.RPP",A)
--reaper.CF_SetClipboard(B)
--reaper.Main_OnCommand(40277,0)
--reaper.MB(B,"",0)

function ultraschall.GetProject_Playrate(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Playrate</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number playrate, integer preserve_pitch, number min_playrate, number max_playrate = ultraschall.GetProject_Playrate(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the tempo-settings of the project, as set in the Project Settings -> Project Settings-tab
    
    It's the entry PLAYRATE
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the playrate-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    number playrate - the currently set playrate
    integer preserve_pitch - 0, don't preserve pitch, when changing playrate; 1, preserve pitch, when chaning playrate
    number min_playrate - the minimum playrate possible in the project
    number max_playrate - the maximum playrate possible in the project
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, playrate, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Playrate","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Playrate","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Playrate","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Playrate", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("PLAYRATE (.-) (.-) (.-) (.-)\n")
  return tonumber(a), tonumber(b), tonumber(c), tonumber(d)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_Playrate("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_MasterAutomode(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterAutomode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer automode = ultraschall.GetProject_MasterAutomode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the automation-mode of the master-track of the project, as set in the "Envelopes for Master Track"-dialog or the context-menu for the Master Track -> Set track automation mode -> ...
    
    It's the entry MASTERAUTOMODE
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-automation-mode; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer automode - the automation-mode, as set in the Envelopes for Master Track
                     - 0, Trim/Read
                     - 1, Read
                     - 2, Touch
                     - 3, Write
                     - 4, Latch
                     - 5, Latch Preview
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, automation mode, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterAutomode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterAutomode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterAutomode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterAutomode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTERAUTOMODE (.-)\n")
  return tonumber(a)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterAutomode("c:\\automitem\\automitem.RPP",A)


function ultraschall.GetProject_MasterSel(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterSel</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer selection = ultraschall.GetProject_MasterSel(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-track-selection-state of the master-track of the project.
    
    It's the entry MASTER_SEL
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-selection; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer selection - the selection-state; 0, master-track unselected; 1, master-track selected
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, selected, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterSel","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterSel","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterSel","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterSel", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTER_SEL (.-)\n")
  return tonumber(a)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterSel("c:\\automitem\\automitem.RPP",A)


function ultraschall.GetProject_MasterFXByp(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterFXByp</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer fx_byp_state = ultraschall.GetProject_MasterFXByp(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the fx-bypass-state of the master-track of the project.
    
    It's the entry MASTER_FX
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-fx-bypass-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer fx_byp_state - the fx-bypass-state; 0, master-track-fx bypassed; 1, master-track-fx normal
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, fx, bypass, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterFXByp","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterFXByp","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterFXByp","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterFXByp", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTER_FX (.-)\n")
  return tonumber(a)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterFXByp("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_MasterMuteSolo(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterMuteSolo</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer mute_solo_state = ultraschall.GetProject_MasterMuteSolo(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the mute-solo-state of the master-track of the project.
    Has no exclusive-solo/mute-settings!
    
    It's the entry MASTERMUTESOLO
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-mute-solo-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer mute_solo_state - the mute-solo-state; it is a bitfield
                            - 0, no mute, no solo, Mono mode L+R
                            - &1, master-track muted
                            - &2, master-track soloed
                            - &4, master-track mono-button
                            - &8, Mono mode:L
                            - &16, Mono mode:R
                            - add 24 for Mono mode L-R
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, mute, solo, mono, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterMuteSolo","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterMuteSolo","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterMuteSolo","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterMuteSolo", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTERMUTESOLO (.-)\n")
  return tonumber(a)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterMuteSolo("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_MasterNChans(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterNChans</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer number_of_channels, integer peak_metering = ultraschall.GetProject_MasterNChans(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the number of output channels-settings of the master-track of the project.

    It's the entry MASTER_NCH
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-nchans; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer number_of_channels - the number of output-channels, as set in the "Outputs for the Master Channel -> Track Channels"-dialog
    integer peak_metering - 2, Multichannel peak metering-setting, as set in the "Master VU settings"-dialog
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, number of channels, master track, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterNChans","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterNChans","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterNChans","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterMuteSolo", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTER_NCH (.-) (.-)\n")
  return tonumber(a), tonumber(b)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterNChans("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_MasterTrackHeight(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterTrackHeight</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer height_state, integer height_lock = ultraschall.GetProject_MasterTrackHeight(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-trackheight-states of the master-track of the project.
    
    It's the entry MASTERTRACKHEIGHT
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the mastertrackheight-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer height_state - the current-height of the master-track, from 24 to 260
    integer height_lock - 0, height-lock is off; 1, height-lock is on
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, trackheight, trackheightlock, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterTrackHeight","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackHeight","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterTrackHeight","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackHeight", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTERTRACKHEIGHT (.-) (.-)\n")
  return tonumber(a), tonumber(b)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterTrackHeight("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_MasterTrackColor(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterTrackColor</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer color = ultraschall.GetProject_MasterTrackColor(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-color of the master-track of the project.
    
    It's the entry MASTERPEAKCOL
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the mastertrack-color; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer color - the color for the master-track
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, color, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterTrackColor","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackColor","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterTrackColor","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackColor", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTERPEAKCOL (.-)\n")
  return tonumber(a)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4=ultraschall.GetProject_MasterTrackColor("c:\\automitem\\automitem.RPP",A)


function ultraschall.GetProject_MasterTrackView(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterTrackView</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer tcp_visibility, number state2, number state3, number state4, integer state5, integer state6, integer state7 = ultraschall.GetProject_MasterTrackView(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-view-state of the master-track of the project.
    
    It's the entry MASTERTRACKVIEW
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the trackview-states; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer tcp_visibility - 0, Master-track is invisible in MCP; 1, Master-track is visible in MCP
    number state2 - unknown
    number state3 - unknown
    number state4 - unknown
    integer state5 - unknown
    integer state6 - unknown
    integer state7 - unknown
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, view, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterTrackView","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackView","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterTrackView","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterTrackView", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d,e,f,g,h=ProjectStateChunk:match("MASTERTRACKVIEW (.-) (.-) (.-) (.-) (.-) (.-) (.-)\n")
  return tonumber(a), tonumber(b), tonumber(c), tonumber(d), tonumber(e), tonumber(f), tonumber(g)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_MasterTrackView("c:\\automitem\\automitem.RPP",A)

function ultraschall.GetProject_CountMasterHWOuts(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_CountMasterHWOuts</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer count_of_hwouts = ultraschall.GetProject_CountMasterHWOuts(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the number of available hwouts in an rpp-project or ProjectStateChunk
    
    It's the entry MASTERHWOUT
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to count the master-hwouts; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer count_of_hwouts - the number of available hwouts in an rpp-project or ProjectStateChunk
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, count, hwout, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_CountMasterHWOuts","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return 0 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CountMasterHWOuts","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return 0 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_CountMasterHWOuts","projectfilename_with_path", "File does not exist!", -3) return 0
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_CountMasterHWOuts", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local offset=""
  local count=0
  while offset~=nil do
    offset,ProjectStateChunk=ProjectStateChunk:match("MASTERHWOUT .-\n()(.*)")
    if offset~=nil then count=count+1 end
  end

  return count
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--Count,L,LL,LLL=ultraschall.GetProject_CountMasterHWOuts(nil,A)

function ultraschall.GetProject_MasterHWOut(projectfilename_with_path, idx, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterHWOut</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer state1, integer state2, number volume, number pan, integer mute, integer phase, integer output_channels, number state8 = ultraschall.GetProject_MasterHWOut(string projectfilename_with_path, integer idx, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the HWOut of the master-track of the project, as set in the "Outputs for Master Track"-dialog
    There can be multiple HWOuts for the Master-Track.
    
    It's the entry MASTERHWOUT
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-hwout-states; nil to use ProjectStateChunk
    integer idx - the number of the requested HWOut-setting; 1 for the first, etc.
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer state1 - unknown
    integer state2 - unknown
    number volume - volume of the HWOut; 
    number pan - the panning; -1(left), 1(right), 0(center)
    integer mute - mute-state; 0, unmuted; 1, muted
    integer phase - phase-inversion; 0, normal phase; 1, inversed phase
    integer output_channels -        -1 - None
                                     0 - Stereo Source 1/2
                                     4 - Stereo Source 5/6
                                    12 - New Channels On Sending Track Stereo Source Channel 13/14
                                    1024 - Mono Source 1
                                    1029 - Mono Source 6
                                    1030 - New Channels On Sending Track Mono Source Channel 7
                                    1032 - New Channels On Sending Track Mono Source Channel 9
                                    2048 - MultiChannel 4 Channels 1-4
                                    2050 - Multichannel 4 Channels 3-6
                                    3072 - Multichannel 6 Channels 1-6 
    number state8 - unknown
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, hwout, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterHWOut","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterHWOut","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterHWOut","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterHWOut", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("GetProject_MasterHWOut","idx", "must be an integer!", -4) return nil end
  local count=ultraschall.GetProject_CountMasterHWOuts(nil, ProjectStateChunk)
  
  if idx<1 or idx>count then ultraschall.AddErrorMessage("GetProject_MasterHWOut","idx", "no such hwout!", -5) return nil end
  local offset
  for i=1, idx-1 do
    offset,ProjectStateChunk=ProjectStateChunk:match("MASTERHWOUT .-\n()(.*)")
  end
  local a,b,c,d,e,f,g,h=ProjectStateChunk:match("MASTERHWOUT (.-) (.-) (.-) (.-) (.-) (.-) (.-) (.-)\n")
  return tonumber(a), tonumber(b), tonumber(c), tonumber(d), tonumber(e), tonumber(f), tonumber(g), tonumber(h)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_MasterHWOut("c:\\automitem\\automitem.RPP", 1, A)

function ultraschall.GetProject_MasterVolume(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterVolume</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number volume, number pan, number pan_law, number state4, number pan_knob3 = ultraschall.GetProject_MasterVolume(string projectfilename_with_path, integer idx, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-volume-state of the master-track of the project.
    
    It's the entry MASTER_VOLUME
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-volume-states; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    number volume - Volume; 0(-inf dB) to 3.981071705535(+12dB);1 for 0dB
    number pan - Panning; -1(left), 1(right), 0(center)
    number pan_law - Pan_Law, as set in the "Pan Law: Master Track"-dialog; 1(0dB); 0.5(-6.02dB)
    number state4 - unknown
    number pan_knob3 - the second pan_knob for pan-mode "Dual Pan" 
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, mastervolume, pan, volume, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterVolume","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolume","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterVolume","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolume", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  
  local a,b,c,d,e,f,g,h=ProjectStateChunk:match("MASTER_VOLUME (.-) (.-) (.-) (.-) (.-)\n")
  return tonumber(a), tonumber(b), tonumber(c), tonumber(d), tonumber(e)
end

--A=ultraschall.ReadFullFile("c:\\automitem\\automitem.rpp")
--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_MasterVolume("c:\\automitem\\automitem.RPP", A)

function ultraschall.GetProject_MasterPanMode(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterPanMode</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer panmode = ultraschall.GetProject_MasterPanMode(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-panmode of the master-track of the project.
    
    It's the entry MASTER_PANMODE
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-panmode; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer panmode - the panmode for the master-track; 
                    -  -1, Project default (Stereo balance)
                    -   3, Stereo balance  / mono pan(default)
                    -   5, Stereo Pan
                    -   6, Dual Pan
                    -   nil, REAPER 3.x balance(deprecated)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, panmode, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterPanMode","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPanMode","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterPanMode","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPanMode", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTER_PANMODE (.-)\n")
  return tonumber(a)
end

--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_MasterPanMode("c:\\automitem\\automitem.RPP", A)


function ultraschall.GetProject_MasterWidth(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterWidth</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number pan_knob_two = ultraschall.GetProject_MasterWidth(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the master-width for the second pan-knob in stereo pan-modes, of the master-track of the project.
    
    It's the entry MASTER_WIDTH
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the masterwidth-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    number pan_knob_two - -1(left), 1(right), 0(center)
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, pan knob two, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterWidth","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterWidth","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterWidth","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterWidth", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("MASTER_WIDTH (.-)\n")
  return tonumber(a)
end

--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_MasterWidth("c:\\automitem\\automitem.RPP", A)

function ultraschall.GetProject_MasterGroupFlagsState(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterGroupFlagsState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer GroupState_as_Flags, array IndividualGroupState_Flags = ultraschall.GetProject_MasterGroupFlagsState(string projectfilename_with_path, optional stirng ProjectStateChunk)</functioncall>
  <description>
    returns the state of the group-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk. 
    
    Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.
    
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):
      group1=groups_bitfield_table[1]&1
      group2=groups_bitfield_table[1]&4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    The GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.
    
    This function will work only for Groups 1 to 32. To get Groups 33 to 64, use <a href="#GetTrackGroupFlags_HighState">GetTrackGroupFlags_HighState</a> instead!
    
    It's the entry MASTER_GROUP_FLAGS
    
    returns -1 in case of failure
  </description>
  <retvals>
    integer GroupState_as_Flags - returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.
    -returns -1 in case of failure
    -
    -the following flags are available:
    -2^0 - Volume Master
    -2^1 - Volume Slave
    -2^2 - Pan Master
    -2^3 - Pan Slave
    -2^4 - Mute Master
    -2^5 - Mute Slave
    -2^6 - Solo Master
    -2^7 - Solo Slave
    -2^8 - Record Arm Master
    -2^9 - Record Arm Slave
    -2^10 - Polarity/Phase Master
    -2^11 - Polarity/Phase Slave
    -2^12 - Automation Mode Master
    -2^13 - Automation Mode Slave
    -2^14 - Reverse Volume
    -2^15 - Reverse Pan
    -2^16 - Do not master when slaving
    -2^17 - Reverse Width
    -2^18 - Width Master
    -2^19 - Width Slave
    -2^20 - VCA Master
    -2^21 - VCA Slave
    -2^22 - VCA pre-FX slave
    
     array IndividualGroupState_Flags  - returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.
    -e.g. If Volume Master is set only in Group 1, entry 1 in the array will be set to 1. If Volume Master is set on Group 2 and Group 4, the first entry in the array will be set to 10.
    -refer to the upper GroupState_as_Flags list to see, which entry in the array is for which set flag, e.g. array[22] is VCA pre-F slave, array[16] is Do not master when slaving, etc
    -As said before, the values in each entry is a flag, that tells you, which of the groups is set with a certain flag. The following flags determine, in which group a certain flag is set:
    -2^0 - Group 1
    -2^1 - Group 2
    -2^2 - Group 3
    -2^3 - Group 4
    -...
    -2^30 - Group 31
    -2^31 - Group 32
  </retvals>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the groups-state-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, groupflags, projectstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsState","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsState","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsState","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsState", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end

  local Project_TrackGroupFlags=ProjectStateChunk:match("MASTER_GROUP_FLAGS.-%c") 
  if Project_TrackGroupFlags==nil then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsState", "", "no trackgroupflags available", -5) return -1 end
  
  
  -- get groupflags-state
  local retval=0  
  local GroupflagString = Project_TrackGroupFlags:match("MASTER_GROUP_FLAGS (.-)%c")
  local count, Tracktable=ultraschall.CSV2IndividualLinesAsArray(GroupflagString, " ")

  for i=1,23 do
    Tracktable[i]=tonumber(Tracktable[i])
    if Tracktable[i]~=nil and Tracktable[i]>=1 then retval=retval+2^(i-1) end
  end
  
  return retval, Tracktable
end

--A,A1=ultraschall.GetProject_MasterGroupFlagsState("c:\\automitem\\automitem.RPP", A)


function ultraschall.GetProject_MasterGroupFlagsHighState(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterGroupFlagsHighState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer GroupState_as_Flags, array IndividualGroupState_Flags = ultraschall.GetProject_MasterGroupFlagsHighState(string projectfilename_with_path, optional stirng ProjectStateChunk)</functioncall>
  <description>
    returns the state of the group-high-flags for the Master-Track, as set in the menu Track Grouping Parameters; from an rpp-projectfile or a ProjectStateChunk. 
    
    Returns a 23bit flagvalue as well as an array with 32 individual 23bit-flagvalues. You must use bitoperations to get the individual values.
    
    You can reach the Group-Flag-Settings in the context-menu of a track.
    
    The groups_bitfield_table contains up to 23 entries. Every entry represents one of the checkboxes in the Track grouping parameters-dialog
    
    Each entry is a bitfield, that represents the groups, in which this flag is set to checked or unchecked.
    
    So if you want to get Volume Master(table entry 1) to check if it's set in Group 1(2^0=1) and 3(2^2=4):
      group1=groups_bitfield_table[1]&1
      group2=groups_bitfield_table[1]&4
    
    The following flags(and their accompanying array-entry-index) are available:
                           1 - Volume Master
                           2 - Volume Slave
                           3 - Pan Master
                           4 - Pan Slave
                           5 - Mute Master
                           6 - Mute Slave
                           7 - Solo Master
                           8 - Solo Slave
                           9 - Record Arm Master
                           10 - Record Arm Slave
                           11 - Polarity/Phase Master
                           12 - Polarity/Phase Slave
                           13 - Automation Mode Master
                           14 - Automation Mode Slave
                           15 - Reverse Volume
                           16 - Reverse Pan
                           17 - Do not master when slaving
                           18 - Reverse Width
                           19 - Width Master
                           20 - Width Slave
                           21 - VCA Master
                           22 - VCA Slave
                           23 - VCA pre-FX slave
    
    The GroupState_as_Flags-bitfield is a hint, if a certain flag is set in any of the groups. So, if you want to know, if VCA Master is set in any group, check if flag &1048576 (2^20) is set to 1048576.
    
    This function will work only for Groups 1 to 32. To get Groups 33 to 64, use <a href="#GetTrackGroupFlags_HighState">GetTrackGroupFlags_HighState</a> instead!
    
    It's the entry MASTER_GROUP_FLAGS_HIGH
    
    returns -1 in case of failure
  </description>
  <retvals>
    integer GroupState_as_Flags - returns a flagvalue with 23 bits, that tells you, which grouping-flag is set in at least one of the 32 groups available.
    -returns -1 in case of failure
    -
    -the following flags are available:
    -2^0 - Volume Master
    -2^1 - Volume Slave
    -2^2 - Pan Master
    -2^3 - Pan Slave
    -2^4 - Mute Master
    -2^5 - Mute Slave
    -2^6 - Solo Master
    -2^7 - Solo Slave
    -2^8 - Record Arm Master
    -2^9 - Record Arm Slave
    -2^10 - Polarity/Phase Master
    -2^11 - Polarity/Phase Slave
    -2^12 - Automation Mode Master
    -2^13 - Automation Mode Slave
    -2^14 - Reverse Volume
    -2^15 - Reverse Pan
    -2^16 - Do not master when slaving
    -2^17 - Reverse Width
    -2^18 - Width Master
    -2^19 - Width Slave
    -2^20 - VCA Master
    -2^21 - VCA Slave
    -2^22 - VCA pre-FX slave
    
     array IndividualGroupState_Flags  - returns an array with 23 entries. Every entry represents one of the GroupState_as_Flags, but it's value is a flag, that describes, in which of the 32 Groups a certain flag is set.
    -e.g. If Volume Master is set only in Group 1, entry 1 in the array will be set to 1. If Volume Master is set on Group 2 and Group 4, the first entry in the array will be set to 10.
    -refer to the upper GroupState_as_Flags list to see, which entry in the array is for which set flag, e.g. array[22] is VCA pre-F slave, array[16] is Do not master when slaving, etc
    -As said before, the values in each entry is a flag, that tells you, which of the groups is set with a certain flag. The following flags determine, in which group a certain flag is set:
    -2^0 - Group 1
    -2^1 - Group 2
    -2^2 - Group 3
    -2^3 - Group 4
    -...
    -2^30 - Group 31
    -2^31 - Group 32
  </retvals>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the groupshigh-state-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, groupflags, projectstatechunk</tags>
</US_DocBloc>
--]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsHighState","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsHighState","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsHighState","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsHighState", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end

  local Project_TrackGroupFlags=ProjectStateChunk:match("MASTER_GROUP_FLAGS_HIGH.-%c") 
  if Project_TrackGroupFlags==nil then ultraschall.AddErrorMessage("GetProject_MasterGroupFlagsHighState", "", "no trackgroupflags available", -5) return -1 end
  
  
  -- get groupflags-state
  local retval=0  
  local GroupflagString = Project_TrackGroupFlags:match("MASTER_GROUP_FLAGS_HIGH (.-)%c")
  local count, Tracktable=ultraschall.CSV2IndividualLinesAsArray(GroupflagString, " ")

  for i=1,23 do
    Tracktable[i]=tonumber(Tracktable[i])
    if Tracktable[i]~=nil and Tracktable[i]>=1 then retval=retval+2^(i-1) end
  end
  
  return retval, Tracktable
end

--A,A1=ultraschall.GetProject_MasterGroupFlagsHighState("c:\\automitem\\automitem.RPP", A)


function ultraschall.GetProject_GroupDisabled(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_GroupDisabled</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer disabled1, integer disabled2 = ultraschall.GetProject_GroupDisabled(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the group-disabled-stated, of the master-track of the project.
    
    It's the entry GROUPS_DISABLED
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the groups-disabled-state; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    integer disabled1 - the disabled groups; it is a bitfield, with &1 for group 1; &32 for group 32; if it's set, the accompanying group is disabled
    integer disabled2 - the disabled groups_high; it is a bitfield, with &1 for group 33; &32 for group 64; if it's set, the accompanying group is disabled
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, group, disabled, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_GroupDisabled","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GroupDisabled","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_GroupDisabled","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_GroupDisabled", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b,c,d=ProjectStateChunk:match("GROUPS_DISABLED (.-) (.-)\n")
  return tonumber(a), tonumber(b)
end

--B,B2,B3,B4,B5,B6,B7,B8=ultraschall.GetProject_GroupDisabled("c:\\automitem\\automitem.RPP", A)

function ultraschall.GetProject_MasterHWVolEnvStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterHWVolEnvStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterHWVolEnvStateChunk = ultraschall.GetProject_MasterHWVolEnvStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-HWVolEnv-StateChunk, that holds MasterHWVolEnv-settings of the master.
    
    It's the entry &lt;MASTERHWVOLENV ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-hwvolenv-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterHWVolEnvStateChunk - the statechunk of the HWVolEnv
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master hwvolend, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterHWVolEnvStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterHWVolEnvStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterHWVolEnvStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterHWVolEnvStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERHWVOLENV.->")
end

--MasterHWVolEnvStateChunk = ultraschall.GetProject_MasterHWVolEnvStateChunk("c:\\automitem\\automitem.RPP", "")

function ultraschall.GetProject_MasterFXListStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterFXListStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterFXListStateChunk = ultraschall.GetProject_MasterFXListStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-FX_List-StateChunk, that holds Master-FX-settings for the window as well as the FX themselves, of the master.
    
    It's the entry &lt;MASTERFXLIST ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-fxlist-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterFXListStateChunk - the statechunk of the Master-FX-list
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master fxlist, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterFXListStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterFXListStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterFXListStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterFXListStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERFXLIST.->")
end

--A = ultraschall.GetProject_MasterFXListStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterDualPanEnvStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterDualPanEnvStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterDualPanEnvStateChunk = ultraschall.GetProject_MasterDualPanEnvStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-DualPanEnv-StateChunk, that holds MasterDualPanEnv-settings of the master.
    
    It's the entry &lt;MASTERDUALPANENV ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-dualpan-env-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterDualPanEnvStateChunk - the statechunk of the Master-DualPan-Env-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master dualpanenv, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERDUALPANENV\n.->")
end

--A = ultraschall.GetProject_MasterDualPanEnvStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterDualPanEnv2StateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterDualPanEnv2StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterDualPanEnv2StateChunk = ultraschall.GetProject_MasterDualPanEnv2StateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-DualPanEnv2-StateChunk, that holds master-DualPanEnv2-settings of the master.
    
    It's the entry &lt;MASTERDUALPANENV2 ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-dualpan-env2-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterDualPanEnvStateChunk - the statechunk of the Master-DualPan-Env-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master dualpanenv2, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnv2StateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnv2StateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterDualPanEnv2StateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnv2StateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERDUALPANENV2\n.->")
end

--A = ultraschall.GetProject_MasterDualPanEnvStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterDualPanEnvLStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterDualPanEnvLStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterDualPanEnvLStateChunk = ultraschall.GetProject_MasterDualPanEnvLStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-DualPan-EnvL-StateChunk, that holds Master-DualPan-EnvL-settings of the master.
    
    It's the entry &lt;MASTERDUALPANENVL ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-dualpan-envL-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterDualPanEnvLStateChunk - the statechunk of the Master-DualPan-EnvL-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master dualpanenvl, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvLStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvLStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvLStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvLStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERDUALPANENVL\n.->")
end

--A = ultraschall.GetProject_MasterDualPanEnvLStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterDualPanEnvL2StateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterDualPanEnvL2StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterDualPanEnvL2StateChunk = ultraschall.GetProject_MasterDualPanEnvL2StateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-Dual-Pan-EnvL2-StateChunk, that holds Master-FX-Dual-Pan-EnvL2-settings of the master.
    
    It's the entry &lt;MASTERDUALPANENVL2 ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-dualpan-envL2-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterDualPanEnvL2StateChunk - the statechunk of the Master-DualPan-EnvL2-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master dualpanenvl2, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvL2StateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvL2StateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvL2StateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterDualPanEnvL2StateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERDUALPANENVL2\n.->")
end

--A = ultraschall.GetProject_MasterDualPanEnvL2StateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterVolEnvStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterVolEnvStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterVolEnvStateChunk = ultraschall.GetProject_MasterVolEnvStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-Vol-Env-StateChunk, that holds Master-Vol-Env-settings of the master.
    
    It's the entry &lt;MASTERVOLENV ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-volenv-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterVolEnvStateChunk - the statechunk of the Master-volenv-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master volenv, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterVolEnvStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnvStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterVolEnvStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnvStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERVOLENV\n.->")
end

--A = ultraschall.GetProject_MasterVolEnvStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)


function ultraschall.GetProject_MasterVolEnv2StateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterVolEnv2StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterVolEnv2StateChunk = ultraschall.GetProject_MasterVolEnv2StateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-Vol-Env2-StateChunk, that holds Master-Vol-Env2-settings of the master.
    
    It's the entry &lt;MASTERVOLENV2 ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-volenv2-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterVolEnv2StateChunk - the statechunk of the Master-volenv2-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master volenv2, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterVolEnv2StateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv2StateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterVolEnv2StateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv2StateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERVOLENV2\n.->")
end

--A = ultraschall.GetProject_MasterVolEnvStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterVolEnv3StateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterVolEnv3StateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterVolEnv3StateChunk = ultraschall.GetProject_MasterVolEnv3StateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-Vol-Env3-StateChunk, that holds Master-Vol-Env3-settings of the master.
    
    It's the entry &lt;MASTERVOLENV3 ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-volenv3-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterVolEnv3StateChunk - the statechunk of the Master-volenv3-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master volenv3, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERVOLENV3\n.->")
end

--A = ultraschall.GetProject_MasterVolEnv2StateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterHWPanEnvStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterHWPanEnvStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterHWPanEnvStateChunk = ultraschall.GetProject_MasterHWPanEnvStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-HW-pan-env-StateChunk, that holds Master-pan-env-settings of the master.
    
    It's the entry &lt;MASTERHWPANENV ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterHWPanEnvStateChunk - the statechunk of the Master-volenv3-state
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master pan env, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterVolEnv3StateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<MASTERHWPANENV\n.->")
end

--A = ultraschall.GetProject_MasterVolEnv2StateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)

function ultraschall.GetProject_MasterPanMode_Ex(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_MasterPanMode_Ex</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string MasterHWPanModeEx_StateChunk = ultraschall.GetProject_MasterPanMode_Ex(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the Master-HW-pan-mode-ex-StateChunk, that holds Master-pan-mode-ex-settings of the master.
    
    It's the entry &lt;MASTER_PANMODE_EX ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the master-HW-pan-env-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string MasterHWPanModeEx_StateChunk - the statechunk of the Master-pan-mode-ex
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, master pan mode ex, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_MasterPanMode_Ex","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPanMode_Ex","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_MasterPanMode_Ex","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_MasterPanMode_Ex", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  local a,b=ProjectStateChunk:match("MASTER_PANMODE_EX (.-) (.-)\n")
  return tonumber(a), tonumber(b)
end

--A = ultraschall.GetProject_MasterPanMode_Ex("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)


function ultraschall.GetProject_TempoEnv_ExStateChunk(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_TempoEnv_ExStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string TempoEnv_ExStateChunk = ultraschall.GetProject_TempoEnv_ExStateChunk(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    returns the TempoEnv_ExStateChunk, that holds TempoEnv_Ex-settings of an rpp-project or ProjectStateChunk.
    
    It's the entry &lt;TEMPOENVEX ... &gt;
    
    returns nil in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the projectfile+path, from which to get the tempo-env-ex-statechunk; nil to use ProjectStateChunk
    optional string ProjectStateChunk - a statechunk of a project, usually the contents of a rpp-project-file
  </parameters>
  <retvals>
    string TempoEnv_ExStateChunk - the statechunk of the Tempo-Env-Ex
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectmanagement, get, tempo env ex, statechunk, projectstatechunk</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_TempoEnv_ExStateChunk","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TempoEnv_ExStateChunk","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_TempoEnv_ExStateChunk","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_TempoEnv_ExStateChunk", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  return ProjectStateChunk:match("<TEMPOENVEX\n.->")
end

--A = ultraschall.GetProject_TempoEnv_ExStateChunk("c:\\automitem\\automitem.RPP", "")
--reaper.MB(A,"",0)


ultraschall.Euro=""

function ultraschall.CombineBytesToInteger(bitoffset, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CombineBytesToInteger</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.CombineBytesToInteger(integer bitoffset, integer Byte_1, optional Byte_2, ..., optional Byte_n)</functioncall>
  <description>
    Combines the Byte-values Byte_1 to Byte_n into one integer.
    That means, if you give 4 values, it will return a 32bit-integer(4*8Bits).
    
    Negative values will use the maximum possible value of that byte minus the bits. 
    In Byte_1, -2 will be 255-1=254, in Byte 2, -2 will be 65280-256=65024.
    
    Use bitoffset to define, from which bit on you want to combine the values.
    
    Returns -1 in case of an error
  </description>
  <parameters>
    integer bitoffset - if you want to start combining the values from a certain bitoffset-onwards, set the offset here; use 0 to start with the first bit.
    integer Byte_1 - a bytevalue that you want to combine into one
    optional integer Byte_2 - a bytevalue that you want to combine into one
    ...
    optional integer Byte_n - a bytevalue that you want to combine into one
  </parameters>
  <retvals>
    integer retval - the combined integer
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, combine, bytes, integer</tags>
</US_DocBloc>
]]
  if math.type(bitoffset)~="integer" then ultraschall.AddErrorMessage("AddBytesToInteger", "bitoffset", "Must be an integer", -1) return -1 end
  if bitoffset<0 then ultraschall.AddErrorMessage("AddBytesToInteger", "bitoffset", "Must be bigger or equal 0", -2) return -1 end
  local F={...}
  local c=0
  local count=1
  local bitcount=0+bitoffset
  while F[count]~=nil do
    if math.type(F[count])~="integer" then ultraschall.AddErrorMessage("AddBytesToInteger", "Byte_"..count, "Must be an integer", -3) return -1 end
    if F[count]>255 or F[count]<-256 then ultraschall.AddErrorMessage("AddBytesToInteger", "Byte_"..count, "Must be between -256 and 255", -4) return -1 end
    if F[count]&1~=0 then c=c+(2^bitcount) end
    if F[count]&2~=0 then c=c+(2^(bitcount+1)) end
    if F[count]&4~=0 then c=c+(2^(bitcount+2)) end
    if F[count]&8~=0 then c=c+(2^(bitcount+3)) end
    
    if F[count]&16~=0 then c=c+(2^(bitcount+4)) end
    if F[count]&32~=0 then c=c+(2^(bitcount+5)) end
    if F[count]&64~=0 then c=c+(2^(bitcount+6)) end
    if F[count]&128~=0 then c=c+(2^(bitcount+7)) end
    count=count+1
    bitcount=bitcount+8
  end
  return math.floor(c)
end

--L=ultraschall.CombineBytesToInteger(1,255)

function ultraschall.SplitIntegerIntoBytes(integervalue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SplitIntegerIntoBytes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer Byte1, integer Byte2, integer Byte3, integer Byte4 = ultraschall.SplitIntegerIntoBytes(integer integervalue)</functioncall>
  <description>
    Splits a 32-bit-integer-value into four bytes.
    
    Returns -1 in case of an error
  </description>
  <parameters>
    integer integeroffset - the integer-value that you want to split into individual bytes
  </parameters>
  <retvals>
    integer Byte1 - the first eight bits of the integer-value as a Byte
    integer Byte2 - the second eight bits of the integer-value as a Byte
    integer Byte3 - the third eight bits of the integer-value as a Byte
    integer Byte4 - the fourth eight bits of the integer-value as a Byte
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, split, bytes, integer</tags>
</US_DocBloc>
]]
  if math.type(integervalue)~="integer" then ultraschall.AddErrorMessage("SplitIntegerIntoBytes", "integervalue", "Must be an integer", -1) return -1 end
  if integervalue<-4294967296 or integervalue>4294967295 then ultraschall.AddErrorMessage("SplitIntegerIntoBytes", "integervalue", "Must be between -4294967296 and 4294967295", -2) return -1 end
  local vars={}
  vars[1]=0
  vars[2]=0
  vars[3]=0
  vars[4]=0
  local entry=1
  local bitcount=0
  local count=0
  for bitcount=0, 31 do
    count=count+1
    if count==9 then count=1 entry=entry+1 end -- vars[entry]=0 end
    if integervalue&(math.floor(2^bitcount))~=0 then       
      vars[entry]=math.floor(vars[entry]+(2^(count-1)))
    end
  end
  return table.unpack(vars)
end

function ultraschall.GetReaperScriptPath()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperScriptPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string reaper_script_path = ultraschall.GetReaperScriptPath()</functioncall>
  <description>
    Returns path to Reaper's script-folder
  </description>
  <retvals>
    string reaper_script_path - the path of the scripts-folder of Reaper
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, reaper, get, scriptpath</tags>
</US_DocBloc>
]]
  if ultraschall.DirectoryExists(reaper.GetResourcePath(), "Scripts")==true then 
  return reaper.GetResourcePath()..ultraschall.Separator.."Scripts"
  else return "" end
end

--A=ultraschall.GetReaperScriptPath()


function ultraschall.GetReaperColorThemesPath()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperColorThemesPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string reaper_colorthemes_path = ultraschall.GetReaperColorThemesPath()</functioncall>
  <description>
    Returns path to Reaper's color-theme-folder
  </description>
  <retvals>
    string reaper_colorthemes_path - the path of the color-theme-folder of Reaper
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, reaper, get, colorthemepath</tags>
</US_DocBloc>
]]
  if ultraschall.DirectoryExists(reaper.GetResourcePath(), "ColorThemes")==true then 
  return reaper.GetResourcePath()..ultraschall.Separator.."ColorThemes"
  else return "" end
end

--A=ultraschall.GetReaperColorThemesPath()

function ultraschall.GetReaperJSFXPath()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperJSFXPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string reaper_jsfx_path = ultraschall.GetReaperJSFXPath()</functioncall>
  <description>
    Returns path to Reaper's JSFX-plugin-folder
  </description>
  <retvals>
    string reaper_jsfx_path - the path of the JSFX-plugin-folder of Reaper
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, reaper, get, jsfxpath</tags>
</US_DocBloc>
]]
  if ultraschall.DirectoryExists(reaper.GetResourcePath(), "Effects")==true then 
  return reaper.GetResourcePath()..ultraschall.Separator.."Effects"
  else return "" end
end

--A=ultraschall.GetReaperJSFXPath()


function ultraschall.GetReaperWebRCPath()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperWebRCPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string reaper_webrc_path, string user_webrc_path = ultraschall.GetReaperWebRCPath()</functioncall>
  <description>
    Returns path to the Web-RC-folder for Reaper as well as for the user-webrc-pages.
  </description>
  <retvals>
    string reaper_script_path - the path of the JSFX-plugin-folder of Reaper
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, reaper, get, webrcpath</tags>
</US_DocBloc>
]]
  local user_dir=""
  local reaper_dir=""
  if ultraschall.DirectoryExists(reaper.GetResourcePath(), "reaper_www_root")==true then user_dir=reaper.GetResourcePath()..ultraschall.Separator.."reaper_www_root" end
  if ultraschall.DirectoryExists(reaper.GetExePath()..ultraschall.Separator.."Plugins", "reaper_www_root")==true then reaper_dir=reaper.GetResourcePath()..ultraschall.Separator.."reaper_www_root" end
  return reaper_dir, user_dir
end

--A,B=ultraschall.GetReaperWebRCPath()

--A=9223199999999999999
--A,B,C,D,E,F,G,H=ultraschall.SplitIntegerIntoBytes(-4294967296)
--reaper.CF_SetClipboard(9222999999999999999+100000000000000)
--A=math.floor(2^0)


function ultraschall.GetProject_Length(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Length</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number length, number last_itemedge, number last_marker_reg_edge, number last_timesig_marker = ultraschall.GetProject_Length(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the projectlength of an rpp-project-file.
    
    It's eturning the position of the overall length, as well as the position of the last itemedge/regionedge/marker/time-signature-marker of the project.
    
    Returns -1 in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the project, that you want to know it's length of; nil to use parameter ProjectStateChunk instead
    optional string ProjectStateChunk - a ProjectStateChunk to count the length of; only available when projectfilename_with_path=nil
  </parameters>
  <retvals>
    number length - the length of the project
    number last_itemedge - the postion of the last itemedge in the project
    number last_marker_reg_edge - the position of the last marker/regionedge in the project
    number last_timesig_marker - the position of the last time-signature-marker in the project
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>project management, get, length of project, marker, region, timesignature, lengt, item, edge</tags>
</US_DocBloc>
]]

  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Length","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return -1 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Length","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return -1 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Length","projectfilename_with_path", "File does not exist!", -3) return -1
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Length", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return -1 end
  end

  local B, C, ProjectLength, Len, Pos, Offs

  -- search for the last item-edge in the project
  B=ProjectStateChunk
  B=B:match("(%<ITEM.*)<EXTENS").."\n<ITEM"
  ProjectLength=0
  local Item_Length=0
  local Marker_Length=0
  local TempoMarker_Length=0
  
  -- let's take a huge project-string apart to make patternmatching much faster
  local K={}
  local counter=0
--  reaper.MB(B:sub(-1000,-1),"",0)
  while B:len()>1000 do     
    K[counter]=B:sub(0, 100000)
    B=B:sub(100001,-1)
    counter=counter+1
  end
  
  local counter2=1
  local B=K[0]
  
  local Itemscount=0
  
--  reaper.MB(B:sub(1,200),"",0)
  
  while B~=nil and B:sub(1,5)=="<ITEM" do
    if B:len()<10000 and counter2<counter then B=B..K[counter2] counter2=counter2+1 end
    Offs=B:match(".()<ITEM")

    local sc=B:sub(1,200)
    if sc==nil then break end

    Pos = sc:match("POSITION (.-)\n")
    Len = sc:match("LENGTH (.-)\n")

    if Pos==nil or Len==nil or Offs==nil then break end
    if ProjectLength<tonumber(Pos)+tonumber(Len) then ProjectLength=tonumber(Pos)+tonumber(Len) end
    B=B:sub(Offs,-1)  
    Itemscount=Itemscount+1
  end
  Item_Length=ProjectLength

  -- search for the last marker/regionedge in the project
  local markerregioncount, NumMarker, Numregions, Markertable = ultraschall.GetProject_MarkersAndRegions(nil, ProjectStateChunk)
  
  for i=1, markerregioncount do
    if ProjectLength<Markertable[i][2]+Markertable[i][3] then ProjectLength=Markertable[i][2]+Markertable[i][3] end
    if Marker_Length<Markertable[i][2]+Markertable[i][3] then Marker_Length=Markertable[i][2]+Markertable[i][3] end
  end
  
  -- search for the last tempo-envx-marker in the project
  B=ultraschall.GetProject_TempoEnv_ExStateChunk(nil, ProjectStateChunk)  
  C=B:match(".*PT (.-) ")
  if C~=nil and ProjectLength<tonumber(C) then ProjectLength=tonumber(C) end
  if C~=nil and TempoMarker_Length<tonumber(C) then TempoMarker_Length=tonumber(C) end
  
  return ProjectLength, Item_Length, Marker_Length, TempoMarker_Length
end

--L=ultraschall.GetProject_Length("c:/temp/testproject/testproject.RPP")


--L=ultraschall.RenderProject_RenderCFG("c:\\rendercode-project-dupl.RPP", "c:\\Reaper-Internal-Docs.mp3", 0, 0, false, true, true, A)


--MT=reaper.GetTrack(0,0)
--C,CC=ultraschall.GetAllMediaItemsBetween(0,400,"1,2,3,4,5",false)
--Aretval, Astr = ultraschall.GetItemStateChunk(reaper.GetMediaItem(0,0), true)
--ALABASTER,ALHula=ultraschall.InsertMediaItem_MediaItemStateChunk(8300,Astr, MT)

--L=ultraschall.SetIDEFontSize(15)


--MT=reaper.GetTrack(reaper.EnumProjects(2,""),0)
--Aretval, Astr = reaper.GetItemStateChunk(reaper.GetMediaItem(0,0), "", true)
--Astr=ultraschall.SetUS_Tracknumber(
--A,B,C,D,E,F,G=ultraschall.InsertMediaItem_MediaItemStateChunk(1000,Astr, MT)

--ultraschall.StopAnyPreview()


--input_filename_with_path="C:\\MarkerProject.RPP"

--A,B=ultraschall.ReadBinaryFile_Offset(input_filename_with_path, 0, 100)
--C,D=ultraschall.ReadBinaryFile_Offset(input_filename_with_path, -20, 21)

--reaper.MB(B..D,tostring(ultraschall.IsValidProjectStateChunk(B..D)),0)



--[[

Unicode Tests


count=0
count2=0
B=""
function main()
  for i=0, 312 do
  count=count+1
  if count==512 then count2=count2+1 count=0 end
--  A=string.pack ("s16", count, count)
--  oldA=A
  A=utf8.char(count)
  B=B.."\n\r"..A
  L=B:len()
  if A==ultraschall.Euro then reaper.MB(count, count2,0) end
  end
--  reaper.CF_SetClipboard(B)
  if count2<256 then reaper.defer(main) else ultraschall.WriteValueToFile("C:\\UTF8-test.txt", B) end
end


--main()
Byte1, Byte2, Byte3, Byte4 = ultraschall.SplitIntegerIntoBytes(261)
Aretval = ultraschall.CombineBytesToInteger(0, 128)
A2=string.char(128)
  A=string.pack ("j", Aretval)
  
--  reaper.MB(A,A:len(),0)
--]]
--L,L2,L3,L4=ultraschall.GetProject_Length("c:\\Users/Meo/Desktop/Lula/lula.rpp")

--L=ultraschall.RenderProject_RenderCFG(nil, "c:\\Reaper-Internal-Docs.mp3", 0, 100, false, true, true)
--A, AA=ultraschall.RenderProjectRegions_RenderCFG("c:\\MarkerProject.rpp", "c:\\Tudelu-test", 1, false, true, true, true)

function ultraschall.ConvertColorToMac(red, green, blue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorToMac</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer mac_colorvalue, boolean retval = ultraschall.ConvertColorToMac(integer red, integer green, integer blue)</functioncall>
  <description>
    Converts a colorvalue to the correct-native-colorvalue for Mac, no matter if you're using Mac, Windows or Linux.
    
    returns 0, false in case of an error
  </description>
  <parameters>
    integer red - the red-value of the color
    integer green - the green-value of the color
    integer blue - the blue-value of the color
  </parameters>
  <retvals>
    integer mac_colorvalue - the Mac-native-colorvalue
    boolean retval - true, if conversion succeeded; false, if conversion failed
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, native, mac, convert</tags>
</US_DocBloc>
]]
  if math.type(red)~="integer" then ultraschall.AddErrorMessage("ConvertColorToMac","red","must be an integer",-1) return 0, false end
  if math.type(green)~="integer" then ultraschall.AddErrorMessage("ConvertColorToMac","green","must be an integer",-2) return 0, false end
  if math.type(blue)~="integer" then ultraschall.AddErrorMessage("ConvertColorToMac","blue","must be an integer",-3) return 0, false end
  if ultraschall.IsOS_Mac()==false then red, blue = blue,red end
  return ultraschall.ConvertColor(red, green, blue)
end

--A=ultraschall.ConvertColorToMac(255,0,127)

function ultraschall.ConvertColorToWin(red, green, blue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorToWin</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer win_linux_colorvalue, boolean retval = ultraschall.ConvertColorToWin(integer red, integer green, integer blue)</functioncall>
  <description>
    Converts a colorvalue to the correct-native-colorvalue for Windows/Linux, no matter if you're using Mac, Windows or Linux.
    
    returns 0, false in case of an error
  </description>
  <parameters>
    integer red - the red-value of the color
    integer green - the green-value of the color
    integer blue - the blue-value of the color
  </parameters>
  <retvals>
    integer win_linux_colorvalue - the Windows/Linux-native-colorvalue
    boolean retval - true, if conversion succeeded; false, if conversion failed
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, native, windows, linux, convert</tags>
</US_DocBloc>
]]
  if math.type(red)~="integer" then ultraschall.AddErrorMessage("ConvertColorToWin","red","must be an integer",-1) return 0, false end
  if math.type(green)~="integer" then ultraschall.AddErrorMessage("ConvertColorToWin","green","must be an integer",-2) return 0, false end
  if math.type(blue)~="integer" then ultraschall.AddErrorMessage("ConvertColorToWin","blue","must be an integer",-3) return 0, false end
  if ultraschall.IsOS_Mac()==true then red, blue = blue,red end
  return ultraschall.ConvertColor(red, green, blue)
end

--A=ultraschall.ConvertColorToWin(255,2,127)

function ultraschall.ConvertColorFromMac(mac_colorvalue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorFromMac</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer red, integer green, integer blue, boolean retval = ultraschall.ConvertColorFromMac(integer mac_colorvalue)</functioncall>
  <description>
    Converts a native-colorvalue to the correct rgb-color-values for Mac, no matter if you're using Mac, Windows or Linux.
    
    returns 0, 0, 0, false in case of an error
  </description>
  <parameters>
    integer mac_colorvalue - the Mac-native-colorvalue
  </parameters>
  <retvals>
    integer red - the red-value of the color
    integer green - the green-value of the color
    integer blue - the blue-value of the color
    boolean retval - true, if conversion succeeded; false, if conversion failed
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, native, mac, convert</tags>
</US_DocBloc>
]]
  if math.type(mac_colorvalue)~="integer" then ultraschall.AddErrorMessage("ConvertColorFromMac","mac_colorvalue","must be an integer",-1) return 0, false end
  local red, green, blue, retval=ultraschall.ConvertColorReverse(mac_colorvalue)
  if ultraschall.IsOS_Mac()==false then red, blue = blue,red end
  return red, green, blue, retval
end

--B,C,D,E=ultraschall.ConvertColorFromMac(A)

function ultraschall.ConvertColorFromWin(win_colorvalue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertColorFromWin</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer red, integer green, integer blue, boolean retval = ultraschall.ConvertColorFromWin(integer win_colorvalue)</functioncall>
  <description>
    Converts a native-colorvalue to the correct rgb-color-values for Windows/Linux, no matter if you're using Mac, Windows or Linux.
    
    returns 0, 0, 0, false in case of an error
  </description>
  <parameters>
    integer win_colorvalue - the Windows/Linux-native-colorvalue
  </parameters>
  <retvals>
    integer red - the red-value of the color
    integer green - the green-value of the color
    integer blue - the blue-value of the color
    boolean retval - true, if conversion succeeded; false, if conversion failed
  </retvals>
  <chapter_context>
    Color Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>color management, native, windows, linux, convert</tags>
</US_DocBloc>
]]
  if math.type(win_colorvalue)~="integer" then ultraschall.AddErrorMessage("ConvertColorFromWin","win_colorvalue","must be an integer",-1) return 0, false end
  local red, green, blue, retval=ultraschall.ConvertColorReverse(win_colorvalue)
  if ultraschall.IsOS_Mac()==true then red, blue = blue,red end
  return red, green, blue, retval
end

--B,C,D,E=ultraschall.ConvertColorFromWin(A)





function ultraschall.DeleteMuteState(tracknumber, position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMuteState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteMuteState(integer tracknumber, number position)</functioncall>
  <description>
    Deletes a mute-point in track tracknumber at position.
    
    Returns false in case of an error
  </description>
  <parameters>
    integer tracknumber - the track in which to delete the mute-point; is 1-based, means 1 for track 1
    number position - the position of the mute-point to delete
  </parameters>
  <retvals>
    boolean retval - true, deleting was successful; false, deleting wasn't successful.
  </retvals>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, delete, mute, cough, position, tracknumber</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("DeleteMuteState", "tracknumber", "Must be an integer.", -1) return false end
  if type(position)~="number" then ultraschall.AddErrorMessage("DeleteMuteState", "position", "Must be a number.", -2) return false end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("DeleteMuteState", "tracknumber", "No such track.", -3) return false end
  if position<0 then ultraschall.AddErrorMessage("DeleteMuteState", "position", "Must be bigger or equal 0.", -4) return false end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(reaper.GetTrack(0,tracknumber-1), "Mute")
  local A=reaper.DeleteEnvelopePointRange(TrackEnvelope, position, position+.000000000000001)
  if A==false then ultraschall.AddErrorMessage("DeleteMuteState", "position", "No mute-envelope-point at position", -5) return false end
  reaper.Envelope_SortPoints(TrackEnvelope)
  --reaper.UpdateArrange()
  return A
end

--L=ultraschall.DeleteMuteState("2", 10)

function ultraschall.DeleteMuteState_TrackObject(MediaTrack, position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteMuteState_TrackObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.DeleteMuteState_TrackObject(MediaTrack MediaTrack, number position)</functioncall>
  <description>
    Deletes a mute-point in a MediaTrack-object at position.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaTrack MediaTrack - the track in which to delete the mute-point
    number position - the position of the mute-point to delete
  </parameters>
  <retvals>
    boolean retval - true, deleting was successful; false, deleting wasn't successful.
  </retvals>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, delete, mute, cough, position, mediatrack</tags>
</US_DocBloc>
]]
  if ultraschall.type(MediaTrack)~="MediaTrack" then ultraschall.AddErrorMessage("DeleteMuteState_TrackObject", "MediaTrack", "Must be a valid MediaTrack-object.", -1) return false end
  if type(position)~="number" then ultraschall.AddErrorMessage("DeleteMuteState_TrackObject", "position", "Must be a number.", -2) return false end
  if position<0 then ultraschall.AddErrorMessage("DeleteMuteState_TrackObject", "position", "Must be bigger or equal 0.", -3) return false end
  local TrackEnvelope=reaper.GetTrackEnvelopeByName(MediaTrack, "Mute")
  local A=reaper.DeleteEnvelopePointRange(TrackEnvelope, position, position+.000000000000001)
  if A==false then ultraschall.AddErrorMessage("DeleteMuteState_TrackObject", "position", "No mute-envelope-point at position", -4) return false end
  reaper.Envelope_SortPoints(TrackEnvelope)
  -- reaper.UpdateArrange()
  return A
end

--ultraschall.DeleteMuteState_TrackObject(reaper.GetTrack(0,1), 1)

function ultraschall.IsMuteAtPosition(tracknumber, position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMuteAtPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, optional integer envIDX, optional number envVal = ultraschall.IsMuteAtPosition(integer tracknumber, number position)</functioncall>
  <description>
    Returns true, if a mute-point exists in track tracknumber at position position.
    
    Returns false in case of an error
  </description>
  <parameters>
    integer tracknumber - the track in which to check for a mute-point; is 1-based, means 1 for track 1
    number position - the position to check for a mute-point
  </parameters>
  <retvals>
    boolean retval - true, if there is a mute-point; false, if there isn't one
    optional integer envIDX - if a mute-point is at position, this holds the index of the envelope-point
    optional number envVal - the current set value of the mute-point
  </retvals>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, check, mute, cough, position, tracknumber</tags>
</US_DocBloc>
]]
  if math.type(tracknumber)~="integer" then ultraschall.AddErrorMessage("IsMuteAtPosition", "tracknumber", "Must be an integer.", -1) return false end
  if type(position)~="number" then ultraschall.AddErrorMessage("IsMuteAtPosition", "position", "Must be a number.", -2) return false end
  if tracknumber<1 or tracknumber>reaper.CountTracks(0) then ultraschall.AddErrorMessage("IsMuteAtPosition", "tracknumber", "No such track.", -3) return false end
  if position<0 then ultraschall.AddErrorMessage("IsMuteAtPosition", "position", "Must be bigger or equal 0.", -4) return false end
  local envIDX, envVal, envPosition = ultraschall.GetNextMuteState(tracknumber, position-.000000000000001)
  if envPosition==position then return true, envIDX, envVal else return false end
end

--ALABAMA,A,B=ultraschall.IsMuteAtPosition(2, 1)

function ultraschall.IsMuteAtPosition_TrackObject(MediaTrack, position)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMuteAtPosition_TrackObject</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, optional integer envIDX, optional number envVal = ultraschall.IsMuteAtPosition_TrackObject(MediaTrack MediaTrack, number position)</functioncall>
  <description>
    Returns true, if a mute-point exists in MediaTrack-object at position position.
    
    Returns false in case of an error
  </description>
  <parameters>
    MediaTrack MediaTrack - the track in which to check for a mute-point
    number position - the position to check for a mute-point
  </parameters>
  <retvals>
    boolean retval - true, if there is a mute-point; false, if there isn't one
    optional integer envIDX - if a mute-point is at position, this holds the index of the envelope-point
    optional number envVal - the current set value of the mute-point
  </retvals>
  <chapter_context>
    Cough-Button
    Muting tracks within envelope-lanes
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>cough button, check, mute, cough, position, mediatrack</tags>
</US_DocBloc>
]]
  if ultraschall.type(MediaTrack)~="MediaTrack" then ultraschall.AddErrorMessage("IsMuteAtPosition_TrackObject", "MediaTrack", "Must be a valid MediaTrack-object.", -1) return false end
  if type(position)~="number" then ultraschall.AddErrorMessage("IsMuteAtPosition_TrackObject", "position", "Must be a number.", -2) return false end
  if position<0 then ultraschall.AddErrorMessage("IsMuteAtPosition_TrackObject", "position", "Must be bigger or equal 0.", -4) return false end
  local envIDX, envVal, envPosition = ultraschall.GetNextMuteState_TrackObject(MediaTrack, position-.000000000000001)
  if envPosition==position then return true, envIDX, envVal else return false end
end

--A,B,C=ultraschall.IsMuteAtPosition_TrackObject(reaper.GetTrack(0,1), 1)


ultraschall.ShowLastErrorMessage()


function ultraschall.ApplyActionToMediaItemArray2(MediaItemArray, actioncommandid, repeat_action, midi, MIDI_hwnd)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ApplyActionToMediaItemArray2</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.ApplyActionToMediaItemArray2(MediaItemArray MediaItemArray, string actioncommandid, integer repeat_action, boolean midi, optional HWND MIDI_hwnd)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Applies an action to the MediaItems in MediaItemArray, in either main or MIDI-Editor section-context
    The action given must support applying itself to selected items.
    
    This function applies the action to all MediaItems at once. To apply the action to each MediaItem in MediaItemArray individually, see <a href="#ApplyActionToMediaItemArray">ApplyActionToMediaItemArray</a>
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running the action was successful; false, if not or an error occured
  </retvals>
  <parameters>
    MediaItemArray MediaItemArray - an array with all MediaItems, to whom the action shall be applied to
    string actioncommandid - the commandid-number or ActionCommandID, that shall be run.
    integer repeat_action - the number of times this action shall be applied to each item; minimum value is 1
    boolean midi - true, run an action from MIDI-Editor-section-context; false, run an action from the main section
    optional HWND MIDI_hwnd - the HWND-handle of the MIDI-Editor, to which a MIDI-action shall be applied to; nil, to use the currently selected one
  </parameters>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>mediaitemmanagement, run, action, midi, main, midieditor, item, mediaitemarray</tags>
</US_DocBloc>
]]
  -- check parameters
  if ultraschall.CheckMediaItemArray(MediaItemArray)==false then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray2","MediaItemArray", "No valid MediaItemArray!", -1) return false end
  if ultraschall.CheckActionCommandIDFormat2(actioncommandid)==false then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray2","actioncommandid", "No such action registered!", -2) return false end
  if type(midi)~="boolean" then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray2","midi", "Must be boolean!", -3) return false end
  if math.type(repeat_action)~="integer" then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray2","repeat_action", "Must be an integer!", -4) return false end
  if repeat_action<1 then ultraschall.AddErrorMessage("ApplyActionToMediaItemArray2","repeat_action", "Must be bigger than 0!", -5) return false end
  
  reaper.PreventUIRefresh(1)
  local count, MediaItemArray_selected = ultraschall.GetAllSelectedMediaItems() -- get old selection
  reaper.SelectAllMediaItems(0, false) -- deselect all MediaItems
  local retval = ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray) -- select to-be-processed-MediaItems
  for i=1, repeat_action do
    ultraschall.RunCommand(actioncommandid,0) -- apply the action
  end
  reaper.SelectAllMediaItems(0, false) -- deselect all MediaItems
  local retval = ultraschall.SelectMediaItems_MediaItemArray(MediaItemArray_selected) -- select the MediaItems formerly selected
  reaper.PreventUIRefresh(-1)
  reaper.UpdateArrange()
  return true
end

-- count, MediaItemArray_selected = ultraschall.GetAllSelectedMediaItems()

-- ultraschall.ApplyActionToMediaItemArray2(MediaItemArray_selected, 41925, 100, false)


function ultraschall.MoveTimeSigMarkersBy(startposition, endposition, moveby, cut_at_borders, update_timeline)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveTimeSigMarkersBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.MoveTimeSigMarkersBy(number startposition, number endposition, number moveby, boolean cut_at_borders, boolean update_timeline)</functioncall>
  <description>
    Moves time-signature-markers between startposition and endposition by moveby.
    
    Does NOT move normal projectmarkers or regions!
    
    Returns -1 in case of failure.
  </description>
  <retvals>
    integer retval - -1 in case of failure
  </retvals>
  <parameters>
    number startposition - the startposition in seconds
    number endposition - the endposition in seconds
    number moveby - in seconds, negative values: move toward beginning of project, positive values: move toward the end of project
    boolean cut_at_borders - shortens or cuts markers, that leave the section between startposition and endposition
    boolean update_timeline - true, updates the timeline after moving time-signature markers; false, don't update timeline(must be done manually then)
  </parameters>
  <chapter_context>
    Markers
    Time Signature Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, move, moveby, timesignature</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","endposition", "must be a number", -2) return -1 end
  if startposition>endposition then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","endposition", "must be bigger than startposition", -3) return -1 end
  if type(moveby)~="number" then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","moveby", "must be a number", -4) return -1 end
  if type(cut_at_borders)~="boolean" then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","cut_at_borders", "must be a boolean", -5) return -1 end
  if type(update_timeline)~="boolean" then ultraschall.AddErrorMessage("MoveTimeSigMarkersBy","update_timeline", "must be a boolean", -6) return -1 end
  if moveby==0 then return -1 end
  local numtimesigmarkers = reaper.CountTempoTimeSigMarkers(0)
  
  local start, stop, step, boolean
  if moveby>0 then start=numtimesigmarkers stop=0 step=-1
  elseif moveby<0 then start=0 stop=numtimesigmarkers step=1
  end

  if cut_at_borders==true then
    for i=numtimesigmarkers, 0, -1 do
      local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
      if timepos>=startposition and timepos<=endposition then
        if (timepos+moveby>endposition or timepos+moveby<startposition) then
          boolean=reaper.DeleteTempoTimeSigMarker(0, i)
        end
      end
    end
  end

  for i=start, stop, step do
    local retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo = reaper.GetTempoTimeSigMarker(0, i)
    if timepos>=startposition and timepos<=endposition then
        boolean = reaper.SetTempoTimeSigMarker(0, i, timepos+moveby, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo)
    end
  end
  
  if update_timeline==true then reaper.UpdateTimeline() end
  return 1
end

--L=ultraschall.MoveTimeSigMarkersBy(20, 55, -1, true, true)

function ultraschall.GetAllTimeSigMarkers()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllTimeSigMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer num_timesig_markers, array TimeSigArray = ultraschall.GetAllTimeSigMarkers()</functioncall>
  <description>
    Returns the number of Tempo/Time-Signature-Markers in the project, as well as an array with all attributes of all these markers.
    
    The array is of the format: TimeSigArray[markernumber(1-based)][attribute-idx]
    where attribute-idx is
    1, number timepos
    2, number measurepos
    3, number beatpos
    4, number bpm
    5, number timesig_num
    6, number timesig_denom
    7, boolean lineartempo 
    
    returns -1 in case of error
  </description>
  <retvals>
    integer num_timesig_markers - the number of time-signature-markers in the project
    array TimeSigArray - an array with all time-signature-markers and all their attributes; see Description for more details
  </retvals>
  <chapter_context>
    Markers
    Time Signature Markers
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, time signature, get, all</tags>
</US_DocBloc>
]]
  local markerarray={}
  for i=0, reaper.CountTempoTimeSigMarkers(0) do
    markerarray[i+1] = {reaper.GetTempoTimeSigMarker(0, i)}
    table.remove(markerarray[i+1],1)
  end
  return reaper.CountTempoTimeSigMarkers(0), markerarray
end

--retval, timepos, measurepos, beatpos, bpm, timesig_num, timesig_denom, lineartempo
--A,B=ultraschall.GetAllTimeSigMarkers()

--A,AA,AAA,AAAA=ultraschall.SectionCut_Inverse(2,4,"1",true)
--ultraschall.SectionCut(2, 4, "1", true)

--ultraschall.RippleCut_Reverse(2, 4, "1", false, true)

function ultraschall.MoveMarkersBy(startposition, endposition, moveby, cut_at_borders)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveMarkersBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.MoveMarkersBy(number startposition, number endposition, number moveby, boolean cut_at_borders)</functioncall>
  <description>
    Moves the markers between startposition and endposition by moveby.
    
    Does NOT move regions and time-signature-markers!
    
    Returns -1 in case of failure.
  </description>
  <retvals>
    integer retval - -1 in case of failure
  </retvals>
  <parameters>
    number startposition - the startposition in seconds
    number endposition - the endposition in seconds
    number moveby - in seconds, negative values: move toward beginning of project, positive values: move toward the end of project
    boolean cut_at_borders - shortens or cuts markers, that leave the section between startposition and endposition when applying moveby
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, move, moveby, marker</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("MoveMarkersBy","startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("MoveMarkersBy","endposition", "must be a number", -2) return -1 end
  if startposition>endposition then ultraschall.AddErrorMessage("MoveMarkersBy","endposition", "must be bigger than startposition", -3) return -1 end
  if type(moveby)~="number" then ultraschall.AddErrorMessage("MoveMarkersBy","moveby", "must be a number", -4) return -1 end
  if type(cut_at_borders)~="boolean" then ultraschall.AddErrorMessage("MoveMarkersBy","cut_at_borders", "must be a boolean", -5) return -1 end

  if moveby==0 then return -1 end
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  
  local start, stop, step, boolean
  if moveby>0 then start=retval-1 stop=0 step=-1
  elseif moveby<0 then start=0 stop=retval step=1
  end

  if cut_at_borders==true then
    for i=retval, 0, -1 do
      local sretval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
      if pos>=startposition and pos<=endposition then
        if (pos+moveby>endposition or pos+moveby<startposition) then
          boolean=reaper.DeleteProjectMarkerByIndex(0, i)
        end
      end
    end
  end

  for i=start, stop, step do
    local sretval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if pos>=startposition and pos<=endposition then
        boolean=reaper.SetProjectMarker(markrgnindexnumber, isrgn, pos+moveby, rgnend, name)
    end
  end
  
  return 1
end

--Aretval = ultraschall.MoveMarkersBy(15, 80, -10, true)


function ultraschall.MoveRegionsBy(startposition, endposition, moveby, cut_at_borders)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MoveRegionsBy</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.MoveRegionsBy(number startposition, number endposition, number moveby, boolean cut_at_borders)</functioncall>
  <description>
    Moves the regions between startposition and endposition by moveby.
    Will affect only regions, who start within start and endposition. It will not affect those, who end within start and endposition but start before startposition.
    
    Does NOT move markers and time-signature-markers!
    
    Returns -1 in case of failure.
  </description>
  <retvals>
    integer retval - -1 in case of failure
  </retvals>
  <parameters>
    number startposition - the startposition in seconds
    number endposition - the endposition in seconds
    number moveby - in seconds, negative values: move toward beginning of project, positive values: move toward the end of project
    boolean cut_at_borders - shortens or cuts markers, that leave the section between startposition and endposition
  </parameters>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, move, moveby, marker</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("MoveRegionsBy","startposition", "must be a number", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("MoveRegionsBy","endposition", "must be a number", -2) return -1 end
  if startposition>endposition then ultraschall.AddErrorMessage("MoveRegionsBy","endposition", "must be bigger than startposition", -3) return -1 end
  if type(moveby)~="number" then ultraschall.AddErrorMessage("MoveRegionsBy","moveby", "must be a number", -4) return -1 end
  if type(cut_at_borders)~="boolean" then ultraschall.AddErrorMessage("MoveRegionsBy","cut_at_borders", "must be a boolean", -5) return -1 end
  if moveby==0 then return -1 end
  local retval, num_markers, num_regions = reaper.CountProjectMarkers(0)
  
  local start, stop, step, boolean
  if moveby>0 then start=retval stop=0 step=-1     -- if moveby is positive, count through the markers backwards
  elseif moveby<0 then start=0 stop=retval step=1  -- if moveby is positive, count through the markers forward
  end
  local markerdeleter={}
  local count=0
  
  for i=start, stop, step do
    local sretval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)

    reaper.MB("Pos:"..pos.." - Start:"..startposition.."  End: "..endposition.." "..tostring(isrgn),"",0)
    
    if isrgn==true and (pos>=startposition and pos<=endposition) then
      -- only regions within start and endposition
      if cut_at_borders==true then
        -- if cutting at the borders=true, with borders determined by start and endposition 
        if pos+moveby>endposition and rgnend+moveby>endposition then
          -- when regions would move after endposition, put it into the markerdelete-array
          markerdeleter[count]=markrgnindexnumber
          count=count+1
          reaper.MB("","0",0)
        elseif pos+moveby<startposition and rgnend+moveby<startposition then
          -- when regions would move before startposition, put it into the markerdelete-array
          markerdeleter[count]=markrgnindexnumber
          count=count+1
          reaper.MB("","1",0)
        elseif pos+moveby<startposition and rgnend+moveby>=startposition and rgnend+moveby<=endposition then
          -- when start of the region is before startposition and end of the region is within start and endposition,
          -- set start of the region to startposition and only move regionend by moveby
          reaper.MB("","2",0)
          boolean=reaper.SetProjectMarker(markrgnindexnumber, isrgn, startposition, rgnend+moveby, name)
--        elseif rgnend+moveby<endposition and pos+moveby>=startposition and pos+moveby<=endposition then
          -- when end of the region is BEFORE endposition and start of the region is within start and endposition,
          -- set end of the region to endposition and only move regionstart(pos) by moveby
        elseif rgnend+moveby>endposition and pos+moveby>=startposition and pos+moveby<=endposition then
          -- when end of the region is after endposition and start of the region is within start and endposition,
          -- set end of the region to endposition and only move regionstart(pos) by moveby
          reaper.MB("","2",0)
          boolean=reaper.SetProjectMarker(markrgnindexnumber, isrgn, pos+moveby, endposition, name)
        else
          -- move the region by moveby
          boolean=reaper.SetProjectMarker(markrgnindexnumber, isrgn, pos+moveby, rgnend+moveby, name)
          reaper.MB("","3",0)
        end
      else
        -- move the region by moveby
        boolean=reaper.SetProjectMarker(markrgnindexnumber, isrgn, pos+moveby, rgnend+moveby, name)
      end
    end
  end
  for i=0, count-1 do
    Aboolean=reaper.DeleteProjectMarker(0, markerdeleter[i], true)
  end
  return 1
end

--Aretval = ultraschall.MoveRegionsBy(-10, 180, -1, false)

function ultraschall.ShowMenu(Title,Entries,x,y)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ShowMenu</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.ShowMenu(string Title, string Entries, integer x, integer y)</functioncall>
  <description>
    Draws a menu at position x,y.
    
    Entries is the string, that contains the Menuentries, separated by |
    Example: "Entry1|Entry2|Entry3"
    
    Each field can start with a special character
      # grays out the entry
      ! entry is checked
      > starts a new submenu, where every following entry will be part of the submenu
      < ends a submenu with this entry being the last one
    These special characters can be combined, however, grayed out entries don't open submenus, even if they are shown as submenus.
    A field with nothing in it || creates a separator.    
    
    The returned number follows the numbering of the clickable(!) entries. Even if grayed out-entries can't be selected, they count as well.
    However, opening-submenu-entries and separators don't count as clickable.
    That said, if you have one grayed out entry and one normal entry, the grayed out entry is 1, the normal entry(the only selectable one) is 2.
    
    The following entry 

      Normal1|>SubmenuOpener|Submenuentry1|<SubmenuEntry2Closer|#Grayed Out

    creates the following menu:
    
      Normal1
      SubmenuOpener >
        Submenuentry1
        SubmenuEntry2Closer
      Grayed Out
    
    One last thing: the title does not count as entry!
    
    Note for Mac-users: has a possible issue with the y coordinate, where it's position is actually "reversed", due a Reaper-bug.
    Note for Linux: does not work on Linux yet.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the selected entry; 0, nothing selected
  </retvals>
  <parameters>
    string Title - the title shown on top of the menu
    string Entries - the individual entries. See above on how to create such an entry.
    integer x - the x-position of the menu
    integer y - the y-position of the menu
  </parameters>
  <chapter_context>
    User Interface
    Context Menus
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, create, menu, contextmenu</tags>
</US_DocBloc>
]]
  if type(Title)~="string" then ultraschall.AddErrorMessage("ShowMenu", "Title", "must be a string", -1) return -1 end
  if type(Entries)~="string" then ultraschall.AddErrorMessage("ShowMenu", "Entries", "must be a string", -2) return -1 end
  if math.type(x)~="integer" then ultraschall.AddErrorMessage("ShowMenu", "x", "must be an integer", -3) return -1 end
  if math.type(y)~="integer" then ultraschall.AddErrorMessage("ShowMenu", "y", "must be an integer", -4) return -1 end
  if Entries=="" then ultraschall.AddErrorMessage("ShowMenu", "Entries", "must have at least one entry", -5) return -1 end
  if Title:len()<=5 then for i=5-Title:len(),1, -1 do Title=Title.." " end end

  local ownwindow=false
  if gfx.h==0 and gfx.w==0 then gfx.init("Ultraschall-Menu",0,0,0,x,y)

--possible workaround for Mac, but unused...
--    left, top, right, bottom = reaper.my_getViewport(1, 1, 2, 2, 1, 1, 2, 2, true)
--    convx, convy = gfx.screentoclient(0, 0)
--    convx2, convy2 = gfx.clienttoscreen(0, 0)
--[[
    if convy~=y then
      gfx.quit()
      count=bottom
      numtable={}
      for i=0, bottom do
        --reaper.ShowConsoleMsg(i.." ")
        numtable[i]=count
        count=count-1
      end
      
      y=numtable[y]
      gfx.init("Ultraschall-Menu",1,1,0,100,y-21)
    end
--]]
    gfx.x=-10
    gfx.y=-25
    ownwindow=true
  else
    convx, convy = gfx.screentoclient(x, y)
    gfx.x=convx
    gfx.y=convy
  end
  local selection=gfx.showmenu("#"..Title.."||"..Entries)
  if ownwindow==true then gfx.quit() end
  return math.floor(selection)-1
end

--L=ultraschall.ShowMenu("","Normal1",-1,-1)

function ultraschall.CycleTable(the_table, offset)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CycleTable</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>table new_table = ultraschall.CycleTable(table the_table, integer offset)</functioncall>
  <description>
    Cycles the entries by offset. Offset can be positive(cycle forward) or negative(cycle negative). The number also tells the function, by how many entries the table shall be cycled, with 1 for one entry, 2 for 2 entries, etc.
    Entries "falling out" of one side(top or bottom) of the table will be readded on the other side.
    
    returns nil in case of error
  </description>
  <retvals>
    table new_table - the altered table
  </retvals>
  <parameters>
    table the_table - the table to cycle through
    integer offset - the offset, by which to cycle the entries through; positive, cycle entries forward; negative, cycle entries backward
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, cycle, table</tags>
</US_DocBloc>
]]
  if type(the_table)~="table" then ultraschall.AddErrorMessage("CycleTable", "the_table", "must be a table", -1) return end
  if math.type(offset)~="integer" then ultraschall.AddErrorMessage("CycleTable", "offset", "must be an integer", -2) return end

  local count, subtables, count_of_subtables = ultraschall.CountEntriesInTable_Main(the_table)
  local the_new_table={}

  local temp=math.floor(offset/count)
  local counter=offset-(temp*count)+1

  for i=1, count do
    the_new_table[counter]=the_table[i]
    counter=counter+1
    if counter>count then counter=1 end
  end
  return the_new_table
end

function ultraschall.GetLastErrorMessage_Funcname(functionname)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastErrorMessage_Funcname</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer errorindex, string parametername, string errormessage, integer errorcode = ultraschall.GetLastErrorMessage_Funcname(string functionname)</functioncall>
  <description>
    Returns the last errormessage, a certain function added to the Error-Messaging-System.
    Sets read-state of the error-message to the date-time of accessing it.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer errorindex - the index of the error within the Error-Messaging-System
    string parametername - the parameter that produced the problem, or "" if no parameter was involved
    string errormessage - the errormessage
    integer errorcode - the errorcode the error has
  </retvals>
  <parameters>
    string functionname - the name of the function, whose last error message you want to retrieve
  </parameters>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, get, last error message, function</tags>
</US_DocBloc>
]]
  if type(functionname)~="string" then ultraschall.AddErrorMessage("GetLastErrorMessage_Funcname", "functionname", "must be a string", -1) return -1 end
  for i=ultraschall.ErrorCounter, 1, -1 do
    if functionname==ultraschall.ErrorMessage[i]["funcname"] then
      ultraschall.ErrorMessage[i]["readstate"]=os.date()
      return i, ultraschall.ErrorMessage[i]["parmname"],
                ultraschall.ErrorMessage[i]["errmsg"],
                ultraschall.ErrorMessage[i]["errcode"]
    end
  end
  return -1
end

--ultraschall.ShowMenu(9,9)
--L=ultraschall.ErrorMessage

--reaper.MB(ultraschall.ErrorMessage[1]["readstate"],"",0)
--for i=0, 10000 do
--end
--ultraschall.GetLastErrorMessage_Funcname("ShowMenu")

function ultraschall.CountErrorMessage_Funcname(functionname)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountErrorMessage_Funcname</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer number_of_errormessages = ultraschall.CountErrorMessage_Funcname(string functionname)</functioncall>
  <description>
    Returns the number of available errormessages for functionname, existing in the Error-Messaging-System.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer number_of_errormessages - the number of errormessages functionname has left in the Error-Messaging-System
  </retvals>
  <parameters>
    string functionname - the name of the function, whose error messages you want to count
  </parameters>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, count, error messages, function</tags>
</US_DocBloc>
]]
  if type(functionname)~="string" then ultraschall.AddErrorMessage("CountErrorMessage_Funcname", "functionname", "must be a string", -1) return -1 end
  local count=0
  for i=ultraschall.ErrorCounter, 1, -1 do
    if functionname==ultraschall.ErrorMessage[i]["funcname"] then
      count=count+1
    end
  end
  return count
end

function ultraschall.GetErrorMessage_Funcname(functionname, index)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetErrorMessage_Funcname</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer errorindex, string parametername, string errormessage, integer errorcode = ultraschall.GetErrorMessage_Funcname(string functionname, integer index)</functioncall>
  <description>
    Returns a specific errormessage specified by index, functionname added to the Error-Messaging-System.
    Sets read-state of the error-message to the date-time of accessing it.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer errorindex - the index of the error within the Error-Messaging-System
    string parametername - the parameter that produced the problem, or "" if no parameter was involved
    string errormessage - the errormessage
    integer errorcode - the errorcode the error has
  </retvals>
  <parameters>
    string functionname - the name of the function, whose last error message you want to retrieve
    integer index - the index of the error-message for functionname
  </parameters>
  <chapter_context>
    Developer
    Error Handling
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>developer, error, get, index, error message, function</tags>
</US_DocBloc>
]]
  if type(functionname)~="string" then ultraschall.AddErrorMessage("GetErrorMessage_Funcname", "functionname", "must be a string", -1) return -1 end
  if math.type(index)~="integer" then ultraschall.AddErrorMessage("GetErrorMessage_Funcname", "index", "must be an integer", -3) return -1 end
  if index<1 then ultraschall.AddErrorMessage("GetErrorMessage_Funcname", "index", "must be higher than 0", -4) return -1 end
  local count=0
  for i=ultraschall.ErrorCounter, 1, -1 do
    if functionname==ultraschall.ErrorMessage[i]["funcname"] then
      count=count+1      
      if count==index then 
        ultraschall.ErrorMessage[i]["readstate"]=os.date()
        return i, ultraschall.ErrorMessage[i]["parmname"],
                  ultraschall.ErrorMessage[i]["errmsg"],
                  ultraschall.ErrorMessage[i]["errcode"]
      end
    end
  end
  return count
end

--A,B,C,D,E=ultraschall.GetErrorMessage_Funcname("GetAllMediaItemsBetween", -1)


function ultraschall.GetSetConfigAlwaysAllowKB(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAlwaysAllowKB</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAlwaysAllowKB(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Allow keyboard commands even when mouse-editing"-checkbox, as set in Preferences -> General ->Advanced UI/system tweaks
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "alwaysallowkb", as well as the reaper.ini-entry "REAPER -> alwaysallowkb"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value; 0(don't allow) to 1(allow)
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value; 0 to 1
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Advanced UI
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, recording, allow, keyboard</tags>
</US_DocBloc>
--]]
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAlwaysAllowKB", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAlwaysAllowKB", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAlwaysAllowKB", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAlwaysAllowKB", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar("alwaysallowkb", -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar("alwaysallowkb", setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", "adjrecmanlat", tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAlwaysAllowKB(true, 2, true)

function ultraschall.GetSetConfigApplyFXTail(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigApplyFXTail</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigApplyFXTail(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Tail length when using Apply FX to items"-inputbox in milliseconds, as set in Preferences -> Media
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "applyfxtail", as well as the reaper.ini-entry "REAPER -> applyfxtail"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value; 0 to 2147483647
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value; 0 to 2147483647
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Media
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, recording, fxtail, apply fx, item</tags>
</US_DocBloc>
--]]
  local config_var="applyfxtail"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigApplyFXTail", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigApplyFXTail", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigApplyFXTail", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>2147483647 then ultraschall.AddErrorMessage("GetSetConfigApplyFXTail", "setting", "must be between 0 and 2147483647", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigApplyFXTail(true, 0, true)

function ultraschall.GetSetConfigAdjRecManLatIn(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAdjRecManLatIn</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAdjRecManLatIn(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Input manual offset-samples"-inputbox, as set in Preferences -> Recording
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "adjrecmanlatin", as well as the reaper.ini-entry "REAPER -> adjrecmanlatin"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Recording
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, input, manual offset</tags>
</US_DocBloc>
--]]
  local config_var="adjrecmanlatin"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLatIn", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLatIn", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLatIn", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>2147483647 then ultraschall.AddErrorMessage("GetSetConfigAdjRecManLatIn", "setting", "must be between 0 and 2147483647", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAdjRecManLatIn(true, -10, true)


function ultraschall.GetSetConfigAudioPrShift(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAudioPrShift</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAudioPrShift(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Preserve pitch in audio items when changing master playrate", as set in the contextmenu of the master-playrate in the transport-area as well as toggled by action 40671(all sections)
    This is a project-setting. That means, setting persist to true will have an effect on new projects create, but only after you restarted Reaper!
    
    This alters the configuration-variable "audioprshift", as well as the reaper.ini-entry "REAPER -> audioprshift"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                   - 0, don't preserve pitch - unchecked
                   - 1, preserve pitch - checked
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
                   - 0, don't preserve pitch - unchecked
                   - 1, preserve pitch - checked
    integer setting - the current/new setting-value
    boolean persist - true, this setting will be kept for new projects, but only after restart of Reaper; false, old standard-project-setting will be kept
  </parameters>
  <chapter_context>
    Configuration Settings
    Transport: Contextmenu
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, preserve pitch, master playrate</tags>
</US_DocBloc>
--]]
  local config_var="audioprshift"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioPrShift", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioPrShift", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAudioPrShift", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAudioPrShift", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAudioPrShift(true, 1, true)

function ultraschall.GetSetConfigAudioCloseStop(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAudioCloseStop</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAudioCloseStop(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Close audio device when stopped and active(less responsive)"-checkbox, as set in Preferences -> Audio  
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "audioclosestop", as well as the reaper.ini-entry "REAPER -> audioclosestop"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Audio
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, audio close, when stopped</tags>
</US_DocBloc>
--]]
  local config_var="audioclosestop"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseStop", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseStop", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseStop", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAudioCloseStop", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAudioCloseStop(true, 1, true)

function ultraschall.GetSetConfigAudioThreadPr(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAudioThreadPr</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAudioThreadPr(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Audio thread priority"-dropdownlist, as set in Preferences -> Device  
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "audiothreadpr", as well as the reaper.ini-entry "REAPER -> audiothreadpr"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
             --1, ASIO Default / MMCSS Pro Audio / Time Critical  
             -0, Normal  
             -1, Above normal  
             -2, Highest  
             -3, Time Critical  
             -4, MMCSS / Time Critical  
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                    --1, ASIO Default / MMCSS Pro Audio / Time Critical  
                    -0, Normal  
                    -1, Above normal  
                    -2, Highest  
                    -3, Time Critical  
                    -4, MMCSS / Time Critical  
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Device
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, audio, thread, priority</tags>
</US_DocBloc>
--]]
  local config_var="audiothreadpr"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioThreadPr", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioThreadPr", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAudioThreadPr", "setting", "must be an integer", -3) return -1 end
  if setting<-1 or setting>6 then ultraschall.AddErrorMessage("GetSetConfigAudioThreadPr", "setting", "must be between -1 and 6", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAudioThreadPr(true, -1, true)

function ultraschall.GetSetConfigAudioCloseTrackWnds(set, setting, persist)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetSetConfigAudioCloseTrackWnds</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetSetConfigAudioCloseTrackWnds(boolean set, integer setting, boolean persist)</functioncall>
  <description>
    Gets/Sets the value of "Allow snap grid/track envelope/routing windows to stay open"-checkbox in Preferences -> General -> Advanced UI/system tweaks.  
    To keep the setting after restart of Reaper, set persist=true
    
    This alters the configuration-variable "autoclosetrackwnds", as well as the reaper.ini-entry "REAPER -> autoclosetrackwnds"
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - the current/new setting-value
                    - 0, it is allowed(on) - checked  
                    - 1, it is not allowed(off) - unchecked  
  </retvals>
  <parameters>
    boolean set - true, set a new value; false, return the current value
    integer setting - the current/new setting-value
                    - 0, it is allowed(on) - checked  
                    - 1, it is not allowed(off) - unchecked  
    boolean persist - true, this setting will be kept after restart of Reaper; false, setting will be lost after exiting Reaper
  </parameters>
  <chapter_context>
    Configuration Settings
    Preferences: Advanced UI
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>configurationsettings, get, set, persist, keep open, windows, routing, track envelope, snapgrid</tags>
</US_DocBloc>
--]]
  local config_var="autoclosetrackwnds"
  if ultraschall.type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseTrackWnds", "set", "must be a boolean", -1) return -1 end
  if persist~=nil and ultraschall.type(persist)~="boolean" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseTrackWnds", "persist", "must be a boolean", -2) return -1 end
  if setting~=nil and ultraschall.type(setting)~="number: integer" then ultraschall.AddErrorMessage("GetSetConfigAudioCloseTrackWnds", "setting", "must be an integer", -3) return -1 end
  if setting<0 or setting>1 then ultraschall.AddErrorMessage("GetSetConfigAudioCloseTrackWnds", "setting", "must be between 0 and 1", -4) return -1 end
  if set==false then return reaper.SNM_GetIntConfigVar(config_var, -33)
  else 
    local temp=reaper.SNM_SetIntConfigVar(config_var, setting)
    if temp==false then return -1 else if persist==true then retval = ultraschall.SetIniFileExternalState("REAPER", config_var, tostring(setting), reaper.get_ini_file()) end return setting end
  end
end

--A=ultraschall.GetSetConfigAudioCloseTrackWnds(true, 1, true)


function ultraschall.tempgfxupdate_snowflakes()
    if ultraschall.US_snowmain~=nil then ultraschall.US_snowmain() end
    ultraschall.snowoldgfx()
end

function ultraschall.WinterlySnowflakes(toggle, falling_speed, number_snowflakes)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WinterlySnowflakes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WinterlySnowflakes(boolean toggle, number falling_speed, integer number_snowflakes)</functioncall>
  <description>
    Exchanges the gfx.update()-function with a variant, that displays falling snowflakes everytime it is called.
    
    returns -1 in case of error
  </description>
  <retvals>
    integer retval - returns -1 in case of a'JS_Window_ListFind' n error; 1, in case of success
  </retvals>
  <parameters>
    boolean toggle - true, toggles falling snow on; false, toggles falling snow off
    number falling_speed - the falling speed of the snowflakes, 1.3 is recommended
    integer number_snowflakes - the number of falling snowflakes at the same time on screen; 2000 is recommended
  </parameters>
  <chapter_context>
    User Interface
    Miscellaneous
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, miscellaneous, winterly snowflakes</tags>
</US_DocBloc>
]]  
  if type(falling_speed)~="number" then ultraschall.AddErrorMessage("WinterlySnowflakes", "falling_speed", "must be a number", -1) return -1 end
  if math.type(number_snowflakes)~="integer" then ultraschall.AddErrorMessage("WinterlySnowflakes", "number_snowflakes", "must be an integer", -2) return -1 end
  ultraschall.snowspeed=falling_speed           -- the falling speed of the snowflakes
  ultraschall.snowsnowfactor=number_snowflakes -- the number of snowflakes
  if toggle==true then
    gfx.update=ultraschall.tempgfxupdate_snowflakes
  else
    gfx.update=ultraschall.snowoldgfx
  end
  return 1
end
--[[
--LL=ultraschall.WinterlySnowflakes(true,"1000",1)
gfx.init()
L=1
function main()
  for i=0, 1 do
  L=L+1
  gfx.update()
  end
  A=gfx.getchar()
  if A==65 then ultraschall.WinterlySnowflakes(true, 1, 1000) end
  if A==66 then ultraschall.WinterlySnowflakes(false, 1, 1000) end
  reaper.defer(main)
end

main()
--]]

function ultraschall.SplitStringAtNULLBytes(splitstring)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SplitStringAtNULLBytes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.941
    Lua=5.3
  </requires>
  <functioncall>integer count, array split_strings = ultraschall.SplitStringAtNULLBytes(string splitstring)</functioncall>
  <description>
    Splits splitstring into individual string at NULL-Bytes.
  </description>
  <retvals>
    integer count - the number of found strings
    array split_strings - the found strings put into an array
  </retvals>
  <parameters>
    string splitstring - the string with NULL-Bytes(\0) into it, that you want to split
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, split, string, nullbytes</tags>
</US_DocBloc>
]]
  if type(splitstring)~="string" then ultraschall.AddErrorMessage("SplitStringAtNULLBytes", "splitstring", "Must be a string.", -1) return -1 end
  -- add a NULL-Byte at the end, helps us finding the end of the string later
  splitstring=splitstring.."\0"
  local count=0
  local strings={}
  local temp, offset
  
  -- let's split the string
  while splitstring~=nil do
    -- find the next string-part
    temp,offset=splitstring:match("(.-)()\0")    
    if temp~=nil then 
      -- if the next found string isn't nil, then add it fo strings-array and count+1
      count=count+1 
      strings[count]=temp
      splitstring=splitstring:sub(offset+1,-1)
      --reaper.MB(splitstring:len(),"",0)
    else 
      -- if temp is nil, the string is probably finished splitting
      break 
    end
  end
  return count, strings
end

--A2,B2=ultraschall.SplitStringAtNULLBytes("splitstrin\0g\0\0\0\0")

function ultraschall.RunBackgroundHelperFeatures(switch_on)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RunBackgroundHelperFeatures</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>ultraschall.RunBackgroundHelperFeatures(boolean switch_on)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Starts background-scripts supplied with the Ultraschall-API, like:  

      - a script for getting the last edit-cursor-position before the current one -> [GetLastCursorPosition()](#GetLastCursorPosition)
      - a script for getting the last playstate before the current one -> [GetLastPlayState()](#GetLastPlayState)
      - a script for getting the last loopstate before the current one -> [GetLastLoopState()](#GetLastLoopState)
  </description>
  <parameters>
    boolean switch_on - true, start the background-scripts/start unstarted background-helper-scripts; false, stop all background-helper-scripts
  </parameters>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, defer scripts, background scripts</tags>
</US_DocBloc>
]]
  local filecount, files = ultraschall.GetAllFilenamesInPath(ultraschall.Api_Path.."/Scripts/HelperDeferScripts/")
  local filename
  for i=1, filecount do
    filename=files[i]:match(".*/(.*)")
    if filename==nil then filename=files[i]:match(".*\\(.*)") end
    if filename==nil then filename=files[i] end
    if reaper.GetExtState("Ultraschall", "defer_scripts_"..filename)~="true" and switch_on~=false then
      local A=reaper.AddRemoveReaScript(true, 0, files[i], false)
      reaper.Main_OnCommand(A,0)
      local B=reaper.AddRemoveReaScript(false, 0, files[i], false)
    end
    if reaper.GetExtState("Ultraschall", "defer_scripts_"..filename)=="true" and switch_on==false then
        reaper.SetExtState("Ultraschall", "defer_scripts_"..filename, "false", false)
    end
  end
end

--ultraschall.RunBackgroundHelperFeatures()

function ultraschall.GetLastCursorPosition()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastCursorPosition</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number last_editcursor_position, number new_editcursor_position, number statechangetime = ultraschall.GetLastCursorPosition()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns the last and current editcursor-position. Needs Ultraschall-API-background-scripts started first, see [RunBackgroundHelperFeatures()](#RunBackgroundHelperFeatures).
    
    returns -1, if Ultraschall-API-backgroundscripts weren't started yet.
  </description>
  <retvals>
    number last_editcursor_position - the last cursorposition before the current one; -1, in case of an error
    number new_editcursor_position - the new cursorposition; -1, in case of an error
    number statechangetime - the time, when the state has changed the last time
  </retvals>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, last position, editcursor</tags>
</US_DocBloc>
]]
  if reaper.GetExtState("Ultraschall", "defer_scripts_ultraschall_track_old_cursorposition.lua")~="true" then return -1 end
  return tonumber(reaper.GetExtState("ultraschall", "editcursor_position_old")), tonumber(reaper.GetExtState("ultraschall", "editcursor_position_new")), tonumber(reaper.GetExtState("ultraschall", "editcursor_position_changetime"))
end

function ultraschall.GetLastPlayState()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastPlayState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string last_play_state, string new_play_state, number statechangetime = ultraschall.GetLastPlayState()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns the last and current playstate. Needs Ultraschall-API-background-scripts started first, see [RunBackgroundHelperFeatures()](#RunBackgroundHelperFeatures).
    
    possible states are STOP, PLAY, PLAYPAUSE, REC, RECPAUSE
    
    returns -1, if Ultraschall-API-backgroundscripts weren't started yet.
  </description>
  <retvals>
    string last_play_state - the last playstate before the current one; -1, in case of an error
    string new_play_state - the new playstate; -1, in case of an error
    number statechangetime - the time, when the state has changed the last time
  </retvals>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, last playstate, editcursor</tags>
</US_DocBloc>
]]
  if reaper.GetExtState("Ultraschall", "defer_scripts_ultraschall_track_old_playstate.lua")~="true" then return -1 end
  return reaper.GetExtState("ultraschall", "playstate_old"), reaper.GetExtState("ultraschall", "playstate_new"), tonumber(reaper.GetExtState("ultraschall", "playstate_changetime"))
end
--ultraschall.RunBackgroundHelperFeatures()
--A=ultraschall.GetLastPlayState()

function ultraschall.GetLastLoopState()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLastLoopState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>string last_loop_state, string new_loop_state, number statechangetime = ultraschall.GetLastLoopState()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns the last and current loopstate. Needs Ultraschall-API-background-scripts started first, see [RunBackgroundHelperFeatures()](#RunBackgroundHelperFeatures).
    
    Possible states are LOOPED, UNLOOPED
    
    returns -1, if Ultraschall-API-backgroundscripts weren't started yet.
  </description>
  <retvals>
    string last_loop_state - the last loopstate before the current one; -1, in case of an error
    string new_loop_state - the current loopstate; -1, in case of an error
    number statechangetime - the time, when the state has changed the last time
  </retvals>
  <chapter_context>
    Navigation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>navigation, last loopstate, editcursor</tags>
</US_DocBloc>
]]
  if reaper.GetExtState("Ultraschall", "defer_scripts_ultraschall_track_old_loopstate.lua")~="true" then return -1 end
  return reaper.GetExtState("ultraschall", "loopstate_old"), reaper.GetExtState("ultraschall", "loopstate_new"), tonumber(reaper.GetExtState("ultraschall", "loopstate_changetime"))
end


function ultraschall.Main_OnCommandByFilename(filename, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Main_OnCommandByFilename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string script_identifier = ultraschall.Main_OnCommandByFilename(string filename, string ...)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Runs a command by a filename. It internally registers the file temporarily as command, runs it and unregisters it again.
    This is especially helpful, when you want to run a command for sure without possible command-id-number-problems.
    
    It returns a unique script-identifier for this script, which can be used to communicate with this script-instance.
    The started script gets its script-identifier using [GetScriptIdentifier](#GetScriptIdentifier).
    You can use this script-identifier e.g. as extstate.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running it was successful; false, if not
    string script_identifier - a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance
  </retvals>
  <parameters>
    string filename - the name and path of the scriptfile to run
    string ... - parameters that shall be passed over to the script
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, run command, filename, scriptidentifier, scriptparameters</tags>
</US_DocBloc>
]]
  -- check parameters
  if type(filename)~="string" then ultraschall.AddErrorMessage("Main_OnCommandByFilename", "filename", "Must be a string.", -1) return false end
  if reaper.file_exists(filename)==false then ultraschall.AddErrorMessage("Main_OnCommandByFilename", "filename", "File does not exist.", -2) return false end
 
  -- create temporary copy of the scriptfile, with a guid in its name
  local filename2=filename:match("(.*)%.")
  if filename2==nil then filename2=filename.."-"..reaper.genGuid() else filename2=filename2.."-"..reaper.genGuid()..filename:match("(%..*)") end
  ultraschall.MakeCopyOfFile(filename, filename2)

  -- register, run and unregister the temporary scriptfile  
  local commandid=reaper.AddRemoveReaScript(true, 0, filename2, true)
  if commandid==0 then ultraschall.AddErrorMessage("Main_OnCommandByFilename", "filename", "Couldn't register filename. Is it a valid ReaScript?.", -3) return false end
  ultraschall.SetScriptParameters(string.gsub("ScriptIdentifier:"..filename2, "\\", "/"), ...)
  reaper.Main_OnCommand(commandid, 0)
  local commandid2=reaper.AddRemoveReaScript(false, 0, filename2, true)
  
  -- delete the temporary scriptfile
  os.remove(filename2)
  
  -- return true and the script-identifier of the started script
  return true, string.gsub("ScriptIdentifier:"..filename2, "\\", "/")
end

--reaper.MB("Hui: "..tostring(ultraschall.tempfilename:match("%-")),ultraschall.tempfilename:sub(50,-1),0) -- %-%{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x%}")),"",0)
--if ultraschall.tempfilename:match("%-%{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x%}")~=nil then reaper.MB("","zusido",0) else reaper.MB("Oh", "",0) end
--ultraschall.ScriptIdentifier="HULA"

--reaper.MB(ultraschall.ScriptIdentifier,"",0)

--A=ultraschall.GetReaperScriptPath().."/testscript_that_displays_stuff.lua"
--A=ultraschall.GetReaperScriptPath().."/us.png"
--B,C=ultraschall.Main_OnCommandByFilename(A)
--reaper.CF_SetClipboard(C.." "..ultraschall.ScriptIdentifier)



function ultraschall.MIDI_OnCommandByFilename(filename, MIDIEditor_HWND, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MIDI_OnCommandByFilename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string script_identifier = ultraschall.MIDI_OnCommandByFilename(string filename, optional HWND Midi_EditorHWND, string ...)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Runs a command by a filename in the MIDI-editor-context. It internally registers the file temporarily as command, runs it and unregisters it again.
    This is especially helpful, when you want to run a command for sure without possible command-id-number-problems.
    
    It returns a unique script-identifier for this script, which can be used to communicate with this script-instance.
    The started script gets its script-identifier using [GetScriptIdentifier](#GetScriptIdentifier).
    You can use this script-identifier e.g. as extstate.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running it was successful; false, if not
    string script_identifier - a unique script-identifier, which can be used as extstate to communicate with the started scriptinstance
  </retvals>
  <parameters>
    HWND Midi_EditorHWND - the window-handler of the MIDI-editor, in which to run the script; nil, for the last active MIDI-editor
    string filename - the name plus path of the scriptfile to run
    string ... - parameters, that shall be passed over to the script
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, run command, filename, midi, midieditor, scriptidentifier, scriptparameters</tags>
</US_DocBloc>
]]
  -- check parameters and MIDI-Editor
  if type(filename)~="string" then ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "filename", "Must be a string.", -1) return false end
  if reaper.file_exists(filename)==false then ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "filename", "File does not exist.", -2) return false end
  if MIDIEditor_HWND~=nil then
    if pcall(reaper.JS_Window_GetTitle, MIDIEditor_HWND, "")==false then ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "MIDIEditor_HWND", "Not a valid HWND.", -3) return false end
    if pcall(reaper.JS_Window_GetTitle(MIDIEditor_HWND, ""):match("MIDI"))==false then ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "MIDIEditor_HWND", "Not a valid MIDI-Editor-HWND.", -4) return false end
  end  

  -- create temporary scriptcopy with a guid in its filename
  local filename2=filename:match("(.*)%.")
  if filename2==nil then filename2=filename.."-"..reaper.genGuid() else filename2=filename2.."-"..reaper.genGuid()..filename:match("(%..*)") end
  ultraschall.MakeCopyOfFile(filename, filename2)
  
  -- register and run the temporary-scriptfile
  local commandid =reaper.AddRemoveReaScript(true, 32060, filename2, true)
  local commandid2=reaper.AddRemoveReaScript(true, 32061, filename2, true)
  local commandid3=reaper.AddRemoveReaScript(true, 32062, filename2, true)
  if commandid==0 then ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "filename", "Couldn't register filename. Is it a valid ReaScript?.", -5) return false end
  if MIDIEditor_HWND==nil then 
    ultraschall.SetScriptParameters(string.gsub("ScriptIdentifier:"..filename2, "\\", "/"), ...)
    local A2=reaper.MIDIEditor_LastFocused_OnCommand(commandid, true)
    if A2==false then A2=reaper.MIDIEditor_LastFocused_OnCommand(commandid, false) end
    if A2==false then 
      ultraschall.AddErrorMessage("MIDI_OnCommandByFilename", "MIDIEditor_HWND", "No last focused MIDI-Editor open.", -6) 
      ultraschall.GetScriptParameters(string.gsub("ScriptIdentifier:"..filename2, "\\", "/"), true)
      return false 
    end
  end
  local L=reaper.MIDIEditor_OnCommand(MIDIEditor_HWND, commandid)
  
  -- unregister the temporary-scriptfile
  local commandid_2=reaper.AddRemoveReaScript(false, 32060, filename2, true)
  local commandid_3=reaper.AddRemoveReaScript(false, 32061, filename2, true)
  local commandid_4=reaper.AddRemoveReaScript(false, 32062, filename2, true)
  
  -- delete the temporary scriptfile and return true and the script-identifier for the started script
  os.remove(filename2)
  return true, string.gsub("ScriptIdentifier:"..filename2, "\\", "/")
end

--A=ultraschall.GetReaperScriptPath().."/testscript_that_displays_stuff.lua"
--AAA=ultraschall.MIDI_OnCommandByFilename(reaper.MIDIEditor_GetActive(), A)
--AAA=ultraschall.MIDI_OnCommandByFilename(A, reaper.MIDIEditor_GetActive())
--reaper.MB("","",0)
--AAA2,AAA3=ultraschall.MIDI_OnCommandByFilename(A, reaper.MIDIEditor_GetActive())
--reaper.ShowConsoleMsg(AAA3.." - outside\n")

function ultraschall.GetScriptParameters(script_identifier, remove)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScriptParameters</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer num_params, array params, string caller_script_identifier = ultraschall.GetScriptParameters(optional string script_identifier, optional boolean remove)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Gets the parameters stored for a specific script_identifier.
  </description>
  <retvals>
    integer num_params - the number of parameters available
    array params - the values of the parameters as an array
    string caller_script_identifier - the scriptidentifier of the script, that set the parameters
  </retvals>
  <parameters>
    optional string script_identifier - the script-identifier, whose parameters you want to retrieve; 
                             - use nil, to get the parameters stored for the current script
    optional boolean remove - true or nil, remove the stored parameter-extstates; false, keep them for later retrieval
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, script, parameters, scriptidentifier</tags>
</US_DocBloc>
]]
  if script_identifier==nil or type(script_identifier)~="string" then script_identifier=ultraschall.ScriptIdentifier end
  local counter=1
  local parms={}
  while reaper.GetExtState(script_identifier, "parm_"..counter)~="" do
    parms[counter]=reaper.GetExtState(script_identifier, "parm_"..counter)
    if remove==true then
      reaper.DeleteExtState(script_identifier, "parm_"..counter, false)
    end
    counter=counter+1
  end
  local caller_script=reaper.GetExtState(script_identifier, "parm_0")
  if remove==true or remove==nil then reaper.DeleteExtState(script_identifier, "parm_0", false) end
  return counter-1, parms, caller_script
end


function ultraschall.SetScriptParameters(script_identifier, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetScriptParameters</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, string script_identifier = ultraschall.SetScriptParameters(string script_identifier, string ...)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Sets the parameters stored for a specific script_identifier.
  </description>
  <retvals>
    boolean retval - true, storing was successful
    string script_identifier - the script_identifier, whose parameters have been set
  </retvals>
  <parameters>
    string script_identifier - the script-identifier, whose parameters you want to retrieve; 
                             - use nil, to set the parameters stored for the current script
    string ... - the parameters you want to set; there can be more than one, but they must be strings
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, script, parameters, scriptidentifier</tags>
</US_DocBloc>
]]
  if script_identifier==nil or type(script_identifier)~="string" then script_identifier=ultraschall.ScriptIdentifier end
  local parms={...}
  local counter=1
  reaper.SetExtState(script_identifier, "parm_0", ultraschall.ScriptIdentifier, false)
  while parms[counter]~=nil do
    reaper.SetExtState(script_identifier, "parm_"..counter, tostring(parms[counter]), false)
    counter=counter+1
  end
  return true, script_identifier
end

--C=ultraschall.SetScriptParameters(script_identifier, 1,2,3,4,5,6,5,4,3,2,1)

--A,B=ultraschall.GetScriptParameters(script_identifier, true)


function ultraschall.GetScriptReturnvalues(script_identifier, remove)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScriptReturnvalues</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer num_params, array retvals, string caller_script_identifier = ultraschall.GetScriptReturnvalues(optional string script_identifier, optional boolean remove)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Gets the return-values stored by a specific script_identifier for the current script.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer num_retvals - the number of return-values available
    array params - the values of the return-values as an array
    string caller_script_identifier - the scriptidentifier of the script, that set the return-values
  </retvals>
  <parameters>
    optional string script_identifier - the script-identifier, whose return-values you want to retrieve; 
    optional boolean remove - true or nil, remove the stored retval-extstates; false, keep them for later retrieval
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, script, returnvalues, scriptidentifier</tags>
</US_DocBloc>
]]
  if type(script_identifier)~="string" then ultraschall.AddErrorMessage("GetScriptReturnvalues", "must be a string", -1) return -1 end
  local counter=1
  local retvals={}
  while reaper.GetExtState(ultraschall.ScriptIdentifier, script_identifier.."_retval_"..counter)~="" do
    retvals[counter]=reaper.GetExtState(ultraschall.ScriptIdentifier, script_identifier.."_retval_"..counter)
    if remove==true or remove==nil then
      reaper.DeleteExtState(ultraschall.ScriptIdentifier, script_identifier.."_retval_"..counter, false)
      local retval_identifier = reaper.GetExtState(script_identifier, "retval_sender_identifier")
      retval_identifier = string.gsub(retval_identifier, script_identifier.."\n", "")      
      if retval_identifier:match(ultraschall.ScriptIdentifier)==nil then
        reaper.SetExtState(script_identifier, "retval_sender_identifier", retval_identifier, false)
      end
    end
    counter=counter+1
  end
  return counter-1, retvals
end


function ultraschall.SetScriptReturnvalues(script_identifier, ...)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetScriptReturnvalues</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetScriptReturnvalues(string script_identifier, string ...)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Send return-values back to the script, that has a specific script_identifier.
    
    returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, storing was successful; false, there was an error
  </retvals>
  <parameters>
    string script_identifier - the script-identifier of the script-instance, to where you want to send the returnvalues 
    string ... - the returnvalues you want to set; there can be more than one, but they must be strings
  </parameters>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, script, returnvalues, scriptidentifier</tags>
</US_DocBloc>
]]
  if type(script_identifier)~="string" then ultraschall.AddErrorMessage("SetScriptReturnvalues", "must be a string", -1) return false end
  local retvals={...}
  local counter=1
  local retval_identifier = reaper.GetExtState(script_identifier, "retval_sender_identifier")
  if retval_identifier:match(ultraschall.ScriptIdentifier)==nil then
    reaper.SetExtState(script_identifier, "retval_sender_identifier", retval_identifier..ultraschall.ScriptIdentifier.."\n", false)
  end
  while retvals[counter]~=nil do
    reaper.SetExtState(script_identifier, ultraschall.ScriptIdentifier.."_retval_"..counter, tostring(retvals[counter]), false)
    counter=counter+1
  end
  return true
end

--ultraschall.SetScriptReturnvalues("Empfnger", 9,222,3,4,5,6,7,8,9,10)
--A,B,C,D,E=ultraschall.GetScriptReturnvalues("Empfnger", true)

--ultraschall.ScriptIdentifier="HalloWelt5"
--ultraschall.SetScriptReturnvalues("HalloWelt5", 9,222,3,4,5,6,7,8,9,10)

function ultraschall.GetScriptReturnvalues_Sender()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetScriptReturnvalues_Sender</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer count, array retval_sender = ultraschall.GetScriptReturnvalues_Sender()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Retrieves, which scripts send returnvalues to the current script.
  </description>
  <retvals>
    integer count - the number of scripts, who have left returnvalues for the current script
    array retval_sender - the ScriptIdentifier of the scripts, who returned values
  </retvals>
  <chapter_context>
    API-Helper functions
    Child Scripts
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, get, script, returnvalues, scriptidentifier, child scripts</tags>
</US_DocBloc>
]]
  local val=reaper.GetExtState(ultraschall.ScriptIdentifier, "retval_sender_identifier"):match("(.*)\n")
  if val==nil then return 0 end
  local count, array = ultraschall.SplitStringAtLineFeedToArray(val)
  return count, array
end

--A,B=ultraschall.GetScriptReturnvalues_Sender()

--C,D,E=ultraschall.GetScriptReturnvalues("HalloWelt5")

--A1,B1=ultraschall.GetScriptReturnvalues_Sender()



function ultraschall.IsValidHWND(HWND)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsValidHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsValidHWND(HWND hwnd)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Checks, if a HWND-handler is a valid one.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if running it was successful; false, if not
  </retvals>
  <parameters>
    HWND hwnd - the HWND-handler to check for
  </parameters>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, hwnd, is valid, check</tags>
</US_DocBloc>
]]
  if pcall(reaper.JS_Window_GetTitle, HWND, "")==false then ultraschall.AddErrorMessage("IsValidHWND", "HWND", "Not a valid HWND.", -1) return false end
  return true
end

--AAA=ultraschall.IsValidHWND(reaper.Splash_GetWnd("tudelu",nil))

--AAAAA=reaper.MIDIEditor_LastFocused_OnCommand(1)

function ultraschall.GetPath(str,sep)
-- return the path of a filename-string
-- -1 if it doesn't work
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetPath</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string path, string filename = ultraschall.GetPath(string str, optional string sep)</functioncall>
  <description>
    returns the path of a filename-string
    
    returns "", "" in case of error 
  </description>
  <retvals>
    string path  - the path as a string
    string filename - the filename, without the path
  </retvals>
  <parameters>
    string str - the path with filename you want to process
    string sep - a separator, with which the function knows, how to separate filename from path; nil to use the last useful separator in the string, which is either / or \\
  </parameters>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,path,separator</tags>
</US_DocBloc>
--]]

  -- check parameters
  if type(str)~="string" then ultraschall.AddErrorMessage("GetPath","str", "only a string allowed", -1) return "", "" end
  if sep~=nil and type(sep)~="string" then ultraschall.AddErrorMessage("GetPath","sep", "only a string allowed", -2) return "", "" end
  
  -- do the patternmatching
  local result, file

--  if result==nil then ultraschall.AddErrorMessage("GetPath","", "separator not found", -3) return "", "" end
--  if file==nil then file="" end
  if sep~=nil then 
    result=str:match("(.*"..sep..")")
    file=str:match(".*"..sep.."(.*)")
    if result==nil then ultraschall.AddErrorMessage("GetPath","", "separator not found", -3) return "", "" end
  else
    result=str:match("(.*".."[\\/]"..")")
    file=str:match(".*".."[\\/]".."(.*)")
  end
  return result, file
end

--B1,B2=ultraschall.GetPath("c:\\nillimul/\\test.kl", "\\")


function ultraschall.BrowseForOpenFiles(windowTitle, initialFolder, initialFile, extensionList, allowMultiple)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>BrowseForOpenFiles</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>string path, integer number_of_files, array filearray = ultraschall.BrowseForOpenFiles(string windowTitle, string initialFolder, string initialFile, string extensionList, boolean allowMultiple)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Opens a filechooser-dialog which optionally allows selection of multiple files.
    Unlike Reaper's own GetUserFileNameForRead, this dialog allows giving non-existant files as well(for saving operations).
    
    Returns nil in case of an error
  </description>
  <retvals>
    string path - the path, in which the selected file(s) lie; nil, in case of an error; "" if no file was selected
    integer number_of_files - the number of files selected; 0, if no file was selected
    array filearray - an array with all the selected files
  </retvals>
  <parameters>
    string windowTitle - the title shown in the filechooser-dialog
    string initialFolder - the initial-folder opened in the filechooser-dialog
    string initialFile - the initial-file selected in the filechooser-dialog, good for giving default filenames
    string extensionList - a list of extensions that can be selected in the selection-list.
                         - the list has the following structure(separate the entries with a \0): 
                         -       "description of type1\0type1\0description of type 2\0type2\0"
                         - the description of type can be anything that describes the type(s), 
                         - to define one type, write: *.ext 
                         - to define multiple types, write: *.ext;*.ext2;*.ext3
                         - the extensionList must end with a \0
    boolean allowMultiple - true, allows selection of multiple files; false, only allows selection of single files
  </parameters>
  <chapter_context>
    User Interface
    Dialogs
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, dialog, file, chooser, multiple</tags>
</US_DocBloc>
]]
  if type(windowTitle)~="string"  then ultraschall.AddErrorMessage("BrowseForOpenFiles", "windowTitle",   "Must be a string.",  -1) return nil end  
  if type(initialFolder)~="string"  then ultraschall.AddErrorMessage("BrowseForOpenFiles", "initialFolder", "Must be a string.",  -2) return nil end  
  if type(initialFile)~="string"  then ultraschall.AddErrorMessage("BrowseForOpenFiles", "initialFile",   "Must be a string.",  -3) return nil end  
  if type(extensionList)~="string"  then ultraschall.AddErrorMessage("BrowseForOpenFiles", "extensionList", "Must be a string.",  -4) return nil end  
  if type(allowMultiple)~="boolean" then ultraschall.AddErrorMessage("BrowseForOpenFiles", "allowMultiple", "Must be a boolean.", -5) return nil end  
  
  local retval, fileNames = reaper.JS_Dialog_BrowseForOpenFiles(windowTitle, initialFolder, initialFile, extensionList, allowMultiple)
  local path, filenames, count
  if allowMultiple==true then
    count, filenames = ultraschall.SplitStringAtNULLBytes(fileNames)
    path = filenames[1]
    table.remove(filenames,1)
  else
    filenames={}
    path, filenames[1]=ultraschall.GetPath(fileNames)
    count=2
  end
  if retval==0 then path="" count=1 filenames={} end
  return path, count-1, filenames
end

--A,B,C=ultraschall.BrowseForOpenFiles("Tudelu", "c:\\", "", "", true)

--A,B,C=reaper.JS_Dialog_BrowseForOpenFiles("Tudelu", "", "", "", false)

function ultraschall.HasHWNDChildWindowNames(HWND, childwindownames)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>HasHWNDChildWindowNames</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.HasHWNDChildWindowNames(HWND hwnd, string childwindownames)</functioncall>
  <description>
    Returns, whether the given HWND has childhwnds with a certain name in them. This is good for checking for valid Reaper-windows. 
    As gfx.init()-windows can have the same as Reaper's original-windows, this function gives you the chance for aditional checks.
    gfx.init windows don't have child-hwnds and other applications probably have child-hwnds with different names.
    
    returns false in case of an error
  </description>
  <retvals>
    boolean retal - true, the HWND has child-hwnds with that name(s); false, it doesn't
  </retvals>
  <parameters>
    HWND hwnd - the HWND, whose child-hwnd-names you want to check
    string childwindownames - a string with the names of the child-HWNDs the parameter hwnd must have. It is a \0-separated string, means, you put \0 in between the child-Hwnd-names.
  </parameters>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, check, childhwnd, hwnd, windows</tags>
</US_DocBloc>
]]
  local count, individual_values = ultraschall.CSV2IndividualLinesAsArray(childwindownames,"\0")
  local retval, list = reaper.JS_Window_ListAllChild(HWND)
  local count2, individual_values2 = ultraschall.CSV2IndividualLinesAsArray(list)
  local Title={}
  for i=1, count2 do
    if individual_values2[i]~="" then
      local tempHwnd=reaper.JS_Window_HandleFromAddress(individual_values2[i])
      Title[i]=reaper.JS_Window_GetTitle(tempHwnd)
      for a=1, count do
        if Title[i]==individual_values[a] then individual_values[a]="found" end
      end
    end
  end
  for i=1, count do
    if individual_values[i]~="found" then return false end
  end
  return true
end

--reaper.ShowConsoleMsg("A")
--A2=reaper.JS_Window_Find("ReaScript console output", true)
--O2=ultraschall.HasHWNDChildWindowNames(A2, "Clear\0 Close")

function ultraschall.CloseReaScriptConsole()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CloseReaScriptConsole</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.CloseReaScriptConsole()</functioncall>
  <description>
    Closes the ReaConsole-window, if opened.
    
    Returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if there is a mute-point; false, if there isn't one
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, reaconsole, close</tags>
</US_DocBloc>
]]
  local translation = reaper.JS_Localize("ReaScript console output", "DLG_437")
  local retval,Adr=reaper.JS_Window_ListFind(translation, true)

--  if retval>1 then ultraschall.AddErrorMessage("CloseReaScriptConsole", "", "Multiple windows are open, that are named \"ReaScript console output\". Can't find the right one, sorry.", -1) return false end
  if retval==0 then ultraschall.AddErrorMessage("CloseReaScriptConsole", "", "ReaConsole-window not opened", -2) return false end
  local count2, individual_values2 = ultraschall.CSV2IndividualLinesAsArray(Adr)
  for i=1, count2 do
    local B=reaper.JS_Window_HandleFromAddress(individual_values2[i])
    if ultraschall.HasHWNDChildWindowNames(B, "Clear\0Close")==true then 
      reaper.JS_Window_Destroy(B) 
      return true 
    end
  end
  return false
end

--gfx.init("ReaScript console output")
--reaper.ShowConsoleMsg("Tudelu")
--LL,LL=ultraschall.CloseReaConsole()

function ultraschall.GetApiVersion()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetApiVersion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string version, string date, string beta, number versionnumber, string tagline = ultraschall.GetApiVersion()</functioncall>
  <description>
    returns the version, release-date and if it's a beta-version plus the currently installed hotfix
  </description>
  <retvals>
    string version - the current Api-version
    string date - the release date of this api-version
    string beta - if it's a beta version, this is the beta-version-number
    number versionnumber - a number, that you can use for comparisons like, "if requestedversion>versionnumber then"
    string tagline - the tagline of the current release
    string hotfix_date - the release-date of the currently installed hotfix ($ResourceFolder/ultraschall_api/ultraschall_hotfixes.lua)
  </retvals>
  <chapter_context>
    API-Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>version,versionmanagement</tags>
</US_DocBloc>
--]]
  return "4.00","1st of March 2019", "Beta 2.72", 400.0272,  "\"Blue Oyster Cult - Don't fear the Reaper\"", ultraschall.hotfixdate
end

--A,B,C,D,E,F,G,H,I=ultraschall.GetApiVersion()

function ultraschall.Base64_Encoder(source_string, base64_type, remove_newlines, remove_tabs)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Base64_Encoder</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string encoded_string = ultraschall.Base64_Encoder(string source_string, optional integer base64_type, optional integer remove_newlines, optional integer remove_tabs)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Converts a string into a Base64-Encoded string. 
    Currently, only standard Base64-encoding is supported.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string encoded_string - the encoded string
  </retvals>
  <parameters>
    string source_string - the string that you want to convert into Base64
    optional integer base64_type - the Base64-decoding-style
                                 - nil or 0, for standard default Base64-encoding
    optional integer remove_newlines - 1, removes \n-newlines(including \r-carriage return) from the string
                                     - 2, replaces \n-newlines(including \r-carriage return) from the string with a single space
    optional integer remove_tabs     - 1, removes \t-tabs from the string
                                     - 2, replaces \t-tabs from the string with a single space
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, encode, base64, string</tags>
</US_DocBloc>
]]
  -- Not to myself:
  -- When you do the decoder, you need to take care, that the bitorder must be changed first, before creating the final-decoded characters
  -- that means: reverse the process of the "tear apart the source-string into bits"-code-passage
  
  -- check parameters and prepare variables
  if type(source_string)~="string" then ultraschall.AddErrorMessage("Base64_Encoder", "source_string", "must be a string", -1) return nil end
  if remove_newlines~=nil and math.type(remove_newlines)~="integer" then ultraschall.AddErrorMessage("Base64_Encoder", "remove_newlines", "must be an integer", -2) return nil end
  if remove_tabs~=nil and math.type(remove_tabs)~="integer" then ultraschall.AddErrorMessage("Base64_Encoder", "remove_tabs", "must be an integer", -3) return nil end
  if base64_type~=nil and math.type(base64_type)~="integer" then ultraschall.AddErrorMessage("Base64_Encoder", "base64_type", "must be an integer", -4) return nil end
  
  local tempstring={}
  local a=1
  local temp
  
  -- this is probably the future space for more base64-encoding-schemes
  local base64_string="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    
  -- if source_string is multiline, get rid of \r and replace \t and \n with a single whitespace
  if remove_newlines==1 then
    source_string=string.gsub(source_string, "\n", "")
    source_string=string.gsub(source_string, "\r", "")
  elseif remove_newlines==2 then
    source_string=string.gsub(source_string, "\n", " ")
    source_string=string.gsub(source_string, "\r", "")  
  end

  if remove_tabs==1 then
    source_string=string.gsub(source_string, "\t", "")
  elseif remove_tabs==2 then 
    source_string=string.gsub(source_string, "\t", " ")
  end
  
  
  -- tear apart the source-string into bits
  -- bitorder of bytes will be reversed for the later parts of the conversion!
  for i=1, source_string:len() do
    temp=string.byte(source_string:sub(i,i))
    temp=temp
    if temp&1==0 then tempstring[a+7]=0 else tempstring[a+7]=1 end
    if temp&2==0 then tempstring[a+6]=0 else tempstring[a+6]=1 end
    if temp&4==0 then tempstring[a+5]=0 else tempstring[a+5]=1 end
    if temp&8==0 then tempstring[a+4]=0 else tempstring[a+4]=1 end
    if temp&16==0 then tempstring[a+3]=0 else tempstring[a+3]=1 end
    if temp&32==0 then tempstring[a+2]=0 else tempstring[a+2]=1 end
    if temp&64==0 then tempstring[a+1]=0 else tempstring[a+1]=1 end
    if temp&128==0 then tempstring[a]=0 else tempstring[a]=1 end
    a=a+8
  end
  
  -- now do the encoding
  local encoded_string=""
  local temp2=0
  
  -- take six bits and make a single integer-value off of it
  -- after that, use this integer to know, which place in the base64_string must
  -- be read and included into the final string "encoded_string"
  for i=0, a-2, 6 do
    temp2=0
    if tempstring[i+1]==1 then temp2=temp2+32 end
    if tempstring[i+2]==1 then temp2=temp2+16 end
    if tempstring[i+3]==1 then temp2=temp2+8 end
    if tempstring[i+4]==1 then temp2=temp2+4 end
    if tempstring[i+5]==1 then temp2=temp2+2 end
    if tempstring[i+6]==1 then temp2=temp2+1 end
    encoded_string=encoded_string..base64_string:sub(temp2+1,temp2+1)
  end

  -- if the number of characters in the encoded_string isn't exactly divideable 
  -- by 3, add = to fill up missing bytes
  if encoded_string:len()%3==1 then encoded_string=encoded_string.."=="
  elseif encoded_string:len()%3==2 then encoded_string=encoded_string.."="
  end
  
  return encoded_string
end


--A=ultraschall.Base64_Encoder("Man is", 9, 9, 9)

function ultraschall.Base64_Decoder(source_string, base64_type)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Base64_Decoder</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string decoded_string = ultraschall.Base64_Decoder(string source_string, optional integer base64_type)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Converts a Base64-encoded string into a normal string. 
    Currently, only standard Base64-encoding is supported.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string decoded_string - the decoded string
  </retvals>
  <parameters>
    string source_string - the Base64-encoded string
    optional integer base64_type - the Base64-decoding-style
                                 - nil or 0, for standard default Base64-encoding
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, decode, base64, string</tags>
</US_DocBloc>
]]
  if type(source_string)~="string" then ultraschall.AddErrorMessage("Base64_Decoder", "source_string", "must be a string", -1) return nil end
  if base64_type~=nil and math.type(base64_type)~="integer" then ultraschall.AddErrorMessage("Base64_Decoder", "base64_type", "must be an integer", -2) return nil end
  
  -- this is probably the place for other types of base64-decoding-stuff  
  local base64_string="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  
  
  -- remove =
  source_string=string.gsub(source_string,"=","")

  local L=source_string:match("[^"..base64_string.."]")
  if L~=nil then ultraschall.AddErrorMessage("Base64_Decoder", "source_string", "no valid Base64-string: invalid characters", -3) return nil end
  
  -- split the string into bits
  local bitarray={}
  local count=1
  local temp
  for i=1, source_string:len() do
    temp=base64_string:match(source_string:sub(i,i).."()")-2
    if temp&32~=0 then bitarray[count]=1 else bitarray[count]=0 end
    if temp&16~=0 then bitarray[count+1]=1 else bitarray[count+1]=0 end
    if temp&8~=0 then bitarray[count+2]=1 else bitarray[count+2]=0 end
    if temp&4~=0 then bitarray[count+3]=1 else bitarray[count+3]=0 end
    if temp&2~=0 then bitarray[count+4]=1 else bitarray[count+4]=0 end
    if temp&1~=0 then bitarray[count+5]=1 else bitarray[count+5]=0 end
    count=count+6
  end
  
  -- combine the bits into the original bytes and put them into decoded_string
  local decoded_string=""
  local temp2=0
  for i=0, count-1, 8 do
    temp2=0
    if bitarray[i+1]==1 then temp2=temp2+128 end
    if bitarray[i+2]==1 then temp2=temp2+64 end
    if bitarray[i+3]==1 then temp2=temp2+32 end
    if bitarray[i+4]==1 then temp2=temp2+16 end
    if bitarray[i+5]==1 then temp2=temp2+8 end
    if bitarray[i+6]==1 then temp2=temp2+4 end
    if bitarray[i+7]==1 then temp2=temp2+2 end
    if bitarray[i+8]==1 then temp2=temp2+1 end
    decoded_string=decoded_string..string.char(temp2)
  end
  return decoded_string
end

--O=ultraschall.Base64_Decoder("VHV0YXNzc0z=")

function ultraschall.MB(msg,title,mbtype)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>MB</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.MB(string msg, optional string title, optional integer type)</functioncall>
  <description>
    Shows Messagebox with user-clickable buttons. Works like reaper.MB() but unlike reaper.MB, this function accepts omitting some parameters for quicker use.
    
    Returns -1 in case of an error
  </description>
  <parameters>
    string msg - the message, that shall be shown in messagebox
    optional string title - the title of the messagebox
    optional integer type - which buttons shall be shown in the messagebox
                            - 0, OK
                            - 1, OK CANCEL
                            - 2, ABORT RETRY IGNORE
                            - 3, YES NO CANCEL
                            - 4, YES NO
                            - 5, RETRY CANCEL
                            - nil, defaults to OK
  </parameters>
  <retvals>
    integer - the button pressed by the user
                           - -1, error while executing this function
                           - 1, OK
                           - 2, CANCEL
                           - 3, ABORT
                           - 4, RETRY
                           - 5, IGNORE
                           - 6, YES
                           - 7, NO
  </retvals>
  <chapter_context>
    User Interface
    Dialogs
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, user, interface, input, dialog, messagebox</tags>
</US_DocBloc>
--]]
--  if type(msg)~="string" then ultraschall.AddErrorMessage("MB","msg", "Must be a string!", -1) return -1 end
  msg=tostring(msg)
  if type(title)~="string" then title="" end
  if math.type(mbtype)~="integer" then mbtype=0 end
  if mbtype<0 or mbtype>5 then ultraschall.AddErrorMessage("MB","mbtype", "Must be between 0 and 5!", -2) return -1 end
  reaper.MB(msg, title, mbtype)
end
--ultraschall.MB(reaper.GetTrack(0,0))

function ultraschall.CreateValidTempFile(filename_with_path, create, suffix, retainextension)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateValidTempFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string tempfilename = ultraschall.CreateValidTempFile(string filename_with_path, boolean create, string suffix, boolean retainextension)</functioncall>
  <description>
    Tries to determine a valid temporary filename. Will check filename_with_path with an included number between 0 and 16384 to create such a filename.
    You can also add your own suffix to the filename.
    
    The pattern is: filename_with_path$Suffix~$number.ext (when retainextension is set to true!)
    
    If you wish, you can also create this temporary-file as an empty file.
    
    The path of the tempfile is always the same as the original file.
    
    Returns nil in case of failure.
  </description>
  <retvals>
    string tempfilename - the valid temporary filename found
  </retvals>
  <parameters>
    string filename_with_path - the original filename
    boolean create - true, if you want to create that temporary file as an empty file; false, just return the filename
    string suffix - if you want to alter the temporary filename with an additional suffix, use this parameter
    boolean retainextension - true, keep the extension(if existing) at the end of the tempfile; false, just add the suffix~number at the end.
  </parameters>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement, create, temporary, file, filename</tags>
</US_DocBloc>
]]
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("CreateValidTempFile","filename_with_path", "Must be a string!", -2) return nil end
  if type(create)~="boolean" then ultraschall.AddErrorMessage("CreateValidTempFile","create", "Must be boolean!", -3) return nil end
  if type(suffix)~="string" then ultraschall.AddErrorMessage("CreateValidTempFile","suffix", "Must be a string!", -4) return nil end
  if type(retainextension)~="boolean" then ultraschall.AddErrorMessage("CreateValidTempFile","retainextension", "Must be boolean!", -5) return nil end
  local extension, tempfilename, A
  if retainextension==true then extension=filename_with_path:match(".*(%..*)") end
  if extension==nil then extension="" end
  for i=0, 16384 do
    tempfilename=filename_with_path..suffix.."~"..i..extension
    if reaper.file_exists(tempfilename)==false then
      if create==true then 
        A=ultraschall.WriteValueToFile(tempfilename,"")
        if A==1 then return tempfilename end
      elseif create==false then 
        return tempfilename
      end
    end
  end
  ultraschall.AddErrorMessage("CreateValidTempFile","filename_with_path", "Couldn't create a valid temp-file!", -1)
  return nil
end


function ultraschall.RenderProject_RenderCFG(projectfilename_with_path, renderfilename_with_path, startposition, endposition, overwrite_without_asking, renderclosewhendone, filenameincrease, rendercfg)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RenderProject_RenderCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer retval, integer renderfilecount, array MediaItemStateChunkArray, array Filearray = ultraschall.RenderProject_RenderCFG(string projectfilename_with_path, string renderfilename_with_path, number startposition, number endposition, boolean overwrite_without_asking, boolean renderclosewhendone, boolean filenameincrease, optional string rendercfg)</functioncall>
  <description>
    Renders a project, using a specific render-cfg-string.
    To get render-cfg-strings, see <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>
    
    Returns -1 in case of an error
    Returns -2 if currently opened project must be saved first(if you want to render the currently opened project).
  </description>
  <retvals>
    integer retval - -1, in case of error; 0, in case of success; -2, if you try to render the currently opened project without saving it first
    integer renderfilecount - the number of rendered files
    array MediaItemStateChunkArray - the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems)
    array Filearray - the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems)
  </retvals>
  <parameters>
    string projectfilename_with_path - the project to render; nil, for the currently opened project(needs to be saved first)
    string renderfilename_with_path - the filename of the output-file. If you give the wrong extension, Reaper will exchange it by the correct one.
                                    - nil, will use the render-filename/render-pattern already set in the project as renderfilename
    number startposition - the startposition of the render-area in seconds; 
                         - -1, to use the startposition set in the projectfile itself; 
                         - -2, to use the start of the time-selection
    number endposition - the endposition of the render-area in seconds; 
                       - 0, to use projectlength of the currently opened and active project(not supported with "external" projectfiles, yet)
                       - -1, to use the endposition set in the projectfile itself
                       - -2, to use the end of the time-selection
    boolean overwrite_without_asking - true, overwrite an existing renderfile; false, don't overwrite an existing renderfile
    boolean renderclosewhendone - true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings
    boolean filenameincrease - true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings
    optional string rendercfg - the rendercfg-string, that contains all render-settings for an output-format
                              - To get render-cfg-strings, see <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>, <a href="#CreateRenderCFG_WAVPACK">CreateRenderCFG_WAVPACK</a>, <a href="#CreateRenderCFG_WebMVideo">CreateRenderCFG_WebMVideo</a>
                              - omit it or set to nil, if you want to use the render-string already set in the project
  </parameters>
  <chapter_context>
    Rendering of Project
    Rendering any Outputformat
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, render, output, file</tags>
</US_DocBloc>
]]
  local retval
  local curProj=reaper.EnumProjects(-1,"")
  if type(startposition)~="number" then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "startposition", "Must be a number in seconds.", -1) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "endposition", "Must be a number in seconds.", -2) return -1 end
  if startposition>=0 and endposition>0 and endposition<=startposition then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "endposition", "Must be bigger than startposition.", -3) return -1 end
  if endposition<-2 then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "endposition", "Must be bigger than 0 or -1(to retain project-file's endposition).", -4) return -1 end
  if startposition<-2 then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "startposition", "Must be bigger than 0 or -1(to retain project-file's startposition).", -5) return -1 end
  if projectfilename_with_path==nil and reaper.IsProjectDirty(0)==1 then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "renderfilename_with_path", "To render current project, it must be saved first!", -8) return -2 end
  if endposition==0 and projectfilename_with_path==nil then endposition=reaper.GetProjectLength(0) end
  if projectfilename_with_path==nil then 
    -- reaper.Main_SaveProject(0, false)
    retval, projectfilename_with_path = reaper.EnumProjects(-1,"")
  end  
  
  if type(projectfilename_with_path)~="string" or reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "projectfilename_with_path", "File does not exist.", -6) return -1 end
  if renderfilename_with_path~=nil and type(renderfilename_with_path)~="string" then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "renderfilename_with_path", "Must be a string.", -7) return -1 end  
  if rendercfg~=nil and ultraschall.GetOutputFormat_RenderCfg(rendercfg)==nil then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "rendercfg", "No valid render_cfg-string.", -9) return -1 end
  if type(overwrite_without_asking)~="boolean" then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "overwrite_without_asking", "Must be boolean", -10) return -1 end

  -- Read Projectfile
  local FileContent=ultraschall.ReadFullFile(projectfilename_with_path, false)
  if ultraschall.CheckForValidFileFormats(projectfilename_with_path)~="RPP_PROJECT" then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "projectfilename_with_path", "Must be a valid Reaper-Project", -14) return -1 end
  local oldrendercfg=ultraschall.GetProject_RenderCFG(nil, FileContent)
  if rendercfg==nil then rendercfg=oldrendercfg end
    
  -- create temporary-project-filename
  local tempfile = ultraschall.CreateValidTempFile(projectfilename_with_path, true, "ultraschall-temp", true) 
  
  -- Write temporary projectfile
  ultraschall.WriteValueToFile(tempfile, FileContent)
  
  -- Add the render-filename to the project 
  if renderfilename_with_path~=nil then
    ultraschall.SetProject_RenderFilename(tempfile, renderfilename_with_path)
    ultraschall.SetProject_RenderPattern(tempfile, nil)
  end
  
  -- Add render-format-settings as well as adding media to project after rendering
  ultraschall.SetProject_RenderCFG(tempfile, rendercfg)
  ultraschall.SetProject_AddMediaToProjectAfterRender(tempfile, 1)
  
  -- Add the rendertime to the temporary project-file, when 
  local bounds, time_start, time_end, tail, tail_length = ultraschall.GetProject_RenderRange(tempfile)
--  if time_end==0 then time_end = ultraschall.GetProject_Length(tempfile) end
  local timesel1_start, timesel1_end = ultraschall.GetProject_Selection(tempfile)
  --   if startposition and/or endposition are -1, retain the start/endposition from the project-file

  if startposition==-1 then startposition=time_start end
  if endposition==-1 or endposition==0 then if time_end==0 then endposition=ultraschall.GetProject_Length(tempfile) else endposition=time_end end end
  if startposition==-2 then startposition=timesel1_start end
  if endposition==-2 then endposition=timesel1_end end

  if endposition==0 and startposition==0 then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "startposition or endposition in RPP-Project", "Can't render a project of length 0 seconds.", -13) os.remove (tempfile) return -1 end
  if endposition<=startposition and endposition~=0 then ultraschall.AddErrorMessage("RenderProject_RenderCFG", "startposition or endposition in RPP-Project", "Must be bigger than startposition.", -11) os.remove (tempfile) return -1 end
  local Bretval = ultraschall.SetProject_RenderRange(tempfile, 0, startposition, endposition, 0, 0)
  if Bretval==-1 then 
    os.remove (tempfile) 
    ultraschall.AddErrorMessage("RenderProject_RenderCFG", "projectfilename_with_path", "Can't set the timerange in the temporary-project "..tempfile, -12)
    return -1 
  end
  

  -- Get currently opened project
  local _temp, oldprojectname=ultraschall.EnumProjects(0)
  
  --Now the magic happens:
  
  -- delete renderfile, if already existing and overwrite_without_asking==true
  if overwrite_without_asking==true then
    if renderfilename_with_path~=nil and reaper.file_exists(renderfilename_with_path)==true then
      os.remove(renderfilename_with_path) 
    end
  end 
  
  
  reaper.Main_OnCommand(40859,0)    -- create new temporary tab
  reaper.Main_openProject(tempfile) -- load the temporary projectfile
  
  -- manage automatically closing of the render-window and filename-increasing
  local val=reaper.SNM_GetIntConfigVar("renderclosewhendone", -99)
  local oldval=val
  if renderclosewhendone==true then 
    if val&1==0 then val=val+1 end
    if val==-99 then val=1 end
  elseif renderclosewhendone==false then 
    if val&1==1 then val=val-1 end
    if val==-99 then val=0 end
  end
  
  if filenameincrease==true then 
    if val&16==0 then val=val+16 end
    if val==-99 then val=16 end
  elseif filenameincrease==false then 
    if val&16==16 then val=val-16 end
    if val==-99 then val=0 end
  end
  reaper.SNM_SetIntConfigVar("renderclosewhendone", val)
  
  -- temporarily disable building peak-caches
  local peakval=reaper.SNM_GetIntConfigVar("peakcachegenmode", -99)
  reaper.SNM_SetIntConfigVar("peakcachegenmode", 0)
  
  local AllTracks=ultraschall.CreateTrackString_AllTracks() -- get number of tracks after rendering and adding of rendered files
  
  reaper.Main_OnCommand(41824,0)    -- render using it with the last rendersettings(those, we inserted included)
  reaper.Main_SaveProject(0, false) -- save it(no use, but otherwise, Reaper would open a Save-Dialog, that we don't want and need)
  local AllTracks2=ultraschall.CreateTrackString_AllTracks() -- get number of tracks after rendering and adding of rendered files
  local retval, Trackstring = ultraschall.OnlyTracksInOneTrackstring(AllTracks, AllTracks2) -- only get the newly added tracks as trackstring
  local count, MediaItemArray, MediaItemStateChunkArray
  if Trackstring~="" then 
    count, MediaItemArray, MediaItemStateChunkArray = ultraschall.GetAllMediaItemsBetween(0, reaper.GetProjectLength(0), Trackstring, false) -- get the new MediaItems created after adding the rendered files
  else
    count=0
  end
  reaper.Main_OnCommand(40860,0)    -- close the temporary-tab again

  local Filearray={}
  for i=1, count do
    Filearray[i]=MediaItemStateChunkArray[i]:match("%<SOURCE.-FILE \"(.-)\"")
  end

  -- reset old renderclose/overwrite/Peak-cache-settings
  reaper.SNM_SetIntConfigVar("renderclosewhendone", oldval)
  reaper.SNM_SetIntConfigVar("peakcachegenmode", peakval)

  --remove the temp-file and we are done.
  os.remove (tempfile)
  os.remove (tempfile.."-bak")
  reaper.SelectProjectInstance(curProj)
  return 0, count, MediaItemStateChunkArray, Filearray
end

--A,B,C,D=ultraschall.RenderProject_RenderCFG(nil, nil, 0, 100, true, true, true)

function ultraschall.GetMediafileAttributes(filename)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetMediafileAttributes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>number length, integer numchannels, integer Samplerate, string Filetype = ultraschall.GetMediafileAttributes(string filename)</functioncall>
  <description>
    returns the attributes of a mediafile
    
    if the mediafile is an rpp-project, this function creates a proxy-file called filename.RPP-PROX, which is a wave-file of the length of the project.
    This file can be deleted safely after that, but would be created again the next time this function is called.    
  </description>
  <parameters>
    string filename - the file whose attributes you want to have
  </parameters>
  <retvals>
    number length - the length of the mediafile in seconds
    integer numchannels - the number of channels of the mediafile
    integer Samplerate - the samplerate of the mediafile in hertz
    string Filetype - the type of the mediafile, like MP3, WAV, MIDI, FLAC, RPP_PROJECT etc
  </retvals>
  <chapter_context>
    MediaItem Management
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, get, position, length, num, channels, samplerate, filetype</tags>
</US_DocBloc>
--]]
  if type(filename)~="string" then ultraschall.AddErrorMessage("GetMediafileAttributes","filename", "must be a string", -1) return -1 end
  if reaper.file_exists(filename)==false then ultraschall.AddErrorMessage("GetMediafileAttributes","filename", "file does not exist", -2) return -1 end
  local PCM_source=reaper.PCM_Source_CreateFromFile(filename)
  local Length, lengthIsQN = reaper.GetMediaSourceLength(PCM_source)
  local Numchannels=reaper.GetMediaSourceNumChannels(PCM_source)
  local Samplerate=reaper.GetMediaSourceSampleRate(PCM_source)
  local Filetype=reaper.GetMediaSourceType(PCM_source, "")  
  reaper.PCM_Source_Destroy(PCM_source)
--  if Filetype=="RPP_PROJECT" then os.remove(filename.."-PROX") end
  return Length, Numchannels, Samplerate, Filetype
end

function ultraschall.RenderProjectRegions_RenderCFG(projectfilename_with_path, renderfilename_with_path, region, addregionname, overwrite_without_asking, renderclosewhendone, filenameincrease, rendercfg)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RenderProjectRegions_RenderCFG</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer retval, integer renderfilecount, array MediaItemStateChunkArray, array Filearray = ultraschall.RenderProjectRegions_RenderCFG(string projectfilename_with_path, string renderfilename_with_path, integer region, boolean addregionname, boolean overwrite_without_asking, boolean renderclosewhendone, boolean filenameincrease, optional string rendercfg)</functioncall>
  <description>
    Renders a region of a project, using a specific render-cfg-string.
    To get render-cfg-strings, see <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>
    
    Returns -1 in case of an error
    Returns -2 if currently opened project must be saved first(if you want to render the currently opened project).
  </description>
  <retvals>
    integer retval - -1, in case of error; 0, in case of success; -2, if you try to render the currently opened project without saving it first
    integer renderfilecount - the number of rendered files
    array MediaItemStateChunkArray - the MediaItemStateChunks of all rendered files, with the one in entry 1 being the rendered master-track(when rendering stems)
    array Filearray - the filenames of the rendered files, including their paths. The filename in entry 1 is the one of the mastered track(when rendering stems)
  </retvals>
  <parameters>
    string projectfilename_with_path - the project to render; nil, for the currently opened project(needs to be saved first)
    string renderfilename_with_path - the filename of the output-file. 
                                    - Don't add a file-extension, when using addregionname=true!
                                    - Give a path only, when you want to use only the regionname as render-filename(set addregionname=true !)
                                    - nil, use the filename/render-pattern already set in the project for the renderfilename
    integer region - the number of the region in the Projectfile to render
    boolean addregionname - add the name of the region to the renderfilename; only works, when you don't add a file-extension to renderfilename_with_path
    boolean overwrite_without_asking - true, overwrite an existing renderfile; false, don't overwrite an existing renderfile
    boolean renderclosewhendone - true, automatically close the render-window after rendering; false, keep rendering window open after rendering; nil, use current settings
    boolean filenameincrease - true, silently increase filename, if it already exists; false, ask before overwriting an already existing outputfile; nil, use current settings
    optional string rendercfg - the rendercfg-string, that contains all render-settings for an output-format
                              - To get render-cfg-strings, see <a href="#CreateRenderCFG_AIFF">CreateRenderCFG_AIFF</a>, <a href="#CreateRenderCFG_DDP">CreateRenderCFG_DDP</a>, <a href="#CreateRenderCFG_FLAC">CreateRenderCFG_FLAC</a>, <a href="#CreateRenderCFG_OGG">CreateRenderCFG_OGG</a>, <a href="#CreateRenderCFG_Opus">CreateRenderCFG_Opus</a>, <a href="#CreateRenderCFG_WAVPACK">CreateRenderCFG_WAVPACK</a>, <a href="#CreateRenderCFG_WebMVideo">CreateRenderCFG_WebMVideo</a>
                              - omit it or set to nil, if you want to use the render-string already set in the project
  </parameters>
  <chapter_context>
    Rendering of Project
    Rendering any Outputformat
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, render, output, file</tags>
</US_DocBloc>
]]
  local retval
  local curProj=reaper.EnumProjects(-1,"")
  if math.type(region)~="integer" then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "region", "Must be an integer.", -1) return -1 end
  if projectfilename_with_path==nil and reaper.IsProjectDirty(0)==1 then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "renderfilename_with_path", "To render current project, it must be saved first!", -2) return -2 end
  if type(projectfilename_with_path)~="string" then 
    -- reaper.Main_SaveProject(0, false)
    retval, projectfilename_with_path = reaper.EnumProjects(-1,"")
  end
  
  if reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "projectfilename_with_path", "File does not exist.", -3) return -1 end
  if renderfilename_with_path~=nil and type(renderfilename_with_path)~="string" then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "renderfilename_with_path", "Must be a string.", -4) return -1 end  
  if rendercfg~=nil and ultraschall.GetOutputFormat_RenderCfg(rendercfg)==nil then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "rendercfg", "No valid render_cfg-string.", -5) return -1 end
  if type(overwrite_without_asking)~="boolean" then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "overwrite_without_asking", "Must be boolean", -6) return -1 end

  local countmarkers, nummarkers, numregions, markertable = ultraschall.GetProject_MarkersAndRegions(projectfilename_with_path)
  if region>numregions then ultraschall.AddErrorMessage("RenderProjectRegions_RenderCFG", "region", "No such region in the project.", -7) return -1 end
  local regioncount=0
  for i=1, countmarkers do
    if markertable[i][1]==true then 
      regioncount=regioncount+1
      if regioncount==region then region=i break end
    end
  end
  if addregionname==true then renderfilename_with_path=renderfilename_with_path..markertable[region][4] end

  return ultraschall.RenderProject_RenderCFG(projectfilename_with_path, renderfilename_with_path, tonumber(markertable[region][2]), tonumber(markertable[region][3]), overwrite_without_asking, renderclosewhendone, filenameincrease, rendercfg)
end




function ultraschall.CreateTemporaryFileOfProjectfile(projectfilename_with_path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateTemporaryFileOfProjectfile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string tempfile = ultraschall.CreateTemporaryFileOfProjectfile(string projectfilename_with_path)</functioncall>
  <description>
    Creates a temporary copy of an rpp-projectfile, which can be altered and rendered again.
    
    Must be deleted by hand using os.remove(tempfile) after you're finished.
    
    returns nil in case of an error
  </description>
  <retvals>
    string tempfile - the temporary-file, that is a valid copy of the projectfilename_with_path
  </retvals>
  <parameters>
    string projectfilename_with_path - the project to render; nil, for the currently opened project(needs to be saved first)
  </parameters>
  <chapter_context>
    Rendering of Project
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, tempfile, temporary, render, output, file</tags>
</US_DocBloc>
]]
  local temp
  if projectfilename_with_path==nil then 
    if reaper.IsProjectDirty(0)~=1 then
      temp, projectfilename_with_path=reaper.EnumProjects(-1, "") 
    else
      ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "", "current project must be saved first", -1) return nil
    end
  end
  if type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "projectfilename_with_path", "must be a string", -2) return nil end
  if reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "projectfilename_with_path", "no such file", -3) return nil end
  local A=ultraschall.ReadFullFile(projectfilename_with_path)
  if A==nil then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "projectfilename_with_path", "Can't read projectfile", -4) return nil end
  if ultraschall.IsValidProjectStateChunk(A)==false then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "projectfilename_with_path", "no valid project-file", -5) return nil end
  local tempfilename=ultraschall.CreateValidTempFile(projectfilename_with_path, true, "", true)
  if tempfilename==nil then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "", "Can't create tempfile", -6) return nil end
  local B=ultraschall.WriteValueToFile(tempfilename, A)
  if B==-1 then ultraschall.AddErrorMessage("CreateTemporaryFileOfProjectfile", "projectfilename_with_path", "Can't create tempfile", -7) return nil else return tempfilename end
end

--length, numchannels, Samplerate, Filetype = ultraschall.GetMediafileAttributes("c:\\Users\\meo\\Desktop\\tudelu\\tudelu.RPP")
--A,B,C,D,E = ultraschall.CreateTemporaryFileOfProjectfile("c:\\Users\\meo\\Desktop\\tudelu\\tudelu.RPP")
--A,B,C,D,E = ultraschall.CreateTemporaryFileOfProjectfile()

function ultraschall.GetProject_Length(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_Length</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.95
    Lua=5.3
  </requires>
  <functioncall>number length, number last_itemedge, number last_marker_reg_edge, number last_timesig_marker = ultraschall.GetProject_Length(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the projectlength of an rpp-project-file.
    
    It's eturning the position of the overall length, as well as the position of the last itemedge/regionedge/marker/time-signature-marker of the project.
    
    Returns -1 in case of an error
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the project, that you want to know it's length of; nil to use parameter ProjectStateChunk instead
    optional string ProjectStateChunk - a ProjectStateChunk to count the length of; only available when projectfilename_with_path=nil
  </parameters>
  <retvals>
    number length - the length of the project
    number last_itemedge - the postion of the last itemedge in the project
    number last_marker_reg_edge - the position of the last marker/regionedge in the project
    number last_timesig_marker - the position of the last time-signature-marker in the project
  </retvals>
  <chapter_context>
    Project-Files
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>project management, get, length of project, marker, region, timesignature, lengt, item, edge</tags>
</US_DocBloc>
]]

  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_Length","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return -1 end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Length","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return -1 end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_Length","projectfilename_with_path", "File does not exist!", -3) return -1
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_Length", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return -1 end
  end

  local B, C, ProjectLength, Len, Pos, Offs

  -- search for the last item-edge in the project
  B=ProjectStateChunk
  B=B:match("(%<ITEM.*)<EXTENS").."\n<ITEM"
  ProjectLength=0
  local Item_Length=0
  local Marker_Length=0
  local TempoMarker_Length=0
  
  -- let's take a huge project-string apart to make patternmatching much faster
  local K={}
  local counter=0
  while B:len()>1000 do     
    K[counter]=B:sub(0, 100000)
    B=B:sub(100001,-1)
    counter=counter+1    
  end
  if counter==0 then K[0]=B end
  
  local counter2=1
  local B=K[0]
  
  local Itemscount=0
  
  
  while B~=nil and B:sub(1,5)=="<ITEM" do  
    if B:len()<10000 and counter2<counter then B=B..K[counter2] counter2=counter2+1 end
    Offs=B:match(".()<ITEM")

    local sc=B:sub(1,200)
    if sc==nil then break end

    Pos = sc:match("POSITION (.-)\n")
    Len = sc:match("LENGTH (.-)\n")

    if Pos==nil or Len==nil or Offs==nil then break end
    if ProjectLength<tonumber(Pos)+tonumber(Len) then ProjectLength=tonumber(Pos)+tonumber(Len) end
    B=B:sub(Offs,-1)  
    Itemscount=Itemscount+1
  end
  Item_Length=ProjectLength

  -- search for the last marker/regionedge in the project
  local markerregioncount, NumMarker, Numregions, Markertable = ultraschall.GetProject_MarkersAndRegions(nil, ProjectStateChunk)
  
  for i=1, markerregioncount do
    if ProjectLength<Markertable[i][2]+Markertable[i][3] then ProjectLength=Markertable[i][2]+Markertable[i][3] end
    if Marker_Length<Markertable[i][2]+Markertable[i][3] then Marker_Length=Markertable[i][2]+Markertable[i][3] end
  end
  
  -- search for the last tempo-envx-marker in the project
  B=ultraschall.GetProject_TempoEnv_ExStateChunk(nil, ProjectStateChunk)  
  C=B:match(".*PT (.-) ")
  if C~=nil and ProjectLength<tonumber(C) then ProjectLength=tonumber(C) end
  if C~=nil and TempoMarker_Length<tonumber(C) then TempoMarker_Length=tonumber(C) end
  
  return ProjectLength, Item_Length, Marker_Length, TempoMarker_Length
end

function ultraschall.SetProject_RenderPattern(projectfilename_with_path, render_pattern, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetProject_RenderPattern</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetProject_RenderPattern(string projectfilename_with_path, string render_pattern, optional string ProjectStateChunk)</functioncall>
  <description>
    Sets the render-filename in an rpp-projectfile or a ProjectStateChunk. Set it to "", if you want to set the render-filename with <a href="#SetProject_RenderFilename">SetProject_RenderFilename</a>.
    
    Returns -1 in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - the filename of the projectfile; nil to use Parameter ProjectStateChunk instead
    string render_pattern - the pattern, with which the rendering-filename will be automatically created. Check also <a href="#GetProject_RenderFilename">GetProject_RenderFilename</a>
    -Capitalizing the first character of the wildcard will capitalize the first letter of the substitution. 
    -Capitalizing the first two characters of the wildcard will capitalize all letters.
    -
    -Directories will be created if necessary. For example if the render target is "$project/track", the directory "$project" will be created.
    -
    -$item    media item take name, if the input is a media item
    -$itemnumber  1 for the first media item on a track, 2 for the second...
    -$track    track name
    -$tracknumber  1 for the first track, 2 for the second...
    -$parenttrack  parent track name
    -$region    region name
    -$regionnumber  1 for the first region, 2 for the second...
    -$namecount  1 for the first item or region of the same name, 2 for the second...
    -$start    start time of the media item, render region, or time selection
    -$end    end time of the media item, render region, or time selection
    -$startbeats  start time in beats of the media item, render region, or time selection
    -$endbeats  end time in beats of the media item, render region, or time selection
    -$timelineorder  1 for the first item or region on the timeline, 2 for the second...
    -$project    project name
    -$tempo    project tempo at the start of the render region
    -$timesignature  project time signature at the start of the render region, formatted as 4-4
    -$filenumber  blank (optionally 1) for the first file rendered, 1 (optionally 2) for the second...
    -$filenumber[N]  N for the first file rendered, N+1 for the second...
    -$note    C0 for the first file rendered,C#0 for the second...
    -$note[X]    X (example: B2) for the first file rendered, X+1 (example: C3) for the second...
    -$natural    C0 for the first file rendered, D0 for the second...
    -$natural[X]  X (example: F2) for the first file rendered, X+1 (example: G2) for the second...
    -$format    render format (example: wav)
    -$samplerate  sample rate (example: 44100)
    -$sampleratek  sample rate (example: 44.1)
    -$year    year
    -$year2    last 2 digits of the year
    -$month    month number
    -$monthname  month name
    -$day    day of the month
    -$hour    hour of the day in 24-hour format
    -$hour12    hour of the day in 12-hour format
    -$ampm    am if before noon,pm if after noon
    -$minute    minute of the hour
    -$second    second of the minute
    -$user    user name
    -$computer  computer name
    -
    -(this description has been taken from the Render Wildcard Help within the Render-Dialog of Reaper)
    optional string ProjectStateChunk - a projectstatechunk, that you want to be changed
  </parameters>
  <retvals>
    integer retval - -1 in case of error, 1 in case of success
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Set
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, set, recording, render pattern, filename, render</tags>
</US_DocBloc>
]]  
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderPattern", "ProjectStateChunk", "Must be a valid ProjectStateChunk", -1) return -1 end
  if projectfilename_with_path~=nil and reaper.file_exists(projectfilename_with_path)==false then ultraschall.AddErrorMessage("SetProject_RenderPattern", "projectfilename_with_path", "File does not exist", -2) return -1 end
  if projectfilename_with_path~=nil then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path) end
  if projectfilename_with_path~=nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderPattern", "projectfilename_with_path", "File is no valid RPP-Projectfile", -3) return -1 end
  if render_pattern~=nil and type(render_pattern)~="string" then ultraschall.AddErrorMessage("SetProject_RenderPattern", "render_pattern", "Must be a string", -4) return -1 end
  if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("SetProject_RenderPattern", "projectfilename_with_path", "No valid RPP-Projectfile!", -5) return -1 end
  local quots

  local FileStart=ProjectStateChunk:match("(<REAPER_PROJECT.-RENDER_FILE.-%c)")
  local FileEnd=ProjectStateChunk:match("<REAPER_PROJECT.-(RENDER_FMT.*)")
  local RenderPattern
  if render_pattern:match("%s")~=nil then quots="\"" else quots="" end
  if render_pattern==nil then RenderPattern="" else RenderPattern="  RENDER_PATTERN "..quots..render_pattern..quots.."\n" end
  
  ProjectStateChunk=FileStart..RenderPattern.."  "..FileEnd
  if projectfilename_with_path~=nil then return ultraschall.WriteValueToFile(projectfilename_with_path, ProjectStateChunk), ProjectStateChunk
  else return 1, ProjectStateChunk
  end  
end

function ultraschall.InsertMediaItemFromFile(filename, track, position, endposition, editcursorpos, offset)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>InsertMediaItemFromFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>integer retval, MediaItem item, number endposition, integer numchannels, integer Samplerate, string Filetype, number editcursorposition, MediaTrack track = ultraschall.InsertMediaItemFromFile(string filename, integer track, number position, number endposition, integer editcursorpos, optional number offset)</functioncall>
  <description>
    Inserts the mediafile filename into the project at position in track
    When giving an rpp-projectfile, it will be rendered by Reaper and inserted as subproject!
    
    Due API-limitations, it creates two undo-points: one for inserting the MediaItem and one for changing the length(when endposition isn't -1).    
    
    Returns -1 in case of failure
  </description>
  <parameters>
    string filename - the path+filename of the mediafile to be inserted into the project
    integer track - the track, in which the file shall be inserted
                  -  0, insert the file into a newly inserted track after the last track
                  - -1, insert the file into a newly inserted track before the first track
    number position - the position of the newly inserted item
    number endposition - the length of the newly created mediaitem; -1, use the length of the sourcefile
    integer editcursorpos - the position of the editcursor after insertion of the mediafile
          - 0 - the old editcursorposition
          - 1 - the position, at which the item was inserted
          - 2 - the end of the newly inserted item
    optional number offset - an offset, to delay the insertion of the item, to overcome possible "too late"-starting of playback of item during recording
  </parameters>
  <retvals>
    integer retval - 0, if insertion worked; -1, if it failed
    MediaItem item - the newly created MediaItem
    number endposition - the endposition of the newly created MediaItem in seconds
    integer numchannels - the number of channels of the mediafile
    integer Samplerate - the samplerate of the mediafile in hertz
    string Filetype - the type of the mediafile, like MP3, WAV, MIDI, FLAC, etc
    number editcursorposition - the (new) editcursorposition
    MediaTrack track - returns the MediaTrack, in which the item is included
  </retvals>
  <chapter_context>
    MediaItem Management
    Insert
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>markermanagement, insert, mediaitem, position, mediafile, track</tags>
</US_DocBloc>
--]]

  -- check parameters
  if reaper.file_exists(filename)==false then ultraschall.AddErrorMessage("InsertMediaItemFromFile", "filename", "file does not exist", -1) return -1 end
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("InsertMediaItemFromFile","track", "must be an integer", -2) return -1 end
  if type(position)~="number" then ultraschall.AddErrorMessage("InsertMediaItemFromFile","position", "must be a number", -3) return -1 end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("InsertMediaItemFromFile","endposition", "must be a number", -4) return -1 end
  if endposition<-1 then ultraschall.AddErrorMessage("InsertMediaItemFromFile","endposition", "must be bigger/equal 0; or -1 for sourcefilelength", -5) return -1 end
  if math.type(editcursorpos)~="integer" then ultraschall.AddErrorMessage("InsertMediaItemFromFile", "editcursorpos", "must be an integer between 0 and 2", -6) return -1 end
  if track<-1 or track>reaper.CountTracks(0) then ultraschall.AddErrorMessage("InsertMediaItemFromFile","track", "no such track available", -7) return -1 end  
  if offset~=nil and type(offset)~="number" then ultraschall.AddErrorMessage("InsertMediaItemFromFile","offset", "must be either nil or a number", -8) return -1 end  
  if offset==nil then offset=0 end
    
  -- where to insert and where to have the editcursor after insert
  local editcursor, mode
  if editcursorpos==0 then editcursor=reaper.GetCursorPosition()
  elseif editcursorpos==1 then editcursor=position
  elseif editcursorpos==2 then editcursor=position+ultraschall.GetMediafileAttributes(filename)
  else ultraschall.AddErrorMessage("InsertMediaItemFromFile","editcursorpos", "must be an integer between 0 and 2", -6) return -1
  end
  
  -- insert file
  local Length, Numchannels, Samplerate, Filetype = ultraschall.GetMediafileAttributes(filename) -- mediaattributes, like length
  local startTime, endTime = reaper.BR_GetArrangeView(0) -- get current arrange-view-range
  local mode=0
  if track>=0 and track<reaper.CountTracks(0) then
    mode=0
  elseif track==0 then
    mode=0
    track=reaper.CountTracks(0)
  elseif track==-1 then
    mode=0
    track=1
    reaper.InsertTrackAtIndex(0,false)
  end
  local SelectedTracks=ultraschall.CreateTrackString_SelectedTracks() -- get old track-selection
  ultraschall.SetTracksSelected(tostring(track), true) -- set track selected, where we want to insert the item
  reaper.SetEditCurPos(position+offset, false, false) -- change editcursorposition to where we want to insert the item
  local CountMediaItems=reaper.CountMediaItems(0) -- the number of items available; the new one will be number of items + 1
  local LLL=ultraschall.GetAllMediaItemGUIDs()
  if LLL[1]==nil then LLL[1]="tudelu" end
  local integer=reaper.InsertMedia(filename, mode)  -- insert item with file
  local LLL2=ultraschall.GetAllMediaItemGUIDs()
  local A,B=ultraschall.CompareArrays(LLL, LLL2)
  local item=reaper.BR_GetMediaItemByGUID(0, A[1])
  if endposition~=-1 then reaper.SetMediaItemInfo_Value(item, "D_LENGTH", endposition) end
  
  reaper.SetEditCurPos(editcursor, false, false)  -- set editcursor to new position
  reaper.BR_SetArrangeView(0, startTime, endTime) -- reset to old arrange-view-range
  if SelectedTracks~="" then ultraschall.SetTracksSelected(SelectedTracks, true) end -- reset old trackselection
  return 0, item, Length, Numchannels, Samplerate, Filetype, editcursor, reaper.GetMediaItem_Track(item)
end

--A,B,C,D,E,F,G,H,I,J=ultraschall.InsertMediaItemFromFile(ultraschall.Api_Path.."/misc/silence.flac", 0, 0, -1, 0)

function ultraschall.GetProject_RenderFilename(projectfilename_with_path, ProjectStateChunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetProject_RenderFilename</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>string render_filename = ultraschall.GetProject_RenderFilename(string projectfilename_with_path, optional string ProjectStateChunk)</functioncall>
  <description>
    Returns the render-filename from an RPP-Projectfile or a ProjectStateChunk. If it contains only a path or nothing, you should check the Render_Pattern using <a href="#GetProject_RenderPattern">GetProject_RenderPattern</a>, as a render-pattern influences the rendering-filename as well.
    
    It's the entry RENDER_FILE
    
    Returns nil in case of error.
  </description>
  <parameters>
    string projectfilename_with_path - filename with path for the rpp-projectfile; nil, if you want to use parameter ProjectStateChunk
    optional string ProjectStateChunk - a ProjectStateChunk to use instead if a filename; only used, when projectfilename_with_path is nil
  </parameters>
  <retvals>
    string render_filename - the filename for rendering, check also <a href="#GetProject_RenderPattern">GetProject_RenderPattern</a>
  </retvals>
  <chapter_context>
    Project-Files
    RPP-Files Get
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, rpp, state, get, recording, path, render filename, filename, render</tags>
</US_DocBloc>
]]
  -- check parameters and prepare variable ProjectStateChunk
  if projectfilename_with_path~=nil and type(projectfilename_with_path)~="string" then ultraschall.AddErrorMessage("GetProject_RenderFilename","projectfilename_with_path", "Must be a string or nil(the latter when using parameter ProjectStateChunk)!", -1) return nil end
  if projectfilename_with_path==nil and ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderFilename","ProjectStateChunk", "No valid ProjectStateChunk!", -2) return nil end
  if projectfilename_with_path~=nil then
    if reaper.file_exists(projectfilename_with_path)==true then ProjectStateChunk=ultraschall.ReadFullFile(projectfilename_with_path, false)
    else ultraschall.AddErrorMessage("GetProject_RenderFilename","projectfilename_with_path", "File does not exist!", -3) return nil
    end
    if ultraschall.IsValidProjectStateChunk(ProjectStateChunk)==false then ultraschall.AddErrorMessage("GetProject_RenderFilename", "projectfilename_with_path", "No valid RPP-Projectfile!", -4) return nil end
  end
  -- get the value and return it
  local temp=ProjectStateChunk:match("<REAPER_PROJECT.-RENDER_FILE%s(.-)%c.-<RENDER_CFG")
  if temp:sub(1,1)=="\"" then temp=temp:sub(2,-1) end
  if temp:sub(-1,-1)=="\"" then temp=temp:sub(1,-2) end
  return temp
end

function ultraschall.WriteValueToFile(filename_with_path, value, binarymode, append)
  -- Writes value to filename_with_path
  -- Keep in mind, that you need to escape \ by writing \\, or it will not work
  -- binarymode
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WriteValueToFile</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WriteValueToFile(string filename_with_path, string value, optional boolean binarymode, optional boolean append)</functioncall>
  <description>
    Writes value to filename_with_path. Will replace any previous content of the file if append is set to false. Returns -1 in case of failure, 1 in case of success.
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval  - -1 in case of failure, 1 in case of success
  </retvals>
  <parameters>
    string filename_with_path - the filename with it's path
    string value - the value to export, can be a long string that includes newlines and stuff. nil is not allowed!
    boolean binarymode - true or nil, it will store the value as binary-file; false, will store it as textstring
    boolean append - true, add the value to the end of the file; false or nil, write value to file and erase all previous data in the file
  </parameters>
  <chapter_context>
    File Management
    Write Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,export,write,file,textfile,binary</tags>
</US_DocBloc>
--]]
  -- check parameters
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("WriteValueToFile","filename_with_path", "invalid filename", -1) return -1 end
  --if type(value)~="string" then ultraschall.AddErrorMessage("WriteValueToFile","value", "must be string; convert with tostring(value), if necessary.", -2) return -1 end
  value=tostring(value)
  
  -- prepare variables
  local binary, appendix, file
  if binarymode==nil or binarymode==true then binary="b" else binary="" end
  if append==nil or append==false then appendix="w" else appendix="a" end
  
  -- write file
  file=io.open(filename_with_path,appendix..binary)
  if file==nil then ultraschall.AddErrorMessage("WriteValueToFile","filename_with_path", "can't create file", -3) return -1 end
  file:write(value)
  file:close()
  return 1
end

function ultraschall.WriteValueToFile_Insert(filename_with_path, linenumber, value)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WriteValueToFile_Insert</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WriteValueToFile_Insert(string filename_with_path, integer linenumber, string value)</functioncall>
  <description>
    Inserts value into a file at linenumber. All lines, up to linenumber-1 come before value, all lines at linenumber to the end of the file will come after value.
    Will return -1, if no such line exists.
    
    Note: non-binary-files only!
  </description>
  <parameters>
    string filename_with_path - filename to write the value to
    integer linenumber - the linenumber, at where to insert the value into the file
    string value - the value to be inserted into the file
  </parameters>
  <retvals>
    integer retval - 1, in case of success, -1 in case of error
  </retvals>
  <chapter_context>
    File Management
    Write Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,export,write,file,textfile,insert</tags>
</US_DocBloc>
]]
  if filename_with_path==nil then ultraschall.AddErrorMessage("WriteValueToFile_Insert","filename_with_path", "nil not allowed as filename", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("WriteValueToFile_Insert","filename_with_path", "file does not exist", -2) return -1 end
  --if value==nil then ultraschall.AddErrorMessage("WriteValueToFile_Insert","value", "nil not allowed", -3) return -1 end
  value=tostring(value)
  if tonumber(linenumber)==nil then ultraschall.AddErrorMessage("WriteValueToFile_Insert","linenumber", "invalid linenumber", -4) return -1 end
  local numberoflines=ultraschall.CountLinesInFile(filename_with_path)
  if tonumber(linenumber)<1 or tonumber(linenumber)>numberoflines then ultraschall.AddErrorMessage("WriteValueToFile_Insert","linenumber", "linenumber must be between 1 and "..numberoflines.." for this file", -5) return -1 end
  local contents, correctnumberoflines = ultraschall.ReadLinerangeFromFile(filename_with_path, 1, linenumber-1) 
  local contents2, correctnumberoflines = ultraschall.ReadLinerangeFromFile(filename_with_path, linenumber, numberoflines)
  return ultraschall.WriteValueToFile(filename_with_path, contents..value..contents2, false, false)
end


function ultraschall.WriteValueToFile_Replace(filename_with_path, startlinenumber, endlinenumber, value)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WriteValueToFile_Replace</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WriteValueToFile_Replace(string filename_with_path, integer startlinenumber, integer endlinenumber, string value)</functioncall>
  <description>
    Replaces the linenumbers startlinenumber to endlinenumber in a file with value. All lines, up to startlinenumber-1 come before value, all lines at endlinenumber+1 to the end of the file will come after value.
    Will return -1, if no such lines exists.
    
    Note: non-binary-files only!
  </description>
  <parameters>
    string filename_with_path - filename to write the value to
    integer startlinenumber - the first linenumber, to be replaced with value in the file
    integer endlinenumber - the last linenumber, to be replaced with value in the file
    string value - the value to be inserted into the file
  </parameters>
  <retvals>
    integer retval - 1, in case of success, -1 in case of error
  </retvals>
  <chapter_context>
    File Management
    Write Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,export,write,file,textfile,replace</tags>
</US_DocBloc>
]]
  if type(filename_with_path)~="string" then ultraschall.AddErrorMessage("WriteValueToFile_Replace","filename_with_path", "must be a string", -1) return -1 end
  if filename_with_path==nil then ultraschall.AddErrorMessage("WriteValueToFile_Replace","filename_with_path", "nil not allowed as filename", -0) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("WriteValueToFile_Replace","filename_with_path", "file does not exist", -2) return -1 end
--  if value==nil then ultraschall.AddErrorMessage("WriteValueToFile_Replace","value", "nil not allowed", -3) return -1 end
  value=tostring(value)
  if tonumber(startlinenumber)==nil then ultraschall.AddErrorMessage("WriteValueToFile_Replace","startlinenumber", "invalid linenumber", -4) return -1 end
  if tonumber(endlinenumber)==nil then ultraschall.AddErrorMessage("WriteValueToFile_Replace","endlinenumber", "invalid linenumber", -5) return -1 end
  local numberoflines=ultraschall.CountLinesInFile(filename_with_path)
  if tonumber(startlinenumber)<1 or tonumber(startlinenumber)>numberoflines then ultraschall.AddErrorMessage("WriteValueToFile_Replace","startlinenumber", "linenumber must be between 1 and "..numberoflines.." for this file", -6) return -1 end
  if tonumber(endlinenumber)<tonumber(startlinenumber) or tonumber(endlinenumber)>numberoflines then ultraschall.AddErrorMessage("WriteValueToFile_Replace","endlinenumber", "linenumber must be bigger than "..startlinenumber.." for startlinenumber and max "..numberoflines.." for this file", -7) return -1 end
  local contents, correctnumberoflines = ultraschall.ReadLinerangeFromFile(filename_with_path, 1, startlinenumber-1) 
  local contents2, correctnumberoflines = ultraschall.ReadLinerangeFromFile(filename_with_path, endlinenumber+1, numberoflines)
  return ultraschall.WriteValueToFile(filename_with_path, contents..value..contents2, false, false)
end

function ultraschall.WriteValueToFile_InsertBinary(filename_with_path, byteposition, value)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WriteValueToFile_InsertBinary</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WriteValueToFile_InsertBinary(string filename_with_path, integer byteposition, string value)</functioncall>
  <description>
    Inserts value into a file at byteposition. All bytes, up to byteposition-1 come before value, all bytes at byteposition to the end of the file will come after value.
    Will return -1, if no such line exists.
    
    Note: good for binary files
  </description>
  <parameters>
    string filename_with_path - filename to write the value to
    integer byteposition - the byteposition, at where to insert the value into the file
    string value - the value to be inserted into the file
  </parameters>
  <retvals>
    integer retval - 1, in case of success, -1 in case of error
  </retvals>
  <chapter_context>
    File Management
    Write Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,export,write,file,textfile,insert,binary</tags>
</US_DocBloc>
]]
  if filename_with_path==nil then ultraschall.AddErrorMessage("WriteValueToFile_InsertBinary","filename_with_path", "nil not allowed as filename", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("WriteValueToFile_InsertBinary","filename_with_path", "file does not exist", -2) return -1 end
  --if value==nil then ultraschall.AddErrorMessage("WriteValueToFile_InsertBinary","value", "nil not allowed", -3) return -1 end
  value=tostring(value)
  if tonumber(byteposition)==nil then ultraschall.AddErrorMessage("WriteValueToFile_InsertBinary","byteposition", "invalid value. Only integer allowed", -4) return -1 end
  local filelength=ultraschall.GetLengthOfFile(filename_with_path)
  if tonumber(byteposition)<0 or tonumber(byteposition)>filelength then ultraschall.AddErrorMessage("WriteValueToFile_InsertBinary","byteposition", "must be inbetween 0 and "..filelength.." for this file", -5) return -1 end
  if byteposition==0 then byteposition=1 end
  local correctnumberofbytes, contents=ultraschall.ReadBinaryFile_Offset(filename_with_path, 0, byteposition-1)
  local correctnumberofbytes2, contents2=ultraschall.ReadBinaryFile_Offset(filename_with_path, byteposition, -1)
  return ultraschall.WriteValueToFile(filename_with_path, contents..value..contents2, true, false)
end

function ultraschall.WriteValueToFile_ReplaceBinary(filename_with_path, startbyteposition, endbyteposition, value)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>WriteValueToFile_ReplaceBinary</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.40
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.WriteValueToFile_ReplaceBinary(string filename_with_path, integer startbyteposition, integer endbyteposition, string value)</functioncall>
  <description>
    Replaces content in the file from startbyteposition to endbyteposition-1 with value. All bytes, up to startbyteposition-1 come before value, all bytes from (and including)endbyteposition to the end of the file will come after value.
    Will return -1, if no such line exists.
    
    Note: good for binary files
  </description>
  <parameters>
    string filename_with_path - filename to write the value to
    integer startbyteposition - the first byte in the file to be replaced, starting with 1, if you want to replace at the beginning of the file. Everything before startposition will be kept.
    integer endbyteposition - the first byte after the replacement. Everything from endbyteposition to the end of the file will be kept.
    string value - the value to be inserted into the file
  </parameters>
  <retvals>
    integer retval - 1, in case of success, -1 in case of error
  </retvals>
  <chapter_context>
    File Management
    Write Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>filemanagement,export,write,file,textfile,replace,binary</tags>
</US_DocBloc>
]]
  if filename_with_path==nil then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","filename_with_path", "nil not allowed as filename", -1) return -1 end
  if reaper.file_exists(filename_with_path)==false then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","filename_with_path", "file does not exist", -2) return -1 end
  --if value==nil then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","value", "nil not allowed", -3) return -1 end
  value=tostring(value)
  if tonumber(startbyteposition)==nil then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","startbyteposition", "invalid value. Only integer allowed", -4) return -1 end
  if tonumber(endbyteposition)==nil then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","endbyteposition", "invalid value. Only integer allowed", -5) return -1 end
  
  local filelength=ultraschall.GetLengthOfFile(filename_with_path)
  if tonumber(startbyteposition)<0 or tonumber(startbyteposition)>filelength then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","startbyteposition", "must be inbetween 0 and "..filelength.." for this file", -6) return -1 end
  if tonumber(endbyteposition)<tonumber(startbyteposition) or tonumber(endbyteposition)>filelength then ultraschall.AddErrorMessage("WriteValueToFile_ReplaceBinary","endbyteposition", "must be inbetween "..startbyteposition.." and "..filelength.." for this file", -7) return -1 end

  if startbyteposition==0 then startbyteposition=1 end
  correctnumberofbytes, contents=ultraschall.ReadBinaryFile_Offset(filename_with_path, 0, startbyteposition-1)
  local correctnumberofbytes2, contents2=ultraschall.ReadBinaryFile_Offset(filename_with_path, endbyteposition-1, -1)
  return ultraschall.WriteValueToFile(filename_with_path, contents..value..contents2, true, false)
end

function ultraschall.StateChunkLayouter(statechunk)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>StateChunkLayouter</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string layouted_statechunk = ultraschall.StateChunkLayouter(string statechunk)</functioncall>
  <description>
    Layouts StateChunks as returned by <a href="Reaper_Api_Documentation.html#GetTrackStateChunk">GetTrackStateChunk</a> or <a href="Reaper_Api_Documentation.html#GetItemStateChunk">GetItemStateChunk</a> into a format that resembles the formatting-rules of an rpp-file.
    This is very helpful, when parsing such a statechunk, as you can now use the number of spaces used for intendation as help parsing.
    Usually, every new element, that starts with &lt; will be followed by none or more lines, that have two spaces added in the beginning.
    Example of a MediaItemStateChunk(I use . to display the needed spaces in the beginning of each line):
    <pre><code>
    &lt;ITEM
    ..POSITION 6.96537864205337
    ..SNAPOFFS 0
    ..LENGTH 1745.2745
    ..LOOP 0
    ..ALLTAKES 0
    ..FADEIN 1 0.01 0 1 0 0
    ..FADEOUT 1 0.01 0 1 0 0
    ..MUTE 0
    ..SEL 1
    ..IGUID {020E6372-97E6-4066-9010-B044F67F2772}
    ..IID 1
    ..NAME myaudio.flac
    ..VOLPAN 1 0 1 -1
    ..SOFFS 0
    ..PLAYRATE 1 1 0 -1 0 0.0025
    ..CHANMODE 0
    ..GUID {79F087CE-49E8-4212-91F5-8487FBCF10B1}
    ..&lt;SOURCE FLAC
    ....FILE "C:\Users\meo\Desktop\X_Karo_Lynn-Interview.flac"
    ..&gt;
    &gt;
    </code></pre>
    
    This function will not check, if you've passed a valid statechunk!
    
    returns nil in case of an error
  </description>
  <parameters>
    string statechunk - a statechunk, that you want to layout properly
  </parameters>
  <retvals>
    string layouted_statechunk - the statechunk, that is now layouted to the rules of rpp-projectfiles
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, layout, statechunk</tags>
</US_DocBloc>
]]

  if type(statechunk)~="string" then ultraschall.AddErrorMessage("StateChunkLayouter","statechunk", "must be a string", -1) return nil end  
  local num_tabs=0
  local newsc=""
  for k in string.gmatch(statechunk, "(.-\n)") do
    if k:sub(1,1)==">" then num_tabs=num_tabs-1 end
    for i=0, num_tabs-1 do
      newsc=newsc.."  "
    end
    if k:sub(1,1)=="<" then num_tabs=num_tabs+1 end
    newsc=newsc..k
  end
  return newsc
end


function ultraschall.CountUltraschallEffectPlugins(track)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountUltraschallEffectPlugins</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer num_studiolink, table studiolink_bypass_state, integer num_studiolink_onair, table studiolink_onair_bypass_state, integer num_soundboard, table soundboard_bypass_state, integer num_usdynamics, table usdynamics_bypass_state = ultraschall.CountUltraschallEffectPlugins(integer track)</functioncall>
  <description>
    Counts the number of loaded StudioLink-plugins, StudioLink_OnAir-plugins, Ultraschall-Soundboards and Ultraschall_Dynamics-instances in this track.
    It also returns the bypass/offline-states of each plugin as a table, of the following format:    
      <pre><code>
        bypass_state_table[plugin_index][1]=bypass state; 1, plugin-instance is bypassed; 0, plugin-instance is normal
        bypass_state_table[plugin_index][2]=offline state; 1, plugin-instance is offline; 0, plugin-instance is online
        bypass_state_table[plugin_index][3]=unknown state(needs documentation first); 0, default setting
      </code></pre>
    Probably only helpful, if you've installed these plugins or using Ultraschall.
    
    returns -1 in case of an error
  </description>
  <parameters>
    integer track - the tracknumber, whose plugin-counts/bypass-states you want to get; 0, Master Track; 1 and higher, Track 1 an higher
  </parameters>
  <retvals>
    integer num_studiolink - the number of loaded StudioLink-plugins in this track
    table studiolink_bypass_state - the bypass-states of StudioLink in this track
    integer num_studiolink_onair - the number of loaded StudioLink_OnAir-plugins in this track
    table studiolink_onair_bypass_state - the bypass-states of StudioLink_OnAir in this track
    integer num_soundboard - the number of loaded Ultraschall Soundboard-plugins in this track
    table soundboard_bypass_state - the bypass-states of the Ultraschall Soundboard in this track
    integer num_usdynamics - the number of loaded Ultraschall_Dynamics-plugins in this track
    table usdynamics_bypass_state - the bypass-states of Ultraschall_Dynamics in this track
  </retvals>
  <chapter_context>
    FX/Plugin Management
    Ultraschall-related
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>fx_pluginmanagement, count, get, studiolink, studiolinkonair, soundboard, ultraschall_dynamics, bypass-state, offline-state</tags>
</US_DocBloc>
]]
  local MediaTrack
  if math.type(track)~="integer" then ultraschall.AddErrorMessage("CountUltraschallEffectPlugins", "track", "must be an integer", -1) return -1 end
  if track==0 then MediaTrack=reaper.GetMasterTrack(0) else MediaTrack=reaper.GetTrack(0, track-1) end
  if MediaTrack==nil then ultraschall.AddErrorMessage("CountUltraschallEffectPlugins", "track", "no such track", -2) return -1 end
  local num_sl=0
  local sl_byp={}
  local num_slonair=0
  local slonair_byp={}
  local num_soundboard=0
  local soundboard_byp={}
  local num_usdynamics=0
  local usdynamics_byp={}
  local lastbypassline=""

  local A,B=reaper.GetTrackStateChunk(MediaTrack,"",false)
  
  for k in string.gmatch(B,"(.-\n)") do
    if k:match("<.-StudioLinkOnAir ")~=nil then 
      num_slonair=num_slonair+1 
      slonair_byp[num_slonair]={lastbypassline:match(" (%d) (%d) (%d)")} 
      slonair_byp[num_slonair][1]=tonumber(slonair_byp[num_slonair][1]) 
      slonair_byp[num_slonair][2]=tonumber(slonair_byp[num_slonair][2]) 
      slonair_byp[num_slonair][3]=tonumber(slonair_byp[num_slonair][3]) 
    elseif k:match("<.-StudioLink ")~=nil then 
      num_sl=num_sl+1 
      sl_byp[num_sl]={lastbypassline:match(" (%d) (%d) (%d)")} 
      sl_byp[num_sl][1]=tonumber(sl_byp[num_sl][1]) 
      sl_byp[num_sl][2]=tonumber(sl_byp[num_sl][2]) 
      sl_byp[num_sl][3]=tonumber(sl_byp[num_sl][3])
    elseif k:match("<.-Soundboard %(Ultraschall%)")~=nil then 
      num_soundboard=num_soundboard+1
      soundboard_byp[num_soundboard]={lastbypassline:match(" (%d) (%d) (%d)")} 
      soundboard_byp[num_soundboard][1]=tonumber(soundboard_byp[num_soundboard][1]) 
      soundboard_byp[num_soundboard][2]=tonumber(soundboard_byp[num_soundboard][2]) 
      soundboard_byp[num_soundboard][3]=tonumber(soundboard_byp[num_soundboard][3]) 
    elseif k:match("<.-Ultraschall_Dynamics")~=nil then 
      num_usdynamics=num_usdynamics+1 
      usdynamics_byp[num_usdynamics]={lastbypassline:match(" (%d) (%d) (%d)")} 
      usdynamics_byp[num_usdynamics][1]=tonumber(usdynamics_byp[num_usdynamics][1]) 
      usdynamics_byp[num_usdynamics][2]=tonumber(usdynamics_byp[num_usdynamics][2]) 
      usdynamics_byp[num_usdynamics][3]=tonumber(usdynamics_byp[num_usdynamics][3]) 
    elseif k:match("BYPASS %d %d %d%c")~=nil then lastbypassline=k
    end
  end
  return num_sl, sl_byp, num_slonair, slonair_byp, num_soundboard, soundboard_byp, num_usdynamics, usdynamics_byp
end


function ultraschall.GetTopmostHWND(hwnd)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTopmostHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>HWND topmost_hwnd, integer number_of_parent_hwnd, table all_parent_hwnds = ultraschall.GetTopmostHWND(HWND hwnd)</functioncall>
  <description>
    returns the topmost-parent hwnd of a hwnd, as sometimes, hwnds are children of a higher hwnd. It also returns the number of parent hwnds available and a list of all parent hwnds for this hwnd.
    
    A hwnd is a window-handler, which contains all attributes of a certain window.
    
    returns nil in case of an error
  </description>
  <parameters>
    HWND hwnd - the HWND, whose topmost parent-HWND you want to have
  </parameters>
  <retvals>
    HWND hwnd - the top-most parent hwnd available
    integer number_of_parent_hwnd - the number of parent hwnds, that are above the parameter hwnd
    table all_parent_hwnds - all available parent hwnds, above the parameter hwnd, including the topmost-hwnd
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, hwnd, topmost, parent hwnd, get, count</tags>
</US_DocBloc>
]]
  if ultraschall.IsValidHWND(hwnd)==false then ultraschall.AddErrorMessage("GetTopmostHWND", "hwnd", "not a valid hwnd", -1) return nil end
  local count=1
  local other_hwnds={}
  while reaper.JS_Window_GetParent(hwnd)~=nil do  
     hwnd=reaper.JS_Window_GetParent(hwnd)
     other_hwnds[count]=hwnd
     count=count+1
  end
  return hwnd, count-1, other_hwnds
end

--A,B,C,D=ultraschall.GetTopmostHWND(reaper.JS_Window_GetFocus())

--reaper.MB(tostring(A).."\n"..tostring(B).."\n"..reaper.JS_Window_GetTitle(C[1])..                                                reaper.JS_Window_GetTitle(C[2]).."\n","",0)
--                                              ..reaper.JS_Window_GetTitle(C[3]),"",0)


function ultraschall.GetReaperWindowAttributes()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaperWindowAttributes</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>integer left, integer top, integer right, integer bottom, boolean active, boolean visible, string title, integer number_of_childhwnds, table childhwnds = ultraschall.GetReaperWindowAttributes()</functioncall>
  <description>
    returns many attributes of the Reaper Main-window, like position, size, active, visibility, childwindows
    
    A hwnd is a window-handler, which contains all attributes of a certain window.
    
    returns nil in case of an error
  </description>
  <parameters>
    HWND hwnd - the HWND, whose topmost parent-HWND you want to have
  </parameters>
  <retvals>
    integer left - the left position of the Reaper-window in pixels
    integer top - the top position of the Reaper-window in pixels
    integer right - the right position of the Reaper-window in pixels
    integer bottom - the bottom position of the Reaper-window in pixels
    boolean active - true, if the window is active(any child-hwnd of the Reaper-window has focus currently); false, if not
    boolean visible - true, Reaper-window is visible; false, Reaper-window is not visible
    string title - the current title of the Reaper-window
    integer number_of_childhwnds - the number of available child-hwnds that the Reaper-window currently has
    table childhwnds - a table with all child-hwnds in the following format:
                     -      childhwnds[index][1]=hwnd
                     -      childhwnds[index][2]=title
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, hwnd, reaper, main window, position, active, visible, child-hwnds</tags>
</US_DocBloc>
]]
  local hwnd=reaper.GetMainHwnd()
  local title = reaper.JS_Window_GetTitle(hwnd)
  local visible=reaper.JS_Window_IsVisible(hwnd)
  local num_child_windows, child_window_list = reaper.JS_Window_ListAllChild(hwnd)
  local childwindows={}
  local count, individual_values = ultraschall.CSV2IndividualLinesAsArray(child_window_list)
  for i=1, count do
    childwindows[i]={}
    childwindows[i][1]=reaper.JS_Window_HandleFromAddress(individual_values[i])
    childwindows[i][2]=reaper.JS_Window_GetTitle(childwindows[i][1])
  end
  
  local retval, left, top, right, bottom = reaper.JS_Window_GetRect(hwnd)

  local hwnd_temp=ultraschall.GetTopmostHWND(reaper.JS_Window_GetFocus())
  if hwnd_temp==hwnd then active=true else active=false end
  
  return left, top, right, bottom, active, visible, title, count, childwindows
end



--retval, number position, number pageSize, number min, number max, number trackPos = reaper.JS_Window_GetScrollInfo(identifier windowHWND, string scrollbar)

--A,B,C,D,E,F,G,H,I,J=ultraschall.GetReaperWindowAttributes()
--reaper.MB(tostring(A).." "..tostring(B).." "..tostring(C).." "..tostring(D).." "..tostring(E).." "..tostring(F).." "..tostring(G).." "..tostring(H).." "..tostring(I),"",0)

function ultraschall.ReverseEndianess_Byte(byte)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReverseEndianess_Byte</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer newbyte = ultraschall.ReverseEndianess_Byte(integer byte)</functioncall>
  <description>
    reverses the endianess of a byte and returns this as value.
    The parameter byte must be between 0 and 255!
    
    returns nil in case of an error
  </description>
  <parameters>
    integer byte - the integer whose endianess you want to reverse
  </parameters>
  <retvals>
    integer newbyte - the endianess-reversed byte
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, integer, endianess</tags>
</US_DocBloc>
]]
  if math.type(byte)~="integer" then ultraschall.AddErrorMessage("ReverseEndianess_Byte", "byte", "must be an integer", -1) return end
  if byte<0 or byte>255 then ultraschall.AddErrorMessage("ReverseEndianess_Byte", "byte", "must be between 0 and 255", -2) return end
  
  local newbyte=0
  if byte&1~=0 then newbyte=newbyte+128 end
  if byte&2~=0 then newbyte=newbyte+64 end
  if byte&4~=0 then newbyte=newbyte+32 end
  if byte&8~=0 then newbyte=newbyte+16 end
  if byte&16~=0 then newbyte=newbyte+8 end
  if byte&32~=0 then newbyte=newbyte+4 end
  if byte&64~=0 then newbyte=newbyte+2 end
  if byte&128~=0 then newbyte=newbyte+1 end
  return newbyte
end


function ultraschall.Windows_Find(title, exact)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>Windows_Find</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>integer count_hwnds, array hwnd_array, array hwnd_adresses = ultraschall.Windows_Find(string title, boolean strict)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns all Reaper-window-HWND-handler, with a given title. Can be further used with the JS\_Window\_functions of the JS-function-plugin.
    
    Doesn't return IDE-windows! Use [GetAllReaScriptIDEWindows](#GetAllReaScriptIDEWindows) to get them.
  </description>
  <parameters>
    integer count_hwnds - the number of windows found
    array hwnd_array - the hwnd-handler of all found windows
    array hwnd_adresses - the adresses of all found windows
  </parameters>
  <retvals>
    string title - the title the window has
    boolean strict - true, if the title must be exactly as given by parameter title; false, only parts of a windowtitle must match parameter title
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, find, hwnd, windows, reaper</tags>
</US_DocBloc>
]]
  if type(title)~="string" then ultraschall.AddErrorMessage("Windows_Find", "title", "must be a string", -1) return -1 end
  if type(exact)~="boolean" then ultraschall.AddErrorMessage("Windows_Find", "exact", "must be a boolean", -2) return -1 end
  local retval, list = reaper.JS_Window_ListFind(title, exact)
  local list=list..","
  local hwnd_list={}
  local hwnd_list2={}
  local count=0
  for i=1, retval do
    local temp,offset=list:match("(.-),()")
    local temphwnd=reaper.JS_Window_HandleFromAddress(temp)
    parenthwnd=reaper.JS_Window_GetParent(temphwnd)
    while parenthwnd~=nil do
      if parenthwnd==reaper.GetMainHwnd() then
        count=count+1
        hwnd_list[count]=temphwnd
        hwnd_list2[count]=temp
      end    
      parenthwnd=reaper.JS_Window_GetParent(parenthwnd)
    end
    if Tudelu~=nil then
    end
    list=list:sub(offset,-1)
  end
  return count, hwnd_list, hwnd_list2
end

--A,B,C=ultraschall.Windows_Find("Reaper", false)

--gfx.init(" - ReaScript Development Environment")

function ultraschall.GetAllReaScriptIDEWindows()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllReaScriptIDEWindows</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>integer count_ide_hwnds, array ide_hwnd_array, array ide_titles = ultraschall.GetAllReaScriptIDEWindows()</functioncall>
  <description>
    Returns the hwnds and all titles of all Reaper-IDE-windows currently opened.
  </description>
  <retvals>
    integer count_ide_hwnds - the number of windows found
    array ide_hwnd_array - the hwnd-handler of all found windows
    array ide_titles - the titles of all found windows
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, get, hwnd, windows, reaper, ide</tags>
</US_DocBloc>
]]
  local translation = reaper.JS_Localize("ReaScript Development Environment", "DLG_114")
  local retval, list = reaper.JS_Window_ListFind("", false)
  local list=list..","
  local IDE_Array={}
  local IDE_Array_Title={}
  local count=0
  
  local temphwnd, retval2, list2, temp
  
  for i=1, retval do
    temphwnd=reaper.JS_Window_HandleFromAddress(list:match("(.-),"))
    if reaper.JS_Window_GetTitle(temphwnd):match(" - ReaScript Development Environment")~=nil then
      retval2, list2 = reaper.JS_Window_ListAllChild(temphwnd)
      list2=list2..","
      if retval2>0 then    
        temp={}
        for i=1, retval2-1 do
          temp[0]=reaper.JS_Window_HandleFromAddress(list2:match("(.-),"))
          --temp[i]=reaper.JS_Window_GetTitle(temp[0])
          list2=list2:match(",(.*)")
        end
        
        count=count+1
        IDE_Array[count]=reaper.JS_Window_GetParent(temp[0])
        IDE_Array_Title[count]=reaper.JS_Window_GetTitle(IDE_Array[count])
      end
    end
    list=list:match(",(.*)")
  end
  return count, IDE_Array, IDE_Array_Title
end


--PP,PPP,PPPP=ultraschall.GetAllReaScriptIDEWindows()

function ultraschall.GetReaScriptConsoleWindow()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetReaScriptConsoleWindow</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>HWND reascript_console_hwnd = ultraschall.GetReaScriptConsoleWindow()</functioncall>
  <description>
    Returns the hwnd of the ReaScript-Console-window, if opened.
    
    returns nil when ReaScript-console isn't opened
  </description>
  <retvals>
    HWND reascript_console_hwnd - the window-handler to the ReaScript-console, if opened
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>window, get, hwnd, windows, reaper, console</tags>
</US_DocBloc>
]]
  local translation = reaper.JS_Localize("ReaScript console output", "DLG_437")
  local retval,Adr=reaper.JS_Window_ListFind(translation, true)
  local count2  
  
  if retval==0 then ultraschall.AddErrorMessage("GetReaScriptConsoleWindow", "", "ReaConsole-window not opened", -2) return nil end
  
  local count2, individual_values2 = ultraschall.CSV2IndividualLinesAsArray(Adr)
  
  for i=1, count2 do
    local B=reaper.JS_Window_HandleFromAddress(individual_values2[i])
    if ultraschall.HasHWNDChildWindowNames(B, "Clear\0Close")==true then return B end
  end
  ultraschall.AddErrorMessage("GetReaScriptConsoleWindow", "", "ReaConsole-window not opened", -2) 
  return nil
end

--gfx.init("ReaScript console output")
--reaper.ShowConsoleMsg("rOCK IT")
--A=ultraschall.GetReaScriptConsoleWindow()

function ultraschall.IsReaperRendering()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsReaperRendering</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, optional number render_position, optional number render_projectlength, optional ReaProject proj, optional boolean queue_render = ultraschall.IsReaperRendering()</functioncall>
  <description>
    Returns, if Reaper is currently rendering and the rendering position and projectlength of the rendered project
  </description>
  <retvals>
    boolean retval - true, Reaper is rendering; false, Reaper does not render
    optional number render_position - the current rendering-position of the rendering project
    optional number render_projectlength - the length of the currently rendering project
    optional ReaProject proj - the project currently rendering
    optional boolean queue_render - true, if a project from the queued-folder is currently being rendered; false, if not; a hint if queued-rendering is currently active
  </retvals>
  <chapter_context>
    Rendering of Project
    Assistance functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>rendering, get, current, renderstate, queued</tags>
</US_DocBloc>
]]
  local A,B=reaper.EnumProjects(0x40000000,"")  
  if A~=nil then 
    if B:match("^"..reaper.GetResourcePath()..ultraschall.Separator.."QueuedRenders"..ultraschall.Separator.."qrender_%d%d%d%d%d%d_%d%d%d%d%d%d")~=nil then queue=true else queue=false end
    return true, reaper.GetPlayPositionEx(A), reaper.GetProjectLength(A), A, queue
  else return false 
  end
end

--function main()
--  C,C1,C2,D,E=ultraschall.IsReaperRendering()
--  reaper.defer(main)
--end
--main()

function ultraschall.GetAllRecursiveFilesAndSubdirectories(path)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllRecursiveFilesAndSubdirectories</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer found_dirs, array dirs_array, integer found_files, array files_array = ultraschall.GetAllRecursiveFilesAndSubdirectories(string path)</functioncall>
  <description>
    Returns all subdirectories and files within a given path.
    
    Might take some time with many folders/files.
    
    
    Returns -1 in case of an error.
  </description>
  <parameters>
    string path - the path from where to retrieve the files and subdirectories
  </parameters>
  <retvals>
    integer found_dirs - the number of directories found; -1, in case of an error
    array dirs_array - the full path to the found directories as an array
    integer found_files - the number of files found
    array files_array - the full path to the found files as an array
  </retvals>
  <chapter_context>
    File Management
    Helper functions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>file management, get, all, files, directories, folder, subfolder, subdirectories, path, recursive</tags>
</US_DocBloc>
]]
  if type(path)~="string" then ultraschall.AddErrorMessage("GetAllRecursiveFilesAndSubdirectories", "path", "must be a string", -1) return -1 end
  if ultraschall.DirectoryExists2(path)==false then ultraschall.AddErrorMessage("GetAllRecursiveFilesAndSubdirectories", "path", "path is not a valid path", -2) return -1 end
  local Dirs={}
  local dirscount=1
  local dirsmaxcount=2
  
  Dirs[1]=path
  
  local Files={}
  local filescount=0
  
  while dirscount<dirsmaxcount do  
    local path=Dirs[dirscount]
    local temp=""
    local subdir=0
    while temp~=nil do
      temp=reaper.EnumerateSubdirectories(Dirs[dirscount],subdir)
      if temp~=nil then
        Dirs[dirsmaxcount]=path.."/"..temp
        dirsmaxcount=dirsmaxcount+1
      end
      subdir=subdir+1
    end
    dirscount=dirscount+1
  end
  
  local dircounter=1
  for i=1, dirsmaxcount do
    local counter=0
    while Dirs[dircounter]~=nil and reaper.EnumerateFiles(Dirs[dircounter],counter)~=nil do
      filescount=filescount+1
      Files[filescount]=Dirs[dircounter].."/"..reaper.EnumerateFiles(Dirs[dircounter],counter)
      counter=counter+1
    end
    dircounter=dircounter+1
  end
  
  return dirsmaxcount-1, Dirs, filescount, Files
end

--A,B,C,D=ultraschall.GetAllRecursiveFilesAndSubdirectories("L:\\")

function ultraschall.RippleCut_Regions(startposition, endposition)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>RippleCut_Regions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean were_regions_altered, integer number_of_altered_regions, array altered_regions  = ultraschall.RippleCut_Regions(number startposition, number endposition)</functioncall>
  <description>
    Ripplecuts regions, where applicable.
    It cuts all (parts of) regions between startposition and endposition and moves remaining parts plus all regions after endposition by endposition-startposition toward projectstart.
    
    Returns false in case of an error.
  </description>
  <parameters>
    number startposition - the startposition from where regions shall be cut from
    number endposition - the endposition to which regions shall be cut from; all regions/parts of regions after that will be moved toward projectstart
  </parameters>
  <retvals>
    boolean were_regions_altered - true, if regions were cut/altered; false, if not
    integer number_of_altered_regions - the number of regions that were altered/cut/moved
    array altered_regions - the regions that were altered:
                          -   altered_regions_array[index_of_region][0] - old startposition
                          -   altered_regions_array[index_of_region][1] - old endposition
                          -   altered_regions_array[index_of_region][2] - name
                          -   altered_regions_array[index_of_region][3] - old indexnumber of the region within all markers in the project
                          -   altered_regions_array[index_of_region][4] - the shown index-number
                          -   altered_regions_array[index_of_region][5] - the color of the region
                          -   altered_regions_array[index_of_region][6] - the change that was applied to this region
                          -   altered_regions_array[index_of_region][7] - the new startposition
                          -   altered_regions_array[index_of_region][8] - the new endposition
  </retvals>
  <chapter_context>
    Markers
    General Markers and Regions
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>marker management, ripple, cut, regions</tags>
</US_DocBloc>
]]
  if type(startposition)~="number" then ultraschall.AddErrorMessage("RippleCut_Regions", "startposition", "must be a number", -1) return false end
  if type(endposition)~="number" then ultraschall.AddErrorMessage("RippleCut_Regions", "endposition", "must be a number", -2) return false end
  local dif=endposition-startposition
  
  -- get all regions, that are candidates for a ripplecut
  local number_of_all_regions, allregionsarray = ultraschall.GetAllRegionsBetween(startposition, reaper.GetProjectLength(0), true)  
  if number_of_all_regions==0 then ultraschall.AddErrorMessage("RippleCut_Regions", "", "no regions found within start and endit", -3) return false, regioncount, regionfound end
  
  -- make startposition and endposition with less precision, or we can't check, if startposition=pos
  -- Reaper seems to work with greater precision for floats than shown
  local start = ultraschall.LimitFractionOfFloat(startposition, 10, true)
  local endit = ultraschall.LimitFractionOfFloat(endposition, 10, true)
  
  -- some more preparation for variables, including localizing them
  local pos, rgnend, name, retval, markrgnindexnumber, color  
  local regionfound={}
  
  -- here comes the magic
  for i=number_of_all_regions, 1, -1 do
    -- get regionattributes from the allregionsarray we got before
     pos=allregionsarray[i][0]
     rgnend=allregionsarray[i][1]
     name=allregionsarray[i][2]
     retval=allregionsarray[i][3]
     markrgnindexnumber=allregionsarray[i][4]
     color = allregionsarray[i][5]
    -- make pos and rgnend with less precision, or we can't check, if startposition=pos
    -- Reaper seems to work with greater precision for floats than shown
    local pos1 = ultraschall.LimitFractionOfFloat(pos, 10, true)
    local rgnend1 = ultraschall.LimitFractionOfFloat(rgnend, 10, true)

    regionfound[i]={}
    regionfound[i][0]=allregionsarray[i][0]
    regionfound[i][1]=allregionsarray[i][1]
    regionfound[i][2]=allregionsarray[i][2]
    regionfound[i][3]=allregionsarray[i][3]
    regionfound[i][4]=allregionsarray[i][4]
    regionfound[i][5]=allregionsarray[i][5]

    -- let's do the checking and manipulation. We also create an array with all entries manipulated
    -- and in which way manipulated
    if pos1>=start and rgnend1<=endit then
      -- if region is fully within start and endit, cut it completely
      regionfound[i][6]="CUT COMPLETELY"
      reaper.DeleteProjectMarker(0, markrgnindexnumber, true)
    elseif pos1<start and rgnend1<=endit and rgnend1>start then
      -- if regionend is within start and endit, move the end to start
      regionfound[i][6]="CUT AT THE END"
      regionfound[i][7]=pos
      regionfound[i][8]=start
      reaper.SetProjectMarker4(proj, markrgnindexnumber, true, pos, start, name, color, 0)
    elseif pos1>=start and pos1<=endit and rgnend1>endit then
      -- if regionstart is within start and endit, shorten the region and move it by difference of start and endit
      --    toward projectstart
      regionfound[i][6]="CUT AT THE BEGINNING"
      regionfound[i][7]=endit-dif
      regionfound[i][8]=rgnend-dif
      reaper.SetProjectMarker4(proj, markrgnindexnumber, true, endit-dif, rgnend-dif, name, color, 0)
    elseif pos1>=endit and rgnend1>=endit then 
      -- if region is after endit, just move the region by difference of start and endit toward projectstart
      regionfound[i][6]="MOVED TOWARD PROJECTSTART"
      regionfound[i][7]=pos-dif
      regionfound[i][8]=rgnend-dif
      reaper.SetProjectMarker4(proj, markrgnindexnumber, true, pos-dif, rgnend-dif, name, color, 0)
    elseif start>=pos1 and endit<=rgnend then
      -- if start and endit is fully within a region, cut at the end of the region the difference of start and endit
      regionfound[i][6]="CUT IN THE MIDDLE"
      regionfound[i][7]=pos
      regionfound[i][8]=rgnend-dif
      reaper.SetProjectMarker4(proj, markrgnindexnumber, true, pos, rgnend-dif, name, color, 0)
    end
  end
  -- sort the table of found regions
  return true, regioncount, regionfound
end

--  A,B=reaper.GetSet_LoopTimeRange(false,true,0,0,false)
--  C,D,E=ultraschall.RippleCut_Regions(A, B)

--  number_of_all_regions, allregionsarray = ultraschall.GetAllRegionsBetween(A,B, true)

function ultraschall.ShowErrorMessagesInReascriptConsole(setting)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>ShowErrorMessagesInReascriptConsole</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>ultraschall.ShowErrorMessagesInReascriptConsole(boolean state)</functioncall>
    <description>
      Sets, if errormessages shall be shown in the ReaScript-Console immediately, when they happen.
      
      Will show functionname, parametername, errorcode plus errormessage and the time the error has happened.
    </description>
    <parameters>
      boolean state - true, show error-messages in the ReaScript-Console when they happen; false, don't show errormessages
    </parameters>
    <chapter_context>
      Developer
      Error Handling
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>developer, error, show, message, reascript, console</tags>
  </US_DocBloc>
  ]]
  if setting==true then ultraschall.ShowErrorInReaScriptConsole=true else ultraschall.ShowErrorInReaScriptConsole=false end
end


function ultraschall.ConvertIntegerIntoString(integervalue)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertIntegerIntoString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string converted_value = ultraschall.ConvertIntegerIntoString(integer integervalue)</functioncall>
  <description>
    Splits an integer into its individual bytes and converts them into a string-representation.
    Only 32bit-integers are supported.
    
    Returns nil in case of an error.
  </description>
  <parameters>
    integer integervalue - the value to convert from
  </parameters>
  <retvals>
    string converted_value - the string-representation of the integer
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, integer, string</tags>
</US_DocBloc>
]]
  if math.type(integervalue)~="integer" then ultraschall.AddErrorMessage("ConvertIntegerIntoString", "integervalue", "must be an integer", -1) return end
  local Byte1, Byte2, Byte3, Byte4 = ultraschall.SplitIntegerIntoBytes(integervalue)
  local String=string.char(Byte1)..string.char(Byte2)..string.char(Byte3)..string.char(Byte4)
  return String
end

--A=ultraschall.ConvertIntegerIntoString(65)

function ultraschall.ConvertIntegerToBits(integer)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ConvertIntegerToBits</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string bitvals_csv, table bitvalues = ultraschall.ConvertIntegerToBits(integer integer)</functioncall>
  <description>
    converts an integer-value(up to 64 bits) into it's individual bits and returns it as comma-separated csv-string as well as a table with 64 entries.
    
    returns nil in case of an error
  </description>
  <parameters>
    integer integer - the integer-number to separated into it's individual bits
  </parameters>
  <retvals>
    string bitvals_csv - a comma-separated csv-string of all bitvalues, with bit 1 coming first and bit 32 coming last
    table bitvalues - a 64-entry table, where each entry contains the bit-value of integer; first entry for bit 1, 64th entry for bit 64
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, convert, integer, bit, bitfield</tags>
</US_DocBloc>
]]
  if math.type(integer)~="integer" then ultraschall.AddErrorMessage("ConvertIntegerToBits", "integer", "must be an integer-value up to 32 bits", -1) return nil end
  local Table={}
  local bitvals=""
  for i=1, 64 do
    Table[i]=integer&1
    bitvals=bitvals..(integer&1)..","
    integer=integer>>1
  end
  return bitvals:sub(1,-2), Table
end


function ultraschall.GetSetIntConfigVar(varname, set, ...)  
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>GetSetIntConfigVar</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      SWS=2.9.7
      Lua=5.3
    </requires>
    <functioncall>boolean retval, integer config_var_value = ultraschall.GetSetIntConfigVar(string varname, boolean set, optional boolean bit1, ..., optional boolean bit32)</functioncall>
    <description>
      Gets/Sets an integer-bitfield of an integer-configvariable.
      
      Pass to it a varname, if it shall be set or gotten from and up to 32 parameters who specify, if that bit shall be set(true) or not(false) or the currently set value shall be used(nil)
      
      See <a href="Reaper_Config_Variables.html">Reaper_Config_Variables.html</a> for more details on config-variables in Reaper.
      
      returns false in case of an error
    </description>
    <parameters>
      string varname - the name of the config-variable
      boolean set - true, set this config-var; false, don't set it
      optional boolean bit1 - true, set this bit; false, don't set this bit; nil, use the currently set value
      ...                   - true, set this bit; false, don't set this bit; nil, use the currently set value
      optional boolean bit32 - true, set this bit; false, don't set this bit; nil, use the currently set value
    </parameters>
    <retvals>
      boolean retval - true, getting/setting the config-var was successful; false, it wasn't successful
      integer config_var_value - the new/current value of the configuration-variable
    </retvals>
    <chapter_context>
      API-Helper functions
      Data Manipulation
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>helper functions, get, set, configvar, integer, bit, bitfield</tags>
  </US_DocBloc>
  ]]
  
  -- check parameters
  local oldval=reaper.SNM_GetIntConfigVar(varname,-99)
  local oldval2=reaper.SNM_GetIntConfigVar(varname,-98)
  local parms={...}
  if type(varname)~="string" then ultraschall.AddErrorMessage("GetSetIntConfigVar", "varname", "must be a string", -1) return false end
  if oldval~=oldval2 then ultraschall.AddErrorMessage("GetSetIntConfigVar", "varname", "no such config-variable", -2) return false end
  if type(set)~="boolean" then ultraschall.AddErrorMessage("GetSetIntConfigVar", "set", "must be a boolean", -3) return false end
  local newval=0
  
  -- if setting config-variable is set to true, create that new value
  -- and set it
  if set==true then
    for i=0, 32 do
      -- if one of the parameters isn't nil or boolean, return with false, leaving the configvar untouched
      if parms[i]~=nil and parms[i]~=true and parms[i]~=false then ultraschall.AddErrorMessage("GetSetIntConfigVar", "bit"..i, "must be either a boolean or nil(to keep currently set value)", -4) return false end
    end    
    
    for i=32, 1, -1 do
      -- create the newval
      -- if parameter is set to nil, use the specifiv bit-value from the original config-var-value
      newval = newval << 1
      if parms[i]==true then newval=newval+1
      elseif parms[i]==nil and oldval&2^i~=0 then newval=newval+1 end
    end
    
    return reaper.SNM_SetIntConfigVar(varname, newval), math.floor(newval)
  else
    return true, math.floor(oldval)
  end
end


--O,O2=ultraschall.GetSetIntConfigVar("mixeruiflag", true, true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true, true,true,true,true,true,true,true,true,true,true)

--reaper.CF_SetClipboard(reaper.genGuid())


function ultraschall.GetScriptIdentifier()
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>GetScriptIdentifier</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>string script_identifier = ultraschall.GetScriptIdentifier()</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      The Ultraschall-API gives any script, that uses the API, a unique identifier generated when the script is run.
      This identifier can be used to communicate with this script. If you start numerous instances of a script, it will create for each instance
      its own script-identifier, so you can be sure, that you communicate with the right instance.
      
      The identifier is of the format "ScriptIdentifier:scriptfilename-{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}.ext", where the {}-part is a guid and ext either .lua .py or .eel
      
      [Defer1](#Defer1) to [Defer20](#Defer20) make use of this to stop a running defer-loop from the outside of a deferred-script.
    </description>
    <retvals>
      string script_identifier - a unique script-identifier for this script-instance, of the format:
                               - ScriptIdentifier: scriptfilename-guid
    </retvals>
    <chapter_context>
      API-Helper functions
      Data Manipulation
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>helper functions, get, script_identifier</tags>
  </US_DocBloc>
  ]]

  return ultraschall.ScriptIdentifier
end

--O=ultraschall.GetScriptIdentifier()

function ultraschall.GetDeferIdentifier(deferinstance)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>GetDeferIdentifier</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>string defer_identifier = ultraschall.GetDeferIdentifier(integer deferinstance)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      returns the identifier for a specific ultraschall-defer-function.
      
      This can be used to stop this defer-loop from the in- and outside of the script.
      
      returns nil in case of an error.
    </description>
    <retvals>
      string defer_identifier - a specific and unique defer-identifier for this script-instance, of the format:
                               - ScriptIdentifier: scriptfilename-guid.ext.deferXX
                               - where XX is the defer-function-number. XX is between 1 and 20
    </retvals>
    <parameters>
      integer deferinstance - the defer-instance, whose identifier you want; 1 to 20
    </parameter>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, get, defer_identifier</tags>
  </US_DocBloc>
  ]]
  if math.type(deferinstance)~="integer" then ultraschall.AddErrorMessage("GetDeferIdentifier", "deferinstance", "must be an integer", -1) return nil end
  if deferinstance<1 or deferinstance>20 then ultraschall.AddErrorMessage("GetDeferIdentifier", "deferinstance", "must be between 1 and 20", -2) return nil end
  if deferinstance<10 then zero="0" else zero="" end
  return ultraschall.GetScriptIdentifier()..".defer_script"..zero..deferinstance
end

--A=ultraschall.GetDeferIdentifier(2)

--reaper.CF_SetClipboard(A)

function ultraschall.Defer1(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer1</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer1(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]
  if type(func)~="function" and type(ultraschall.deferfunc1)~="function" then 
    ultraschall.AddErrorMessage("Defer1", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer1==nil then 
    ultraschall.AddErrorMessage("Defer1", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer1=timer_counter end 
  if func~=nil then ultraschall.deferfunc1=func end
  if mode~=nil then 
    ultraschall.defermode1=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01", "running", false)
    if mode==2 then ultraschall.defertimer1=ultraschall.defertimer1+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode1==nil then
    ultraschall.defermode1=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01", "running", false)
  end
  
  if (ultraschall.defermode1==0 or ultraschall.defermode1==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01")=="running" then 
    return reaper.defer(ultraschall.deferfunc1), ultraschall.ScriptIdentifier..".defer_script01"
  elseif ultraschall.defermode1==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01")=="running" then
    ultraschall.defertimer1=ultraschall.defertimer1-1
    if ultraschall.defertimer1>0 then reaper.defer(ultraschall.Defer1) else return reaper.defer(ultraschall.deferfunc1), ultraschall.ScriptIdentifier..".defer_script01" end
  elseif ultraschall.defermode1==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01")=="running" then
    if ultraschall.defertimer1>reaper.time_precise() then reaper.defer(ultraschall.Defer1) else return reaper.defer(ultraschall.deferfunc1), ultraschall.ScriptIdentifier..".defer_script01" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script01")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer1", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script01"
end

function main()

end

--A,B=ultraschall.Defer1(main,1,1)
--reaper.CF_SetClipboard(B)


function ultraschall.StopDeferCycle(identifier)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>StopDeferCycle</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval = ultraschall.StopDeferCycle(string defer_identifier)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      Stops a running ultraschall.Defer-instance of a script-instance.
      
      returns false in case of an error
    </description>
    <parameters>
      string defer_identifier - the identifier of the defer-cycle of a script-instance
    </parameters>
    <retvals>
      boolean retval - true, stopping this defer-cycle was successful; false, it wasn't successful
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, stop</tags>
  </US_DocBloc>
  ]]
  if type(identifier)~="string" then ultraschall.AddErrorMessage("StopDeferCycle", "identifier", "must be a string", -1) return false end
  local IdentifierPattern="ScriptIdentifier:.-%-{%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x}.defer_script%d%d"
--  if identifier:match(IdentifierPattern)==nil then ultraschall.AddErrorMessage("StopDeferCycle", "identifier", "no valid defer-identifier", -2) return false end  
  if reaper.HasExtState("ultraschall", identifier)==true then
    reaper.DeleteExtState("ultraschall", identifier, false)
    return true
  else
    return false
  end
end







function ultraschall.Defer2(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer2</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer2(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc2)~="function" then 
    ultraschall.AddErrorMessage("Defer2", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer2==nil then 
    ultraschall.AddErrorMessage("Defer2", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer2=timer_counter end 
  if func~=nil then ultraschall.deferfunc2=func end
  if mode~=nil then 
    ultraschall.defermode2=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02", "running", false)
    if mode==2 then ultraschall.defertimer2=ultraschall.defertimer2+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode2==nil then
    ultraschall.defermode2=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02", "running", false)
  end
  
  if (ultraschall.defermode2==0 or ultraschall.defermode2==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02")=="running" then 
    return reaper.defer(ultraschall.deferfunc2), ultraschall.ScriptIdentifier..".defer_script02"
  elseif ultraschall.defermode2==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02")=="running" then
    ultraschall.defertimer2=ultraschall.defertimer2-1
    if ultraschall.defertimer2>0 then reaper.defer(ultraschall.Defer2) else return reaper.defer(ultraschall.deferfunc2), ultraschall.ScriptIdentifier..".defer_script02" end
  elseif ultraschall.defermode2==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02")=="running" then
    if ultraschall.defertimer2>reaper.time_precise() then reaper.defer(ultraschall.Defer2) else return reaper.defer(ultraschall.deferfunc2), ultraschall.ScriptIdentifier..".defer_script02" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script02")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer2", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script02"
end


function ultraschall.Defer3(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer3</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer3(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc3)~="function" then 
    ultraschall.AddErrorMessage("Defer3", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer3==nil then 
    ultraschall.AddErrorMessage("Defer3", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer3=timer_counter end 
  if func~=nil then ultraschall.deferfunc3=func end
  if mode~=nil then 
    ultraschall.defermode3=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03", "running", false)
    if mode==2 then ultraschall.defertimer3=ultraschall.defertimer3+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode3==nil then
    ultraschall.defermode3=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03", "running", false)
  end
  
  if (ultraschall.defermode3==0 or ultraschall.defermode3==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03")=="running" then 
    return reaper.defer(ultraschall.deferfunc3), ultraschall.ScriptIdentifier..".defer_script03"
  elseif ultraschall.defermode3==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03")=="running" then
    ultraschall.defertimer3=ultraschall.defertimer3-1
    if ultraschall.defertimer3>0 then reaper.defer(ultraschall.Defer3) else return reaper.defer(ultraschall.deferfunc3), ultraschall.ScriptIdentifier..".defer_script03" end
  elseif ultraschall.defermode3==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03")=="running" then
    if ultraschall.defertimer3>reaper.time_precise() then reaper.defer(ultraschall.Defer3) else return reaper.defer(ultraschall.deferfunc3), ultraschall.ScriptIdentifier..".defer_script03" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script03")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer3", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script03"
end


function ultraschall.Defer4(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer4</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer4(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc4)~="function" then 
    ultraschall.AddErrorMessage("Defer4", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer4==nil then 
    ultraschall.AddErrorMessage("Defer4", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer4=timer_counter end 
  if func~=nil then ultraschall.deferfunc4=func end
  if mode~=nil then 
    ultraschall.defermode4=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04", "running", false)
    if mode==2 then ultraschall.defertimer4=ultraschall.defertimer4+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode4==nil then
    ultraschall.defermode4=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04", "running", false)
  end
  
  if (ultraschall.defermode4==0 or ultraschall.defermode4==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04")=="running" then 
    return reaper.defer(ultraschall.deferfunc4), ultraschall.ScriptIdentifier..".defer_script04"
  elseif ultraschall.defermode4==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04")=="running" then
    ultraschall.defertimer4=ultraschall.defertimer4-1
    if ultraschall.defertimer4>0 then reaper.defer(ultraschall.Defer4) else return reaper.defer(ultraschall.deferfunc4), ultraschall.ScriptIdentifier..".defer_script04" end
  elseif ultraschall.defermode4==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04")=="running" then
    if ultraschall.defertimer4>reaper.time_precise() then reaper.defer(ultraschall.Defer4) else return reaper.defer(ultraschall.deferfunc4), ultraschall.ScriptIdentifier..".defer_script04" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script04")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer4", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script04"
end


function ultraschall.Defer5(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer5</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer5(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc5)~="function" then 
    ultraschall.AddErrorMessage("Defer5", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer5==nil then 
    ultraschall.AddErrorMessage("Defer5", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer5=timer_counter end 
  if func~=nil then ultraschall.deferfunc5=func end
  if mode~=nil then 
    ultraschall.defermode5=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05", "running", false)
    if mode==2 then ultraschall.defertimer5=ultraschall.defertimer5+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode5==nil then
    ultraschall.defermode5=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05", "running", false)
  end
  
  if (ultraschall.defermode5==0 or ultraschall.defermode5==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05")=="running" then 
    return reaper.defer(ultraschall.deferfunc5), ultraschall.ScriptIdentifier..".defer_script05"
  elseif ultraschall.defermode5==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05")=="running" then
    ultraschall.defertimer5=ultraschall.defertimer5-1
    if ultraschall.defertimer5>0 then reaper.defer(ultraschall.Defer5) else return reaper.defer(ultraschall.deferfunc5), ultraschall.ScriptIdentifier..".defer_script05" end
  elseif ultraschall.defermode5==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05")=="running" then
    if ultraschall.defertimer5>reaper.time_precise() then reaper.defer(ultraschall.Defer5) else return reaper.defer(ultraschall.deferfunc5), ultraschall.ScriptIdentifier..".defer_script05" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script05")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer5", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script05"
end


function ultraschall.Defer6(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer6</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer6(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc6)~="function" then 
    ultraschall.AddErrorMessage("Defer6", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer6==nil then 
    ultraschall.AddErrorMessage("Defer6", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer6=timer_counter end 
  if func~=nil then ultraschall.deferfunc6=func end
  if mode~=nil then 
    ultraschall.defermode6=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06", "running", false)
    if mode==2 then ultraschall.defertimer6=ultraschall.defertimer6+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode6==nil then
    ultraschall.defermode6=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06", "running", false)
  end
  
  if (ultraschall.defermode6==0 or ultraschall.defermode6==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06")=="running" then 
    return reaper.defer(ultraschall.deferfunc6), ultraschall.ScriptIdentifier..".defer_script06"
  elseif ultraschall.defermode6==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06")=="running" then
    ultraschall.defertimer6=ultraschall.defertimer6-1
    if ultraschall.defertimer6>0 then reaper.defer(ultraschall.Defer6) else return reaper.defer(ultraschall.deferfunc6), ultraschall.ScriptIdentifier..".defer_script06" end
  elseif ultraschall.defermode6==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06")=="running" then
    if ultraschall.defertimer6>reaper.time_precise() then reaper.defer(ultraschall.Defer6) else return reaper.defer(ultraschall.deferfunc6), ultraschall.ScriptIdentifier..".defer_script06" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script06")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer6", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script06"
end


function ultraschall.Defer7(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer7</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer7(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc7)~="function" then 
    ultraschall.AddErrorMessage("Defer7", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer7==nil then 
    ultraschall.AddErrorMessage("Defer7", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer7=timer_counter end 
  if func~=nil then ultraschall.deferfunc7=func end
  if mode~=nil then 
    ultraschall.defermode7=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07", "running", false)
    if mode==2 then ultraschall.defertimer7=ultraschall.defertimer7+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode7==nil then
    ultraschall.defermode7=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07", "running", false)
  end
  
  if (ultraschall.defermode7==0 or ultraschall.defermode7==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07")=="running" then 
    return reaper.defer(ultraschall.deferfunc7), ultraschall.ScriptIdentifier..".defer_script07"
  elseif ultraschall.defermode7==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07")=="running" then
    ultraschall.defertimer7=ultraschall.defertimer7-1
    if ultraschall.defertimer7>0 then reaper.defer(ultraschall.Defer7) else return reaper.defer(ultraschall.deferfunc7), ultraschall.ScriptIdentifier..".defer_script07" end
  elseif ultraschall.defermode7==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07")=="running" then
    if ultraschall.defertimer7>reaper.time_precise() then reaper.defer(ultraschall.Defer7) else return reaper.defer(ultraschall.deferfunc7), ultraschall.ScriptIdentifier..".defer_script07" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script07")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer7", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script07"
end


function ultraschall.Defer8(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer8</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer8(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc8)~="function" then 
    ultraschall.AddErrorMessage("Defer8", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer8==nil then 
    ultraschall.AddErrorMessage("Defer8", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer8=timer_counter end 
  if func~=nil then ultraschall.deferfunc8=func end
  if mode~=nil then 
    ultraschall.defermode8=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08", "running", false)
    if mode==2 then ultraschall.defertimer8=ultraschall.defertimer8+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode8==nil then
    ultraschall.defermode8=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08", "running", false)
  end
  
  if (ultraschall.defermode8==0 or ultraschall.defermode8==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08")=="running" then 
    return reaper.defer(ultraschall.deferfunc8), ultraschall.ScriptIdentifier..".defer_script08"
  elseif ultraschall.defermode8==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08")=="running" then
    ultraschall.defertimer8=ultraschall.defertimer8-1
    if ultraschall.defertimer8>0 then reaper.defer(ultraschall.Defer8) else return reaper.defer(ultraschall.deferfunc8), ultraschall.ScriptIdentifier..".defer_script08" end
  elseif ultraschall.defermode8==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08")=="running" then
    if ultraschall.defertimer8>reaper.time_precise() then reaper.defer(ultraschall.Defer8) else return reaper.defer(ultraschall.deferfunc8), ultraschall.ScriptIdentifier..".defer_script08" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script08")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer8", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script08"
end


function ultraschall.Defer9(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer9</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer9(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc9)~="function" then 
    ultraschall.AddErrorMessage("Defer9", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer9==nil then 
    ultraschall.AddErrorMessage("Defer9", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer9=timer_counter end 
  if func~=nil then ultraschall.deferfunc9=func end
  if mode~=nil then 
    ultraschall.defermode9=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09", "running", false)
    if mode==2 then ultraschall.defertimer9=ultraschall.defertimer9+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode9==nil then
    ultraschall.defermode9=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09", "running", false)
  end
  
  if (ultraschall.defermode9==0 or ultraschall.defermode9==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09")=="running" then 
    return reaper.defer(ultraschall.deferfunc9), ultraschall.ScriptIdentifier..".defer_script09"
  elseif ultraschall.defermode9==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09")=="running" then
    ultraschall.defertimer9=ultraschall.defertimer9-1
    if ultraschall.defertimer9>0 then reaper.defer(ultraschall.Defer9) else return reaper.defer(ultraschall.deferfunc9), ultraschall.ScriptIdentifier..".defer_script09" end
  elseif ultraschall.defermode9==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09")=="running" then
    if ultraschall.defertimer9>reaper.time_precise() then reaper.defer(ultraschall.Defer9) else return reaper.defer(ultraschall.deferfunc9), ultraschall.ScriptIdentifier..".defer_script09" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script09")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer9", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script09"
end


function ultraschall.Defer10(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer10</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer10(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc10)~="function" then 
    ultraschall.AddErrorMessage("Defer10", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer10==nil then 
    ultraschall.AddErrorMessage("Defer10", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer10=timer_counter end 
  if func~=nil then ultraschall.deferfunc10=func end
  if mode~=nil then 
    ultraschall.defermode10=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10", "running", false)
    if mode==2 then ultraschall.defertimer10=ultraschall.defertimer10+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode10==nil then
    ultraschall.defermode10=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10", "running", false)
  end
  
  if (ultraschall.defermode10==0 or ultraschall.defermode10==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10")=="running" then 
    return reaper.defer(ultraschall.deferfunc10), ultraschall.ScriptIdentifier..".defer_script10"
  elseif ultraschall.defermode10==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10")=="running" then
    ultraschall.defertimer10=ultraschall.defertimer10-1
    if ultraschall.defertimer10>0 then reaper.defer(ultraschall.Defer10) else return reaper.defer(ultraschall.deferfunc10), ultraschall.ScriptIdentifier..".defer_script10" end
  elseif ultraschall.defermode10==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10")=="running" then
    if ultraschall.defertimer10>reaper.time_precise() then reaper.defer(ultraschall.Defer10) else return reaper.defer(ultraschall.deferfunc10), ultraschall.ScriptIdentifier..".defer_script10" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script10")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer10", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script10"
end


function ultraschall.Defer11(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer11</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer11(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc11)~="function" then 
    ultraschall.AddErrorMessage("Defer11", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer11==nil then 
    ultraschall.AddErrorMessage("Defer11", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer11=timer_counter end 
  if func~=nil then ultraschall.deferfunc11=func end
  if mode~=nil then 
    ultraschall.defermode11=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11", "running", false)
    if mode==2 then ultraschall.defertimer11=ultraschall.defertimer11+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode11==nil then
    ultraschall.defermode11=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11", "running", false)
  end
  
  if (ultraschall.defermode11==0 or ultraschall.defermode11==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11")=="running" then 
    return reaper.defer(ultraschall.deferfunc11), ultraschall.ScriptIdentifier..".defer_script11"
  elseif ultraschall.defermode11==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11")=="running" then
    ultraschall.defertimer11=ultraschall.defertimer11-1
    if ultraschall.defertimer11>0 then reaper.defer(ultraschall.Defer11) else return reaper.defer(ultraschall.deferfunc11), ultraschall.ScriptIdentifier..".defer_script11" end
  elseif ultraschall.defermode11==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11")=="running" then
    if ultraschall.defertimer11>reaper.time_precise() then reaper.defer(ultraschall.Defer11) else return reaper.defer(ultraschall.deferfunc11), ultraschall.ScriptIdentifier..".defer_script11" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script11")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer11", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script11"
end


function ultraschall.Defer12(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer12</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer12(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc12)~="function" then 
    ultraschall.AddErrorMessage("Defer12", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer12==nil then 
    ultraschall.AddErrorMessage("Defer12", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer12=timer_counter end 
  if func~=nil then ultraschall.deferfunc12=func end
  if mode~=nil then 
    ultraschall.defermode12=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12", "running", false)
    if mode==2 then ultraschall.defertimer12=ultraschall.defertimer12+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode12==nil then
    ultraschall.defermode12=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12", "running", false)
  end
  
  if (ultraschall.defermode12==0 or ultraschall.defermode12==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12")=="running" then 
    return reaper.defer(ultraschall.deferfunc12), ultraschall.ScriptIdentifier..".defer_script12"
  elseif ultraschall.defermode12==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12")=="running" then
    ultraschall.defertimer12=ultraschall.defertimer12-1
    if ultraschall.defertimer12>0 then reaper.defer(ultraschall.Defer12) else return reaper.defer(ultraschall.deferfunc12), ultraschall.ScriptIdentifier..".defer_script12" end
  elseif ultraschall.defermode12==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12")=="running" then
    if ultraschall.defertimer12>reaper.time_precise() then reaper.defer(ultraschall.Defer12) else return reaper.defer(ultraschall.deferfunc12), ultraschall.ScriptIdentifier..".defer_script12" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script12")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer12", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script12"
end


function ultraschall.Defer13(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer13</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer13(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc13)~="function" then 
    ultraschall.AddErrorMessage("Defer13", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer13==nil then 
    ultraschall.AddErrorMessage("Defer13", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer13=timer_counter end 
  if func~=nil then ultraschall.deferfunc13=func end
  if mode~=nil then 
    ultraschall.defermode13=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13", "running", false)
    if mode==2 then ultraschall.defertimer13=ultraschall.defertimer13+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode13==nil then
    ultraschall.defermode13=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13", "running", false)
  end
  
  if (ultraschall.defermode13==0 or ultraschall.defermode13==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13")=="running" then 
    return reaper.defer(ultraschall.deferfunc13), ultraschall.ScriptIdentifier..".defer_script13"
  elseif ultraschall.defermode13==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13")=="running" then
    ultraschall.defertimer13=ultraschall.defertimer13-1
    if ultraschall.defertimer13>0 then reaper.defer(ultraschall.Defer13) else return reaper.defer(ultraschall.deferfunc13), ultraschall.ScriptIdentifier..".defer_script13" end
  elseif ultraschall.defermode13==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13")=="running" then
    if ultraschall.defertimer13>reaper.time_precise() then reaper.defer(ultraschall.Defer13) else return reaper.defer(ultraschall.deferfunc13), ultraschall.ScriptIdentifier..".defer_script13" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script13")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer13", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script13"
end


function ultraschall.Defer14(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer14</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer14(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc14)~="function" then 
    ultraschall.AddErrorMessage("Defer14", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer14==nil then 
    ultraschall.AddErrorMessage("Defer14", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer14=timer_counter end 
  if func~=nil then ultraschall.deferfunc14=func end
  if mode~=nil then 
    ultraschall.defermode14=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14", "running", false)
    if mode==2 then ultraschall.defertimer14=ultraschall.defertimer14+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode14==nil then
    ultraschall.defermode14=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14", "running", false)
  end
  
  if (ultraschall.defermode14==0 or ultraschall.defermode14==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14")=="running" then 
    return reaper.defer(ultraschall.deferfunc14), ultraschall.ScriptIdentifier..".defer_script14"
  elseif ultraschall.defermode14==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14")=="running" then
    ultraschall.defertimer14=ultraschall.defertimer14-1
    if ultraschall.defertimer14>0 then reaper.defer(ultraschall.Defer14) else return reaper.defer(ultraschall.deferfunc14), ultraschall.ScriptIdentifier..".defer_script14" end
  elseif ultraschall.defermode14==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14")=="running" then
    if ultraschall.defertimer14>reaper.time_precise() then reaper.defer(ultraschall.Defer14) else return reaper.defer(ultraschall.deferfunc14), ultraschall.ScriptIdentifier..".defer_script14" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script14")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer14", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script14"
end


function ultraschall.Defer15(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer15</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer15(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc15)~="function" then 
    ultraschall.AddErrorMessage("Defer15", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer15==nil then 
    ultraschall.AddErrorMessage("Defer15", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer15=timer_counter end 
  if func~=nil then ultraschall.deferfunc15=func end
  if mode~=nil then 
    ultraschall.defermode15=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15", "running", false)
    if mode==2 then ultraschall.defertimer15=ultraschall.defertimer15+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode15==nil then
    ultraschall.defermode15=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15", "running", false)
  end
  
  if (ultraschall.defermode15==0 or ultraschall.defermode15==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15")=="running" then 
    return reaper.defer(ultraschall.deferfunc15), ultraschall.ScriptIdentifier..".defer_script15"
  elseif ultraschall.defermode15==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15")=="running" then
    ultraschall.defertimer15=ultraschall.defertimer15-1
    if ultraschall.defertimer15>0 then reaper.defer(ultraschall.Defer15) else return reaper.defer(ultraschall.deferfunc15), ultraschall.ScriptIdentifier..".defer_script15" end
  elseif ultraschall.defermode15==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15")=="running" then
    if ultraschall.defertimer15>reaper.time_precise() then reaper.defer(ultraschall.Defer15) else return reaper.defer(ultraschall.deferfunc15), ultraschall.ScriptIdentifier..".defer_script15" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script15")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer15", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script15"
end


function ultraschall.Defer16(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer16</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer16(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc16)~="function" then 
    ultraschall.AddErrorMessage("Defer16", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer16==nil then 
    ultraschall.AddErrorMessage("Defer16", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer16=timer_counter end 
  if func~=nil then ultraschall.deferfunc16=func end
  if mode~=nil then 
    ultraschall.defermode16=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16", "running", false)
    if mode==2 then ultraschall.defertimer16=ultraschall.defertimer16+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode16==nil then
    ultraschall.defermode16=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16", "running", false)
  end
  
  if (ultraschall.defermode16==0 or ultraschall.defermode16==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16")=="running" then 
    return reaper.defer(ultraschall.deferfunc16), ultraschall.ScriptIdentifier..".defer_script16"
  elseif ultraschall.defermode16==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16")=="running" then
    ultraschall.defertimer16=ultraschall.defertimer16-1
    if ultraschall.defertimer16>0 then reaper.defer(ultraschall.Defer16) else return reaper.defer(ultraschall.deferfunc16), ultraschall.ScriptIdentifier..".defer_script16" end
  elseif ultraschall.defermode16==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16")=="running" then
    if ultraschall.defertimer16>reaper.time_precise() then reaper.defer(ultraschall.Defer16) else return reaper.defer(ultraschall.deferfunc16), ultraschall.ScriptIdentifier..".defer_script16" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script16")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer16", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script16"
end


function ultraschall.Defer17(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer17</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer17(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc17)~="function" then 
    ultraschall.AddErrorMessage("Defer17", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer17==nil then 
    ultraschall.AddErrorMessage("Defer17", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer17=timer_counter end 
  if func~=nil then ultraschall.deferfunc17=func end
  if mode~=nil then 
    ultraschall.defermode17=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17", "running", false)
    if mode==2 then ultraschall.defertimer17=ultraschall.defertimer17+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode17==nil then
    ultraschall.defermode17=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17", "running", false)
  end
  
  if (ultraschall.defermode17==0 or ultraschall.defermode17==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17")=="running" then 
    return reaper.defer(ultraschall.deferfunc17), ultraschall.ScriptIdentifier..".defer_script17"
  elseif ultraschall.defermode17==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17")=="running" then
    ultraschall.defertimer17=ultraschall.defertimer17-1
    if ultraschall.defertimer17>0 then reaper.defer(ultraschall.Defer17) else return reaper.defer(ultraschall.deferfunc17), ultraschall.ScriptIdentifier..".defer_script17" end
  elseif ultraschall.defermode17==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17")=="running" then
    if ultraschall.defertimer17>reaper.time_precise() then reaper.defer(ultraschall.Defer17) else return reaper.defer(ultraschall.deferfunc17), ultraschall.ScriptIdentifier..".defer_script17" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script17")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer17", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script17"
end


function ultraschall.Defer18(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer18</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer18(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc18)~="function" then 
    ultraschall.AddErrorMessage("Defer18", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer18==nil then 
    ultraschall.AddErrorMessage("Defer18", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer18=timer_counter end 
  if func~=nil then ultraschall.deferfunc18=func end
  if mode~=nil then 
    ultraschall.defermode18=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18", "running", false)
    if mode==2 then ultraschall.defertimer18=ultraschall.defertimer18+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode18==nil then
    ultraschall.defermode18=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18", "running", false)
  end
  
  if (ultraschall.defermode18==0 or ultraschall.defermode18==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18")=="running" then 
    return reaper.defer(ultraschall.deferfunc18), ultraschall.ScriptIdentifier..".defer_script18"
  elseif ultraschall.defermode18==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18")=="running" then
    ultraschall.defertimer18=ultraschall.defertimer18-1
    if ultraschall.defertimer18>0 then reaper.defer(ultraschall.Defer18) else return reaper.defer(ultraschall.deferfunc18), ultraschall.ScriptIdentifier..".defer_script18" end
  elseif ultraschall.defermode18==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18")=="running" then
    if ultraschall.defertimer18>reaper.time_precise() then reaper.defer(ultraschall.Defer18) else return reaper.defer(ultraschall.deferfunc18), ultraschall.ScriptIdentifier..".defer_script18" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script18")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer18", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script18"
end


function ultraschall.Defer19(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer19</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer19(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc19)~="function" then 
    ultraschall.AddErrorMessage("Defer19", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer19==nil then 
    ultraschall.AddErrorMessage("Defer19", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer19=timer_counter end 
  if func~=nil then ultraschall.deferfunc19=func end
  if mode~=nil then 
    ultraschall.defermode19=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19", "running", false)
    if mode==2 then ultraschall.defertimer19=ultraschall.defertimer19+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode19==nil then
    ultraschall.defermode19=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19", "running", false)
  end
  
  if (ultraschall.defermode19==0 or ultraschall.defermode19==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19")=="running" then 
    return reaper.defer(ultraschall.deferfunc19), ultraschall.ScriptIdentifier..".defer_script19"
  elseif ultraschall.defermode19==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19")=="running" then
    ultraschall.defertimer19=ultraschall.defertimer19-1
    if ultraschall.defertimer19>0 then reaper.defer(ultraschall.Defer19) else return reaper.defer(ultraschall.deferfunc19), ultraschall.ScriptIdentifier..".defer_script19" end
  elseif ultraschall.defermode19==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19")=="running" then
    if ultraschall.defertimer19>reaper.time_precise() then reaper.defer(ultraschall.Defer19) else return reaper.defer(ultraschall.deferfunc19), ultraschall.ScriptIdentifier..".defer_script19" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script19")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer19", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script19"
end


function ultraschall.Defer20(func, mode, timer_counter)
  --[[
  <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
    <slug>Defer20</slug>
    <requires>
      Ultraschall=4.00
      Reaper=5.965
      Lua=5.3
    </requires>
    <functioncall>boolean retval, string defer_identifier = ultraschall.Defer20(function func, optional integer mode, optional number timer_counter)</functioncall>
    <description markup_type="markdown" markup_version="1.0.1" indent="default">
      runs a custom-defer-cycle, which can be individualized.
      
      You can set, how often this script shall be run(every x defer-cycle or every x seconds) and even stop the defer-cycle from in- and outside of the script, using the defer\_identifier.
      
      Don't run this twice in your script. It you need more than one such defer-cycle, use 

        [Defer1](#Defer1), [Defer2](#Defer2), [Defer3](#Defer3), [Defer4](#Defer4), [Defer5](#Defer5), [Defer6](#Defer6), [Defer7](#Defer7), [Defer8](#Defer8), [Defer9](#Defer9), [Defer10](#Defer10),
        [Defer11](#Defer11), [Defer12](#Defer12), [Defer13](#Defer13), [Defer14](#Defer14), [Defer15](#Defer15), [Defer16](#Defer16), [Defer17](#Defer17), [Defer18](#Defer18), [Defer19](#Defer19), [Defer20](#Defer20)

      where every such defer-instance can be controlled individually, including stopping it.      
      It will return, if the defer-cycle could be started and a defer-identifier, which can be used to stop it from the in/outside of the script-instance.
      
      When this defer-instance is stopped, it will return true, nil, otherwise it will return true, defer\_identifier
      
      To stop such a defer-cycle, use [StopDeferCycle](#StopDeferCycle)
      
      returns false in case of an error (e.g. already 1024 defer-cycles are running in the current script-instance)
    </description>
    <parameters>
      function func - the function, you would love to defer to
      optional integer mode - 0 or nil, just run as regular defer-cycle
                            - 1, run the defer-cycle only every timer_counter-cycle
                            - 2, run the defer-cycle only every timer_counter-seconds
      optional number timer_counter - the timer for the defer-cycle
                                    -   mode=1: 1 and higher, the next defer-cycle that shall be used by function func. Use 1 for every cycle, 2 for every second cycle.
                                    -               30 cycles are approximately 1 second.
                                    -   mode=2: 0 and higher, the amount of seconds to wait, until the function func is run the next time.
    </parameters>
    <retvals>
      boolean retval - true, running this defer-cycle was successful; false, it wasn't successful
      string defer_identifier - an identifier-string, that can be used to stop the defer-cycle
    </retvals>
    <chapter_context>
      Defer-Management
    </chapter_context>
    <target_document>US_Api_Documentation</target_document>
    <source_document>ultraschall_functions_engine.lua</source_document>
    <tags>defermanagement, defer, timer, defer-cycles, wait, seconds</tags>
  </US_DocBloc>
  ]]  if type(func)~="function" and type(ultraschall.deferfunc20)~="function" then 
    ultraschall.AddErrorMessage("Defer20", "func", "must be a function", -1)
    return false 
  end
  if mode~=0 and mode~=nil and timer_counter==nil and ultraschall.defertimer20==nil then 
    ultraschall.AddErrorMessage("Defer20", "timer_counter", "must be a number, when mode is 1 or 2", -2)
    return false 
  end
  if timer_counter~=nil then ultraschall.defertimer20=timer_counter end 
  if func~=nil then ultraschall.deferfunc20=func end
  if mode~=nil then 
    ultraschall.defermode20=mode
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20", "running", false)
    if mode==2 then ultraschall.defertimer20=ultraschall.defertimer20+reaper.time_precise() end
  elseif mode==nil and ultraschall.defermode20==nil then
    ultraschall.defermode20=0
    reaper.SetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20", "running", false)
  end
  
  if (ultraschall.defermode20==0 or ultraschall.defermode20==nil) and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20")=="running" then 
    return reaper.defer(ultraschall.deferfunc20), ultraschall.ScriptIdentifier..".defer_script20"
  elseif ultraschall.defermode20==1 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20")=="running" then
    ultraschall.defertimer20=ultraschall.defertimer20-1
    if ultraschall.defertimer20>0 then reaper.defer(ultraschall.Defer20) else return reaper.defer(ultraschall.deferfunc20), ultraschall.ScriptIdentifier..".defer_script20" end
  elseif ultraschall.defermode20==2 and reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20")=="running" then
    if ultraschall.defertimer20>reaper.time_precise() then reaper.defer(ultraschall.Defer20) else return reaper.defer(ultraschall.deferfunc20), ultraschall.ScriptIdentifier..".defer_script20" end
  elseif reaper.GetExtState("ultraschall", ultraschall.ScriptIdentifier..".defer_script20")~="running" then
    return true
  else 
    ultraschall.AddErrorMessage("Defer20", "mode", "no such mode, must be between 0 and 2 or nil", -3)
    return false
  end
  return true, ultraschall.ScriptIdentifier..".defer_script20"
end

function ultraschall.GetTrackSelection_TrackStateChunk(TrackStateChunk)
-- returns the trackname as a string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetTrackSelection_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer selection_state = ultraschall.GetTrackSelection_TrackStateChunk(string TrackStateChunk)</functioncall>
  <description>
    returns selection of the track.    
    
    It's the entry SEL.
    
    Works only with statechunks stored in ProjectStateChunks, due API-limitations!
  </description>
  <retvals>
    integer selection_state - 0, track is unselected; 1, track is selected
  </retvals>
  <parameters>    
    string TrackStateChunk - a TrackStateChunk whose selection-state you want to retrieve; works only with TrackStateChunks from ProjectStateChunks!
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, selection, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if ultraschall.IsValidTrackStateChunk(TrackStateChunk)==false then ultraschall.AddErrorMessage("GetTrackSelection", "TrackStateChunk", "no valid TrackStateChunk", -1) return nil end
  
  -- get selection
  local Track_Name=str:match(".-SEL (.-)%c.-REC")
  return tonumber(Track_Name)
end

--A=ultraschall.GetProjectStateChunk()
--B=ultraschall.GetProject_TrackStateChunk(nil, 1, false, A)


--C=ultraschall.GetTrackSelection(-1,B)

function ultraschall.SetTrackSelection_TrackStateChunk(selection_state, TrackStateChunk)
-- returns the trackname as a string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetTrackSelection_TrackStateChunk</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string alteredTrackStateChunk = ultraschall.SetTrackSelection_TrackStateChunk(integer selection_state, string TrackStateChunk)</functioncall>
  <description>
    set selection of the track in a TrackStateChunk.    
    
    It's the entry SEL.
    
    Works only with statechunks stored in ProjectStateChunks, due API-limitations!
  </description>
  <retvals>
    string alteredTrackStateChunk - the altered TrackStateChunk with the new selection
  </retvals>
  <parameters>    
    integer selection_state - 0, track is unselected; 1, track is selected
    string TrackStateChunk - a TrackStateChunk whose selection-state you want to set; works only with TrackStateChunks from ProjectStateChunks!
  </parameters>
  <chapter_context>
    Track Management
    Get Track States
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>trackmanagement, selection, state, get, trackstatechunk</tags>
</US_DocBloc>
--]]

  -- check parameters
  if ultraschall.IsValidTrackStateChunk(TrackStateChunk)==false then ultraschall.AddErrorMessage("GetTrackSelection", "TrackStateChunk", "no valid TrackStateChunk", -1) return nil end
  if math.type(selection_state)~="integer" then ultraschall.AddErrorMessage("GetTrackSelection", "selection_state", "must be an integer", -2) return nil end
  if selection_state<0 or selection_state>1 then ultraschall.AddErrorMessage("GetTrackSelection", "selection_state", "must be either 0 or 1", -3) return nil end
  
  -- set selection
  local Start=TrackStateChunk:match(".-FREEMODE.-\n")
  local End=TrackStateChunk:match("REC.*")
  return Start.."    SEL "..selection_state.."\n    "..End
end

--A=ultraschall.GetProjectStateChunk()
--B=ultraschall.GetProject_TrackStateChunk(nil, 1, false, A)

--C=ultraschall.SetTrackSelection_TrackStateChunk(1, B)
--print2(C)

function ultraschall.GetIniFileValue(section, key, errval, inifile)
-- returns the trackname as a string
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetIniFileValue</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer length_of_value, string value = ultraschall.GetIniFileValue(string section, string key, string errval, string inifile)</functioncall>
  <description>
    Gets a value from a key of an ini-file
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer length_of_value - the length of the value in bytes
    string value - the value from the key-value-pair
  </retvals>
  <parameters>    
    string section - the section, in which the key-value-pair is located
    string key - the key whose value you want
    string errval - an errorvalue, which will be shown, if key-value-store doesn't exist
    string inifile - the ini-file, from which you want to retrieve the key-value-store
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>inifilemanagement, get, key, value, section</tags>
</US_DocBloc>
--]]
  if type(inifile)~="string" then ultraschall.AddErrorMessage("GetIniFileValue", "inifile", "must be a string", -1) return -1 end
  if section==nil then ultraschall.AddErrorMessage("GetIniFileValue", "section", "must be a string", -2) return -1 end
  if key==nil then ultraschall.AddErrorMessage("GetIniFileValue", "key", "must be a string", -3) return -1 end
  if errval==nil then errval="" end
  section=tostring(section)
  key=tostring(key)

  local A=ultraschall.ReadFullFile(inifile).."\n["
  
  local SectionArea=A:match(section.."%](.-)\n%[").."\n"
  local KeyValue=SectionArea:match("\n"..key.."=(.-)\n")
  if KeyValue==nil then KeyValue=errval end
  return KeyValue:len(), KeyValue
end



--A=ultraschall.GetIniFileValue("section", "key", "LULATSCH", reaper.get_ini_file():match("(.-)REAPER.ini").."ultraschall.ini")


function ultraschall.SetIniFileValue(section, key, value, inifile)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetIniFileValue</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.SetIniFileValue(string section, string key, string value, string inifile)</functioncall>
  <description>
    Sets a value of a key in an ini-file
    
    returns -1 in case of an error
  </description>
  <retvals>
    integer retval - -1, in case of an error; 1, in case of success
  </retvals>
  <parameters>    
    string section - the section, in which the key-value-pair is located
    string key - the key whose value you want to change
    string value - the new value for this key-value-pair
    string inifile - the ini-file, in which you want to set the key-value-store
  </parameters>
  <chapter_context>
    Configuration-Files Management
    Ini-Files
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>inifilemanagement, set, key, value, section</tags>
</US_DocBloc>
--]]
  if type(inifile)~="string" then ultraschall.AddErrorMessage("SetIniFileValue", "inifile", "must be a string", -1) return -1 end
  if section==nil then ultraschall.AddErrorMessage("SetIniFileValue", "section", "must be a string", -2) return -1 end
  if key==nil then ultraschall.AddErrorMessage("SetIniFileValue", "key", "must be a string", -3) return -1 end
  if value==nil then ultraschall.AddErrorMessage("SetIniFileValue", "value", "must be a string", -4) return -1 end
  section=tostring(section)
  key=tostring(key)
  value=tostring(value)
  
  local Start, Middle, Ende, A, Kombi, Offset
  local A=ultraschall.ReadFullFile(inifile)
  if A==nil then A="" end
  if A:match("%["..section.."%]")~=nil then
    A=A.."\n["
    Start=A:match("(.*)%["..section)
    Middle, Offset=A:match("(%["..section.."%].-)()%[")
    Ende=A:sub(Offset,-2)
    
    if Middle:match(key)~=nil then
      Middle=string.gsub(Middle, key.."=.-\n", key.."="..value.."\n")
    else
      Middle=Middle..key.."="..value.."\n\n"
      Ende="\n"..Ende
    end
     
  else
    Start=A
    Middle="\n"
    Ende="["..section.."]\n"..key.."="..value.."\n"
  end
  Kombi=string.gsub(Start..Middle..Ende, "\n\n", "\n")
  return ultraschall.WriteValueToFile(inifile, Kombi)
end

--A1=ultraschall.SetIniFileValue(file:match("(.-)REAPER.ini").."lula.ini", "ultrascshall_update", "D", "1")

function ultraschall.GetLoopState()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetLoopState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer retval = ultraschall.GetLoopState()</functioncall>
  <description>
    Returns the current loop-state
  </description>
  <retvals>
    integer retval - 0, loop is on; 1, loop is off
  </retvals>
  <chapter_context>
    Navigation
    Transport
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>transportmanagement, get, loop</tags>
</US_DocBloc>
--]]
  return reaper.GetToggleCommandState(1068)
end

--A=ultraschall.GetLoopState()

function ultraschall.SetLoopState(state)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetLoopState</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetLoopState(integer state)</functioncall>
  <description>
    Sets the current loop-state
    
    returns false in case of an error
  </description>
  <retvals>
    boolean retval - true, if setting was successful; false, if setting was unsuccessful
  </retvals>
  <parameters>
    integer state - 0, loop is on; 1, loop is off
  </parameters>
  <chapter_context>
    Navigation
    Transport
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>transportmanagement, set, loop</tags>
</US_DocBloc>
--]]
  if math.type(state)~="integer" then ultraschall.AddErrorMessage("SetLoopState", "state", "must be an integer", -1) return false end
  if state~=0 and state~=1 then ultraschall.AddErrorMessage("SetLoopState", "state", "must be 1(on) or 0(off)", -2) return false end
  if ultraschall.GetLoopState()~=state then
    reaper.Main_OnCommand(1068, 0)
  end
  return true
end

--A=ultraschall.SetLoopState(0)

function ultraschall.GetHWND_ArrangeViewAndTimeLine()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetHWND_ArrangeViewAndTimeLine</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.964
    SWS=2.9.7
    Lua=5.3
  </requires>
  <functioncall>HWND arrange_view, HWND timeline = ultraschall.GetHWND_ArrangeViewAndTimeLine()</functioncall>
  <description>
    Returns the HWND-windowhandler for the tracklist- and timeline-area in the arrange-view 
    
    returns nil in case of an error. Please report such an error, which means, that you should use ultraschall.ShowLastErrorMessage() to show that error and report the information requested(fruitful bugreports lead to a handwritten postcard as reward :) )
  </description>
  <retvals>
    HWND arrange_view - the HWND-window-handler for the tracklist-area of the arrangeview
    HWND timeline - the HWND-window-handler for the timeline/markerarea of the arrangeview
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, get, hwnd, arrangeview, timeline, trackview</tags>
</US_DocBloc>
--]]
  -- fantastic arrangeview- and timeline-hwnds and where to find them...
  -- by "J.K."Mespotine ;)

  -- preparation of variables
  local ARHWND, TLHWND, temphwnd
  
  -- if we haven't stored the adress of the arrangeviewhwnd yet, let's go find them.
  if reaper.GetExtState("ultraschall", "arrangehwnd")=="" then
    -- prepare some values we need
    local Start,Stop = reaper.BR_GetArrangeView(0)
    local Projectlength=reaper.GetProjectLength()

    -- get mainhwnd of Reaper and all of it's childhwnds
    local HWND=reaper.GetMainHwnd()    
    local retval, list = reaper.JS_Window_ListAllChild(HWND)    
    
    --Now, the magic happens
    
    
    -- [ Getting Arrangeview HWND] --
    
    -- split the hwnd-adresses into individual adresses
    local Count, Individual_values = ultraschall.CSV2IndividualLinesAsArray(list)
    
    
    -- get current scroll-state of all hwnds
    local ScrollState={}
    for i=1, Count do
      ScrollState[i]={}
      local temphwnd=reaper.JS_Window_HandleFromAddress(Individual_values[i])
    
      ScrollState[i]["retval"], ScrollState[i]["position"], ScrollState[i]["pageSize"], ScrollState[i]["min"], ScrollState[i]["max"], ScrollState[i]["trackPos"] = reaper.JS_Window_GetScrollInfo(temphwnd,"h")
      retval, ScrollState[i]["left"], ScrollState[i]["top"], ScrollState[i]["right"], ScrollState[i]["bottom"] = reaper.JS_Window_GetRect(temphwnd)
    end
    
    -- alter scrollstate
    reaper.BR_SetArrangeView(0,Start+100000,Stop+100000)
    
    -- check scrollstate of all hwnds for the one, whose scrollstate changed, as this is the arrange-view-hwnd
    for i=1, Count do
      temphwnd=reaper.JS_Window_HandleFromAddress(Individual_values[i])
      local retval, position, pageSize, min, max, trackPos = reaper.JS_Window_GetScrollInfo(temphwnd,"h")
      if position~=ScrollState[i]["position"] or 
         pageSize~=ScrollState[i]["pageSize"] or
         min~=ScrollState[i]["min"] or
         max~=ScrollState[i]["max"] or
         trackPos~=ScrollState[i]["trackPos"] then
        ARHWND=temphwnd 
        --[[print2(reaper.JS_Window_GetTitle(temphwnd), position, ScrollState[i]["position"], 
                                                    pageSize, ScrollState[i]["pageSize"],
                                                    min, ScrollState[i]["min"],
                                                    max, ScrollState[i]["max"],
                                                    trackPos, ScrollState[i]["trackPos"]
                                                    )--]]
        break
      end
    end

    -- in the unlikely case that I can't find a hwnd, return this error-message    
    if ARHWND==nil then ultraschall.AddErrorMessage("GetHWND_ArrangeViewAndTimeLine", "", 
          [[Couldn't find Arrangeview for some reason. Please report this to me as a bug and what you did to make this error happen!
  
  Please include in the bugreport your OS, the Reaper-version and the following information:
  ]]..Projectlength..", "..Start..", "..Stop..", "..reaper.GetHZoomLevel(), -1) return nil end
    
    -- reset arrangeview-scrolling to it's original state
    reaper.BR_SetArrangeView(0,Start,Stop)
    

    -- [ Getting Timeline HWND] --
    
    -- let's get the dimensions of the arrangeview-hwnd, as top, left and right-positions can be used
    -- to determine bottom, left, right of the timeline-hwnd
    local retval, left, top, right, bottom = reaper.JS_Window_GetRect(ARHWND)
    
    -- check all hwnds to find the one, that has right=right, left=left, bottom_timeline=top_arrangeview
    for i=1, Count do
      local temphwnd=reaper.JS_Window_HandleFromAddress(Individual_values[i])
      if ScrollState[i]["left"]==left and ScrollState[i]["right"]==right and ScrollState[i]["bottom"]==top then
        TLHWND=temphwnd 
        break
      end
    end
    
    -- store the adresses of the found HWNDs of Arrangeview and Timeline into an extstate for further use, to prevent useless
    -- scroll-state-altering of the Arrangeview(which could cause stuck Arrangeviews, when done permanently)
    reaper.SetExtState("ultraschall", "arrangehwnd", reaper.JS_Window_AddressFromHandle(ARHWND), false)
    reaper.SetExtState("ultraschall", "timelinehwnd", reaper.JS_Window_AddressFromHandle(TLHWND), false)
    ultraschall.ARHWND=ARHWND
    ultraschall.TLHWND=TLHWND
  else
    -- if the extstate already has stored the arrangeview-hwnd-address, just convert the one for arrangeview and timeline
    -- it into their handles and return them
    ARHWND=reaper.JS_Window_HandleFromAddress(reaper.GetExtState("ultraschall", "arrangehwnd"))
    TLHWND=reaper.JS_Window_HandleFromAddress(reaper.GetExtState("ultraschall", "timelinehwnd"))
  end  
  return ARHWND, TLHWND
end

--    reaper.SetExtState("ultraschall", "arrangehwnd", "", false)

--A,B=ultraschall.GetHWND_ArrangeViewAndTimeLine()
--C,D=reaper.JS_Window_GetTitle(B)
--P=reaper.GetHZoomLevel()
--C=reaper.JS_Window_FromPoint(reaper.GetMousePosition())

--ultraschall.ShowLastErrorMessage()


function ultraschall.GetVerticalScroll()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetVerticalScroll</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>integer vertical_scroll_factor = ultraschall.GetVerticalScroll()</functioncall>
  <description>
    Gets the current vertical_scroll_value. The valuerange is dependent on the vertical zoom.
  </description>
  <retvals>
    integer vertical_scroll_factor - the vertical-scroll-factor
  </retvals>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>arrangeviewmanagement, get, vertical, scroll factor</tags>
</US_DocBloc>
--]]
  local retval, position = reaper.JS_Window_GetScrollInfo(ultraschall.GetHWND_ArrangeViewAndTimeLine(), "SB_VERT")
  
  return position
end

--A=ultraschall.GetVerticalScroll()

function ultraschall.SetVerticalScroll(scrollposition)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetVerticalScroll</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.962
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetVerticalScroll(integer scrollposition)</functioncall>
  <description>
    Sets the vertical-scroll-factor.
    
    The possible value-range depends on the vertical-zoom.
    
    returns false in case of an error or if scrolling is impossible(e.g. zoomed out fully)
  </description>
  <retvals>
    boolean retval - true, if setting was successful; false, if setting was unsuccessful
  </retvals>
  <parameters>
    integer scrollposition - the vertical scrolling-position
  </parameters>
  <chapter_context>
    User Interface
    Arrangeview Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>arrangeviewmanagement, set, vertical, scroll factor</tags>
</US_DocBloc>
--]]
  if math.type(position)~="integer" then ultraschall.AddErrorMessage("SetVerticalScroll", "scrollposition", "must be an integer", -1) return false end
  
  return reaper.JS_Window_SetScrollPos(ultraschall.GetHWND_ArrangeViewAndTimeLine(), "SB_VERT", scrollposition)
end

--A=ultraschall.SetVerticalScroll(2000000)

function ultraschall.GetUserInputs(title, caption_names, default_retvals, length)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetUserInputs</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer number_of_inputfields, table returnvalues = ultraschall.GetUserInputs(string title, table caption_names, table default_retvals, integer length)</functioncall>
  <description>
    Gets inputs from the user.
    
    The captions and the default-returnvalues must be passed as an integer-index table.
    e.g.
      caption_names[1]="first caption name"
      caption_names[2]="second caption name"
      caption_names[1]="*third caption name, which creates an inputfield for passwords, due the * at the beginning"
     
    returns false in case of an error.
  </description>
  <retvals>
    boolean retval - true, the user clicked ok on the userinput-window; false, the user clicked cancel or an error occured
    integer number_of_inputfields - the number of returned values; nil, in case of an error
    table returnvalues - the returnvalues input by the user as a table; nil, in case of an error
  </retvals>
  <parameters>
    string title - the title of the inputwindow
    table caption_names - a table with all inputfield-captions. All non-string-entries will be converted to string-entries. Begin an entry with a * for password-entry-fields.
    table default_retvals - a table with all default retvals. All non-string-entries will be converted to string-entries.
    integer length - the extralength of the user-inputfield. With that, you can enhance the length of the inputfields. 1-500
  </parameters>
  <chapter_context>
    User Interface
    Dialogs
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>userinterface, dialog, get, user input</tags>
</US_DocBloc>
--]]
  if type(title)~="string" then ultraschall.AddErrorMessage("GetUserInputs", "title", "must be a string", -1) return false end
  if type(caption_names)~="table" then ultraschall.AddErrorMessage("GetUserInputs", "caption_names", "must be a table", -2) return false end
  if type(default_retvals)~="table" then ultraschall.AddErrorMessage("GetUserInputs", "default_retvals", "must be a table", -3) return false end
  if math.type(length)~="integer" then ultraschall.AddErrorMessage("GetUserInputs", "length", "must be an integer", -4) return false end
  if length>500 or length<1 then ultraschall.AddErrorMessage("GetUserInputs", "length", "must be between 1 and 500", -5) return false end
  local count = ultraschall.CountEntriesInTable_Main(caption_names)
  length=(length*2)+18
  
  local captions=""
  local retvals=""
  
  for i=1, count do
    if caption_names[i]==nil then caption_names[i]="" end
    captions=captions..tostring(caption_names[i])..","
  end
  captions=captions:sub(1,-2)
  captions=captions..",extrawidth="..length
  
  for i=1, count do
    if default_retvals[i]==nil then default_retvals[i]="" end
    retvals=retvals..tostring(default_retvals[i])..","
  end
  retvals=retvals:sub(1,-2)  
  
  local retval, retvalcsv = reaper.GetUserInputs(title, count, captions, retvals)
  if retval==false then return false end
  return retval, ultraschall.CSV2IndividualLinesAsArray(retvalcsv) 
end

function ultraschall.CreateRenderCFG_AIFF(bits)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_AIFF</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_AIFF(integer bits)</functioncall>
  <description>
    Returns the render-cfg-string for the AIFF-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected AIFF-settings
  </retvals>
  <parameters>
    integer bits - the bitrate of the aiff-file; 8, 16, 24 and 32 are supported
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, aiff</tags>
</US_DocBloc>
]]
  if math.type(bits)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_AIFF", "bits", "must be an integer", -1) return nil end
  local renderstring="ZmZpY..AAA=="
  if bits==8 then renderstring=string.gsub(renderstring, "%.%.", "Qg")
  elseif bits==16 then renderstring=string.gsub(renderstring, "%.%.", "RA")
  elseif bits==24 then renderstring=string.gsub(renderstring, "%.%.", "Rg")
  elseif bits==32 then renderstring=string.gsub(renderstring, "%.%.", "SA")
  else ultraschall.AddErrorMessage("CreateRenderCFG_AIFF", "bits", "only 8, 16, 24 and 32 are supported by AIFF", -2) return nil
  end
  return renderstring
end


function ultraschall.CreateRenderCFG_AudioCD(trackmode, only_markers_starting_with_hash, leadin_silence_tracks, leadin_silence_disc, burncd_image_after_render)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CreateRenderCFG_AudioCD</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>string render_cfg_string = ultraschall.CreateRenderCFG_AudioCD(integer trackmode, boolean only_markers_starting_with_hash, integer leadin_silence_tracks, integer leadin_silence_disc, boolean burncd_image_after_render)</functioncall>
  <description>
    Returns the render-cfg-string for the AudioCD-format. You can use this in ProjectStateChunks, RPP-Projectfiles and reaper-render.ini
    
    You can also check, whether to burn the created cd-image after rendering.
    
    Returns nil in case of an error
  </description>
  <retvals>
    string render_cfg_string - the render-cfg-string for the selected AudioCD-image-settings
  </retvals>
  <parameters>
    integer trackmode - Track mode-dropdownlist: 1, Markers define new track; 2, Regions define tracks (other areas ignored); 3, One Track
    boolean only_markers_starting_with_hash - Only use markers starting with #-checkbox; true, checked; false, unchecked
    integer leadin_silence_tracks - Lead-in silence for tracks-inputbox, in milliseconds; 0 to 100000 supported by Ultraschall-API
    integer leadin_silence_disc - Extra lead-in silence for disc-inputbox, in milliseconds; 0 to 100000 supported by Ultraschall-API
    boolean burncd_image_after_render - Burn CD image after render-checkbox; true, checked; false, unchecked
  </parameters>
  <chapter_context>
    Rendering of Project
    Creating Renderstrings
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>projectfiles, create, render, outputformat, audiocd, cd, image, burn cd</tags>
</US_DocBloc>
]]

  local ini_file=ultraschall.Api_Path.."IniFiles/Reaper-Render-Codes-for-AudioCD.ini"
  if reaper.file_exists(ini_file)==false then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "Ooops", "external audio-cd-render-code-ini-file does not exist. Reinstall Ultraschall-API again, please!", -1) return nil end
  if math.type(trackmode)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "trackmode", "Must be an integer between 1 and 3!", -2) return nil end
  if type(only_markers_starting_with_hash)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "only_markers_starting_with_hash", "Must be a boolean!", -3) return nil end
  if math.type(leadin_silence_tracks)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "leadin_silence_tracks", "Must be an integer!", -4) return nil end
  if math.type(leadin_silence_disc)~="integer" then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "leadin_silence_disc", "Must be an integer!", -5) return nil end
  if type(burncd_image_after_render)~="boolean" then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "burncd_image_after_render", "Must be a boolean!", -6) return nil end
  
  if trackmode<1 or trackmode>3 then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "trackmode", "Must be an integer between 1 and 3!", -7) return nil end
  if leadin_silence_tracks<0 or leadin_silence_tracks>100000 then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "leadin_silence_tracks", "Ultraschall-API supports only millisecond-values between 0 to 100000, sorry.", -8) return nil end
  if leadin_silence_disc<0 or leadin_silence_disc>100000 then ultraschall.AddErrorMessage("CreateRenderCFG_AudioCD", "leadin_silence_disc", "Ultraschall-API supports only millisecond-values between 0 to 100000, sorry.", -9) return nil end

  
  if trackmode==1 then trackmode="1"
  elseif trackmode==2 then trackmode="2"
  elseif trackmode==3 then trackmode="3"
  end
  
  if only_markers_starting_with_hash==true then only_markers_starting_with_hash="checked" else only_markers_starting_with_hash="unchecked" end
  
  if burncd_image_after_render==true then burncd_image_after_render="checked" else burncd_image_after_render="unchecked" end
  
  local _temp, renderstring=ultraschall.GetIniFileExternalState("AUDIOCD", "Renderstring", ini_file)
  local _temp, leadin_silence_disc=ultraschall.GetIniFileExternalState("AUDIOCD", "DISCLEADIN_"..leadin_silence_disc, ini_file)
  local _temp, leadin_silence_tracks=ultraschall.GetIniFileExternalState("AUDIOCD", "TRACKLEADIN_"..leadin_silence_tracks, ini_file)
  local _temp, trackmode=ultraschall.GetIniFileExternalState("AUDIOCD", "Trackmode_"..trackmode, ini_file)
  local _temp, burncd_image_after_render=ultraschall.GetIniFileExternalState("AUDIOCD", "BurnCDImage_"..burncd_image_after_render, ini_file)
  local _temp, only_markers_starting_with_hash=ultraschall.GetIniFileExternalState("AUDIOCD", "OnlyUseMarkers_"..only_markers_starting_with_hash, ini_file)


  renderstring=string.gsub(renderstring, "%[DISCLEADIN%]", leadin_silence_disc)
  renderstring=string.gsub(renderstring, "%[TRACKLEADIN%]", leadin_silence_tracks)
  renderstring=string.gsub(renderstring, "%[BurnCDImage%]", burncd_image_after_render)
  renderstring=string.gsub(renderstring, "%[Trackmode%]", trackmode)
  renderstring=string.gsub(renderstring, "%[OnlyUseMarkers%]", only_markers_starting_with_hash)

  return renderstring
end

--A=ultraschall.CreateRenderCFG_AudioCD(1,false,100000,100000,false)
--reaper.CF_SetClipboard(A)

--B="IG9zaaCGAQCghgEAAAAAAAAAAAAAAAAA"

function ultraschall.ReplacePartOfString(originalstring, insertstring, offset, length)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>ReplacePartOfString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>string replaced_string = ultraschall.ReplacePartOfString(string originalstring, string insertstring, integer offset, optional integer length)</functioncall>
  <description>
    replaces a part of a string with a second string
    
    Returns nil in case of an error
  </description>
  <retvals>
    string replaced_string - the altered string
  </retvals>
  <parameters>
    string originalstring - the originalstring, in which you want to insert the string
    string insertstring - the string that shall be inserted
    integer offset - the position, at which to insert the string
    optional integer length - the length of the part of the originalstring that shall be replaced, counted from offset. 0 or nil for simple insertion.
  </parameters>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, replace, string, offset, length, insert</tags>
</US_DocBloc>
]]

  if type(originalstring)~="string" then ultraschall.AddErrorMessage("ReplacePartOfString", "originalstring", "must be a string", -1) return nil end
  if type(insertstring)~="string" then ultraschall.AddErrorMessage("ReplacePartOfString", "insertstring", "must be a string", -2) return nil end
  if math.type(offset)~="integer" then ultraschall.AddErrorMessage("ReplacePartOfString", "offset", "must be an integer", -3) return nil end
  if length==nil then length=0 end
  if math.type(length)~="integer" then ultraschall.AddErrorMessage("ReplacePartOfString", "length", "must be an integer", -4) return nil end
  
  local start=originalstring:sub(1,offset)
  local endof=originalstring:sub(offset+length+1,-1)
  
  return start..insertstring..endof
end




function ultraschall.SearchStringInString(fullstring, searchstring, searchnested)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SearchStringInString</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.77
    Lua=5.3
  </requires>
  <functioncall>integer count, array posarray = ultraschall.SearchStringInString(string fullstring, string searchstring)</functioncall>
  <description>
    Searches for the string searchstring in fullstring. 
    
    Keep in mind: Umlauts may produce multibyte-values. Therefore, the returned offsets might be confusing.
    
    returns -1 in case of error, 0 if string wasn't found
  </description>
  <parameters>
    string fullstring - the string to be searched through
    string searchstring - the string to search for within fullstring
  </parameters>
  <retvals>
    integer count - the number of found occurences of searchstring in fullstring
    array posarray - an array that contains the positions, where searchstring was found within fullstring
  </retvals>
  <chapter_context>
    API-Helper functions
    Data Manipulation
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>helper functions, search, string</tags>
</US_DocBloc>
--]]

  -- check parameters
  if type(fullstring)~="string" then ultraschall.AddErrorMessage("SearchStringInString", "fullstring", "must be a string", -1) return -1 end
  if type(searchstring)~="string" then ultraschall.AddErrorMessage("SearchStringInString", "searchstring", "must be a string", -2) return -1 end

  -- prepare variables
  local count=0
  local count2=0
  local posstring={}

  local temp, TEMPO2, temp3
  
  while fullstring~=nil do
    temp,TEMPO2,temp3=fullstring:match(".*()("..searchstring..")()")
    if temp==nil then break end
    fullstring=fullstring:sub(1,temp-1)
    count=count+1
    posstring[count]=temp-1
  end

  -- return result
  table.sort(posstring)
  return count, posstring
end

--L2,LL2=ultraschall.SearchStringInString("ABCmABCABCmABC", "Cm")

function ultraschall.GetRenderToFileHWND()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetRenderToFileHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>HWND hwnd = ultraschall.GetRenderToFileHWND()</functioncall>
  <description>
    returns the HWND of the Render to File-dialog, if the window is opened.
    
    returns nil if Render to File-dialog is closed
  </description>
  <retvals>
    HWND hwnd - the window-handler of the Render to File-dialog
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, window, render to file, hwnd, get</tags>
</US_DocBloc>
--]]

  local translation=reaper.JS_Localize("Render to File", "DLG_506")
  local open_render_queue_tr=reaper.JS_Localize("Open render queue...", "DLG_506")
  local save_changes_and_close_tr=reaper.JS_Localize("Save changes and close", "DLG_506")
  local render_tr=reaper.JS_Localize("Render...", "DLG_506")
  local wildcards_tr=reaper.JS_Localize("Wildcards", "DLG_506")
  
  local count_hwnds, hwnd_array, hwnd_adresses = ultraschall.Windows_Find(translation, true)
  if count_hwnds==0 then return nil
  else
    for i=count_hwnds, 1, -1 do
      if ultraschall.HasHWNDChildWindowNames(hwnd_array[i], 
                                            open_render_queue_tr.."\0"..
                                            save_changes_and_close_tr.."\0"..
                                            render_tr.."\0"..
                                            wildcards_tr)==true then return hwnd_array[i] end
    end
  end
  return nil
end

--AAAA=ultraschall.GetRenderToFileHWND()

--AAA=ultraschall.GetRenderToFileHWND()

function ultraschall.GetActionsHWND()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetActionsHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>HWND hwnd = ultraschall.GetActionsHWND()</functioncall>
  <description>
    returns the HWND of the Actions-dialog, if the window is opened.
    
    returns nil if the Actions-dialog is closed
  </description>
  <retvals>
    HWND hwnd - the window-handler of the Actions-dialog
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, window, hwnd, actions, get</tags>
</US_DocBloc>
--]]
  local translation=reaper.JS_Localize("Actions", "common")
  local find_shortcut=reaper.JS_Localize("Find shortcut...", "DLG_274")
  local add=reaper.JS_Localize("Add...", "DLG_274")
  local new=reaper.JS_Localize("New...", "DLG_274")
  local run_close=reaper.JS_Localize("Run/close", "actiondialog")
  
  local count_hwnds, hwnd_array, hwnd_adresses = ultraschall.Windows_Find(translation, true)
  if count_hwnds==0 then return nil
  else
    for i=count_hwnds, 1, -1 do
      if ultraschall.HasHWNDChildWindowNames(hwnd_array[i], 
                                            find_shortcut.."\0"..
                                            add.."\0"..
                                            new.."\0"..
                                            run_close)==true then return hwnd_array[i] end
    end
  end
  return nil
end

--AAA=ultraschall.GetActionsHWND()

function ultraschall.GetVideoHWND()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetVideoHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.963
    Lua=5.3
  </requires>
  <functioncall>HWND hwnd = ultraschall.GetVideoHWND()</functioncall>
  <description>
    returns the HWND of the Video window, if the window is opened.
    
    due API-limitations on Mac and Linux: if more than one window called "Video Window" is opened, it will return -1
    I hope to find a workaround for that problem at some point...
    
    returns nil if the Video Window is closed
  </description>
  <retvals>
    HWND hwnd - the window-handler of the Video Window
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>US_Api_Documentation</target_document>
  <source_document>ultraschall_functions_engine.lua</source_document>
  <tags>user interface, window, hwnd, video, get</tags>
</US_DocBloc>
--]]
  local translation=reaper.JS_Localize("Video Window", "common")
  local count_hwnds, hwnd_array, hwnd_adresses = ultraschall.Windows_Find(translation, true)
  if count_hwnds==0 then return nil
  elseif reaper.GetOS():match("Win")~=nil then
    for i=count_hwnds, 1, -1 do
      if reaper.JS_Window_GetClassName(hwnd_array[i], "")=="REAPERVideoMainwnd" then 
        local retval, left, top, right, bottom = reaper.JS_Window_GetClientRect(hwnd_array[i])
        return hwnd_array[i], left, top, right, bottom
      end
    end
  else 
    if count_hwnds==1 then
      return hwnd_array[1]
    else
      ultraschall.AddErrorMessage("GetVideoHWND", "", "more than one window called Video Window opened. Can't determine the right one...sorry", -1)
      return -1
    end
  end
  return nil
end
--gfx.init(reaper.JS_Localize("Video Window", "common"))
--A=ultraschall.GetVideoHWND()

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GFX_Init</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.964
    Lua=5.3
  </requires>
  <functioncall>integer retval, HWND hwnd = ultraschall.GFX_Init(string "name", optional integer width, optional integer height, optional integer dockstate, optional integer xpos, optional integer ypos)</functioncall>
  <description>
    Opens a new graphics window and returns its HWND-windowhandler object.
  </description>
  <parameters>
    string "name" - the name of the window, which will be shown in the title of the window
    optional integer width -  the width of the window; minmum is 50
    optional integer height -  the height of the window; minimum is 16
    optional integer dockstate - &1=0, undocked; &1=1, docked
    optional integer xpos - x-position of the window in pixels; minimum is -80
    optional integer ypos - y-position of the window in pixels; minimum is -15
  </parameters>
  <retvals>
    number retval  -  1.0, if window is opened
    HWND hwnd - the window-handler of the newly created window; can be used with JS_Window_xxx-functions of the JS-extension-plugin
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>gfx, functions, gfx, init, window, create, hwnd</tags>
</US_DocBloc>
]]

--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GFX_GetWindowHWND</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    JS=0.964
    Lua=5.3
  </requires>
  <functioncall>HWND hwnd = ultraschall.GFX_GetWindowHWND()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Returns the HWND of the currently opened gfx-window. You need to use [ultraschall.GFX_Init()](#GFX_Init), otherwise 
    it will contain the message "Please, use ultraschall.GFX_Init() for window-creation, not gfx.init(!), to retrieve the HWND of the gfx-window."
  </description>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
     HWND hwnd - the window-handler of the opened gfx-window; will contain a helpermessage, if you didn't use ultraschall.GFX_Init() for window creation.
  </retvals>
  <chapter_context>
    User Interface
    Window Management
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>gfx, functions, gfx, init, window, get, hwnd</tags>
</US_DocBloc>
]]

function ultraschall.GetAllCustomMarkers(custom_marker_name)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllCustomMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer count, table marker_array = ultraschall.GetAllCustomMarkers(string custom_marker_name)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will return all custom-markers with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not check custom-regions, use [GetAllCustomRegions](#GetAllCustomRegions) instead.
    
    returns -1 in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    integer count - the number of found markers; -1, in case of an error
    table marker_array - an array with all found custom-markers. It follows the scheme:
                       -
                       -    marker_array[index]["index"] - index of the marker, in timeline-order, with 0 for the first in the project
                       -    marker_array[index]["pos"]   - position of the marker in seconds
                       -    marker_array[index]["name"]  - name of the marker, excluding the custom-marker-name
                       -    marker_array[index]["shown_number"]  - the number of the marker, that is displayed in the timeline
                       -    marker_array[index]["color"]  - color-value of the marker
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, get, all, custom markers, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("GetAllCustomMarkers", "custom_marker_name", "must be a string", -1) return -1 end
  if ultraschall.IsValidMatchingPattern(custom_marker_name)==false then ultraschall.AddErrorMessage("GetAllCustomMarkers", "custom_marker_name", "not a valid matching-pattern", -2) return -1 end
  local count=0
  local MarkerArray={}

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==false and name:match("^_"..custom_marker_name..":")~=nil then 
      count=count+1 
      MarkerArray[count]={}
      MarkerArray[count]["index"]=i
      MarkerArray[count]["pos"]=pos
      MarkerArray[count]["name"]=name:match(".-:%s-(.*)")
      MarkerArray[count]["shown_number"]=markrgnindexnumber
      MarkerArray[count]["color"]=color
    end
  end
  return count, MarkerArray
end

--A,B,C = ultraschall.GetAllCustomMarkers("Whiskey")


function ultraschall.GetAllCustomRegions(custom_region_name)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetAllCustomRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer count, table marker_array = ultraschall.GetAllCustomRegions(string custom_region_name)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will return all custom-regions with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not check custom-markers, use [GetAllCustomMarkers](#GetAllCustomMarkers) instead.
    
    returns -1 in case of an error
  </description>
  <parameters>
    string custom_region_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    integer count - the number of found regions; -1, in case of an error
    table region_array - an array with all found custom-markers. It follows the scheme:
                       -
                       -    region_array[index]["index"] - index of the region, in timeline-order, with 0 for the first in the project
                       -    region_array[index]["pos"]   - position of the region in seconds
                       -    region_array[index]["regionend"] - the endposition of the region in seconds
                       -    region_array[index]["name"]  - name of the region, excluding the custom-region-name
                       -    region_array[index]["shown_number"]  - the number of the region, that is displayed in the timeline
                       -    region_array[index]["color"]  - color-value of the region
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, get, all, custom regions, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("GetAllCustomRegions", "custom_region_name", "must be a string", -1) return -1 end
  if ultraschall.IsValidMatchingPattern(custom_region_name)==false then ultraschall.AddErrorMessage("GetAllCustomRegions", "custom_region_name", "not a valid matching-pattern", -2) return -1 end
  local count=0
  local MarkerArray={}

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==true and name:match("^_"..custom_region_name..":")~=nil then 
      count=count+1 
      MarkerArray[count]={}
      MarkerArray[count]["index"]=i
      MarkerArray[count]["pos"]=pos
      MarkerArray[count]["regionend"]=rgnend
      MarkerArray[count]["name"]=name:match(".-:%s*(.*)")
      MarkerArray[count]["shown_number"]=markrgnindexnumber
      MarkerArray[count]["color"]=color
    end
  end
  return count, MarkerArray
end

--A,B,C=ultraschall.GetAllCustomRegions("Whiskey")

function ultraschall.CountAllCustomMarkers(custom_marker_name)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountAllCustomMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer count = ultraschall.CountAllCustomMarkers(string custom_marker_name)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will count all custom-markers with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not count custom-regions, use [CountAllCustomRegions](#CountAllCustomRegions) instead.
    
    returns -1 in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    integer count - the number of found markers; -1, in case of an error
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, count, all, custom markers</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("GetAllCustomMarkers", "custom_marker_name", "must be a string", -1) return -1 end
  if ultraschall.IsValidMatchingPattern(custom_marker_name)==false then ultraschall.AddErrorMessage("GetAllCustomMarkers", "custom_marker_name", "not a valid matching-pattern", -2) return -1 end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==false and name:match("^_"..custom_marker_name..":")~=nil then 
      count=count+1 
    end
  end
  return count
end

--A,B,C = ultraschall.CountAllCustomMarkers("Whiskey")


function ultraschall.CountAllCustomRegions(custom_region_name)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>CountAllCustomRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer count = ultraschall.CountAllCustomRegions(string custom_region_name)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will count all custom-regions with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not count custom-markers, use [CountAllCustomMarkers](#CountAllCustomMarkers) instead.
    
    returns -1 in case of an error
  </description>
  <parameters>
    string custom_region_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    integer count - the number of found regions; -1, in case of an error
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, count, all, custom regions</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("CountAllCustomRegions", "custom_region_name", "must be a string", -1) return -1 end
  if ultraschall.IsValidMatchingPattern(custom_region_name)==false then ultraschall.AddErrorMessage("CountAllCustomRegions", "custom_region_name", "not a valid matching-pattern", -2) return -1 end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==true and name:match("^_"..custom_region_name..":")~=nil then 
      count=count+1 
    end
  end
  return count
end

--B,C=ultraschall.CountAllCustomRegions(true)


function ultraschall.EnumerateCustomMarkers(custom_marker_name, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateCustomMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer marker_index, number pos, string name, integer shown_number, integer color = ultraschall.EnumerateCustomMarkers(string custom_marker_name, integer idx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will return a specific custom-marker with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not enumerate custom-regions, use [EnumerateCustomRegions](#EnumerateCustomRegions) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
    integer idx - the index of the marker within all same-named custom-markers; 0, for the first custom-marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if the custom-marker exists; false, if not or an error occurred
    integer marker_index - the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc
    number pos - the position of the marker in seconds
    string name - the name of the marker, exluding the custom-marker-name
    integer shown_number - the markernumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, enumerate, custom markers, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("EnumerateCustomMarkers", "custom_marker_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_marker_name)==false then ultraschall.AddErrorMessage("EnumerateCustomMarkers", "custom_marker_name", "not a valid matching-pattern", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("EnumerateCustomMarkers", "idx", "must be an integer", -3) return false end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==false and name:match("^_"..custom_marker_name..":")~=nil then 
      count=count+1 
      if idx==count-1 then return true, i, pos, name:match(".-:%s*(.*)"), markrgnindexnumber, color end
    end
  end
  return false
end

--A,B,C,D,E,F,G = ultraschall.EnumerateCustomMarkers("Whiskey",-3)


function ultraschall.EnumerateCustomRegions(custom_region_name, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>EnumerateCustomRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer marker_index, number pos, number regionend, string name, integer shown_number, integer color = ultraschall.EnumerateCustomRegions(string custom_marker_name, integer idx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will return a specific custom-region with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not enumerate custom-markers, use [EnumerateCustomMarkers](#EnumerateCustomMarkers) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_region_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
    integer idx - the index of the region within all same-named custom-regions; 0, for the first custom-region
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if the custom-region exists; false, if not or an error occurred
    integer marker_index - the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc
    number pos - the position of the region in seconds
    number rgnend - the end of the region in seconds
    string name - the name of the region, exluding the custom-region-name
    integer shown_number - the regionnumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the region
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, enumerate, custom regions, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("EnumerateCustomRegions", "custom_region_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_region_name)==false then ultraschall.AddErrorMessage("EnumerateCustomRegions", "custom_region_name", "not a valid matching-pattern", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("EnumerateCustomRegions", "idx", "must be an integer", -3) return false end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==true and name:match("^_"..custom_region_name..":")~=nil then 
      count=count+1 
      if idx==count-1 then return true, i, pos, rgnend, name:match(".-:%s*(.*)"), markrgnindexnumber, color end
    end
  end
  return false
end

--A,B,C,D,E,F,G = ultraschall.EnumerateCustomRegions("Whiskey",4)

function ultraschall.DeleteCustomMarkers(custom_marker_name, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteCustomMarkers</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer marker_index, number pos, string name, integer shown_number, integer color = ultraschall.DeleteCustomMarkers(string custom_marker_name, integer idx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will delete a specific custom-marker with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not delete custom-regions, use [DeleteCustomRegions](#DeleteCustomRegions) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
    integer idx - the index of the marker within all same-named custom-markers; 0, for the first custom-marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if the custom-marker exists; false, if not or an error occurred
    integer marker_index - the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc
    number pos - the position of the marker in seconds
    string name - the name of the marker, exluding the custom-marker-name
    integer shown_number - the markernumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, delete, custom markers, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("DeleteCustomMarkers", "custom_marker_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_marker_name)==false then ultraschall.AddErrorMessage("DeleteCustomMarkers", "custom_marker_name", "not a valid matching-pattern", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteCustomMarkers", "idx", "must be an integer", -3) return false end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==false and name:match("^_"..custom_marker_name..":")~=nil then 
      count=count+1 
      if idx==count-1 then 
        reaper.DeleteProjectMarkerByIndex(0, i) 
        return true, i, pos, name:match(".-:%s*(.*)"), markrgnindexnumber, color 
      end
    end
  end
  return false
end

--A,B,C,D,E,F,G = ultraschall.DeleteCustomMarkers("Whiskey",2)


function ultraschall.DeleteCustomRegions(custom_region_name, idx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>DeleteCustomRegions</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer marker_index, number pos, number regionend, string name, integer shown_number, integer color = ultraschall.DeleteCustomRegions(string custom_marker_name, integer idx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Deletes a specific custom-region with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not delete custom-markers, use [DeleteCustomMarkers](#DeleteCustomMarkers) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_region_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
                              - Lua-pattern-matching-expressions are allowed. This parameter is NOT case-sensitive.
    integer idx - the index of the region within all same-named custom-regions; 0, for the first custom-region
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if the custom-region exists; false, if not or an error occurred
    integer marker_index - the index of the marker within all markers and regions, as positioned in the project, with 0 for the first, 2 for the second, etc
    number pos - the position of the region in seconds
    number rgnend - the end of the region in seconds
    string name - the name of the region, exluding the custom-region-name
    integer shown_number - the regionnumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the region
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, delete, custom regions, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("DeleteCustomRegions", "custom_region_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_region_name)==false then ultraschall.AddErrorMessage("DeleteCustomRegions", "custom_region_name", "not a valid matching-pattern", -2) return false end
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("DeleteCustomRegions", "idx", "must be an integer", -3) return false end
  local count=0

  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0,i)
    if isrgn==true and name:match("^_"..custom_region_name..":")~=nil then 
      count=count+1 
      if idx==count-1 then 
        reaper.DeleteProjectMarkerByIndex(0, i) 
        return true, i, pos, rgnend, name:match(".-:%s*(.*)"), markrgnindexnumber, color 
      end
    end
  end
  return false
end

--A,B,C,D,E,F,G = ultraschall.DeleteCustomRegions("Whiskey",3)

function ultraschall.AddCustomMarker(custom_marker_name, pos, name, shown_number, color)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddCustomMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.AddCustomMarker(string custom_marker_name, number pos, string name, integer shown_number, integer color)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will add new custom-marker with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not add custom-regions, use [AddCustomRegion](#AddCustomRegion) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
    number pos - the position of the marker in seconds
    string name - the name of the marker, exluding the custom-marker-name
    integer shown_number - the markernumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if adding the custom-marker was successful; false, if not or an error occurred
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, add, custom markers, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  -- ToDo: return the index of the newly added marker, if that is useful
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("AddCustomMarker", "custom_marker_name", "must be a string", -1) return false end
  if type(pos)~="number" then ultraschall.AddErrorMessage("AddCustomMarker", "pos", "must be a number", -2) return false end
  if type(name)~="string" then ultraschall.AddErrorMessage("AddCustomMarker", "name", "must be a string", -3) return false end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("AddCustomMarker", "shown_number", "must be an integer", -4) return false end
  if math.type(color)~="integer" then ultraschall.AddErrorMessage("AddCustomMarker", "color", "must be an integer; 0, for default color", -5) return false end  
  
  reaper.AddProjectMarker2(0, false, pos, 0, "_"..custom_marker_name..": "..name, shown_number, color)
  return true
end
--A,B,C=ultraschall.AddCustomMarker("vanillachief", 1, "Hulahoop", 987, 9865)


function ultraschall.AddCustomRegion(custom_region_name, pos, regionend, name, shown_number, color)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddCustomRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer shown_number = ultraschall.AddCustomRegion(string custom_region_name, number pos, number regionend, string name, integer shown_number, integer color)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will add new custom-region with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not add custom-markers, use [AddCustomMarker](#AddCustomMarker) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
    number pos - the position of the region in seconds
    number regionend - the endposition of the region in seconds
    string name - the name of the region, exluding the custom-region-name
    integer shown_number - the regionnumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if adding the custom-region was successful; false, if not or an error occurred
    integer shown_number - if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, add, custom region, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  -- ToDo: return the index of the newly added marker, if that is useful
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("AddCustomRegion", "custom_region_name", "must be a string", -1) return false end
  if type(pos)~="number" then ultraschall.AddErrorMessage("AddCustomRegion", "pos", "must be a number", -2) return false end
  if type(length)~="number" then ultraschall.AddErrorMessage("AddCustomRegion", "length", "must be a number", -6) return false end
  if type(name)~="string" then ultraschall.AddErrorMessage("AddCustomRegion", "name", "must be a string", -3) return false end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("AddCustomRegion", "shown_number", "must be an integer", -4) return false end
  if math.type(color)~="integer" then ultraschall.AddErrorMessage("AddCustomRegion", "color", "must be an integer; 0, for default color", -5) return false end  
  
  local shown_number=reaper.AddProjectMarker2(0, true, pos, length, "_"..custom_region_name..": "..name, shown_number, color)
  return true, shown_number
end

--A,B,C=ultraschall.AddCustomRegion("vanillachief", 105, 150, "Hulahoop", 987, 9865)


function ultraschall.SetCustomMarker(custom_marker_name, idx, pos, name, shown_number, color)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>SetCustomMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.SetCustomMarker(string custom_marker_name, integer idx, number pos, string name, integer shown_number, integer color)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will set attributes of an already existing custom-marker with a certain name.
    
    A custom-marker has the naming-scheme 
        
        \_customname: text for this marker
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-marker has the name
      
       \_\_customname:: test for this marker
        
    Example:
    
    The custom-marker *VanillaChief* has the custom\_marker\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-markers.
    
    Will not set custom-regions, use [SetCustomRegion](#SetCustomRegion) instead.
    
    returns false in case of an error
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-marker. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-marker is called "__CustomMarker::"
    integer idx - the index-number of the custom-marker within all custom-markers
    number pos - the position of the marker in seconds
    string name - the name of the marker, exluding the custom-marker-name
    integer shown_number - the markernumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if setting the new attributes of the custom-marker was successful; false, if not or an error occurred
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, set, custom markers, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("SetCustomMarker", "custom_marker_name", "must be a string", -1) return false end
  if type(pos)~="number" then ultraschall.AddErrorMessage("SetCustomMarker", "pos", "must be a number", -2) return false end
  if type(name)~="string" then ultraschall.AddErrorMessage("SetCustomMarker", "name", "must be a string", -3) return false end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("SetCustomMarker", "shown_number", "must be an integer", -4) return false end
  if math.type(color)~="integer" then ultraschall.AddErrorMessage("SetCustomMarker", "color", "must be an integer; 0, for default color", -5) return false end  
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("SetCustomMarker", "idx", "must be an integer", -6) return false end
  
  local retval, markerindex = ultraschall.EnumerateCustomMarkers(custom_marker_name, idx)
  
  if retval==false then ultraschall.AddErrorMessage("SetCustomMarker", "idx", "no such custom-marker", -7) return false end
  
  return reaper.SetProjectMarkerByIndex2(0, markerindex, false, pos, 0, shown_number, "_"..custom_marker_name..": "..name, color, 0)
end

--A,B,C=ultraschall.SetCustomMarker("vanillachief", -3, 30, "Hulahoop9", 48787, 12)


function ultraschall.SetCustomRegion(custom_region_name, idx, pos, regionend, name, shown_number, color)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>AddCustomRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval, integer shown_number = ultraschall.AddCustomRegion(string custom_region_name, number pos, string name, integer shown_number, integer color)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    Will add new custom-region with a certain name.
    
    A custom-region has the naming-scheme 
        
        \_customname: text for this region
        
    You just need to pass customname to this function, leaving out the preceding \_ and the trailing :
    Exception: if the custom-region has the name
      
        \_\_customname:: test for this region
        
    Example:
    
    The custom-region *VanillaChief* has the custom\_region\_name *VanillaChief* and will be shown as *\_VanillaChief: text* in the project.
    So you pass VanillaChief to this function to get all \_VanillaChief:-regions.
    
    Will not add custom-markers, use [AddCustomMarker](#AddCustomMarker) instead.
    
    returns false in case of an error, like the desired shown_number is already taken by another region
  </description>
  <parameters>
    string custom_marker_name - the name of the custom-region. Don't include the _ at the beginning and the : at the end, or it might not be found. Exception: Your custom-region is called "__CustomRegion::"
    number pos - the position of the region in seconds
    string name - the name of the region, exluding the custom-region-name
    integer shown_number - the regionnumber, that is displayed in the timeline of the arrangeview
    integer color - the color of the marker
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, if adding the region was successful; false, if not or an error occurred
    integer shown_number - if the desired shown_number is already used by another region, this will hold the alternative number for the new custom-region
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, set, custom region, color, name, position, shown_number, index</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("SetCustomRegion", "custom_region_name", "must be a string", -1) return false end
  if type(pos)~="number" then ultraschall.AddErrorMessage("SetCustomRegion", "pos", "must be a number", -2) return false end
  if type(regionend)~="number" then ultraschall.AddErrorMessage("SetCustomRegion", "regionend", "must be a number", -7) return false end
  if type(name)~="string" then ultraschall.AddErrorMessage("SetCustomRegion", "name", "must be a string", -3) return false end
  if math.type(shown_number)~="integer" then ultraschall.AddErrorMessage("SetCustomRegion", "shown_number", "must be an integer", -4) return false end
  if math.type(color)~="integer" then ultraschall.AddErrorMessage("SetCustomRegion", "color", "must be an integer; 0, for default color", -5) return false end  
  if math.type(idx)~="integer" then ultraschall.AddErrorMessage("SetCustomRegion", "idx", "must be an integer", -6) return false end
  
  local retval, markerindex = ultraschall.EnumerateCustomRegions(custom_region_name, idx)
  
  if retval==false then ultraschall.AddErrorMessage("SetCustomRegion", "idx", "no such custom-region", -7) return false end
  
  return reaper.SetProjectMarkerByIndex2(0, markerindex, true, pos, regionend, shown_number, "_"..custom_region_name..": "..name, color, 0)
end
--A,B,C=ultraschall.SetCustomRegion("vanillachief", 0, 10, 20, "HudelDudel", 2, 0)


function ultraschall.GetNextFreeRegionIndex()
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>GetNextFreeRegionIndex</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>integer free_shown_number = ultraschall.GetNextFreeRegionIndex()</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    returns the next unused region-index-number, beginning with 0.
  </description>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    integer free_shown_number - the next free/unused region-index-number
  </retvals>
  <chapter_context>
    Markers
    Assistance functions
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, get, free, region, index</tags>
</US_DocBloc>
]]
  local count=0
  local numbertable={}
  for i=0, reaper.CountProjectMarkers(0)-1 do
    local retval, isrgn, pos, rgnend, name, markrgnindexnumber, color = reaper.EnumProjectMarkers3(0, i)
    if isrgn==true then 
      count=count+1
      numbertable[count]=markrgnindexnumber
    end
  end
  
  table.sort(numbertable)
  
  for i=1, count do
    if numbertable[i]~=i-1 then return i-1 end
  end
  return count
end

--A=ultraschall.GetNextFreeRegionIndex()

function ultraschall.IsMarkerValidCustomMarker(custom_marker_name, markeridx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsMarkerValidCustomMarker</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsMarkerValidCustomMarker(string custom_marker_name, integer markeridx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    returns true, if the marker with id markeridx is a valid custom-marker of the type custom_marker_name
    
    markeridx is the index of all markers and regions!
    
    returns false in case of an error
  </description>
  <paramters>
    string custom_marker_name - the custom-marker-name to check against; can also be a Lua-pattern-matching-expression
    integer markeridx - the index of the marker to check; this is the index of all markers and regions!
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, marker is a valid custom-marker of type custom_marker_name; false, it is not or an error occurred
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, isvalid, custom-marker</tags>
</US_DocBloc>
]]
  if type(custom_marker_name)~="string" then ultraschall.AddErrorMessage("IsMarkerValidCustomMarker", "custom_marker_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_marker_name)==false then ultraschall.AddErrorMessage("IsMarkerValidCustomMarker", "custom_marker_name", "not a valid matching-pattern", -2) return false end
  if math.type(markeridx)~="integer" then ultraschall.AddErrorMessage("IsMarkerValidCustomMarker", "markeridx", "must be an integer", -3) return false end
  local A,B=ultraschall.GetAllCustomMarkers(custom_marker_name)
  for i=1, A do
    if B[i]["index"]==markeridx then return true end
  end
  return false
end

--C=ultraschall.IsMarkerValidCustomMarker("(.*)",0)


function ultraschall.IsRegionValidCustomRegion(custom_region_name, markeridx)
--[[
<US_DocBloc version="1.0" spok_lang="en" prog_lang="*">
  <slug>IsRegionValidCustomRegion</slug>
  <requires>
    Ultraschall=4.00
    Reaper=5.965
    Lua=5.3
  </requires>
  <functioncall>boolean retval = ultraschall.IsRegionValidCustomRegion(string custom_region_name, integer markeridx)</functioncall>
  <description markup_type="markdown" markup_version="1.0.1" indent="default">
    returns true, if the marker with id markeridx is a valid custom-region of the type custom_region_name
    
    markeridx is the index of all markers and regions!
    
    returns false in case of an error
  </description>
  <paramters>
    string custom_region_name - the custom-reion-name to check against; can also be a Lua-pattern-matching-expression
    integer markeridx - the index of the marker to check; this is the index of all markers and regions!
  </parameters>
  <retvals markup_type="markdown" markup_version="1.0.1" indent="default">
    boolean retval - true, marker is a valid custom-region of type custom_region_name; false, it is not or an error occurred
  </retvals>
  <chapter_context>
    Markers
    Custom Markers
  </chapter_context>
  <target_document>USApiGfxReference</target_document>
  <source_document>ultraschall_gfx_engine.lua</source_document>
  <tags>marker management, isvalid, custom-region</tags>
</US_DocBloc>
]]
  if type(custom_region_name)~="string" then ultraschall.AddErrorMessage("IsRegionValidCustomRegion", "custom_region_name", "must be a string", -1) return false end
  if ultraschall.IsValidMatchingPattern(custom_region_name)==false then ultraschall.AddErrorMessage("IsRegionValidCustomRegion", "custom_region_name", "not a valid matching-pattern", -2) return false end
  if math.type(markeridx)~="integer" then ultraschall.AddErrorMessage("IsRegionValidCustomRegion", "markeridx", "must be an integer", -3) return false end
  local A,B=ultraschall.GetAllCustomRegions(custom_region_name)
  for i=1, A do
    if B[i]["index"]==markeridx then return true end
  end
  return false
end

--C=ultraschall.IsRegionValidCustomRegion("vanillachief", 1)



ultraschall.ShowLastErrorMessage()

runcommand=ultraschall.RunCommand

--CC=ultraschall.ToggleMute_TrackObject(Track,1,1)
