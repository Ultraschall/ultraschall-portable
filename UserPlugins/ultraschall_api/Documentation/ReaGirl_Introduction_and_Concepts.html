<html><head><title>
ReaGirl Introduction, Concepts and Tutorials
</title>
<link href="style2.css" rel="stylesheet">
<link href="custom.css" rel="stylesheet">
</head>
<body>    
<a class="anch" id="This-is-the-TopOfTheWorld"></a>
<div style="position: sticky; top:0; padding-left:4%; z-index:100;">
<div style="background-color:#282828; width:95%; font-family:tahoma; font-size:16;">
<a href="US_Api_Functions.html"><img style="position: absolute; left:4.2%; width:11%;" src="gfx/US_Button_Un.png" alt="Ultraschall Internals Documentation"></a>  
<a href="Reaper_Api_Documentation.html"><img style="position: absolute; left:15.2%; width:8.7%;" src="gfx/Reaper_Button_Un.png" alt="Reaper Internals Documentation"></a>
<a href="ReaGirl_Functions.html"><img style="position: absolute; left:23.95%; width:8.7%;" src="gfx/ReaGirl_Button.png" alt="ReaGirl Documentation"></a>
<a href="Downloads.html"><img style="position:absolute; left:74.4%; width:6.9%;" src="gfx/Downloads_Un.png" alt="Downloads"></a>
<a href="ChangeLog.html"><img style="position:absolute; left:81.3%; width:6.9%;" src="gfx/Changelog_Un.png" alt="Changelog of documentation"></a>
<a href="Impressum.html"><img style="position:absolute; left:88.2%; width:6.9%;" src="gfx/Impressum_Un.png" alt="Impressum and Contact"></a>
<div style="padding-top:2.5%">
<table border="0" style="color:#aaaaaa; width:100%;">
<tr>
<td style="width:27.2%; padding-top:2; ">
<a href="http://api.mespotine.de"><img style="width:100%;" src="gfx/ReaGirl_Internals.png" alt="ReaGirl internals logo"></a>
</td>
<td style="position: absolute; padding-top:5; width:14%;"><u>Docs</u></td>
<td style="padding-top:5; width:10%;"> </td>
<td style="padding-top:5; width:10%;"> </td>
<td style="padding-top:5; width:10%;"> </td>
<td width="10%;">&nbsp;<u></u></td>
<td width="10%;">&nbsp;<u></u></td>
<td width="10%;">&nbsp;<u></u></td>
</tr>
<tr>
<td></td>
<td style="background-color:#777777; color:#BBBBBB; border: 1px solid #333333; border-radius:5%/5%;"><a href="ReaGirl_Introduction_and_Concepts.html" style="color:#BBBBBB; text-decoration: none; justify-content: center;">&nbsp;Concepts&Tutorials&nbsp;</a></td>
</tr>
<tr>
<td></td>
<td style="background-color:#555555; color:#BBBBBB; border: 1px solid #333333; border-radius:5%/5%;"><a href="ReaGirl_Functions.html" style="color:#BBBBBB; text-decoration: none; justify-content: center;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions</a></td>
</tr>
<tr>
<td></td>
</tr>
</table><hr color="#444444">
<div style="position:absolute; right:6%; top:80%;"><a style="color:#CCCCCC;" href="#This-is-the-TopOfTheWorld">Jump to Index</a></div>
</div>
</div>
</div>
<div class="ch"><p></p>
<!-- Clipboard Button -->
<script src="./scripts/clipboard.min.js.Download"></script>
<!-- External Script -->
<script src="./scripts/scripts.js.Download"></script>
<table class="indexpad" border="0"><tr><td><br><a class="inpad" id="Introduction"><a href="#Introduction">^</a></a><strong> <u>Introduction</u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#Introduction_001_Introduction">Introduction</a></td></tr><td class="tdsm"><a href="#Introduction_002_Installation">Installation</a></td></tr><td class="tdsm"><a href="#Introduction_003_Included_Actions">Included Actions</a></td></tr><td class="tdsm"><a href="#Tutorial_000_Introduction">Tutorial Introduction</a></td></tr></table><table class="indexpad" border="0"><tr><td><br><a class="inpad" id="Introduction  "><a href="#Introduction  ">^</a></a><strong> <u>Introduction  </u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#Introduction_001_First_Steps">First steps in ReaGirl</a></td></tr></table><table class="indexpad" border="0"><tr><td><br><a class="inpad" id="Tutorials"><a href="#Tutorials">^</a></a><strong> <u>Tutorials</u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#Tutorial_001_A_Basic_Gui">Tutorial 001: A Basic Gui</a></td></tr><td class="tdsm"><a href="#Tutorial_002_Adding_Tabs_to_a_Gui">Tutorial 002: Adding Tabs to a Gui</a></td></tr><td class="tdsm"><a href="#Tutorial_003_A_Basic_Image_Viewer">Tutorial 003: A Basic Image Viewer with a file-drop-zone and a context menu</a></td></tr><td class="tdsm"><a href="#Tutorial_004_Disabled_UI_Elements">Tutorial 004: Disabled UI Elements</a></td></tr><td class="tdsm"><a href="#Tutorial_005_Draggable_Images">Tutorial 005: Draggable Images</a></td></tr><td class="tdsm"><a href="#Tutorial_006_Enter_ESC_AtExit">Tutorial 006: Enter, Esc-Key and AtExit</a></td></tr><td class="tdsm"><a href="#Tutorial_007_Autopositioning_Of_UI_Elements">Tutorial 007: Autopositioning of UI-Elements</a></td></tr><td class="tdsm"><a href="#Tutorial_008_Autopositioning_With_Tabs">Tutorial 008: Autopositioning with Tabs</a></td></tr><td class="tdsm"><a href="#Tutorial_009_Structuring_Guis_With_Labels">Tutorial 009: Structuring Guis with Labels</a></td></tr><td class="tdsm"><a href="#Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning">Tutorial 010: Structuring Guis with Labels when autopositioning</a></td></tr><td class="tdsm"><a href="#Tutorial_011_Linking_UI_Elements_To_States">Tutorial 011: Linking UI-elements to states</a></td></tr><td class="tdsm"><a href="#Tutorial_012_Sticky_UI_Elements">Tutorial 012: Sticky UI-elements</a></td></tr><td class="tdsm"><a href="#Tutorial_013_Meters">Tutorial 013: Meters for tracks and hardware inputs</a></td></tr><td class="tdsm"><a href="#Tutorial_014_ToolbarButtons">Tutorial 014: doing toolbars with Toolbarbuttons</a></td></tr><td class="tdsm"><a href="#Tutorial_015_ExternalControlOfGuis">Tutorial 015: External control of ReaGirl-guis</a></td></tr></table><table class="indexpad" border="0"><tr><td><br><a class="inpad" id="The Gui Elements"><a href="#The Gui Elements">^</a></a><strong> <u>The Gui Elements</u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#The_Gui_Elements_000">The Gui Elements</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_001_Buttons">Buttons</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_002_Checkboxes">Checkboxes</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_003_Labels">Labels</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_004_Images">Images</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_005_Inputboxes">Inputboxes(Edit-Fields)</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_006_DropDownMenus_ComboBoxes">DropDownMenus(ComboBoxes)</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_007_Sliders">Sliders</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_008_Tabs">Tabs</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_009_ColorRectangle">Color Rectangle</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_010_BurgerMenu">Burger Menu</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_011_ToolbarButtons">Toolbarbuttons</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_012_LevelMeters">Level Meters</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_Concepts001_Context_Menus">Context Menus</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_Concepts002_FileDropZones">File Drop Zones</a></td></tr><td class="tdsm"><a href="#The_Gui_Elements_100_General">Functions for getting/setting ui-elements in general</a></td></tr></table><table class="indexpad" border="0"><tr><td><br><a class="inpad" id="Best Practices"><a href="#Best Practices">^</a></a><strong> <u>Best Practices</u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#Best_Practices_On_Accessibility">Best Practices On Accessibility</a></td></tr><td class="tdsm"><a href="#Best_Practices_On_Writing_Guis_As_Blind_Scripter">Best Practices on Writing guis as Blind Scripter</a></td></tr></table><table class="indexpad" border="0"><tr><td><br><a class="inpad" id="Final Words"><a href="#Final Words">^</a></a><strong> <u>Final Words</u></strong><br><br>
</td></tr><tr><td class="tdsm"><a href="#Final_words">Final Words</a></td></tr></table><br></div><div class="ch">
<hr>
<a class="anch" id="Introduction_001_Introduction"></a>
<a href="#Introduction_001_Introduction"> ^</a> <u><b>Introduction</b></u><br>			<p>
<div class="ch">
<p>Welcome to ReaGirl, an accessible Gui-library for Reaper.</p>
<p>Up until now, there are numerous gui-libraries available for Reaper who do a great job at allowing you to code your own guis.<br />
The problem is: none of them allow making guis for blind people for various (mostly technical) reasons, so only people who can see without a problem can use them.<br />
ReaGirl's intention is to solve this with a gui-library that makes it easy for you to code your own guis that are also useable by blind users.</p>
<p>And it does not only feature accessibility for blind users, but it has some additional benefits:</p>
<ul>
<li>It's easy to use.<br />
I tried to make it as easy to use as possible so you can quickly throw together a gui for your needs without having to practice using ReaGirl 40 hours a day.<br />
</li>
<li>It has 8 ui-elements available for your needs.<br />
Labels, Checkboxes, Buttons, Drop Down Menus, Sliders, InputBoxes, Tabs and Images<br />
</li>
<li>Fully useable via keyboard.<br />
You can navigate through it with keyboard, as you are used with every other gui out there.<br />
</li>
<li>It has scrolling features.<br />
So if your gui is bigger than the window, users can simpy scroll around to reach every gui-element.<br />
</li>
<li>Context-Menus for UI-Elements.<br />
Each ui-element can get it's own context menu. And you don't need to worry about positioning and click management. Just associate a context-menu with a ui-element and ReaGirl does the rest for you.<br />
</li>
<li>File Drop Zones<br />
Each ui-element can have a file-drop zone so you can easily drag n drop files onto them. And just like context-menus, you don't need to place or manage anything. Just add it to a ui-element and ReaGirl does the rest.<br />
</li>
<li>AutoScaling<br />
ReaGirl scales the gui automatically. So if you change the scaling-factor in Reaper's preferences or use a gui on HiDPI/Retina-displays, ReaGirl scales properly for you.<br />
* Linking of UI-Elements to states<br />
Many of the ui-elements can be linked to toggle-states, extstates, ini-file-entries and config-variables<br />
</li>
<li>Screen Reader Support<br />
Blind people can navigate through your gui via keyboard and get feedback to their screen readers, which reads to them the currently selected ui-element and the chosen setting. ReaGirl does it all for you.</li>
</ul>
<p>So if you want to make easy guis that are also useable by blind users of your scripts, ReaGirl is there for you and tries to manage everthing you need.</p>
<p>There's also an official support thread for ReaGirl in the Reaper-forum at:<br />
<a href="https://forum.cockos.com/showthread.php?t=291220">https://forum.cockos.com/showthread.php?t=291220</a></p>
<p>So if you find bugs or need help in general, head over there and ask your questions.</p>
<p>But there's one question left now:<br />
"How do I start?" you may ask?</p>
<p>Well, let's dive into ReaGirl in the next chapters.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Introduction_002_Installation"></a>
<a href="#Introduction_002_Installation"> ^</a> <u><b>Installation</b></u><br>			<p>
<div class="ch">
<p>Since ReaGirl is part of Ultraschall-API, the installation-instructions from Ultraschall-API are applicable here as well.</p>
<p>First make sure, you use the right versions of Reaper, SWS and JS-extension:<br />
<a href="https://www.reaper.fm">Reaper 7.03 and higher</a>, <a href="https://www.sws-extension.org">SWS 2.10.0.1 and higher</a> and <a href="https://github.com/juliansader/ReaExtensions/tree/master/js_ReaScriptAPI/">Julian Sader's plugin 1.215 and higher.</a><br />
You can download them at <a href="http://www.reaper.fm">reaper.fm</a> and <a href="http://www.sws-extension.org">sws-extension.org</a> respectively.<br />
Julian Sader's plugin can be installed using ReaPack or gotten from <a href="https://github.com/juliansader/ReaExtensions/tree/master/js_ReaScriptAPI/">his own github-site</a></p>
<p>The screen reader compatbility needs at least Windows 10 or Mac OS. It's not available on Linux because Linux isn't that accessible for screen reader users to begin with.</p>
<p>To install Ultraschall-API with ReaGirl, just follow the following steps:</p>
<p><strong>Installation via ReaPack</strong>:</p>
<p>The easiest way is to install Ultraschall-API and ReaGirl using ReaPack. ReaPack is a package-manager for extensions and helper-stuff for Reaper, which allows you to easily install and update content done by the Reaper community.<br />
Many Scripts, Themes, JSFX-FX, etc are available through that.</p>
<ol>
<li><p>Install ReaPack. Get it from <a href="https://reapack.com/">https://reapack.com/</a>. There's also a real good <a href="https://reapack.com/user-guide">User guide</a> for it available, that explains, how to do it.<br />
Copy the downloaded dll(Windows), dylib(Mac) or so(Linux)-file into the UserPlugins-folder in the Resources-folder of Reaper.<br />
You can find the correct Resources-path in the Reaper-menu "Options -&gt; Show REAPER resource path in explorer/finder...".<br />
</p></li>
<li><p>(Re-)Start Reaper<br />
</p></li>
<li><p>Go into the Menu Extensions -&gt; ReaPack -&gt; Manage Repositories<br />
</p></li>
<li><p>Click on Import/export...-button and choose Import repositories<br />
</p></li>
<li><p>Paste into the dialog the following link</p>
<pre><code> https://github.com/Ultraschall/ultraschall-lua-api-for-reaper/raw/master/ultraschall_api_index.xml  </code></pre>
<p>and hit OK.<br />
</p></li>
<li><p>Doubleclick on the Ultraschall-API-entry. A dialog will pop up with a description of the Ultraschall-API and ReaGirl<br />
</p></li>
<li><p>Hit the Install/update Ultraschall-API-button and select Install all packages in this repository<br />
</p></li>
<li><p>ReaPack will ask you, if you want to install new packages/updates the next time you synchronize ReaPack.<br />
Hit Yes.<br />
</p></li>
<li><p>ReaPack installs the Ultraschall-API with ReaGirl. If no error appears, it will tell you to restart Reaper, as a new extension has been installed<br />
</p></li>
<li><p>Restart Reaper.</p></li>
</ol>
<p>To update the Ultraschall-API with ReaGirl in the future, choose in the menu Extensions -&gt; ReaPack -&gt; Synchronize packages. If an update is available, it will install it automatically.<br />
For more information on ReaPack and it's usage, refer <a href="https://reapack.com/user-guide">User guide</a>.</p>
<p><strong>Manual Installation</strong>:</p>
<p>If you can't or don't want to install ReaPack, you can also install it manually.</p>
<ol>
<li>Just download the zip-file of the current version from <a href="https://github.com/Ultraschall/ultraschall-lua-api-for-reaper/raw/master/ultraschall_api5.3.zip">ultraschall_api5.3.zip</a>.<br />
</li>
<li>Extract it to the UserPlugins-folder in the Resources-folder of Reaper. You can find the correct Resources-path in the Reaper-menu "Options -&gt; Show REAPER resource path in explorer/finder...".<br />
The folder UserPlugins should contain the folder ultraschall_api and the files ultraschall_api_readme.txt, ultraschall_api.lua and reagirl.lua after this step.<br />
</li>
<li>Restart Reaper.</li>
</ol>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Introduction_003_Included_Actions"></a>
<a href="#Introduction_003_Included_Actions"> ^</a> <u><b>Included Actions</b></u><br>			<p>
<div class="ch">
<p>ReaGirl provides a variety of actions that go along with it. Some are meant for development, some for the general users, some both.</p>
<p><strong>Development:</strong></p>
<ul>
<li><strong>ReaGirl_Help_Introduction_Concepts_Tutorials_Documentation.lua</strong> - opens this documentation<br />
</li>
<li><strong>ReaGirl_Help_Functions_Documentation.lua</strong> - opens a documentation of all available ReaGirl-functions<br />
</li>
<li><strong>ReaGirl_OpenFolder_ExampleScripts.lua</strong> - opens the example-scripts-folder</li>
</ul>
<p><strong>Settings:</strong></p>
<ul>
<li><strong>ReaGirl_Gui_Settings.lua</strong> - a settings-dialog, with which you can set various things in ReaGirl's behavior. Includes also some settings relevant for development. Some of these settings are also settable via actions.</li>
</ul>
<p><strong>Scaling:</strong></p>
<ul>
<li><strong>ReaGirl_Gui_Settings_Set_Scaling_To_AutoScaling.lua</strong> - sets scaling to auto, to use Reaper's/HiDPI/Retina scaling automatically<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Set_Scaling_To_1.lua</strong> - sets scaling to 1x<br />
</li>
<li>...<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Set_Scaling_To_8.lua</strong> - sets scaling to 2x</li>
</ul>
<p><strong>General user settings:</strong></p>
<ul>
<li><strong>ReaGirl_Gui_Settings_Hovered_UI_Element_Enable_Report.lua</strong> - enables, if hovering above a ui-element will get read the name of it to screen readers<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Hovered_UI_Element_Disable_Report.lua</strong> - disables, that hovered ui-elements get read to screen readers<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Move_Mouse_When_Tabbing_Enable.lua</strong> - enables that mouse moves to tabbed ui-element for screen reader users(helpful for when clicking using context-menus)<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Move_Mouse_When_Tabbing_Disable.lua</strong> - disables mouse-move when tabbing to ui-elements for screen reader users(makes right-clicking for context-menus difficult)<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Helpmessage_Enable.lua</strong> - enables that screen reader-users get an additional help-message on how to use ui-elements<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Helpmessage_Disable.lua</strong> - disables help-message on how to use ui-elements<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Messages_Enable.lua</strong> - enable screen reader-support in ReaGirl<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Messages_Disable.lua</strong> - disable screen reader-support in ReaGirl<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Tooltips_Enable.lua</strong> - shows tooltips when hovering above ui-elements<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Tooltips_Disable.lua</strong>- don't show tooltips<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Scroll_Via_Keyboard_Enable.lua</strong> - enables scrolling of ReaGirl-guis via keyboard</li>
<li><strong>ReaGirl_Gui_Settings_Scroll_Via_Keyboard_Disable.lua</strong> - disables scrolling of ReaGirl-guis via keyboard</li>
<li><strong>ReaGirl_Gui_Settings_Reset_Settings_Window_Pos_And_Size.lua</strong> - resets settings window's position and size</li>
</ul>
<p><strong>Developer settings:</strong></p>
<ul>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Messages_Show_In_Console.lua</strong> - show screen reader-messages in ReaScript console-window. Helps you debugging meaninOfUI_Element for blind people.<br />
</li>
<li><strong>ReaGirl_Gui_Settings_Screen_Reader_Messages_Hide_From_Console.lua</strong> - don't show screen reader-messages in the console</li>
</ul>
<p><strong>Experimental Edit Mode:</strong></p>
<ul>
<li><strong>ReaGirl_Gui_Settings_EditMode_Enable.lua</strong> - will enable experimental edit-mode. This will allow you to drag around ui-elements in a ReaGirl-gui, show a grid by typing g, double-click to edit caption, etc<br />
</li>
<li><strong>ReaGirl_Gui_Settings_EditMode_Disable.lua</strong> - disable experimental edit-mode</li>
</ul>
<p>You'll probably won't need many of them, especially when developing new guis with ReaGirl and if you are not a screen reader-user, but it's probably good to know that these exists, if you need to provide support for users of your ReaGirl-gui-script.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_000_Introduction"></a>
<a href="#Tutorial_000_Introduction"> ^</a> <u><b>Tutorial Introduction</b></u><br>			<p>
<div class="ch">
<p>In the next few chapters, I will show you a lot of the available concepts and features of ReaGirl through various tutorials.</p>
<p>I added ready to use code-snippets and I tried to add screenshots wherever possible.</p>
<p>If for some reason or another you might not be able to copy the code-snippets from the documentation, you can also<br />
find them as lua-script-examples. Just run the action "ReaGirl_OpenFolder_ExampleScripts.lua" which will open the<br />
examples folder of ReaGirl. In the folders named tutorial, you find the codes used in the tutorials as ready to use lua-files.<br />
The last lua-file in each tutorial-folder is the finished tutorial-example, if you want to jump ahead.</p>
<p>The documentation is available with the actions "ReaGirl_Help_Introduction_Concepts_Tutorials_Documentation.lua" for the explanation chapters and "ReaGirl_Help_Functions_Documentation.lua" for the function's reference.</p>
<p>At the end of this document, you'll also find two chapters on best practices for accessible guis with ReaGirl.<br />
I recomment you to read these to improve accessibility on your guis with a handful of rules of thumb.<br />
<a href="#Best_Practices_On_Accessibility">Best Practices on Accessibility</a> and <a href="#Best_Practices_On_Writing_Guis_As_Blind_Scripter">Best Practices on ReaGirl-Guis for blind scripters</a>.<br />
I will update them from time to time so check them out occasionally for more practices from feedback by users of ReaGirl.</p>
<p>And now, without much further ado, let's head over to the tutorials.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Introduction_001_First_Steps"></a>
<a href="#Introduction_001_First_Steps"> ^</a> <u><b>First steps in ReaGirl</b></u><br>			<p>
<div class="ch">
<p>When making a gui in ReaGirl, you basically have to work through 5 steps.</p>
<p>0) Initialize ReaGirl<br />
1) Add some run-functions<br />
2) Start a new gui using reagirl.Gui_New()<br />
3) Add some ui-elements using the various _Add-functions<br />
4) Open a gui using reagirl.Gui_Open()<br />
5) Write and run a defer-function, in which you call reagirl.Gui_Manage()</p>
<p>Let's get into these steps in more details.</p>
<h4>Step 0: Initialize ReaGirl</h4>
<p>First add the line</p>
<p><code>dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")</code></p>
<p>to your script. It will load all functions and features of ReaGirl. After that, you can start writing your guis with it.<br />
It would also be a good idea to check here, if the installed ReaGirl-version is the one your script is requiring.<br />
For this you can use reagirl.GetVersion() and warn the user, if the installed version is too old.</p>
<h4>Step 1: Add some run-functions</h4>
<p>Run-Functions are functions that are run, when the user interacts with a user-interface-element(ui-element). For instance, clicking a checkbox or a button.<br />
Or typing/hitting enter into an inputbox. Or if the user moves the slider or selects a menu in a drop-down-menu.<br />
Or if the user selects a context-menu-entry or drag n drops files onto a ui-element.<br />
So in a run function you tell Reaper what to do, after the user interacted with a ui element.</p>
<p>A rule of thumb is: every ui-element and interaction-style gets it's own run-function.<br />
So one for when the user hits the button. One for when the user toggles a checkbox. One for when the user types text into an inputbox and one for when the user hits enter into the inputbox, etc, etc.<br />
These run-functions will get parameters passed from the gui, like the identifier of a ui-element(more on this later) or additional information like a selected menu-entry.<br />
So run-functions are powerful and will make the magic happen, once the user interacted with a ui-element.</p>
<p>When writing a new gui, you can just write some "empty" functions that do nothing. We'll fill them in later.<br />
More on run-functions in our tutorials.</p>
<h4>Step 2: Start a new gui using reagirl.Gui_New()</h4>
<p>This will tell ReaGirl, that you want to start a new gui. And it's simple, just add reagirl.Gui_New() to your script and you're done.<br />
You can also use this later in more complex scripts to throw away an already existing gui and start a new one, but in most cases, you'll only do this once at the beginning of your gui-script.</p>
<h4>Step 3: Add some ui-elements using the various _Add-functions</h4>
<p>Now the magic starts, we add our first ui-elements. You do it using the various _Add-functions like Button_Add, InputBox_Add, DropDownMenu_Add, Slider_Add, Checkbox_Add, Label_Add, Image_Add, etc.<br />
All these add-functions will ask you for the position of the ui-element, a caption(which is usually shown next to it), an accessibility-hint which is shown as tooltip and also helps blind users to navigate and understand your gui, and a run-function.<br />
Some may ask you for more things like width and height(Images) or initial values(Checkboxes, Sliders, DropDownMenu) or even additional run-functions(InputBox uses one run-function when the user types text and one for when the user hits enter in the inputbox).</p>
<p>All _Add-functions return a string called element_id. This element_id is like a unique name for your ui-element.<br />
You can use this to do additional things with the ui-element. For instance, you can make the edges of a button more round or more edgier using the reagirl-Button_SetRadius()-function.<br />
The function needs this element_id to know, of which button you want to edit the edges and alter it accordingly.<br />
If you remember what I told you about run-functions, then you'll know already that element_ids are also passed to a run-function by ReaGirl.<br />
So you can use one run-function for all buttons. You just check, whether the element_id passed to the run-function is the same as the element_id of button1, button2 or button3.<br />
So keep these element_ids in variables or tables, as you can do really nice things with it(we'll dive deeper into element_ids in the tutorials).</p>
<p>You can add up to several thousand ui-elements in your gui(though usually, you will do much less).</p>
<h4>Step 4: Open a gui using reagirl.Gui_Open()</h4>
<p>This will open the gui. You can pass to it the position, the dimensions, the window-title, an accessibility-hint which tells the blind user what to expect from your gui and so on.<br />
It's pretty straightforward, so just follow the documentation for what the parameters shall be.</p>
<h4>Step 5: Write and run a defer-function, in which you call reagirl.Gui_Manage()</h4>
<p>This one's also very easy. Add the following lines at the end of your script:</p>
<pre><code>  function main()  
    -- let ReaGirl manage the gui  
    reagirl.Gui_Manage()  
      
    -- check, if the gui-window is still open and if not, stop the script  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>This will run the Gui_Manage-function, which basically does all the management of the gui, like drawing, click-management, runnning the run-functions when the user interacts with a ui-element, scrolling and other cool stuff, so you don't have to do it yourself.<br />
And that's it, 5 steps to make your own gui.</p>
<p>Some general things to know about ReaGirl:<br />
Don't bother with scrolling your ui-elements. This is done by ReaGirl. So if a ui-element is outside of the window, scrollbars appear and you can scroll around with them or by swiping or by keyboard(basically like you do in web-browsers).</p>
<p>Also don't bother about scaling like Retina/HiDPI or something. This is also done by ReaGirl automatically. So if the user chooses to run your script on Retina/HiDPI-displays or even with an altered scaling set in the preferences, your gui will change automatically.</p>
<p>Since one of the key-features in ReaGirl is accessibility for blind people, most of the stuff needed for screen reader-management is done by ReaGirl itself. You just need to set the parameters meaningOfUI_Element properly by giving a short and precise explanation, what the ui-element is doing and why. This will be shown as tooltip and also communicated to blind users via screen reader. This happens automatically, so you don't need to do much more.<br />
There's a chapter dedicated on best practices for accessible guis later, if you want to improve on things further.</p>
<p>In the next chapters, I will take you through some basic tutorials on how making a gui is done in practice.<br />
And we'll start with a basic one.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_001_A_Basic_Gui"></a>
<a href="#Tutorial_001_A_Basic_Gui"> ^</a> <u><b>Tutorial 001: A Basic Gui</b></u><br>			<p>
<div class="ch">
<p>In this tutorial, I will show you how to make a basic gui with some buttons, inputboxes and checkboxes. I will also explain to you the basic concepts in practice that you need to know to make guis with ReaGirl.<br />
Stick with me, it's easier than you think.</p>
<p>Let's start with a basic gui, which will show one single button.</p>
<p><img src="gfx/Tutorial1_1.png" title="Screenshot of the gui-window with one ok-button." alt="Screenshot of the gui-window with one ok-button." /></p>
<pre><code>  -- Step 0: initialize ReaGirl  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- Step 1: write the run-functions  
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    reaper.MB(&quot;Button has been pressed&quot;, &quot;Pressed&quot;, 0)  
  end  

  -- Step 2: create new gui  
  reagirl.Gui_New()  
    
  -- Step 3: add the ui-elements to the gui  
  -- add an ok-button to the gui at x-position 30 and y-position 200 with the run-function Button_RunFunction  
  -- The meaningOfUI_Element-parameter &quot;Apply changes and close dialog&quot; will be shown as tooltip   
  -- and sent to a screen reader for blind people.  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
    
  -- Step 4: open the new gui with size 640x250 pixels, titled &quot;The dialog&quot;.   
  -- In addition to the title, blind people will also get &quot;This is a demo dialog with settings for tool xyz.&quot;   
  -- sent to their screen readers.  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  -- Step 5: Write and run a defer-function, in which you call reagirl.Gui_Manage()  
  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You see the 5 steps I mentioned in the first steps-chapter detailed out in this script.</p>
<p>This script adds a button and the run-function Button_RunFunction which is run when the user hits the button.<br />
Also note the parameter meaningOfUI_Element, which is set to "Apply changes and close dialog". This parameter will be shown as a tooltip. It will also tell blind users, what the ui-element is supposed to do and why via screen reader. So if you add your own ui-elements, add a short and descriptive explanation into this parameter which says more than just "ok". Blind users will thank you for that.</p>
<p>And that's it, a simple gui with one button. Try it and experiment with it. Write a different text into the button. Alter the numbers in the parameters of reagirl.Button_Add to see what happens.<br />
Don't worry about making mistakes. When you pass wrong parameters to ReaGirl-functions, they will tell you with an error message, what went wrong and where.</p>
<p>One thing you'll note in the code is that reagirl.Button_Add() returns the element_id as a returnvalue that I put into the variable button_ok_id. We will use this later on.</p>
<p>As a sidenote: ReaGirl stores in the background the position, size and dockstate of the window, so you can reopen it the next time with the old position, size and dockstate.<br />
This will be done by the first two parameters of reagirl.Gui_New(). The first parameter is a name for your window that should be a unique one like "Mespotine_My gui Window", which will be used by ReaGirl as a settings name to store position, size and dockstate in the background.<br />
The second parameter sets, if the window shall be reopened with the old position, size and dockstate. Set it to false to open always with the position you give in reagirl.Gui_Open() or set it to true to reopen it with the old position, size and dockstate.<br />
Try it. Set the second parameter in reagirl.Gui_Open() to true and run the script. Move it, resize it and then close it. When you run the script again, the window reopens at the position where you closed it.<br />
In the tutorials, we will set the second parameter to false so the examples always behave the same. But in your scripts, you can do what works best for you.</p>
<p>Ok, now that you fiddled around with the example, how about adding a second button?<br />
For this, we add a second Button_Add-function for a Cancel-button. We'll also give it the same run-function like the first button. The returned element_id of the cancel-button we put into the variable button_cancel_id.<br />
It's looks like the following.</p>
<p><img src="gfx/Tutorial1_2.png" title="Screenshot of the gui-window with one ok-button and one cancel-button." alt="Screenshot of the gui-window with one ok-button and one cancel-button." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  
  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You'll also notice, that I altered the run-function Button_RunFunction. I mentioned in the first steps chapter, that the run-function gets passed over several parameters, with the first one being the element_id of the button that got pressed.<br />
In our example, the function Button_RunFunction has a parameter pressed_button_id into which ReaGirl will tell you, which button that uses this run-function got pressed.</p>
<p>You remember, that both added buttons share the same run-function.</p>
<p>And that's the reason, why the variables button_ok_id and button_cancel_id come in handy, because you can use them now to check, if pressed_button_id==button_ok_id(the ok-button got pressed) or elseif pressed_button_id==button_cancel_id(the cancel button got pressed).<br />
In this code, we will show a message-box that tells you, which one has been pressed.<br />
This way, all buttons can share the same run-function, as you can compare the element_ids of each button with the parameter pressed_button_id.</p>
<p>As a little excercise, add another button called "Help". Put its return-value into the variable button_help_id and add to the run-function a help-message shown, when the help button is pressed.<br />
It'll help you internalising how the mechanics work and will help you further down the road with more complex guis.</p>
<p>Now that we have two buttons, we could add another ui-element. This time it's checkboxes.<br />
You know the drill: Checkbox_Add adds checkboxes into the next script. The Checkbox_Add-functions return the element_ids which will be put into the variables checkbox_remember and checkbox_mysetting.<br />
We also add a run-function for it called Checkbox_RunFunction, which will pop up a dialog when one of the checkboxes is checked. It'll tell you which one it will be with the help of the element_ids, just like we did with the buttons.</p>
<p><img src="gfx/Tutorial1_3.png" title="Screenshot of the gui-window with two buttons and two checkboxes as examples." alt="Screenshot of the gui-window with two buttons and two checkboxes as examples." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>One thing that's different from before is, that the run-function for the checkboxes Checkbox_RunFunction gets now two parameters, whereas the one for the buttons only got one.<br />
The parameters are:</p>
<ol>
<li>the element_id of the clicked checkbox(like it was in the button's run-function) AND<br />
</li>
<li>a parameter for the current checkstate after clicking the checkbox.</li>
</ol>
<p>So a run-function for checkboxes gets the element_id and the state of the checkbox after it was clicked. That way you know, how the checkbox-state currently is.<br />
You can then use it for things like storing settings in the background: when the checkbox is checked you store "true" and when the checkbox is unchecked you store "false".<br />
And since you can check against the individual element_ids of the checkboxes, you know, which one got clicked and therefore must be stored.</p>
<p>The different parameters of the run-functions is also the reason, why you cannot use the same run-function for all types of ui-elements, as different ui-elements pass over different parameters to the run-function.<br />
This could confuse your code. It's possible to code around this but I highly recommend to only use one run-function for all buttons and one for all checkboxes and one for all sliders, etc.</p>
<p>Although you can do one run-function for each ui-element, which is perfectly fine.</p>
<p>Back to our example.</p>
<p>We have now two checkboxes and two buttons. Let's add another type of ui-elements: InputBoxes.<br />
InputBoxes allow to type in text into your gui. They are added basically like all other ui-elements: InputBox_Add and two run-functions.</p>
<p>Two run-functions?</p>
<p>Yes, InputBoxes allow to have two run-functions. One is called everytime the user enters a character into the inputbox while the other one is called when the user hits enter into the inputbox.<br />
Let's add two inputboxes with the two run-functions(InputBox_RunFunction_Type for when the user types text, InputBox_RunFunction_Enter when the user hits enter into the inputbox).</p>
<p><img src="gfx/Tutorial1_4.png" title="Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes as examples." alt="Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes as examples." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;My Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  
    </code></pre>
<p>If you run this script, you can click into the inputbox and enter text. The entered text will be shown in the debugging-window "ReaScript Console" of Reaper.<br />
This outputting is done by the run-function InputBox_RunFunction_Type. When you hit enter, a message-box appears which shows you the entered text. This is done by the run-function InputBox_RunFunction_Enter.<br />
Both run-functions get as parameters the element_id(inputbox_id) as well as the entered text(entered_text).</p>
<p>Ok, now we have two buttons, two checkboxes and two inputboxes, all doing stuff when clicking/typing.</p>
<p>I would like to introduce you to another ui-element, the label element. This allows you to show some text.<br />
It's working the same: Label_Add adds a label. This could potentially be made clickable which would mean, we need a run-function as well, but right now we just make it a regular label that just shows text.<br />
Therefore the last parameter for the run-function is nil(which means, no run-function available for this ui-element).<br />
I would also like to show you something else that you can do with the element_id: setting additional attributes for a ui-element.<br />
In this case, we want to make the font-size of the label bigger and set it's style to underlined.<br />
For this, we use the functions Label_SetFontSize and Label_SetStyle.</p>
<p><img src="gfx/Tutorial1_5.png" title="Screenshot of the gui-window with two buttons, two checkboxes, two inputboxes and a label text." alt="Screenshot of the gui-window with two buttons, two checkboxes, two inputboxes and a label text." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)    

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Running this code will add the text "This is a settings dialog" to the gui in font-size 40 and underlined.<br />
You'll notice that Label_SetFontSize and Label_SetStyle are using the element_id stored in the variable label_header to adress, which label shall be altered.<br />
Another use-case for element_ids.<br />
This is how you can actually change other ui-elements too. For buttons for instance, just look up all functionnames starting with reagirl.Button_ in the <a href="ReaGirl_Functions.html#Button">functions list</a> to find lots of functions to alter buttons. They'll expect the element_id of the button that you want to alter.<br />
The same goes for reagirl.InputBox_, reagirl.Slider_, reagirl.DropDownMenu_\, reagirl.Label_, reagirl.Checkbox_, reagirl.Tabs_, etc.</p>
<p>Speaking of altering buttons: let's make the OK-button more round and the Cancel-button more edgier.<br />
For this, we use the function reagirl.Button_SetRadius in the following code, which allows us to set the radius of the edges.</p>
<p><img src="gfx/Tutorial1_6.png" title="Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text." alt="Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  


  -- create new gui  
  reagirl.Gui_New()  

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  
    </code></pre>
<p>You see, it's working the same: you give the reagirl.Button_SetRadius-function the element_id of the button that you want to alter.</p>
<p>What's now bothering me, is the black background, which looks a little bleak in my eyes, so let's change it using reagirl.Background_GetSetColor.<br />
This function accepts four parameters, with the first one setting if you want to set the background or get its colors and the other three the red, green and blue-color values from 0-255.<br />
I'll choose to set it(true) to a grey tone(55).</p>
<p><img src="gfx/Tutorial1_8.png" title="Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text. The window has a grey background, now." alt="Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text. The window has a grey background now." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  


  -- create new gui  
  reagirl.Gui_New()  

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Ahh, that's better. Of course, you can choose a different color. Just experiment with it.</p>
<p>And while we are at making things prettier, let's add one last ui-element, an image.<br />
Reaper deploys several images for track-icons so let's choose one of them to display here, one of a bass-guitar.<br />
This time, though, I would like to anchor the image to the right and bottom side of the window. ReaGirl supports anchoring ui-elements to the right-side/bottom of the window.<br />
To achieve this, just make the x/y-coordinate negative. In the case of our image, I choose to make the image 150 pixels from the right side of the window(-150) and 120 pixels from the bottom(-120).</p>
<p><img src="gfx/Tutorial1_8.gif" title="Gif of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes, a label text and an image of a bass guitar, linked to the bottom and right edge of the window." alt="Gif of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes, a label text and an image of a bass guitar, linked to the bottom and right edge of the window." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  


  -- create new gui  
  reagirl.Gui_New()    

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  

  -- add an image of a bass guitar  
  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;A Bass guitar&quot;, &quot;An image of a bass guitar.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Hmmm, nice bass guitar, Davie. And when you resize the window, you'll notice, that it'll stay linked to the right and bottom side of the window.<br />
You can also link other ui-elements that way or even just link width and height of a ui-element to it(if a ui-element has width and height). Works the same: make the coordinate negative.<br />
Let's link the width of the first inputbox to the right-side of the window(-50) to see how that looks.</p>
<p><img src="gfx/Tutorial1_9.gif" title="Gif showing, that one of the inputboxe&#39;s length is linked to right window-edge." alt="Gif showing, that one of the inputboxe&#39;s length is linked to right window-edge." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()    

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, -50, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  

  -- add an image of a bass guitar  
  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;A Bass guitar&quot;, &quot;An image of a bass guitar.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  
    </code></pre>
<p>Looking good. This way, the user can choose, how long the visible inputbox shall be.<br />
Images support this as well, so you can experiment by making x and y linked to the left/top of the window(positive value) and link width and height to the right/bottom of the window(negative value).<br />
That way, the size of the image changes the way the window is resized. You can also use reagirl.Image_KeepAspectRatio() to keep the image from looking stretched(more on this in tutorial #3: "a basic image viewer with a drag'n'drop-zone and a context menu").</p>
<p>When resizing the window to make it smaller, you probably noticed already, that the image is moving behind the inputboxes at some point. It would be nice to have a way to prevent that.<br />
There's a way. The functions reagirl.Window_ForceSize_Minimum() and reagirl.Window_ForceSize_Maximum() set a minimum and maximum window-size. So the user cannot resize it bigger or smaller than that.<br />
Let's add them into our gui and set some reasonable boundaries.</p>
<p><img src="gfx/Tutorial1_10.gif" title="Gif of the gui-window that shows, that resizing the window can&#39;t be done below or beyond a certain size." alt="Gif of the gui-window that shows, that resizing the window can&#39;t be done below or beyond a certain size." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  


  -- create new gui  
  reagirl.Gui_New()  

  -- add a textlabel to the top of the gui  
  label_header=reagirl.Label_Add(30, 50, &quot;This is a settings dialog&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, -50, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  

  -- add an image of a bass guitar  
  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;A Bass guitar&quot;, &quot;An image of a bass guitar.&quot;, nil)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 250) -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(800, 400) -- set the maximum size of the window  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you try to resize the window now, it will remain within the chosen constraints, not bigger and not smaller, only inbetweens.<br />
And so we're done. Our first basic gui with a lot of ui-elements and features applied.</p>
<p>A sidenote: when you read the functions-reference, you'll notice that the add-functions also have an optional parameter "unique_identifier". This is a unique name for your ui-element. Set this to a name that you only use once in your gui. This can be used by users to control your gui-script from the outside with additional functions(more about it in a later tutorial) and will be a major part for when I add localization-features for ReaGirl-scripts. So give every ui-element such a unique identifier-name, this will allow cool things in the future.</p>
<p>Alright, our first gui. We can be proud of it. Fiddle and toy around with it to get a deeper grip on how the basic concepts work.</p>
<p>And when you are ready, you can move on to tutorial #2, which shows you, how to add tabs to this gui.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_002_Adding_Tabs_to_a_Gui"></a>
<a href="#Tutorial_002_Adding_Tabs_to_a_Gui"> ^</a> <u><b>Tutorial 002: Adding Tabs to a Gui</b></u><br>			<p>
<div class="ch">
<p>In the first tutorial, we made a basic gui with some ui-elements. In this tutorial we want to add tabs and put the ui-elements into the individual tabs.<br />
The first tab gets all inputboxes, the second tab all checkboxes and the third tab all buttons.<br />
I removed the label and the image from the gui in this tutorial to make it a little simpler.<br />
Our initial gui looks this way, now:</p>
<p><img src="gfx/Tutorial2_1.png" title="Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes." alt="Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add inputboxes to type in text  
  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>The first thing we will do is to create three tables, in which we will store the element_ids of the gui-elements.<br />
Each table represents a tab, means: tab1 contains all element_ids of the ui-elements of tab 1, tab2 all element_ids of the ui-elements of tab 2 and tab3 all of tab 3.</p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add tables that will contain the element-ids of the ui-element  
  tab1={} -- for the ui-elements in tab 1  
  tab2={} -- for the ui-elements in tab 2  
  tab3={} -- for the ui-elements in tab 3  
    
  -- add inputboxes to type in text  
  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You'll notice that we added three tables, tab1, tab2 and tab3. You'll also notice, that we put the element_ids returned by the _Add-functions into these tabs, for instance :</p>
<p><code>inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)</code></p>
<p>became</p>
<p><code>tab1.inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)</code></p>
<p>means, we added <strong>tab1.</strong> in front of the variable-name, so it's now associated with the table that stores the gui-elements of the first tab.</p>
<p>All Inputbox_Add add to tab1, all Checkbox_Add add to tab2 and all Button_Add add to tab3. That way we have one table for each tab with all ui-elements that shall be in that tab.<br />
Now, let's add the tabs-ui-element to the gui using the function reagirl.Tabs_Add(). We also add a run-function for tabs called Tab_RunFunction.</p>
<p><img src="gfx/Tutorial2_3.gif" title="Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which triggers a dialog that says the name of the tab." alt="Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which triggers a dialog that says the name of the tab." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  
    
    
  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
    -- this function is run, when tabs are switched  
    reaper.MB(&quot;Tab #&quot;..tab_selected..&quot; with name &quot;..tab_name_selected..&quot; is selected.&quot;, &quot;Tabs&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add tables that will contain the element-ids of the ui-element  
  tab1={} -- for the ui-elements in tab 1  
  tab2={} -- for the ui-elements in tab 2  
  tab3={} -- for the ui-elements in tab 3  
    
  -- let&#39;s add tabs  
  reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Inputboxes&quot;, &quot;Checkboxes&quot;, &quot;Buttons&quot;}, 1, Tab_RunFunction)  
    
  -- add inputboxes to type in text  
  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  

  -- add two checkboxes to the gui  
  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>If you run this example, you'll have tabs. Click on them and the run-function will show a dialog with the selected tab number and its name.<br />
Tabs can have a background drawn, which I set here to 620x187 pixels. You can alter them or make them linked to the right/bottom of the window by making them negative.<br />
You can also pass nil instead of numbers. This will make the background enclose all ui-elements automatically. If you don't want a background, pass 0 as background-width and height.<br />
Toy around with it to get an idea.</p>
<p>This dialog still shows all ui-elements in all tabs, so let's alter the tabs-run-function to show only all ui-elements associated with a certain tab.<br />
To achieve this, we use the function reagirl.Tabs_SetUIElementsForTab(), which allows us to link element_ids stored in a table with a certain tab.<br />
Now, tab1, tab2 and tab3 come in handy. We associated the ui-elements of tab1 with the first table(1), the one of tab2 with the second(2) and the one from tab3 with the third(3).<br />
Here's how it looks like with reagirl.Tabs_SetUIElementsForTab()</p>
<p><img src="gfx/Tutorial2_4.gif" title="Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which shows now only the ui-elements associated with a certain tab." alt="Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which shows now only the ui-elements associated with a certain tab." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  
    
    
  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
    -- this function is run, when tabs are switched  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add tables that will contain the element-ids of the ui-element  
  tab1={} -- for the ui-elements in tab 1  
  tab2={} -- for the ui-elements in tab 2  
  tab3={} -- for the ui-elements in tab 3  
    
  -- let&#39;s add tabs  
  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Inputboxes&quot;, &quot;Checkboxes&quot;, &quot;Buttons&quot;}, 1, Tab_RunFunction)  
    
  -- add inputboxes to type in text  
  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
    
  -- add two checkboxes to the gui  
  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
    
  -- set ui-elements to the tabs.   
  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
  -- and give tab 3 the ones stored in tab3.  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Now we're talking! If we switch the tabs, now, it will show all correct ui-elements: tab 1 all inputboxes, tab 2 all checkboxes and tab 3 all buttons.<br />
We're almost done.<br />
You remember from the first tutorial, that interacting with the user elements was showing dialogs. For instance, clicking the OK-button shows a dialog saying "OK button is pressed".<br />
But when you click it now, it does nothing.<br />
This is because our run-functions still use the old variables that used to store the element_ids but they are stored in the tables tab1, tab2 and tab3, now.<br />
So let's alter the run-functions to check not for i.e. pressed_button_id==button_ok_id but pressed_button_id==tab3.button_ok_id and so on.<br />
Here's how the run-functions look like, when they check against the table-entries of the ui-elements:</p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==tab3.button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==tab3.button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==tab2.checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==tab2.checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==tab1.inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==tab1.inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==tab1.inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==tab1.inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  
    
    
  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
    -- this function is run, when tabs are switched  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add tables that will contain the element-ids of the ui-element  
  tab1={} -- for the ui-elements in tab 1  
  tab2={} -- for the ui-elements in tab 2  
  tab3={} -- for the ui-elements in tab 3  
    
  -- let&#39;s add tabs  
  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Inputboxes&quot;, &quot;Checkboxes&quot;, &quot;Buttons&quot;}, 1, Tab_RunFunction)  
    
  -- add inputboxes to type in text  
  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
    
  -- add two checkboxes to the gui  
  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
    
  -- set ui-elements to the tabs.   
  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
  -- and give tab 3 the ones stored in tab3.  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Now the code works exactly as intended. Tab 1 shows all ui-elements of tab1, tab 2 shows all ui-elements of tab2, tab 3 shows all ui-elements of tab3.<br />
Plus: interacting with all ui-elements works properly now.</p>
<p>There's one final thing: what if I want to have buttons shown all the time, like apply and close-buttons or additional checkboxes?<br />
It's simple: add them BUT don't add their ids to tab1, tab2 or tab3:</p>
<p><img src="gfx/Tutorial2_6.gif" title="Gif of the gui-window with tabs which consists of two inputboxes. Under the tabs-area are now two buttons and a checkbox, that are always visible when changing tabs." alt="Gif of the gui-window with tabs which consists of two inputboxes. Under the tabs-area are now two buttons and a checkbox, that are always visible when changing tabs." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction(pressed_button_id)  
    -- this function is run, when a button is pressed  
    if pressed_button_id==tab3.button_ok_id then  
      reaper.MB(&quot;OK Button is pressed&quot;, &quot;OK Button&quot;, 0)  
    elseif pressed_button_id==tab3.button_cancel_id then  
      reaper.MB(&quot;Cancel Button is pressed&quot;, &quot;Cancel Button&quot;, 0)  
    elseif pressed_button_id==apply_button then  
      reaper.MB(&quot;Apply Button is pressed&quot;, &quot;Apply Button&quot;, 0)  
    elseif pressed_button_id==close_button then  
      reaper.MB(&quot;Close Button is pressed&quot;, &quot;Close Button&quot;, 0)  
    end  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==tab2.checkbox_remember then  
      reaper.MB(&quot;Checkbox \&quot;Remember\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==tab2.checkbox_mysetting then  
      reaper.MB(&quot;Checkbox \&quot;my Setting\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    elseif checked_checkbox_id==global_checkbox then  
      reaper.MB(&quot;Checkbox \&quot;Apply only to project\&quot; is &quot;..tostring(checkstate), &quot;Checkbox-State changed&quot;, 0)  
    end  
  end  

  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
    -- this function is run, when the user types in text into an inputbox  
    reaper.ClearConsole()  
    if inputbox_id==tab1.inputbox_name_of_setting then  
      reaper.ShowConsoleMsg(&quot;NAME: &quot;..entered_text)  
    elseif inputbox_id==tab1.inputbox_description_of_setting then  
      reaper.ShowConsoleMsg(&quot;DESCRIPTION: &quot;..entered_text)  
    end  
  end  

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
    -- this function is run, when the user hits enter into an inputbox  
    if inputbox_id==tab1.inputbox_name_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into NAME was&quot;, 0)  
    elseif inputbox_id==tab1.inputbox_description_of_setting then  
      reaper.MB(entered_text, &quot;The typed text into DESCRIPTION was&quot;, 0)  
    end  
  end  
    
    
  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
    -- this function is run, when tabs are switched  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add tables that will contain the element-ids of the ui-element  
  tab1={} -- for the ui-elements in tab 1  
  tab2={} -- for the ui-elements in tab 2  
  tab3={} -- for the ui-elements in tab 3  
    
  -- let&#39;s add tabs  
  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Inputboxes&quot;, &quot;Checkboxes&quot;, &quot;Buttons&quot;}, 1, Tab_RunFunction)  
    
  -- add inputboxes to type in text  
  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, &quot;Name of the setting:&quot;, 150, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, &quot;Description of the setting:&quot;, 150, &quot;Type in here a description of the setting.&quot;, &quot;No Description&quot;, InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
    
  -- add two checkboxes to the gui  
  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, &quot;My setting&quot;, &quot;How shall my setting be set?&quot;, true, Checkbox_RunFunction)  
  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, Checkbox_RunFunction)  

  -- add an ok-button and a cancel button to the gui  
  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, Button_RunFunction)  
  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, Button_RunFunction)  

  -- add a &quot;global&quot; checkbox, as well as an apply-button and close-button to the gui  
  global_checkbox = reagirl.Checkbox_Add(10, 225, &quot;Apply only to project&quot;, &quot;Shall these settings be applied only to a project?&quot;, true, Checkbox_RunFunction)  
  apply_button = reagirl.Button_Add(532, 225, 0, 0, &quot;Apply&quot;, &quot;Apply changes.&quot;, Button_RunFunction)  
  close_button = reagirl.Button_Add(582, 225, 0, 0, &quot;Close&quot;, &quot;Close dialog.&quot;, Button_RunFunction)  

  -- let&#39;s force window-sizes  
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
    
  -- set ui-elements to the tabs.   
  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
  -- and give tab 3 the ones stored in tab3.  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with some options.&quot;, 640, 250)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run this script, a checkbox and two buttons are added to the bottom of the window. And you can switch tabs, they will always be visible.<br />
And all we did was adding a checkbox and two more buttons, whose ids are stored into apply_button, close_button and global_checkbox and not in tab1 or tab2 or tab3.<br />
We also altered the run-functions Button_RunFunction and Checkbox_RunFunction so clicking these ui-elements will also show a dialog.</p>
<p>If you want, you can place the ui-elements properly into the upper part of the each tab as an excercise.</p>
<p>Now you know everything you need to make guis with tabs in ReaGirl.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_003_A_Basic_Image_Viewer"></a>
<a href="#Tutorial_003_A_Basic_Image_Viewer"> ^</a> <u><b>Tutorial 003: A Basic Image Viewer with a file-drop-zone and a context menu</b></u><br>			<p>
<div class="ch">
<p>In this tutorial, I will show you a basic image viewer. I will also show you, how to add a drag'n'drop-zone to this image as well as a context menu.<br />
And as a cherry on the top, we will make clicking the image setting the loaded image as track icon for the first track in the current project.<br />
So let's get it on.</p>
<p>Let's start with basic code, which will show one of Reaper's images, a bass guitar, in a window.</p>
<p><img src="gfx/Tutorial3_1.png" title="Screenshot of the gui-window with an image of a bass guitar." alt="Screenshot of the gui-window with an image of a bass guitar." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run it, it will show the image of a bass guitar.<br />
Now, we will try to adapt the code, so you can drag n drop an image onto it to change it. To achieve this, we need a drag n drop area for this image.<br />
In ReaGirl, you can add to each ui-element a dropzone. This will have the dimensions and position of the ui-element.<br />
This dropzone gets it's own run-function that is run every time a file is dropped onto the dropzone.<br />
So, let's add a dropzone for our image, using the function reagirl.UI_Element_GetSet_DropZoneFunction(). We also add a run-function for this drop-zone, Image_DropZone_RunFunction.</p>
<p><img src="gfx/Tutorial3_2.gif" title="Gif of the gui-window with an image of a bass guitar. When dropping files onto it, a dialog appears that shows the dropped filename." alt="Gif of the gui-window with an image of a bass guitar. When dropping files onto it, a dialog appears that shows the dropped filename." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
    reaper.MB(dropped_filenames_table[1], &quot;First dropped file&quot;, 0)  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You'll notice, it's only one functioncall to add the dropzone plus a run-function. That's all you need.<br />
Now you can drop files onto the image. A dialog will pop up that tells you the filename of the first file dropped. It's only the first one in this code, but you could drop multiple files at the same time into it.<br />
What we would like to do next, is to change the shown image. For this, we alter the function Image_DropZone_RunFunction accordingly.</p>
<p><img src="gfx/Tutorial3_3.gif" title="Gif of the gui-window with an image of a bass guitar. It shows how dropping of image-files changes the shown image." alt="Gif of the gui-window with an image of a bass guitar. It shows how dropping of image-files changes the shown image." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
      
    -- load the first file dropped as new image and show it  
    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You see, it's simply one functioncall of reagirl.Image_Load() to load the dropped file, the first file dropped in this case (dropped_filenames_table[1]).<br />
Now that we have an image-viewer that accepts dropping of image-files, we might want to have a context-menu that allows us to load a file-requester and to clear the image.<br />
Contextmenus work the same as dropzones. You can add a context-menu to a specific ui-element and you add a run-function.<br />
When the user right-clicks the ui-element, the context-menu is opened. When the user selects a menu-entry, the run-function for this context-menu is run, which gives you the chance to react to the user's choice.<br />
Let's add a context-menu using reagirl.UI_Element_GetSet_ContextMenu() including its run-function.</p>
<p><img src="gfx/Tutorial3_4.gif" title="Gif of the gui-window with an image of a bass guitar. It shows how right-clicking opens a context-menu. Selecting a menu-item shows a dialog that signals which menu-item was selected." alt="Gif of the gui-window with an image of a bass guitar. It shows how right-clicking opens a context-menu. Selecting a menu-item shows a dialog that signals which menu-item was selected." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
      
    -- load the first file dropped as new image and show it  
    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
  end  
    
  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
    -- this function will be called when the user opens up   
    -- the context-menu of the image and makes a choice  
    reaper.MB(&quot;The user chose menuentry &quot;..menu_entry_selection, &quot;Menu chosen&quot;, 0)  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
  -- add a context-menu to this image  
  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, &quot;Clear Image|Select a file&quot;, Image_ContextMenu_RunFunction)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Now you can right-click on the image and a menu will appear. You can select either of the entries and the run-function Image_ContextMenu_RunFunction() will show a dialog with the selected menu-entry-number.<br />
The parameter menu of the function reagirl.UI_Element_GetSet_ContextMenu works like gfx.showmenu from Reaper's own gfx-functions.<br />
So check out the docs for it for more details or read the chapter about context-menus, where I'll explain it in more detail.</p>
<p>Ok, now that we have a menu, let's alter the run-function Image_ContextMenu_RunFunction() to react to the individual menu-entries.<br />
The first menu-entry will clear the image to be fully black, while the other one loads a filerequester that allows you to choose an image.</p>
<p><img src="gfx/Tutorial3_5.gif" title="Gif of the gui-window with an image of a bass guitar. It shows a context-menu which allows clearing the image and using a file-requester to select an image-file." alt="Gif of the gui-window with an image of a bass guitar. It shows a context-menu which allows clearing the image and using a file-requester to select an image-file." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
      
    -- load the first file dropped as new image and show it  
    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
  end  
    
  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
    -- this function will be called when the user opens up   
    -- the context-menu of the image and makes a choice  
      
    if menu_entry_selection==1 then  
      -- if user chose the first menu-entry, clear the image to black  
      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
    elseif menu_entry_selection==2 then  
      -- if user chose the second menu-entry, allow to load an image using a file requester  
      local retval, filename =   
              reaper.GetUserFileNameForRead(reaper.GetResourcePath()..&quot;/Data/track_icons/&quot;,   
                                            &quot;Choose an image to load&quot;,   
                                            &quot;*.png;*.jpg&quot;)  
      if retval==true then  
        reagirl.Image_Load(element_id, filename)    
      end  
    end  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
  -- add a context-menu to this image  
  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, &quot;Clear Image|Select a file&quot;, Image_ContextMenu_RunFunction)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Nice, it does the job. But there's still one thing, that might bother you: images that are not square will be shown stretched. So, why not keeping the aspect ratio of the image properly?<br />
We can achieve this with the function reagirl.Image_KeepAspectRatio()</p>
<p><img src="gfx/Tutorial3_6.png" title="Two gui-windows who are square each who show the same hight image. On the left, the image looks stretched, on the right the same image is shown with correct aspect ratio." alt="Two gui-windows who are square each who show the same high image. On the left, the image looks stretched, on the right the same image is shown with correct aspect ratio." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
      
    -- load the first file dropped as new image and show it  
    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
  end  
    
  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
    -- this function will be called when the user opens up   
    -- the context-menu of the image and makes a choice  
    if menu_entry_selection==1 then  
      -- if user chose the first menu-entry, clear the image to black  
      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
    elseif menu_entry_selection==2 then  
      -- if user chose the second menu-entry, allow to load an image using a file requester  
      local retval, filename =   
              reaper.GetUserFileNameForRead(reaper.GetResourcePath()..&quot;/Data/track_icons/&quot;,   
                                            &quot;Choose an image to load&quot;,   
                                            &quot;*.png;*.jpg&quot;)  
      if retval==true then  
        reagirl.Image_Load(element_id, filename)    
      end  
    end  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
  -- add a context-menu to this image  
  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, &quot;Clear Image|Select a file&quot;, Image_ContextMenu_RunFunction)  
  -- keep the aspect ratio of the image properly  
  reagirl.Image_KeepAspectRatio(image_id, true)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>This is starting to look good.<br />
Since we're good in programming flow, let's put the currently loaded image as track-icon of the first track in the project everytime the user clicks on the image.<br />
For this, we need to adapt the run-function for the image(it's finally used!).<br />
First, we get the filename of the currently used image-file for the image using reagirl.Image_GetImageFilename() and pass it over to reaper.GetSetMediaTrackInfo_String().</p>
<p><img src="gfx/Tutorial3_7.gif" title="A gif showing how images are dropped onto the gui window and clicking the image in the gui sets the image-file as track-icon." alt="A gif showing how images are dropped onto the gui window and clicking the image in the gui sets the image-file as track-icon." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Image_RunFunction(clicked_image_id)  
    -- this function is run, when the image is clicked  
      
    -- get the filename of the currently loaded image-file  
    filename = reagirl.Image_GetImageFilename(clicked_image_id)  
      
    -- set it as track-icon of the first track  
    reaper.GetSetMediaTrackInfo_String(reaper.GetTrack(0,0), &quot;P_ICON&quot;, filename, true)  
  end  
    
  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
    -- this function will be called everytime a file is dropped onto the image  
      
    -- load the first file dropped as new image and show it  
    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
  end  
    
  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
    -- this function will be called when the user opens up   
    -- the context-menu of the image and makes a choice  
    if menu_entry_selection==1 then  
      -- if user chose the first menu-entry, clear the image to black  
      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
    elseif menu_entry_selection==2 then  
      -- if user chose the second menu-entry, allow to load an image using a file requester  
      local retval, filename =   
              reaper.GetUserFileNameForRead(reaper.GetResourcePath()..&quot;/Data/track_icons/&quot;,   
                                            &quot;Choose an image to load&quot;,   
                                            &quot;*.png;*.jpg&quot;)  
      if retval==true then  
        reagirl.Image_Load(element_id, filename)    
      end  
    end  
  end  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- add the image of a bass guitar to this gui  
  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;An image&quot;, &quot;A user selectable image.&quot;, Image_RunFunction)  
  -- add a dropzone for dropped files for this image  
  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
  -- add a context-menu to this image  
  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, &quot;Clear Image|Select a file&quot;, Image_ContextMenu_RunFunction)  
  -- keep the aspect ratio of the image properly  
  reagirl.Image_KeepAspectRatio(image_id, true)  
    
  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Image Viewer&quot;, &quot;This is a demo image viewer.&quot;, 120, 120)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When running this script, left-clicking the image will set the loaded image to be the track-icon of track 1 in the project.</p>
<p>And then we're done.<br />
A gui-script which shows an image on which you can drag n drop image-files. You can also use a context-menu with it to clear it/load a new image.<br />
And when clicking on it, the loaded imagefile will be set as track-icon.<br />
In 64 lines of code(including comments ;) ).</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_004_Disabled_UI_Elements"></a>
<a href="#Tutorial_004_Disabled_UI_Elements"> ^</a> <u><b>Tutorial 004: Disabled UI Elements</b></u><br>			<p>
<div class="ch">
<p>You may have seen it in certain guis, that sometimes gui-elements are disabled. You can do this too in ReaGirl.<br />
In this tutorial, I will show you, how.</p>
<p>First things first: not all ui-elements can be set to disabled, but those who can have a _SetDisabled-function.<br />
Like reagirl.Button_SetDisabled() or reagirl.Checkbox_SetDisabled, etc.<br />
So let's dive into it.</p>
<p>In this tutorial I want to introduce you to two new gui-elements not yet covered in the other ones: Sliders and Drop Down Menus.<br />
Our final gui will have one slider and one drop down menu plus checkboxes who disable/enable them.</p>
<p>First, let's create our basic gui without any gui-element in it as a base, that just opens a window.</p>
<p><img src="gfx/Tutorial4_1.png" title="A gui-window with no ui-elements, yet." alt="A gui-window with no ui-elements, yet." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Now, let's add first ui-elements: a checkbox and a slider. I will also add two run-functions, one for the checkboxes and one for the slider.</p>
<p><img src="gfx/Tutorial4_2.png" title="A gui-window with one checkbox and one slider." alt="A gui-window with one checkbox and one slider." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Slider_RunFunction(used_slider_id, current_value)  
    -- this function is run, when the slider is moved  
    reaper.ClearConsole()  
    reaper.ShowConsoleMsg(&quot;The current value is: &quot;..current_value)  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
    if checked_checkbox_id==checkbox_disableSlider_id then  
      reaper.ClearConsole()  
      reaper.ShowConsoleMsg(&quot;Checkbox is &quot;..tostring(checkstate), &quot;&quot;, 0)  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a checkbox and a slider to the gui  
  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, &quot;Activated&quot;, &quot;Check to activate slider.&quot;, true, Checkbox_RunFunction)  
  slider_id = reagirl.Slider_Add(200, 50, -20, &quot;I am a slider&quot;, nil, &quot;A slider to set a value.&quot;, &quot;%&quot;, 20, 200, 1, 25, 100, Slider_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run this code, you see a checkbox and a slider. When you click on the checkbox or move the slider, you will see the current value in the ReaScript console window.<br />
Now, let's make the checkbox disable the slider. For this, we use the function reagirl.Slider_SetDisabled() in the run-function Checkbox_RunFunction.<br />
We will use the element_id of the slider called slider_id to adress it in reagirl.Slider_SetDisabled().</p>
<p><img src="gfx/Tutorial4_3.gif" title="A gif of gui-window with one checkbox and one slider. The gif shows, how the checkbox disables the slider so it can not be dragged." alt="A gif of gui-window with one checkbox and one slider. The gif shows, how the checkbox disables the slider so it can not be dragged." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Slider_RunFunction(used_slider_id, current_value)  
    -- this function is run, when the slider is moved  
    reaper.ClearConsole()  
    reaper.ShowConsoleMsg(&quot;The current value is: &quot;..current_value)  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
      
    if checked_checkbox_id==checkbox_disableSlider_id then  
      -- if the first checkbox&#39;s checkstate is changed to true  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
      else -- otherwise  
        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
      end  
    end  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a checkbox and a slider to the gui  
  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, &quot;Activated&quot;, &quot;Check to activate slider.&quot;, true, Checkbox_RunFunction)  
  slider_id = reagirl.Slider_Add(200, 50, -20, &quot;I am a slider&quot;, nil, &quot;A slider to set a value.&quot;, &quot;%&quot;, 20, 200, 1, 25, 100, Slider_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When running this script, clicking the checkbox will change the slider to disabled/enabled, depending on the checkbox-state.<br />
Now, let's do this for another ui-element. But this time with a drop down menu. And we want it to set disabled at script startup.</p>
<p>To do this, we add another checkbox and a drop down menu(using reagirl.DropDownMenu_Add()).<br />
And as usual: we add a run-function called DropDownMenu_RunFunction() for the drop down menu.<br />
For the second checkbox, we use again the Checkbox_RunFunction(), but we'll modify it in a later step.</p>
<p>Let's see, how the gui looks now.</p>
<p><img src="gfx/Tutorial4_4.png" title="A gui window with two checkboxes, one slider and one drop down menu." alt="A gui window with two checkboxes, one slider and one drop down menu." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Slider_RunFunction(used_slider_id, current_value)  
    -- this function is run, when the slider is moved  
    reaper.ClearConsole()  
    reaper.ShowConsoleMsg(&quot;The current value is: &quot;..current_value)  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
      
    if checked_checkbox_id==checkbox_disableSlider_id then  
      -- if the first checkbox&#39;s checkstate is changed to true  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
      else -- otherwise  
        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
      end  
    end  
  end  

  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
    -- this function is run, when the user selects a menu-entry  
    reaper.MB(&quot;Dropdownmenu entry #&quot;..selected_menuitem..&quot; - &quot;..selected_name, &quot;&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a checkbox and a slider to the gui  
  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, &quot;Activated&quot;, &quot;Check to activate slider.&quot;, true, Checkbox_RunFunction)  
  slider_id = reagirl.Slider_Add(200, 50, -20, &quot;I am a slider&quot;, nil, &quot;A slider to set a value.&quot;, &quot;%&quot;, 20, 200, 1, 25, 100, Slider_RunFunction)  

  -- add a checkbox and a drop-down-menu to the gui  
  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, &quot;Activated&quot;, &quot;Check to activate drop-down-menu.&quot;, false, Checkbox_RunFunction)  
  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, &quot;I am a dropdownmenu&quot;, nil, &quot;A Drop Down Menu to choose from.&quot;, {&quot;Entry 1 - The first entry&quot;, &quot;Entry 2 - The second entry&quot;, &quot;Entry 3 - The third entry&quot;}, 2, DropDownMenu_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>This code shows now additionally a checkbox and a drop down menu. You can select menu-entries by clicking into it and when you do, the run-function of the drop down menu will show a messagebox with the selected menu-entry.<br />
The checkbox isn't doing anything yet, so clicking has no effect. Let's change this, by altering the run-function Checkbox_RunFunction().<br />
It's basically done the same way, as we did for the slider. However, we use now reagirl.DropDownMenu_SetDisabled() to disable the drop down menu.</p>
<p><img src="gfx/Tutorial4_5.gif" title="A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu." alt="A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Slider_RunFunction(used_slider_id, current_value)  
    -- this function is run, when the slider is moved  
    reaper.ClearConsole()  
    reaper.ShowConsoleMsg(&quot;The current value is: &quot;..current_value)  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
      
    if checked_checkbox_id==checkbox_disableSlider_id then  
      -- if the first checkbox&#39;s checkstate is changed to true  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
      else -- otherwise  
        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
      end  
      -- if the second checkbox&#39;s checkstate is changed to true  
    elseif checked_checkbox_id==checkbox_disableDropDownMenu_id then  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, false) -- set the drop down menu to enabled  
      else -- otherwise  
        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true)  -- set the drop down menu to disabled  
      end  
    end  
  end  

  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
    -- this function is run, when the user selects a menu-entry  
    reaper.MB(&quot;Dropdownmenu entry #&quot;..selected_menuitem..&quot; - &quot;..selected_name, &quot;&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a checkbox and a slider to the gui  
  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, &quot;Activated&quot;, &quot;Check to activate slider.&quot;, true, Checkbox_RunFunction)  
  slider_id = reagirl.Slider_Add(200, 50, -20, &quot;I am a slider&quot;, nil, &quot;A slider to set a value.&quot;, &quot;%&quot;, 20, 200, 1, 25, 100, Slider_RunFunction)  

  -- add a checkbox and a drop-down-menu to the gui  
  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, &quot;Activated&quot;, &quot;Check to activate drop-down-menu.&quot;, false, Checkbox_RunFunction)  
  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, &quot;I am a dropdownmenu&quot;, nil, &quot;A Drop Down Menu to choose from.&quot;, {&quot;Entry 1 - The first entry&quot;, &quot;Entry 2 - The second entry&quot;, &quot;Entry 3 - The third entry&quot;}, 2, DropDownMenu_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>This will set the drop down menu to disabled, when you set the checkbox to unchecked and enabled when you set it to checked.<br />
However, you have probably noticed when starting up the script, the checkbox is unchecked but the drop down menu is still enabled. Only checking the checkbox on and off will make it disabled.<br />
To solve this, we add one last reagirl.DropDownMenu_SetDisabled(), this time right after the reagirl.DropDownMenu_Add-functioncall, using the element_id of the drop down list.<br />
And we set it to disable the drop down menu(true).</p>
<p>Here's how the code looks like now.</p>
<p><img src="gfx/Tutorial4_6.gif" title="A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu. The drop down menu is now disabled at startup of the script." alt="A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu. The drop down menu is now disabled at startup of the script." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Slider_RunFunction(used_slider_id, current_value)  
    -- this function is run, when the slider is moved  
    reaper.ClearConsole()  
    reaper.ShowConsoleMsg(&quot;The current value is: &quot;..current_value)  
  end  

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
    -- this function is run, when the checkstate of a checkbox is changed  
      
    if checked_checkbox_id==checkbox_disableSlider_id then  
      -- if the first checkbox&#39;s checkstate is changed to true  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
      else -- otherwise  
        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
      end  
      -- if the second checkbox&#39;s checkstate is changed to true  
    elseif checked_checkbox_id==checkbox_disableDropDownMenu_id then  
      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, false) -- set the drop down menu to enabled  
      else -- otherwise  
        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true)  -- set the drop down menu to disabled  
      end  
    end  
  end  

  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
    -- this function is run, when the user selects a menu-entry  
    reaper.MB(&quot;Dropdownmenu entry #&quot;..selected_menuitem..&quot; - &quot;..selected_name, &quot;&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- add a checkbox and a slider to the gui  
  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, &quot;Activated&quot;, &quot;Check to activate slider.&quot;, true, Checkbox_RunFunction)  
  slider_id = reagirl.Slider_Add(200, 50, -20, &quot;I am a slider&quot;, nil, &quot;A slider to set a value.&quot;, &quot;%&quot;, 20, 200, 1, 25, 100, Slider_RunFunction)  

  -- add a checkbox and a drop-down-menu to the gui  
  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, &quot;Activated&quot;, &quot;Check to activate drop-down-menu.&quot;, false, Checkbox_RunFunction)  
  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, &quot;I am a dropdownmenu&quot;, nil, &quot;A Drop Down Menu to choose from.&quot;, {&quot;Entry 1 - The first entry&quot;, &quot;Entry 2 - The second entry&quot;, &quot;Entry 3 - The third entry&quot;}, 2, DropDownMenu_RunFunction)  
  reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true) -- set drop-down-menu to disabled  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 640, 120)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>And there we are: the finished gui that enables/disables the slider and the drop down menu according to the states of the checkboxes.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_005_Draggable_Images"></a>
<a href="#Tutorial_005_Draggable_Images"> ^</a> <u><b>Tutorial 005: Draggable Images</b></u><br>			<p>
<div class="ch">
<p>In this tutorial, I will show you, how to make a gui, where an image is draggable to multiple destinations.<br />
It will have one image, that can be dragged and two other images and a label, which act as destinations for the dragged source-image.<br />
Dragging the source-image to the destination-images will change the destination-image to the one of the source image, while dragging to the label will show the filename+path of the source-image.</p>
<p>Note: blind users can drag the image using Ctrl+Shift+PageUp or Ctrl+Shift+PageDown to select, to which ui-element the images shall be dragged to and Ctrl+Shift+Enter to drop it.</p>
<p>Let's start first with a basic-gui, that will show the source-image and have an empty run-function for the image.</p>
<p><img src="gfx/Tutorial5_1.png" title="A gui-window with one image of a bass guitar." alt="A gui-window with one image of a bass guitar." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
    -- this function will be run when the image is clicked or dragged to a destination  
  end  

  -- start a new gui  
  reagirl.Gui_New()  

  -- add the source-image, which we will draggable  
  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  


  -- open gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

  -- manage gui  
  function main()  
    reagirl.Gui_Manage()  
      
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>This will show our image of a bass guitar. Note, how the meaningOfUI_Element-parameter explains, that the image shows a bass-guitar. This is important for blind users, since they can't see the image and need to know, what the image looks like by you giving a short description.<br />
Clicking the image does nothing yet, as well as trying to drag.<br />
Now, let's add our dragging-destinations, which will be a label and two images.</p>
<p><img src="gfx/Tutorial5_2.png" title="A gui-window with one image of a bass guitar on the left and in the center a label that says &quot;Nothing has been dragged to this label yet&quot;, underneath it an image of an ampflifier and underneath it an image of congas." alt="A gui-window with one image of a bass guitar on the left and in the center a label that says &quot;Nothing has been dragged to this label yet&quot;, underneath it an image of an ampflifier and underneath it an image of congas." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
    -- this function will be run when the image is clicked or dragged to a destination  
  end  

  -- start a new gui  
  reagirl.Gui_New()  

  -- add the source-image, which we will draggable  
  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  

  -- add some additional images and a label, that are the destinations for the dragging  
  label_id = reagirl.Label_Add(240, 10, &quot;Nothing has been dragged to this label, yet&quot;, &quot;A destination for the source-image to drag to.&quot;, false, nil)  
  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/amp.png&quot;, &quot;Amplifier&quot;, &quot;An image of an amplifier.&quot;, nil)  
  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/congas.png&quot;, &quot;Congas&quot;, &quot;An image of congas.&quot;, nil)  

  -- open gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

  -- manage gui  
  function main()  
    reagirl.Gui_Manage()  
      
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  
    
  main()  </code></pre>
<p>This shows now the source and destination-images as well as a label. The parameter meaningOfUI_Element describes now, what the images are showing(amp, congas).</p>
<p>In the next step, we will make the source-image draggable. For this, we use the function reagirl.Image_SetDraggable(), in which we can set, which ui-element shall be destination of the source-image-dragging.<br />
It will look like this.</p>
<p><img src="gfx/Tutorial5_3.gif" title="A gif that shows how the image of a bass guitar is dragged over to the other three ui-elements. When the bass is dropped onto them, a dialog pops up that says, onto what the bass guitar was dropped." alt="A gif that shows how the image of a bass guitar is dragged over to the other three ui-elements. When the bass is dropped onto them, a dialog pops up that says, onto what the bass guitar was dropped." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
    -- this function will be run when the image is clicked or dragged to a destination  
    reaper.MB(&quot;Dragged to: &quot;..reagirl.UI_Element_GetSetCaption(drag_destination, false, &quot;&quot;), &quot;&quot;, 0)  
  end  

  -- start a new gui  
  reagirl.Gui_New()  

  -- add the source-image, which we will draggable  
  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  

  -- add some additional images and a label, that are the destinations for the dragging  
  label_id = reagirl.Label_Add(240, 10, &quot;Nothing has been dragged to this label, yet&quot;, &quot;A destination for the source-image to drag to.&quot;, false, nil)  
  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/amp.png&quot;, &quot;Amplifier&quot;, &quot;An image of an amplifier.&quot;, nil)  
  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/congas.png&quot;, &quot;Congas&quot;, &quot;An image of congas.&quot;, nil)  

  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  

  -- open gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

  -- manage gui  
  function main()  
    reagirl.Gui_Manage()  
      
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  
    
  main()  </code></pre>
<p>You can see, that we pass to it the element_ids of the destinations, like label_id, image_dest1_id and image_dest2_id.<br />
When you run this, you can drag the source-image of a bass-guitar around. You will see a smaller version of the image is shown at the mouse-cursor during dragging.<br />
When dropping the source-image to a destination, the run-function of the source-image Image_Runfunction() will be run and shows a messagebox that tells you, onto which ui-element you dragged the source-image.<br />
It will use the function reagirl.UI_Element_GetSetCaption() to get the caption of the dragged ui-element.<br />
The run-function uses the third parameter, drag_destination. This parameter is sent to run-functions once the image it is associated with is set to draggable, like image_source_id in our case.</p>
<p>Now, we want to make the label show the filename of the source-image when dropping the source-image onto it.</p>
<p><img src="gfx/Tutorial5_4.gif" title="A gif that shows, how the bass guitar is dragged to the label and dropped there. The label changes to show the filename of the bass-guitar-image after dropping." alt="A gif that shows, how the bass guitar is dragged to the label and dropped there. The label changes to show the filename of the bass-guitar-image after dropping." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
    -- this function will be run when the image is clicked or dragged to a destination  
      if drag_destination==label_id then  
      -- if source-image is dragged to the label, set labeltext to filename of the source-image  
        
      -- get the filename of the source-image  
      image_filename = reagirl.Image_GetImageFilename(element_id)   
      -- set label-text to filename of source-image  
      reagirl.Label_SetLabelText(label_id, &quot;Filename of source-image is: &quot;..image_filename)   
    end  
  end  

  -- start a new gui  
  reagirl.Gui_New()  

  -- add the source-image, which we will draggable  
  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  

  -- add some additional images and a label, that are the destinations for the dragging  
  label_id = reagirl.Label_Add(240, 10, &quot;Nothing has been dragged to this label, yet&quot;, &quot;A destination for the source-image to drag to.&quot;, false, nil)  
  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/amp.png&quot;, &quot;Amplifier&quot;, &quot;An image of an amplifier.&quot;, nil)  
  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/congas.png&quot;, &quot;Congas&quot;, &quot;An image of congas.&quot;, nil)  

  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  

  -- open gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

  -- manage gui  
  function main()  
    reagirl.Gui_Manage()  
      
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  
    
  main()  </code></pre>
<p>When we drag the source-image now to the label, the run-function Image_Runfunction() is run, in which we check the parameter drag_destination against the element_id label_id.<br />
If the source-image has been dropped at the label(drag_destination==label_id) then we get the filename of the source-image and set the caption of the label to it.</p>
<p>Nice.<br />
Now, let's alter the run-function even further. We will now make it, that dragging the source-image onto the destination-images will change the destination-images once the image was dropped on them.</p>
<p><img src="gfx/Tutorial5_5.gif" title="A gif that shows, how the bass-guitar-image is dropped on the label, after that on the image of the amplifier and after that on the image of the congas. The label changes to show the filename of the bass guitar while the amplifier and the congas get exchanged with the image of the bass guitar." alt="A gif that shows, how the bass-guitar-image is dropped on the label, after that on the image of the amplifier and after that on the image of the congas. The label changes to show the filename of the bass guitar while the amplifier and the congas get exchanged with the image of the bass guitar." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
    -- this function will be run when the image is clicked or dragged to a destination  
    if drag_destination==label_id then  
      -- if source-image is dragged to the label, set labeltext to   
      -- filename of the source-image  
        
      -- get the filename of the source-image  
      image_filename = reagirl.Image_GetImageFilename(element_id)   
      -- set label-text to filename of source-image  
      reagirl.Label_SetLabelText(label_id, &quot;Filename of source-image is: &quot;..image_filename)   
    elseif drag_destination==image_dest1_id then  
      -- if source_image is dragged to image2, change it&#39;s image to the  
      -- one of the source-image  
        
      -- get the filename of the source-image  
      image_filename = reagirl.Image_GetImageFilename(element_id)  
      -- load the filename of the source-image in the destination-image  
      reagirl.Image_Load(image_dest1_id, image_filename)  

    elseif drag_destination==image_dest2_id then  
      -- if source_image is dragged to image2, change it&#39;s image to the  
      -- one of the source-image  
        
      -- get the filename of the source-image  
      image_filename = reagirl.Image_GetImageFilename(element_id)  
      -- load the filename of the source-image in the destination-image  
      reagirl.Image_Load(image_dest2_id, image_filename)  
    end  
  end  

  -- start a new gui  
  reagirl.Gui_New()  

  -- add the source-image, which we will draggable  
  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  

  -- add some additional images and a label, that are the destinations for the dragging  
  label_id = reagirl.Label_Add(240, 10, &quot;Nothing has been dragged to this label, yet&quot;, &quot;A destination for the source-image to drag to.&quot;, false, nil)  
  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/amp.png&quot;, &quot;Amplifier&quot;, &quot;An image of an amplifier.&quot;, nil)  
  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/congas.png&quot;, &quot;Congas&quot;, &quot;An image of congas.&quot;, nil)  

  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  

  -- open gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

  -- manage gui  
  function main()  
    reagirl.Gui_Manage()  
      
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When we run this code, dropping the source-image onto one of the destination-images will now change the shown image.<br />
To achieve this, we checked in the run-function Image_Runfunction() if the destination-ui-element(drag_destination-parameter) was either the first destination image(image_dest1_id) or the second(image_dest2_id).<br />
If so, we get the filename of the source using reagirl.Image_GetImageFilename() and load it using reagirl.Image_Load() into the destination-image.</p>
<p>Awesome, it's already looking good. But: there's one thing we missed:<br />
Remember that the description of the destination images was amp and conga? It still is, even though it's now showing a bass-guitar. That means, blind users didn't get, that the images was changed.<br />
Let's change that.<br />
For this, we need to alter the run-function Image_Runfunction and add the two functions, reagirl.UI_Element_GetSetMeaningOfUIElement() and reagirl.UI_Element_GetSetCaption().<br />
The function reagirl.UI_Element_GetSetCaption() will change the caption, which is sent to blind users when hovering above a ui-element.<br />
The function reagirl.UI_Element_GetSetMeaningOfUIElement() will change the screen reader-message, which is sent to blind users when they are tabbing through the ui-elements.<br />
For the label we don't need to change the caption, since label-text and caption is the same.<br />
We need to alter the run-function for the images as well as the label.</p>
<p>Note: in the ReaGirl-Settings you find an option called "Show screen reader messages in console", which will show the messages sent to blind users in the ReaScript-console window.<br />
With that, you can check, whether the meaningOfUI_Element was correctly altered or is even reflecting the correct message.</p>
<p>Ok, now that we altered the script, it looks like this now.</p>
<pre><code>dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
  -- this function will be run when the image is clicked or dragged to a destination  
  if drag_destination==label_id then  
    -- if source-image is dragged to the label, set labeltext to   
    -- filename of the source-image  
      
    -- get the filename of the source-image  
    image_filename = reagirl.Image_GetImageFilename(element_id)   
    -- set label-text to filename of source-image  
    reagirl.Label_SetLabelText(label_id, &quot;Filename of source-image is: &quot;..image_filename)   
    -- change meaningOfUI_Element to reflect, what the label shows now for blind users  
    reagirl.UI_Element_GetSetMeaningOfUIElement(label_id, true, &quot;An image of a bass-guitar&quot;)  
    
  elseif drag_destination==image_dest1_id then  
    -- if source_image is dragged to image2, change it&#39;s image to the  
    -- one of the source-image  
      
    -- get the filename of the source-image  
    image_filename = reagirl.Image_GetImageFilename(element_id)  
    -- load the filename of the source-image in the destination-image  
    reagirl.Image_Load(image_dest1_id, image_filename)  
    -- change meaningOfUI_Element to reflect, what the image shows now for blind users  
    reagirl.UI_Element_GetSetMeaningOfUIElement(image_dest1_id, true, &quot;An image of a bass-guitar&quot;)  
    reagirl.UI_Element_GetSetCaption(image_dest1_id, true, &quot;Image of a bass guitar&quot;)  
    
  elseif drag_destination==image_dest2_id then  
    -- if source_image is dragged to image2, change it&#39;s image to the  
    -- one of the source-image  
      
    -- get the filename of the source-image  
    image_filename = reagirl.Image_GetImageFilename(element_id)  
    -- load the filename of the source-image in the destination-image  
    reagirl.Image_Load(image_dest2_id, image_filename)  
    -- change meaningOfUI_Element to reflect, what the image shows now for blind users  
    reagirl.UI_Element_GetSetMeaningOfUIElement(image_dest2_id, true, &quot;An image of a bass-guitar.&quot;)  
    reagirl.UI_Element_GetSetCaption(image_dest2_id, true, &quot;Image of a bass guitar&quot;)  
  end  
end  

-- start a new gui  
reagirl.Gui_New()  

-- add the source-image, which we will draggable  
image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/bass.png&quot;, &quot;Bass-guitar&quot;, &quot;An image of a bass guitar.&quot;, Image_Runfunction)  

-- add some additional images and a label, that are the destinations for the dragging  
label_id = reagirl.Label_Add(240, 10, &quot;Nothing has been dragged to this label, yet&quot;, &quot;A destination for the source-image to drag to.&quot;, false, nil)  
image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/amp.png&quot;, &quot;Amplifier&quot;, &quot;An image of an amplifier.&quot;, nil)  
image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath()..&quot;/Data/track_icons/congas.png&quot;, &quot;Congas&quot;, &quot;An image of congas.&quot;, nil)  

-- add the element_ids of image2-4_id as drag-destinations of image1_id  
reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  

-- open gui  
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;ReaGirl Tutorial&quot;, &quot;Tutorial for draggable images.&quot;, 665, 310, nil, nil, nil)  

-- manage gui  
function main()  
  reagirl.Gui_Manage()  
    
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
end  
main()  
  </code></pre>
<p>You'll notice, how we alter the screen reader-message using reagirl.UI_Element_GetSetMeaningOfUIElement() as well as the caption using reagirl.UI_Element_GetSetCaption().<br />
And when you run the script, tabbing through the ui-elements will now tell to blind users, which image has been used by image_dest1_id and image_dest2_id and label_id.</p>
<p>Great. Now we have a script that allows dragging a source-image to various destinations. It alters the images and labels when the source-image has been dropped.<br />
We also altered the screen reader-messages accordingly to reflect the changes, so blind users know, what has happened with dragging as well.</p>
<p>In this tutorial, we made images draggable, but you can also make labels draggable. The only difference is, that for labels, the run-function is getting the destination-element_id as second parameter instead of the third.<br />
The rest is the same.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_006_Enter_ESC_AtExit"></a>
<a href="#Tutorial_006_Enter_ESC_AtExit"> ^</a> <u><b>Tutorial 006: Enter, Esc-Key and AtExit</b></u><br>			<p>
<div class="ch">
<p>In ReaGirl, you can set a run-function for when the gui-window is closed using esc and closing via the close-button.<br />
You can also set a run-function to the enter-key, so you can have a "Apply settings and close window via Enter-key"-feature.<br />
In this tutorial, we'l look at how to do them.</p>
<p>Let's start with a basic gui.</p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction()  
    -- this function will be run when the button is pressed  
      
    -- It stores the setting and keeps the dialog open  
    reaper.SetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;, reagirl.Slider_GetValue(slider_percentage), true)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- Add a slider and a button to the gui.  
  -- First: get old stored value of the slider  
  old_slider_value=reaper.GetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;)   
  -- Second: if there isn&#39;t a slider-value stored yet, use a default of 0  
  if old_slider_value==&quot;&quot; then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
  -- add the slider with the slider-value stored in old_slider_value  
  slider_percentage = reagirl.Slider_Add(4, 4, 250, &quot;Percentage&quot;, 140, &quot;Set the percentage.&quot;, nil, 0, 8, 1, old_slider_value, 0, nil)  
  -- add a store button  
  button = reagirl.Button_Add(260, 4, 0, 0, &quot;Store&quot;, &quot;Store percentage setting.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 325, 40)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run the script, you get a script with one slider and a button to store the value of the slider in an extstate.<br />
You can close it via the close-button of the window and the esc-key.<br />
In the next step, we want to show a dialog that tells the user that the slider-value wasn't stored when closing via esc-key or the close-button.<br />
For this we add a new run-function AtExit_RunFunction and also add the function reagirl.Gui_AtExit() to tell ReaGirl, which run-function to use when the gui is closed.<br />
This is how it looks like, now.</p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction()  
    -- this function will be run when the button is pressed  
      
    -- It stores the setting and keeps the dialog open  
    reaper.SetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;, reagirl.Slider_GetValue(slider_percentage), true)  
  end  
    
  function AtExit_RunFunction()  
    -- this function is run when the window is closed by either esc-key or the x-button of the window  
      
    -- it will show an aborted dialog  
    reaper.MB(&quot;Aborted setting the percentage.\n\nPercentage is not stored.&quot;, &quot;Abort&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- Add a slider and a button to the gui.  
  -- First: get old stored value of the slider  
  old_slider_value=reaper.GetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;)   
  -- Second: if there isn&#39;t a slider-value stored yet, use a default of 0  
  if old_slider_value==&quot;&quot; then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
  -- add the slider with the slider-value stored in old_slider_value  
  slider_percentage = reagirl.Slider_Add(4, 4, 250, &quot;Percentage&quot;, 140, &quot;Set the percentage.&quot;, nil, 0, 8, 1, old_slider_value, 0, nil)  
  -- add a store button  
  button = reagirl.Button_Add(260, 4, 0, 0, &quot;Store&quot;, &quot;Store percentage setting.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 325, 40)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run this script, you can close the window via esc-key and the close-button and if you do, a dialog opens up that tells the user that storing the setting was aborted.<br />
We made this possible with the function AtExit_RunFunction(), which opens a dialog using reaper.MB(). And we used reagirl.Gui_AtExit(AtExit_RunFunction) to tell Reaper to run the run-function AtExit_RunFunction everytime the window is closes using the close-button or the esc-key.<br />
Great.<br />
In the next step, we add that hitting enter stores the slider-value and closes the window. For this, we add another run-function AtEnter_RunFunction() and the function reagirl.Gui_AtEnter(AtEnter_RunFunction) to tell ReaGirl to run the run-function everytime the user hits enter in the dialog.</p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  function Button_RunFunction()  
    -- this function will be run when the button is pressed  
      
    -- It stores the setting and keeps the dialog open  
    reaper.SetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;, reagirl.Slider_GetValue(slider_percentage), true)  
  end  
    
  function AtEnter_RunFunction()  
    -- this function is run, when the enter-key is hit  
      
    -- it stores the setting, shows a success-message and closes the gui  
    reaper.SetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;, reagirl.Slider_GetValue(slider_percentage), true)  
    reaper.MB(&quot;Entered new percentage&quot;, &quot;Success&quot;, 0)  
    reagirl.Gui_Close()  
  end  
    
  function AtExit_RunFunction()  
    -- this function is run when the window is closed by either esc-key or the x-button of the window  
      
    -- it will show an aborted dialog  
    reaper.MB(&quot;Aborted setting the percentage.\n\nPercentage is not stored.&quot;, &quot;Abort&quot;, 0)  
  end  

  -- create new gui  
  reagirl.Gui_New()  

  -- Add a slider and a button to the gui.  
  -- First: get old stored value of the slider  
  old_slider_value=reaper.GetExtState(&quot;My_Setting&quot;, &quot;My_Key&quot;)   
  -- Second: if there isn&#39;t a slider-value stored yet, use a default of 0  
  if old_slider_value==&quot;&quot; then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
  -- add the slider with the slider-value stored in old_slider_value  
  slider_percentage = reagirl.Slider_Add(4, 4, 250, &quot;Percentage&quot;, 140, &quot;Set the percentage.&quot;, nil, 0, 8, 1, old_slider_value, 0, nil)  
  -- add a store button  
  button = reagirl.Button_Add(260, 4, 0, 0, &quot;Store&quot;, &quot;Store percentage setting.&quot;, Button_RunFunction)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 325, 40)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You'll notice, that the run-function AtEnter_RunFunction() stores the slider-value into an extstate. It also closes the gui using Gui_Close() and shows a dialog using reaper.MB() that tells the user that the slider-value is stored.<br />
And when you run this script, you can change the slider, hit enter and when you rerun the script, the stored slider-value is restored.</p>
<p>With that, you have a dialog that reacts to closing via close-button, the esc-key and the enter key.</p>
<p>One thing to notice: the run-function for enter isn't run when the an inputbox is currently selected, which uses a run-function for the enter-key! It's also not run when the inputbox is currently selected and the user is a screen reader-user.<br />
So you might need to add a run-function for inputboxes that does the same as the enter-run-function used by reagirl.Gui_AtEnter()</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_007_Autopositioning_Of_UI_Elements"></a>
<a href="#Tutorial_007_Autopositioning_Of_UI_Elements"> ^</a> <u><b>Tutorial 007: Autopositioning of UI-Elements</b></u><br>			<p>
<div class="ch">
<p>When doing guis in ReaGirl, you can use its autopositioning-feature. This is very practical, as you don't really need to place them by hand.<br />
Especially when you are blind and want to create a gui, you need a way to position the gui-elements without having to use your eyes to finetune things.<br />
In this and the next tutorials, I will show you, how to use it.<br />
And believe me: it's easy.</p>
<p>First we start with a basic gui with no ui-element in it.</p>
<p><img src="gfx/Tutorial7_1.png" title="An empty dialog-window." alt="An empty dialog-window." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>And then we add some ui-elements in it, let's say, three checkboxes. These shall be one after another in one line.<br />
To do that with the autopositioning-feature, you simply set the x and y-parameters to nil.<br />
Here's how it looks like.</p>
<p><img src="gfx/Tutorial7_2.png" title="An dialog-window with three checkboxes automatically positioned." alt="A dialog-window with three checkboxes automatically positioned." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- first line of checkboxes  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>There you are. Three checkboxes, positioned after each other in one line.<br />
Now, let's add another line into it, but how to do that?<br />
Simple. Before we start another line, we add reagirl.NextLine() to it. Then we add another line of checkboxes with x and y set to nil.</p>
<p><img src="gfx/Tutorial7_3.png" title="An dialog-window with five checkboxes(two new ones) automatically positioned." alt="A dialog-window with five checkboxes(two new ones) automatically positioned." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- first line of checkboxes  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  
    
  -- second line of checkboxes  
  reagirl.NextLine() -- start a new line of ui-elements  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 4&quot;, &quot;This is the fourth checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When you run it, you see two lines of checkboxes, one with three and one with two checkboxes.<br />
Let's add another line of ui-elements, this time a checkbox and a button, anchored to the right side of the window. And we position it a few pixels more than the space between the first two lines were.<br />
To do that, we use reagirl.NextLine() but this time we add 10 pixels as parameter to it.<br />
And then we add a checkbox and a button. For the checkbox we add as x-parameter 200 pixels from the right side of the window(-200) and y-parameter we leave at nil for autopositioning.<br />
The button, we set x=nil and y=nil.</p>
<p><img src="gfx/Tutorial7_4.png" title="A dialog-window with six checkboxes(one new one) and a button automatically positioned." alt="A dialog-window with six checkboxes(one new one) and a button automatically positioned." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- first line of checkboxes  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  
    
  -- second line of checkboxes  
  reagirl.NextLine() -- start a new line of ui-elements  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 4&quot;, &quot;This is the fourth checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
    
  -- third line with one checkbox and one button anchored to right side of the window  
  -- this line is placed 10 pixels lower to gain some distance between the lines  
  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
  reagirl.Checkbox_Add(-200, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store&quot;, &quot;Store 1.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>When we run this script, the newly added checkbox and button are anchored to the right side of the window. So when you resize it, they more accordingly.<br />
You also notice, that the button is positioned relative to the checkbox that we put at x=-200. So ui-elements coming after a ui-element that was positioned "manually" will be placed relative to the manually placed one.<br />
Let's add another line with a checkbox and a button, this time anchored again to the left side of the window.<br />
But how do we do that?<br />
Simple:<br />
We set the x-position(40) and this time the y-position as well(100) of the checkbox. After that, we autoposition another button with x=nil and y=nil.</p>
<p><img src="gfx/Tutorial7_5.png" title="A dialog-window with seven checkboxes(one new one) and two buttons(one new one) automatically positioned." alt="A dialog-window with seven checkboxes(one new one) and two buttons(one new one) automatically positioned." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  -- first line of checkboxes  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  
    
  -- second line of checkboxes  
  reagirl.NextLine() -- start a new line of ui-elements  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 4&quot;, &quot;This is the fourth checkbox.&quot;, true, nil)  
  reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
    
  -- third line with one checkbox and one button anchored to right side of the window  
  -- this line is placed 10 pixels lower to gain some distance between the lines  
  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
  reagirl.Checkbox_Add(-200, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store&quot;, &quot;Store 1.&quot;, nil)  
    
  -- fourth line with one checkbox and one button anchored to the left side of the window  
  reagirl.Checkbox_Add(40, 100, &quot;Checkbox 6&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store 2&quot;, &quot;Store 2.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>And there you are. The new line added is anchored to the left side of the window again and the button has been placed relative to this checkbox.</p>
<p>So rule of thumb is:<br />
1. to autoposition, set x and/or y-position to nil to place ui-elements after each other.<br />
2. add reagirl.NextLine() to start another line of ui-elements<br />
3. when you place a ui-element to specific coordinates, all following ui-elements will be autopositioned relative to the previous one when x=nil and/or y=nil</p>
<p>Toy around with it to get a grip on it.</p>
<p>More on using autopositioning as blind scripter in a later chapter.</p>
<p>In the next tutorial, I will explain to you, how to use auto-positioning with tabs.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_008_Autopositioning_With_Tabs"></a>
<a href="#Tutorial_008_Autopositioning_With_Tabs"> ^</a> <u><b>Tutorial 008: Autopositioning with Tabs</b></u><br>			<p>
<div class="ch">
<p>In the last tutorial, I showed you how to use autopositioning in ReaGirl. In this one, we will enhance it by adding tabs, which differs slightly.<br />
You probably remember from the last tutorial, that when using auto-positioning, the next ui-element is positioned relative to the previous ui-element.<br />
Means: next to the right of the previous ui-element or underneath it(when using reagirl.NextLine()).<br />
We could use the same thing using tabs, what would look like the following, which includes all the ui-elements from the<br />
previous tutorial but sorted into tabs, using autopositioning:</p>
<p><img src="gfx/Tutorial8_1.gif" title="A gif showing the autopositioned checkboxes and buttons from the previous tutorial placed over four tabs. The tabs get switched which reveal, that the ui-elements start one line lower with each tab. So they kind of walk from the top to the bottom with each tab." alt="A gif showing the autopositioned checkboxes and buttons from the previous tutorial placed over four tabs. The tabs get switched which reveal, that the ui-elements start one line lower with each tab. So they kind of walk from the top to the bottom with each tab." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  tab1={}  
  tab2={}  
  tab3={}  
  tab4={}  
    
  -- let&#39;s add tabs  
  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Tab1&quot;, &quot;Tab2&quot;, &quot;Tab3&quot;, &quot;Tab4&quot;}, 1, Tab_RunFunction)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 4, tab4)  
  --]]  
    
  -- first line of checkboxes  
  tab1.checkbox1 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  tab1.checkbox2 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  tab1.checkbox3 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  
    
  -- second line of checkboxes  
  reagirl.NextLine() -- start a new line of ui-elements  
  tab2.checkbox1 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 4&quot;, &quot;This is the fourth checkbox.&quot;, true, nil)  
  tab2.checkbox2 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
    
  -- third line with one checkbox and one button anchored to right side of the window  
  -- this line is placed 10 pixels lower to gain some distance between the lines  
  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
  tab3.checkbox = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  tab3.button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store&quot;, &quot;Store 1.&quot;, nil)  
    
  -- fourth line with one checkbox and one button anchored to the left side of the window  
  reagirl.NextLine()  
  tab4.checkbox = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 6&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  tab4.button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store 2&quot;, &quot;Store 2.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)--, 425, 240)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>However, when you run it, you quickly realize, there's a problem. When clicking through the tabs, the ui-elements are positioned<br />
under the ui-elements from the previous tabs. So when you click through tab1 to tab4, the ui-elements wander downwards.<br />
This is due the fact, that they are positioned according to the last ui-element in the code and not by the tabs.<br />
And it would be much better, if the ui-elements would start at the top of each tab.<br />
For this, we add another new function, called reagirl.AutoPosition_SetNextYToUIElement(). With this function,<br />
you can set, which ui-element shall be seen as the previous one, so autoposition uses this "newly set" ui-element as basis to position the next ui-element.</p>
<p>In our element, we want to set the first checkbox of each tab right after the tab. So all we do is include</p>
<p><code>reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)</code></p>
<p>into our script right before each checkbox, that shall be put at the beginning of the tab. You'll notice, that we<br />
put the element_id of the tabs, "tabs_id", as parameter. This tells autoposition "The next ui-element shall be put after tabs.<br />
Here's how it looks like:</p>
<p><img src="gfx/Tutorial8_2.gif" title="A gif that switches through all the tabs of the gui-window. The ui-elements are now placed on top of each tab." alt="A gif that switches through all the tabs of the gui-window. The ui-elements are now placed on top of each tab." /></p>
<pre><code>  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  
    
  -- create new gui  
  reagirl.Gui_New()  
    
  tab1={}  
  tab2={}  
  tab3={}  
  tab4={}  
    
  -- let&#39;s add tabs  
  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, &quot;Tabs&quot;, &quot;Different options in this dialog.&quot;, {&quot;Tab1&quot;, &quot;Tab2&quot;, &quot;Tab3&quot;, &quot;Tab4&quot;}, 1, Tab_RunFunction)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
  reagirl.Tabs_SetUIElementsForTab(tabs_id, 4, tab4)  
    
  -- first line of checkboxes  
  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
  tab1.checkbox1 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 1&quot;, &quot;This is the first checkbox.&quot;, true, nil)  
  tab1.checkbox2 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 2&quot;, &quot;This is the second checkbox.&quot;, true, nil)  
  tab1.checkbox3 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 3&quot;, &quot;This is the third checkbox.&quot;, true, nil)  
    
  -- second line of checkboxes  
  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
  reagirl.NextLine() -- start a new line of ui-elements  
  tab2.checkbox1 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 4&quot;, &quot;This is the fourth checkbox.&quot;, true, nil)  
  tab2.checkbox2 = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
    
  -- third line with one checkbox and one button anchored to right side of the window  
  -- this line is placed 10 pixels lower to gain some distance between the lines  
  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
  tab3.checkbox = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 5&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  tab3.button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store&quot;, &quot;Store 1.&quot;, nil)  
    
  -- fourth line with one checkbox and one button anchored to the left side of the window  
  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
  reagirl.NextLine()  
  tab4.checkbox = reagirl.Checkbox_Add(nil, nil, &quot;Checkbox 6&quot;, &quot;This is the fifth checkbox.&quot;, true, nil)  
  tab4.button = reagirl.Button_Add(nil, nil, 0, 0, &quot;Store 2&quot;, &quot;Store 2.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  

  reagirl.Gui_AtExit(AtExit_RunFunction)  
  reagirl.Gui_AtEnter(AtEnter_RunFunction)  

  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>You'll notice, that reagirl.AutoPosition_SetNextYToUIElement() is put right before the reagirl.Checkbox_Add()-functioncalls to tell ReaGirl to autoposition the next checkbox right after the next tab.<br />
And when you run it and click through the tabs, the ui-elements are now positioned at the right position: right after the tabs.</p>
<p>One thing to notice: you could theoretically put the element_id of any ui-element into reagirl.AutoPosition_SetNextYToUIElement(), not just tabs.<br />
That way, you can autoposition in relation to any ui-element.<br />
Keep in mind: when using tabs, autoposition will assume that the next ui-element shall be put into the next line, so you don't need to use reagirl.NextLine() when using reagirl.AutoPosition_SetNextYToUIElement() with tabs.<br />
With other ui-elements, like buttons, checkboxes, sliders, etc, the next ui-element will be placed next to the right of it. So you might need to add reagirl.NextLine() when needed.<br />
You'll see it when it happens and if you want to put the next ui-element underneath the one you put in reagirl.AutoPosition_SetNextYToUIElement(), simply use reagirl.NextLine() and you're fine.</p>
<p>And there you are. If you followed all tutorials up til this one, you know most of the concepts and possibilities in ReaGirl.<br />
This should give you plenty of possibilities to code guis as you need and wish.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_009_Structuring_Guis_With_Labels"></a>
<a href="#Tutorial_009_Structuring_Guis_With_Labels"> ^</a> <u><b>Tutorial 009: Structuring Guis with Labels</b></u><br>			<p>
<div class="ch">
<p>In this tutorial, we will structure Guis using labels. For this, we will add backdrops around ui-elements to create sections in your gui. We will also have spaces between these sections, so each section is easy to separate from the other ones for the user.<br />
Backdrops are additional elements for labels. They are a rectangle that starts at half the height of the label and goes around until it ends again on the other side of the label.<br />
You can imagine this as a rectangle, that has a gap on the top at which the label-text is placed. The bottom ends under the last ui-elements of a section of ui-elements.<br />
Backdrops enclose ui-elements to make it easier to see, which ui-elements belong to each other.</p>
<p>If you do only simple guis, you will usually not having problems with guis that are hard to read.<br />
However, when you have a lot of ui-elements in your gui, you may quickly end up with a wall of ui-elements.<br />
Consider the following example-gui.</p>
<p><img src="gfx/Tutorial9_1.png" title="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read." alt="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read." /></p>
<pre><code>-- load ReaGirl into this script  
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

-- create new gui  
reagirl.Gui_New()  

-- now let&#39;s add all ui-elements of the first tab to table tab1  
 
-- Labels  
label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
 
reagirl.NextLine()  
label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
  
label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

reagirl.NextLine()  
label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
  
label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
  
label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                        -- let it end underneath label_large - the largest label  
-- Inputboxes  
reagirl.NextLine()  
label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
  
reagirl.NextLine()  
inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

reagirl.NextLine()  
button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button                                                                             
  
-- Checkboxes  
reagirl.NextLine()  
label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

reagirl.NextLine() -- first line of checkboxes  
checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
  
reagirl.NextLine() -- second line of checkboxes  
checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
  
-- Images  
reagirl.NextLine()   
label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  
-- local some images from Reaper  
reagirl.NextLine()  
image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

-- Buttons  
reagirl.NextLine(10)  
button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

-- open the new gui  
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

-- make the background grey  
reagirl.Background_GetSetColor(true, 55, 55, 55)  


function main()  
  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
  reagirl.Gui_Manage()  
    
  -- if the gui-window hasn&#39;t been closed, keep the script alive.  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
end  

main()  
  </code></pre>
<p>When you run this gui, you see gazillions of ui-elements placed onto this gui. And you also notice that it's hard to read.<br />
You don't know, where one context starts and where another context ends. It's using labels to somewhat structure the gui but the labels simply drown in this multiverse of ui-elements.<br />
It would be awesome to have a way to separate each context from each other: "Labels", "Inputboxes", "And some checkboxes" and "Or Images".</p>
<p>Behold, there's a way to do it, an attribute-function for labels, the function reagirl.Label_SetBackdrop().<br />
With this function, you can create a backdrop for ui-elements. This backdrop is a boundary box that you surround around your ui-elements, beginning at a certain label.<br />
The function accepts as first parameter the element_id of the label, where the backdrop shall start, then the width and height of it.<br />
Let's add this function to draw a backdrop from the label "Labels" underneath the huge label "size".</p>
<p><img src="gfx/Tutorial9_2.png" title="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The labels on the top are now enclosed with a label-backdrop going from the label &#39;Labels&#39; to underneath the label &#39;size&#39;." alt="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The labels on the top are now enclosed with a label-backdrop going from the label &quot;Labels&quot; to underneath the label &quot;size&quot;." /></p>
<pre><code>-- load ReaGirl into this script  
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

-- create new gui  
reagirl.Gui_New()  

-- now let&#39;s add all ui-elements of the first tab to table tab1  
 
-- Labels  
label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
 
reagirl.NextLine()  
label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
  
label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

reagirl.NextLine()  
label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
  
label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
  
label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                        -- let it end underneath label_large - the largest label  
                                                          
reagirl.Label_SetBackdrop(label_header, 290, 80)  
  
-- Inputboxes  
reagirl.NextLine()  
label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
  
reagirl.NextLine()  
inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

reagirl.NextLine()  
button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
  
-- Checkboxes  
reagirl.NextLine()  
label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

reagirl.NextLine() -- first line of checkboxes  
checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
  
reagirl.NextLine() -- second line of checkboxes  
checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
  
-- Images  
reagirl.NextLine()   
label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  
-- local some images from Reaper  
reagirl.NextLine()  
image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

-- Buttons  
reagirl.NextLine(10)  
button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

-- open the new gui  
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

-- make the background grey  
reagirl.Background_GetSetColor(true, 55, 55, 55)  


function main()  
  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
  reagirl.Gui_Manage()  
    
  -- if the gui-window hasn&#39;t been closed, keep the script alive.  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
end  

main()  </code></pre>
<p>That looks much better, the upper part for labels is much easier to distinguish from the other parts.<br />
In the code, we added reagirl.Label_SetBackdrop(label_header, 290, 80) which started the label from the label with the element_\id label_header and a backdrop-size of 290 by 80 pixels.<br />
Let's add it for the other parts as well to see, if things get more easier to read with that.</p>
<p><img src="gfx/Tutorial9_3.png" title="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the &#39;Choose File&#39;-button." alt="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the &#39;Choose File&#39;-button." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_SetBackdrop(label_header, 290, 80)  
    
  -- Inputboxes  
  reagirl.NextLine()  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  reagirl.Label_SetBackdrop(label_header2, 290, 53)  
    
  -- Checkboxes  
  reagirl.NextLine()  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  reagirl.Label_SetBackdrop(label_header3, 290, 55)  
    
  -- Images  
  reagirl.NextLine()   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  reagirl.Label_SetBackdrop(label_header4, 290, 65)  

  -- Buttons  
  reagirl.NextLine(10)  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  
    </code></pre>
<p>This is even better. Each part is now separated from the other one. However, some are a little crammed to each other, so let's add some space by setting a margin into the function reagirl.NextLine() right above the labels with a backdrop "And some checkboxes" and "Or Images".<br />
That way, the gui "can breathe" a little bit better and give the user even more clear indication, where one section starts and where one section ends.</p>
<p><img src="gfx/Tutorial9_4.png" title="Screenshot of the gui-window with dozens of ui-elements. The label-backdrops which make up all the sections have now more space inbetween them so the gui can breathe a little better." alt="Screenshot of the gui-window with dozens of ui-elements. The label-backdrops which make up all the sections have now more space inbetween them so the gui can breathe a little better." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_SetBackdrop(label_header, 290, 80)  
    
  -- Inputboxes  
  reagirl.NextLine()  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  reagirl.Label_SetBackdrop(label_header2, 290, 53)  
    
  -- Checkboxes  
  reagirl.NextLine(8)  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  reagirl.Label_SetBackdrop(label_header3, 290, 55)  
    
  -- Images  
  reagirl.NextLine(9)   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  reagirl.Label_SetBackdrop(label_header4, 290, 65)  

  -- Buttons  
  reagirl.NextLine(10)  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  
    
    </code></pre>
<p>Ah, now each part is separated from the other one properly and has some margin, so the gui "can breathe" a little.<br />
So if you compare the first example in this tutorial with the final one, you see a huge improvement in readability.<br />
In this tutorial, I used autopositioning for the most ui-elements, but if you position the ui-elements "manually" by giving exact positions, the same things are valid.<br />
Use reagirl.Label_SetBackdrop() to create backdrops around ui-elements that you want to be seen together, usually the ones from the same context.<br />
And give some space between each of these backdrops, so each section is obviously separated from each other. This will make it easier for users to quickly see each section, glancing at the label of each section to get, if the section is important right now and ignore everything that is unimportant.</p>
<p>Also keep in mind: don't add other ui-elements at the same y-position as the label that shall start a backdrop. Otherwise your ui-element will have a line right through it from the backdrop.</p>
<p>In the next tutorial, I will show you, how to do the same with autopositioning. So if you can't place the backdrops by eye, you still have an option to structure your gui better.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning"></a>
<a href="#Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning"> ^</a> <u><b>Tutorial 010: Structuring Guis with Labels when autopositioning</b></u><br>			<p>
<div class="ch">
<p>In this tutorial, I will show you, how to structure guis with autopositioning.<br />
We will do the same as in the tutorial before: add backdrops around ui-elements to create sections in your gui and add spaces between these sections to make it easier to separate each section from each other by the user.</p>
<p>As a reminder: Backdrops are additional elements for labels. They are a rectangle that starts at half the height of the label and goes around until it ends again on the other side of the label.<br />
You can imagine this as a rectangle, that has a gap on the top at which the label-text is placed. The bottom ends under the last ui-elements of a section of ui-elements.<br />
Backdrops enclose ui-elements to make it easier to see, which ui-elements belong to each other.</p>
<p>Let's start with the same crowded gui from the previous tutorial.</p>
<p><img src="gfx/Tutorial10_1.png" title="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read." alt="Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read." /></p>
<pre><code>-- load ReaGirl into this script  
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

-- create new gui  
reagirl.Gui_New()  

-- now let&#39;s add all ui-elements of the first tab to table tab1  
 
-- Labels  
label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
 
reagirl.NextLine()  
label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
  
label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

reagirl.NextLine()  
label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
  
label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
  
label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                        -- let it end underneath label_large - the largest label  
-- Inputboxes  
reagirl.NextLine()  
label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
  
reagirl.NextLine()  
inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

reagirl.NextLine()  
button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
  
-- Checkboxes  
reagirl.NextLine()  
label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

reagirl.NextLine() -- first line of checkboxes  
checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
  
reagirl.NextLine() -- second line of checkboxes  
checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
  
-- Images  
reagirl.NextLine()   
label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
  
-- local some images from Reaper  
reagirl.NextLine()  
image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

-- Buttons  
reagirl.NextLine()  
button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

-- open the new gui  
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

-- make the background grey  
reagirl.Background_GetSetColor(true, 55, 55, 55)  


function main()  
  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
  reagirl.Gui_Manage()  
    
  -- if the gui-window hasn&#39;t been closed, keep the script alive.  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
end  

main()  </code></pre>
<p>Ooof, this is really hard to read. Let's create some backdrops to make it better, shall we?<br />
Let us start with the backdrop for the first section that starts with the label "Labels" with the element_id "label_header".<br />
In the previous tutorial, we defined specific coordinates for the backdrop. In this tutorial, we will specify a backdrop from a label to underneath a specific ui-element.<br />
For this, we use the function reagirl.Label_AutoBackdrop(). This accepts as first parameter the label at which the backdrop starts and the element_id of a second ui-element, under which the backdrop shall end.<br />
Let's do this for the first section called "Labels". We add reagirl.Label_AutoBackdrop() and let it start with the label "Labels" with the element_id label_header and end it underneath the label "and style" with the element_id label_medium_and_style.</p>
<p><img src="gfx/Tutorial10_2.png" title="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. However, the biggest label &#39;size&#39; is only half within the label-backdrop." alt="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. However, the biggest label &#39;size&#39; is only half within the label-backdrop." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_AutoBackdrop(label_header, label_medium_and_style)  
    
  -- Inputboxes  
  reagirl.NextLine()  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  -- Checkboxes  
  reagirl.NextLine()  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  -- Images  
  reagirl.NextLine()   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  -- Buttons  
  reagirl.NextLine()  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Hmm, this is close to what we want but not perfect. Most of the labels are within the backdrop but the label "size" is only halfway in it.<br />
This is due to the fact, that the we set the backdrop to a label that isn't the highest ui-element in that line "and style". However, we gave the label "size" a much bigger height than "and style" so we need to choose "size" as the ui-element, underneath it the backdrop ends.<br />
Let's do this by altering reagirl.Label_AutoBackdrop() to use "label_large"(the element_id of label "size") instead.</p>
<p><img src="gfx/Tutorial10_3.png" title="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. The biggest label &#39;size&#39; is now within the label-backdrop." alt="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. The biggest label &#39;size&#39; is now within the label-backdrop." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_AutoBackdrop(label_header, label_large)  
    
  -- Inputboxes  
  reagirl.NextLine()  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  -- Checkboxes  
  reagirl.NextLine()  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  -- Images  
  reagirl.NextLine()   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  -- Buttons  
  reagirl.NextLine()  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Ah, that looks much better. Now all labels are within the backdrop, since we end it underneath the biggest ui-element "size".<br />
This will usually not be a problem happening in your practice, since only labels and images can be higher than other ui-elements. But keep in mind that you need to keep track, if between two reagirl.NextLine()-functioncalls you have higher ui-elements than usual.<br />
If you do and you want to end a backdrop underneath them, use the highest ui-element as ending-point for the bottom border, which isn't neccessarily the last ui-element in the line!</p>
<p>Ok, let's add backdrops for the other sections too, shall we?</p>
<p><img src="gfx/Tutorial10_4.png" title="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the &#39;Choose File&#39;-button." alt="Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the &#39;Choose File&#39;-button." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_AutoBackdrop(label_header, label_large)  
    
  -- Inputboxes  
  reagirl.NextLine()  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  reagirl.Label_AutoBackdrop(label_header2, button_choose_file_id)  
    
  -- Checkboxes  
  reagirl.NextLine()  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  reagirl.Label_AutoBackdrop(label_header3, checkbox_remember)  
    
  -- Images  
  reagirl.NextLine()   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  reagirl.Label_AutoBackdrop(label_header4, image5)  

  -- Buttons  
  reagirl.NextLine()  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>Ahh, much easier on the eyes. And all we added was four times a reagirl.Label_AutoBackdrop()-functioncall to the gui.<br />
Now let's do one last step and add some space between each section, so the gui "can breathe" a little better.<br />
For this we add some margin of 10 into the reagirl.NextLine()-functioncalls above the labels "Inputboxes", "And some checkboxes" and "And Images".<br />
The first label "Labels" we don't move, since it's already at the top of the window.</p>
<p><img src="gfx/Tutorial10_5.png" title="Screenshot of the gui-window with dozens of ui-elements. The label-backdrops that make up the sections are now spaced better so the gui can &#39;breathe a little&#39;." alt="Screenshot of the gui-window with dozens of ui-elements. The label-backdrops that make up the sections are now spaced better so the gui can &#39;breathe a little&#39;." /></p>
<pre><code>  -- load ReaGirl into this script  
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)  

  -- create new gui  
  reagirl.Gui_New()  

  -- now let&#39;s add all ui-elements of the first tab to table tab1  
   
  -- Labels  
  label_header=reagirl.Label_Add(nil, nil, &quot;Labels&quot;, &quot;Possible labels with ReaGirl.&quot;, false, nil)  
   
  reagirl.NextLine()  
  label_regular=reagirl.Label_Add(nil, nil, &quot;Example label&quot;, &quot;A regular label.&quot;, false, nil)  
  label_clickable=reagirl.Label_Add(nil, nil, &quot;Clickable label&quot;, &quot;A clickable label.&quot;, true, nil)  
    
  label_styled=reagirl.Label_Add(nil, nil, &quot;Styled label&quot;, &quot;A styled label.&quot;, false, nil)  
  reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  

  reagirl.NextLine()  
  label_small=reagirl.Label_Add(nil, nil, &quot;different&quot;, &quot;Label with small font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
    
  label_medium=reagirl.Label_Add(nil, nil, &quot;font&quot;, &quot;Label with medium font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
    
  label_large=reagirl.Label_Add(nil, nil, &quot;size&quot;, &quot;Label with large font-size.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  

  label_medium_and_style=reagirl.Label_Add(nil, nil, &quot;and style&quot;, &quot;Label with medium font-size and some styles.&quot;, false, nil)  
  reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
  reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                          -- let it end underneath label_large - the largest label  
                                                            
  reagirl.Label_AutoBackdrop(label_header, label_large)  
    
  -- Inputboxes  
  reagirl.NextLine(10)  
  label_header2=reagirl.Label_Add(nil, nil, &quot;Inputboxes&quot;, &quot;Some demo-inputboxes.&quot;, false, nil)  
    
  reagirl.NextLine()  
  inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, &quot;Name:&quot;, 90, &quot;Type in here the name of the setting.&quot;, &quot;No title&quot;, nil, nil)  

  reagirl.NextLine()  
  button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, &quot;Choose file&quot;, &quot;Choose a file.&quot;, nil) -- a button  
    
  reagirl.Label_AutoBackdrop(label_header2, button_choose_file_id)  
    
  -- Checkboxes  
  reagirl.NextLine(10)  
  label_header3=reagirl.Label_Add(nil, nil, &quot;And some checkboxes&quot;, &quot;Some checkboxes in ReaGirl.&quot;, false, nil)  

  reagirl.NextLine() -- first line of checkboxes  
  checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, &quot;My setting&quot;, &quot;The first checkbox.&quot;, true, nil)  
  checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, &quot;Another setting&quot;, &quot;The second checkbox.&quot;, true, nil)  
    
  reagirl.NextLine() -- second line of checkboxes  
  checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, &quot;Extra&quot;, &quot;A third checkbox?&quot;, true, nil)  
  checkbox_remember = reagirl.Checkbox_Add(108, nil, &quot;Remember chosen setting&quot;, &quot;Shall this setting be used as future default?&quot;, true, nil)  
    
  reagirl.Label_AutoBackdrop(label_header3, checkbox_remember)  
    
  -- Images  
  reagirl.NextLine(10)   
  label_header4=reagirl.Label_Add(nil, nil, &quot;Or Images&quot;, &quot;Set the settings, as you wish.&quot;, false, nil)  
    
  -- local some images from Reaper  
  reagirl.NextLine()  
  image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/idea.png&quot;, &quot;An idea-cloud&quot;, &quot;An image of an idea-thought-cloud.&quot;, nil)  
  image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/envelope.png&quot;, &quot;An envelope&quot;, &quot;An image of an envelope.&quot;, nil)  
  image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/ff.png&quot;, &quot;ff notation symbol&quot;, &quot;An image of a ff-notation-symbol.&quot;, nil)  
  image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/folder_up.png&quot;, &quot;A folder up&quot;, &quot;An image of a folder with an arrow pointing up.&quot;, nil)  
  image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath()..&quot;/Data/track_icons/bass_clef.png&quot;, &quot;A bass clef&quot;, &quot;An image of a bass clef.&quot;, nil)  

  reagirl.Label_AutoBackdrop(label_header4, image5)  

  -- Buttons  
  reagirl.NextLine(10)  
  button_ok_id = reagirl.Button_Add(205, nil, 0, 0, &quot;OK&quot;, &quot;Apply changes and close dialog.&quot;, nil)  
  button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, &quot;Cancel&quot;, &quot;Discard changes and close dialog.&quot;, nil)  

  -- open the new gui  
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;The dialog&quot;, &quot;This is a demo dialog with settings for tool xyz.&quot;)  

  -- make the background grey  
  reagirl.Background_GetSetColor(true, 55, 55, 55)  


  function main()  
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
    reagirl.Gui_Manage()  
      
    -- if the gui-window hasn&#39;t been closed, keep the script alive.  
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
  end  

  main()  </code></pre>
<p>And that's it. We added backdrops for each section of ui-elements, so it's easier to separate them from each other, using autopositioning and reagirl.Label_AutoBackdrop() and added space between each section with reagirl.NextLine(10).</p>
<p>For blind scripters: this can be confusing in the beginning, so get some feedback from sighted users for your scripts that use label-backdrops.<br />
That way you can improve on potential wrongfully positioned backdrops. Once you got a grip on how to achieve this, you'll be able to do it without feedback too.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_011_Linking_UI_Elements_To_States"></a>
<a href="#Tutorial_011_Linking_UI_Elements_To_States"> ^</a> <u><b>Tutorial 011: Linking UI-elements to states</b></u><br>			<p>
<div class="ch">
<p>In ReaGirl, you can link many of the ui-elements to states like toggle-command-states, extstates, ini-file-entries or config-variables. That means: if the state is updated by something, the ui-element is updated immediately and clicking/altering the ui-element updates the state is is linked to immediately as well. With that, you can easily create guis that alter configuration-settings without having to think about it a lot. Let me show you an example by linking a checkbox to the toggle-state of the loop-button-action.</p>
<p>We start with the basic gui containing one checkbox:</p>
<pre><code>    -- 0. enable ReaGirl for the script
    dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

    -- 1. add the run-functions for the ui-elements
    function checkbox_run_function()
    end

    -- 2. start a new gui
    reagirl.Gui_New()

    -- 3. add the checkbox, that shall display the toggle-state of the loop-action
    checkbox_id = reagirl.Checkbox_Add(10, 10, &quot;Loop-State&quot;, &quot;Shows the state of the loop-button.\nGets immediately updated when the loop-button is clicked/the loop-action is run.&quot;, true, checkbox_run_function)

    -- 4. open the gui
    reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

    -- 5. start the gui with the manage-function, whose parameter is set to true
    reagirl.Gui_Manage(true)</code></pre>
<p><img src="gfx/Tutorial11_1.png" title="A window with one checkbox that reads &quot;Loop-State&quot; in the caption" alt="A window with one checkbox that reads &quot;Loop-State&quot; in the caption." /></p>
<p>This shows a nice little window with one checkbox, but clicking it does nothing to the loop-button.<br />
So let's add one new line, a functioncall to reagirl.Checkbox_LinkToToggleState() directly after the Checkbox_Add-function. We link it to the action "Transport: Toggle repeat" with command-id 1068 in the main-section(0) and we set the last parameter to true that signals, that toggling the checkbox shall run the linked action to change the toggle-state(some actions require this, more about this later).<br />
Ok, let's see, how the code looks now with the new line:</p>
<pre><code>    -- 0. enable ReaGirl for the script
    dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

    -- 1. add the run-functions for the ui-elements
    function checkbox_run_function()
    end

    -- 2. start a new gui
    reagirl.Gui_New()

    -- 3. add the checkbox, that shall display the toggle-state of the loop-action
    checkbox_id = reagirl.Checkbox_Add(10, 10, &quot;Loop-State&quot;, &quot;Shows the state of the loop-button.\nGets immediately updated when the loop-button is clicked/the loop-action is run.&quot;, true, checkbox_run_function)
    reagirl.Checkbox_LinkToToggleState(checkbox_id, 0, 1068, true)

    -- 4. open the gui
    reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

    -- 5. start the gui with the manage-function, whose parameter is set to true
    reagirl.Gui_Manage(true)</code></pre>
<p>Looking good, so let's run it and check, what happens, when we toggle the checkbox and the loop-button.</p>
<p><img src="gfx/Tutorial11_2.gif" title="A window with one checkbox that reads &quot;Loop-State&quot; in the caption. Toggling the checkbox toggles the loop-button-state as well. Toggling the loop-button toggles the checkbox-state as well." alt="A window with one checkbox that reads &quot;Loop-State&quot; in the caption. Toggling the checkbox toggles the loop-button-state as well. Toggling the loop-button toggles the checkbox-state as well." /></p>
<p>Nice. With just one additional line, we made the checkbox behaving according to the loop-button. And it even works, when you run the loop-action from the actionlist or from a shortcut: the checkbox is toggled accordingly.</p>
<p>Note: as I said, some actions need to be run for the toggle-state to change. In that case, set the last parameter of reagirl.Checkbox_LinkToToggleState() to true. If you need to set the last parameter to true or false depends on how the action actually works. Best is to check first with false and see, if the behavior is as you expected. If not, set it to true and test it again. This should work most of the times.</p>
<p>As mentioned, you can link ui-elements to toggle-states(checkboxes), ext-states(checkbox, dropdownmenu, slider, inputbox), ini-file-entries(checkbox, dropdownmenu, slider, inputbox), integer-bitfield-config-variables(checkbox), integer/double config-variables(slider), string config-variables(inputbox). And everytime the linked-state is updated, the ui-element gets updated and when the ui-element gets updated, the state gets updated immediately too.</p>
<p>And to unlink a ui-element from a ui-element, use the _UnLink() functions, like reagirl.Checkbox_UnLink() for checkboxes.</p>
<p>This should make things real easy for you, when making guis with certain settings available in one spot.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_012_Sticky_UI_Elements"></a>
<a href="#Tutorial_012_Sticky_UI_Elements"> ^</a> <u><b>Tutorial 012: Sticky UI-elements</b></u><br>			<p>
<div class="ch">
<p>ReaGirl has the option to make ui-elements sticky. That means, that they will not be scrolled around and stick to their initial place when the users scrolls the gui.<br />
You can choose, whether to prevent horizontal scrolling, vertical scrolling or both.<br />
In the following tutorial, we will see, how to make sticky ui-elements possible.</p>
<p>Let's start with a basic gui, that has two inputboxes, one at the top and one at the bottom.</p>
<pre><code>        -- 0. enable ReaGirl for the script
            dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)


        -- 1. add the run-functions for the ui-elements
            function checkbox_run_function()
            end
            
            function inputbox_run_function_enter()
            end
            
            function inputbox_run_function_type()
            end


        -- 2. start a new gui
            reagirl.Gui_New()


        -- 3. add the ui-elements and set their attributes

        -- add the inputbox and background decorative rectangle to the top of the window
        -- inputbox
            inputbox = reagirl.Inputbox_Add(-220, 6, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;Test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)

        -- add the inputbox and background decorative rectangle to the bottom of the window
        -- inputbox
            inputbox2 = reagirl.Inputbox_Add(-220, -35, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;More test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)

        -- 4. open the gui
            reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, 235, 225, nil, nil, nil)


        -- 5. a main-function that runs the gui-management-function
            function main()
                reagirl.Gui_Manage()
            
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
            end
            
            main()</code></pre>
<p><img src="gfx/Tutorial12_01.png" title="A window with tow inputboxes that read &quot;InputBox&quot; as caption and &quot;Test text&quot; and &quot;More test text&quot; as their values." alt="A window with tow inputboxes that read &quot;InputBox&quot; as caption and &quot;Test text&quot; and &quot;More test text&quot; as their values." /></p>
<p>This doesn't scroll at all, so let's add 100 checkboxes to the code, which looks like this:</p>
<pre><code>        -- 0. enable ReaGirl for the script
            dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)


        -- 1. add the run-functions for the ui-elements
            function checkbox_run_function()
            end
            
            function inputbox_run_function_enter()
            end
            
            function inputbox_run_function_type()
            end


        -- 2. start a new gui
            reagirl.Gui_New()


        -- 3. add the ui-elements and set their attributes

        -- add the inputbox and background decorative rectangle to the top of the window
        -- inputbox
            inputbox = reagirl.Inputbox_Add(-220, 6, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;Test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)

        -- add the inputbox and background decorative rectangle to the bottom of the window
        -- inputbox
            inputbox2 = reagirl.Inputbox_Add(-220, -35, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;More test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)

        -- add some checkboxes
            checkboxes={}
        -- add the first checkbox with a fixed position
            checkboxes[1]=reagirl.Checkbox_Add(10, 35, &quot;Checkbox #1&quot;, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
        -- add all the other checkboxes with autopositioning
            for i=2, 100 do
                reagirl.NextLine()
                checkboxes[i]=reagirl.Checkbox_Add(10, nil, &quot;Checkbox #&quot;..i, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
            end

        -- 4. open the gui
            reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, 235, 225, nil, nil, nil)


        -- 5. a main-function that runs the gui-management-function
            function main()
                reagirl.Gui_Manage()
            
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
            end
            
            main()</code></pre>
<p><img src="gfx/Tutorial12_02.gif" title="The same window with 100 additional checkboxes, that are scrolled around. The inputboxes are scrolled with them." alt="The same window with 100 additional checkboxes, that are scrolled around. The inputboxes are scrolled with them." /></p>
<p>What you'll quickly notice is, that the inputboxes are scrolling around with the checkboxes. So let's prevent that.</p>
<p>For this, we need the function reagirl.UI_Element_GetSetSticky(), which we will use for the inputboxes. It has four parameters.<br />
First, the element_id of the ui-element that we want to set to sticky, in our case inputbox and inputbox2.<br />
The second parameter is either true for setting or false for getting the stickyness of a ui-element.<br />
The last two parameters decide, whether the scrolling of the sticky ui-element shall be prevented for the horizontal and/or the vertical direction respectively.<br />
In this tutorial, we set, that the inputboxes shall scroll horizontally(false) but not vertically(true).</p>
<p>The code looks like this:</p>
<pre><code>        -- 0. enable ReaGirl for the script
            dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)


        -- 1. add the run-functions for the ui-elements
            function checkbox_run_function()
            end
            
            function inputbox_run_function_enter()
            end
            
            function inputbox_run_function_type()
            end


        -- 2. start a new gui
            reagirl.Gui_New()


        -- 3. add the ui-elements and set their attributes

        -- add the inputbox and background decorative rectangle to the top of the window
        -- inputbox
            inputbox = reagirl.Inputbox_Add(-220, 6, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;Test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox, true, false, true) -- set the inputbox at the top to sticky
            
        -- add the inputbox and background decorative rectangle to the bottom of the window
        -- inputbox
            inputbox2 = reagirl.Inputbox_Add(-220, -35, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;More test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox2, true, false, true) -- set the inputbox at the bottom to sticky

        -- add some checkboxes
            checkboxes={}
        -- add the first checkbox with a fixed position
            checkboxes[1]=reagirl.Checkbox_Add(10, 35, &quot;Checkbox #1&quot;, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
        -- add all the other checkboxes with autopositioning
            for i=2, 100 do
                reagirl.NextLine()
                checkboxes[i]=reagirl.Checkbox_Add(10, nil, &quot;Checkbox #&quot;..i, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
            end

        -- 4. open the gui
            reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, 235, 225, nil, nil, nil)


        -- 5. a main-function that runs the gui-management-function
            function main()
                reagirl.Gui_Manage()
            
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
            end
            
            main()</code></pre>
<p><img src="gfx/Tutorial12_03.gif" title="The same window, whose checkboxes are scrolled around and tabbed through. The inputboxes stay at the same position. Some ui-elements get stuck behind inputboxes." alt="The same window, whose checkboxes are scrolled around and tabbed through. The inputboxes stay at the same position. Some ui-elements get stuck behind inputboxes." /></p>
<p>Yeah, this looks much better. However, when scrolling around or using the tab-key, you'll quickly notice, that ui-elements can become stuck behind the sticky inputboxes.<br />
But there's a solution for this: sticky offsets.<br />
Sticky offsets are offsets at the top or at the bottom of the window, where you can define, how much space the sticky ui-elements need. Once defined, scrolling and tabbing will always put the ui-elements into view and prevent them from being hidden behind.<br />
For this, we need the function reagirl.Gui_GetSetStickyOffset(), which has three parameters. First, if you want to set the offsets(true) or get the currently added offsets(false), then the offset in pixels from the top and from the bottom respectively.</p>
<p>So let's add the offsets:</p>
<pre><code>        -- 0. enable ReaGirl for the script
            dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)


        -- 1. add the run-functions for the ui-elements
            function checkbox_run_function()
            end
            
            function inputbox_run_function_enter()
            end
            
            function inputbox_run_function_type()
            end


        -- 2. start a new gui
            reagirl.Gui_New()


        -- 3. add the ui-elements and set their attributes

        -- add the inputbox and background decorative rectangle to the top of the window
        -- inputbox
            inputbox = reagirl.Inputbox_Add(-220, 6, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;Test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox, true, false, true) -- set the inputbox at the top to sticky
            
        -- add the inputbox and background decorative rectangle to the bottom of the window
        -- inputbox
            inputbox2 = reagirl.Inputbox_Add(-220, -35, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;More test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox2, true, false, true) -- set the inputbox at the bottom to sticky

        -- add some checkboxes
            checkboxes={}
        -- add the first checkbox with a fixed position
            checkboxes[1]=reagirl.Checkbox_Add(10, 35, &quot;Checkbox #1&quot;, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
        -- add all the other checkboxes with autopositioning
            for i=2, 100 do
                reagirl.NextLine()
                checkboxes[i]=reagirl.Checkbox_Add(10, nil, &quot;Checkbox #&quot;..i, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
            end
            
        -- set a scrolling/tabbing offset to the top and the bottom of the window, so ui-elements
        -- don&#39;t get stuck behind the sticky ui-elements
            reagirl.Gui_GetSetStickyOffset(true, 35, 25)

        -- 4. open the gui
            reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, 235, 225, nil, nil, nil)


        -- 5. a main-function that runs the gui-management-function
            function main()
                reagirl.Gui_Manage()
            
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
            end
            
            main()</code></pre>
<p><img src="gfx/Tutorial12_04.gif" title="The same window, whose checkboxes are scrolled around and tabbed through. The inputboxes stay at the same position. The ui-elements never get stuck behind inputboxes now." alt="The same window, whose checkboxes are scrolled around and tabbed through. The inputboxes stay at the same position. The ui-elements never get stuck behind inputboxes now." /></p>
<p>Great, that looks much better.</p>
<p>Now the ui-elements do not get stuck behind the inputboxes, which is fantastic.</p>
<p>But there's still one bad thing, though: the caption of the inputboxes is hard to read when checkboxes are behind them.<br />
For this, we use a feature of ReaGirl, called DecorRectangles.</p>
<p>These are decorative rectangles that are just drawn but can't be selected or clicked. If we put them behind the input-boxes, the captions will become readable.<br />
reagirl.DecorRectangle_Add() has 8 parameters. First, x, y, width and height and then the radius of the edges of the rectangle. The last three parameters are the color-r, g, b-values.<br />
We can also set the individual edges of the decorative rectangle to square or rounded with the additional function reagirl.DecorRectangle_SetEdgeStyle(). That way, we can have the bottom edges of the top and the top edges of the bottom rectangle rounded, which looks much nicer.</p>
<p>With this, we can add these decorative rectangles behind the inputboxes to make the captions readable.<br />
We also need to set these rectangles to sticky, so they don't scroll around.</p>
<p>So let's fix the caption issue, shall we?</p>
<pre><code>        -- 0. enable ReaGirl for the script
            dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)


        -- 1. add the run-functions for the ui-elements
            function checkbox_run_function()
            end
            
            function inputbox_run_function_enter()
            end
            
            function inputbox_run_function_type()
            end


        -- 2. start a new gui
            reagirl.Gui_New()


        -- 3. add the ui-elements and set their attributes

        -- add the inputbox and background decorative rectangle to the top of the window
        -- inputbox
            inputbox = reagirl.Inputbox_Add(-220, 6, 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;Test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox, true, false, true) -- set the inputbox at the top to sticky
            -- decorative rectangle
            decorect=reagirl.DecorRectangle_Add(-230, 0, 220, 30, 10, 40, 40, 40)    -- add decorative rectangle to the top
            reagirl.UI_Element_GetSetSticky(decorect, true, false, true)             -- set decorative rectangle sticky
            reagirl.DecorRectangle_SetEdgeStyle(decorect, true, false, true, false)  -- set top edges square

        -- add the inputbox and background decorative rectangle to the bottom of the window
        -- inputbox
            inputbox2 = reagirl.Inputbox_Add(-220, -35 200, &quot;InputBox&quot;, 50, &quot;.&quot;, &quot;More test text&quot;, inputbox_run_function_enter, inputbox_run_function_type)
            reagirl.UI_Element_GetSetSticky(inputbox2, true, false, true) -- set the inputbox at the bottom to sticky
            -- decorative rectangle
            decorect2=reagirl.DecorRectangle_Add(-230, -42, 220, 30, 10, 40, 40, 40) -- add decorative rectangle to the bottom
            reagirl.UI_Element_GetSetSticky(decorect2, true, false, true)            -- set decorative rectangle sticky
            reagirl.DecorRectangle_SetEdgeStyle(decorect2, false, true, false, true) -- set bottom edges square

        -- add some checkboxes
            checkboxes={}
        -- add the first checkbox with a fixed position
            checkboxes[1]=reagirl.Checkbox_Add(10, 35, &quot;Checkbox #1&quot;, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
        -- add all the other checkboxes with autopositioning
            for i=2, 100 do
                reagirl.NextLine()
                checkboxes[i]=reagirl.Checkbox_Add(10, nil, &quot;Checkbox #&quot;..i, &quot;A demo checkbox.&quot;, true, checkbox_run_function)
            end

        -- set a scrolling/tabbing offset to the top and the bottom of the window, so ui-elements
        -- don&#39;t get stuck behind the sticky ui-elements
            reagirl.Gui_GetSetStickyOffset(true, 35, 25)


        -- 4. open the gui
            reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, 235, 225, nil, nil, nil)


        -- 5. a main-function that runs the gui-management-function
            function main()
                reagirl.Gui_Manage()
            
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
            end
            
            main()</code></pre>
<p><img src="gfx/Tutorial12_05.gif" title="The ui-elements never get stuck behind inputboxes now and the captions of the inputbox is now readable thanks to the decorative rectangle." alt="The same window, whose checkboxes are scrolled around and tabbed through. The inputboxes stay at the same position. The ui-elements never get stuck behind inputboxes now and the captions of the inputbox is now readable thanks to the decorative rectangle." /></p>
<p>Ahh, no we're talking.<br />
The caption is now readable, thanks to the decorative rectangles. They are also sticky and have some of the edges rounded and others square. With this, the gui is finished.</p>
<p>A note for blind scripters: if you want to place a decorative rectangle, put the x and y-position a few pixels left and above the ui-element(s) that shall be backed up by it. Set the width and height to the lowest and most right edges of the lowest and most right ui-element AND: add the number of pixels*2 you positioned it to the left and top. So if you place the rectangle 3 pixels from the left and 3 pixesl from the top of the first ui-element, add to the width and height 3*2 pixels. That way, it will always look properly positioned.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_013_Meters"></a>
<a href="#Tutorial_013_Meters"> ^</a> <u><b>Tutorial 013: Meters for tracks and hardware inputs</b></u><br>			<p>
<div class="ch">
<p>In ReaGirl, you can add level-meters. These are meters, as you are used from the mixer or the track control panel, that show the levels. You can show meters for tracks(including the main-track) and hardware inputs. When you have set a track to multichannel, the meters will reflect this immediately.</p>
<p>So how to add meters to your script? Well, I will show you. We will write a script with tabs, where the first tab shows multiple meters, one vertical one for the main track and five horizontal ones for track 1 to 5. The second tab will show meters for the first five hardware inputs. So as soon as we have the script ready, you can monitor them as you wish.</p>
<p>Let's start with the first part of the script, the tabs.</p>
<pre><code>  -- 0. enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
  -- check for required version; alter the version-number if necessary
  if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

  -- 1. add the run-functions for the ui-elements

  -- 2. start a new gui
  reagirl.Gui_New()

  -- 3. add the ui-elements and set their attributes
  tabs=reagirl.Tabs_Add(nil, nil, nil, -20, &quot;Tabs&quot;, &quot;Some meters.&quot;, {&quot;Track-meters&quot;, &quot;Hardware Inputs&quot;}, 1, nil)
  track_meters={} -- the table for all track-meters in tab 1
  hardware_meters={} -- the table for all hardware-input-meters in tab 2
  reagirl.Tabs_SetUIElementsForTab(tabs, 1, track_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1
  reagirl.Tabs_SetUIElementsForTab(tabs, 2, hardware_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1

  -- 4. open the gui
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, 360, nil, nil, nil)

  -- 5. a main-function that runs the gui-management-function
  function main()
  reagirl.Gui_Manage()

  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end
  main()</code></pre>
<p><img src="gfx/Tutorial13_01.png" title="Two empty tabs, with the first that will be for track-meters and the second for hardware input-meters." alt="Two empty tabs, with the first that will be for track-meters and the second for hardware input-meters." /></p>
<p>Ok, let's populate the first tab with a meter for the main track. We add the meter with reagirl.Meter_Add(). In an earlier tutorial, you learnt about linking of ui-elements. With meters, it is possible to link a meter to either a track or a hardware input. In this case, we will link this newly added meter to track 0, which is the main-track. Look at reagirl.Meter_Add() which adds the meter and reagirl.Meter_LinkToTrack() which links the meter to the main track. In that, the first parameter is the element_id of the meter, that you want to link and the second the track, with 0 for the main track and 1 and higher for track 1 and higher. So let's add a first meter and to make things nicer, let's add a label, which signals that it's the main track.</p>
<pre><code>  -- 0. enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
  -- check for required version; alter the version-number if necessary
  if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

  -- 1. add the run-functions for the ui-elements

  -- 2. start a new gui
  reagirl.Gui_New()

  -- 3. add the ui-elements and set their attributes
  tabs=reagirl.Tabs_Add(nil, nil, nil, -20, &quot;Tabs&quot;, &quot;Some meters.&quot;, {&quot;Track-meters&quot;, &quot;Hardware Inputs&quot;}, 1, nil)
  track_meters={} -- the table for all track-meters in tab 1
  hardware_meters={} -- the table for all hardware-input-meters in tab 2
  reagirl.Tabs_SetUIElementsForTab(tabs, 1, track_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1
  reagirl.Tabs_SetUIElementsForTab(tabs, 2, hardware_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1

  -- UI-elements in tab 1
  -- the meter for the main track
  track_meters.main_track_label = reagirl.Label_Add(20, 50, &quot;Main track&quot;, &quot;The main track.&quot;, false)
  
  track_meters.main_track_meter = reagirl.Meter_Add(20, 70, 60, -50, 3, &quot;Main track&quot;, &quot;The levels of the main track.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.main_track_meter, 1)

  -- 4. open the gui
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, 360, nil, nil, nil)

  -- 5. a main-function that runs the gui-management-function
  function main()
  reagirl.Gui_Manage()

  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end
  main()</code></pre>
<p><img src="gfx/Tutorial13_02.gif" title="The first tab, with one vertical meter for the main track. It shows the amplitude of the main track, which will change, while the fader of the main-track is adjusted." alt="The first tab, with one vertical meter for the main track. It shows the amplitude of the main track, which will change, while the fader of the main-track is adjusted." /></p>
<p>If you playback now a project, you will notice, that the main track is linked to the meter of the gui. Adjust the volume-fader of the main track to see the changes reflected in the meter of the gui as well. Nice. Now, let's add additional meters for track 1-5. We will do it the same like we did with the main-track: reagirl.Meter_Add() for adding them, reagirl.Meter_LinkToTrack() for linking them to track 1-5. The linked track is 1 for the first, 2 for the second, etc. Let's see, how it looks now.</p>
<pre><code>  -- 0. enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
  -- check for required version; alter the version-number if necessary
  if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

  -- 1. add the run-functions for the ui-elements

  -- 2. start a new gui
  reagirl.Gui_New()

  -- 3. add the ui-elements and set their attributes
  tabs=reagirl.Tabs_Add(nil, nil, nil, -20, &quot;Tabs&quot;, &quot;Some meters.&quot;, {&quot;Track-meters&quot;, &quot;Hardware Inputs&quot;}, 1, nil)
  track_meters={} -- the table for all track-meters in tab 1
  hardware_meters={} -- the table for all hardware-input-meters in tab 2
  reagirl.Tabs_SetUIElementsForTab(tabs, 1, track_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1
  reagirl.Tabs_SetUIElementsForTab(tabs, 2, hardware_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1

  -- UI-elements in tab 1
  -- the meter for the main track
  track_meters.main_track_label = reagirl.Label_Add(20, 50, &quot;Main track&quot;, &quot;The main track.&quot;, false)
  track_meters.main_track_meter = reagirl.Meter_Add(20, 70, 60, -50, 3, &quot;Main track&quot;, &quot;The levels of the main track.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.main_track_meter, 0)

  -- the meters for tracks 1-5
  track_meters.track_label = reagirl.Label_Add(90, 50, &quot;Track 1-5&quot;, &quot;Tracks 1-5.&quot;, false)

  track_meters.track_1_meter = reagirl.Meter_Add(90, 70,  -30, 40, 2, &quot;Track 1&quot;, &quot;The levels of the track 1.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_1_meter, 1)

  track_meters.track_2_meter = reagirl.Meter_Add(90, 120, -30, 40, 2, &quot;Track 2&quot;, &quot;The levels of the track 2.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_2_meter, 2)

  track_meters.track_3_meter = reagirl.Meter_Add(90, 170, -30, 40, 2, &quot;Track 3&quot;, &quot;The levels of the track 3.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_3_meter, 3)

  track_meters.track_4_meter = reagirl.Meter_Add(90, 220, -30, 40, 2, &quot;Track 4&quot;, &quot;The levels of the track 4.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_4_meter, 4)

  track_meters.track_5_meter = reagirl.Meter_Add(90, 270, -30, 40, 2, &quot;Track 5&quot;, &quot;The levels of the track 5.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_5_meter, 5)

  -- 4. open the gui
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, 360, nil, nil, nil)

  -- 5. a main-function that runs the gui-management-function
  function main()
  reagirl.Gui_Manage()

  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end
  main()</code></pre>
<p><img src="gfx/Tutorial13_03.gif" title="The first tab, with one vertical meter for the main track in the first column and five horizontal meters for track 1 through 5 in the second column. Adjusting the faders also affects the corresponding tracks." alt="The first tab, with one vertical meter for the main track in the first column and five horizontal meters for track 1 through 5 in the second column. Adjusting the faders also affects the corresponding tracks." /></p>
<p>Nice, looking good. We have now meters for the main track and track 1 through 5. When we playback the project and adjust the faders of the tracks, the meters will show theses changes as well.</p>
<p>Ok, we added meters for tracks but how about adding some for the hardware inputs as well into the second tab? It's basically the same as before, but for linking the meters to a hardware input, we use reagirl.Meter_LinkToHWInput(). Everything else is the same: first parameter is the element_id of the meter and the second is the hardware input with 1 for the first, 2 for the second, etc. So let's add a meter for the first hardware input to the second tab, shall we?</p>
<pre><code>  -- 0. enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
  -- check for required version; alter the version-number if necessary
  if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

  -- 1. add the run-functions for the ui-elements

  -- 2. start a new gui
  reagirl.Gui_New()

  -- 3. add the ui-elements and set their attributes
  tabs=reagirl.Tabs_Add(nil, nil, nil, -20, &quot;Tabs&quot;, &quot;Some meters.&quot;, {&quot;Track-meters&quot;, &quot;Hardware Inputs&quot;}, 1, nil)
  track_meters={} -- the table for all track-meters in tab 1
  hardware_meters={} -- the table for all hardware-input-meters in tab 2
  reagirl.Tabs_SetUIElementsForTab(tabs, 1, track_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1
  reagirl.Tabs_SetUIElementsForTab(tabs, 2, hardware_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1

  -- UI-elements in tab 1
  -- the meter for the main track
  track_meters.main_track_label = reagirl.Label_Add(20, 50, &quot;Main track&quot;, &quot;The main track.&quot;, false)
  track_meters.main_track_meter = reagirl.Meter_Add(20, 70, 60, -50, 3, &quot;Main track&quot;, &quot;The levels of the main track.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.main_track_meter, 0)

  -- the meters for tracks 1-3
  track_meters.track_label = reagirl.Label_Add(90, 50, &quot;Track 1-5&quot;, &quot;Tracks 1-5.&quot;, false)

  track_meters.track_1_meter = reagirl.Meter_Add(90, 70,  -30, 40, 2, &quot;Track 1&quot;, &quot;The levels of the track 1.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_1_meter, 1)

  track_meters.track_2_meter = reagirl.Meter_Add(90, 120, -30, 40, 2, &quot;Track 2&quot;, &quot;The levels of the track 2.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_2_meter, 2)

  track_meters.track_3_meter = reagirl.Meter_Add(90, 170, -30, 40, 2, &quot;Track 3&quot;, &quot;The levels of the track 3.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_3_meter, 3)

  track_meters.track_4_meter = reagirl.Meter_Add(90, 220, -30, 40, 2, &quot;Track 4&quot;, &quot;The levels of the track 4.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_4_meter, 4)

  track_meters.track_5_meter = reagirl.Meter_Add(90, 270, -30, 40, 2, &quot;Track 5&quot;, &quot;The levels of the track 5.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_5_meter, 5)

  -- UI-elements in tab 2
  -- a label
  hardware_meters.hardware_inputs = reagirl.Label_Add(20, 50, &quot;Hardware input 1&quot;, &quot;Hardware inputs 1.&quot;, false)

  -- the meters for hardware input 1
  hardware_meters.track_1_meter = reagirl.Meter_Add(20, 70,  -30, 40, 2, &quot;Hardware input 1&quot;, &quot;The levels of hardware input 1.&quot;)
  reagirl.Meter_LinkToHWInput(hardware_meters.track_1_meter, 1)

  -- 4. open the gui
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, 360, nil, nil, nil)

  -- 5. a main-function that runs the gui-management-function
  function main()
  reagirl.Gui_Manage()

  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end
  main()
  </code></pre>
<p><img src="gfx/Tutorial13_04.gif" title="The second tab showing one horizontal meter for hardware input 1. It&#39;s column is showing input-signal of the hardware input." alt="The second tab showing one horizontal meter for hardware input 1. It&#39;s column is showing input-signal of the hardware input." /></p>
<p>Now we have a meter for hardware input 1. When we send in a signal into hardware input 1, the meter is showing the signal. Nice. So, for a nice finishing touch, let's add two more meters for hardware input 2 and 3. The drill is the same as with hardware input 1, we just use 2 and 3 respectively.</p>
<pre><code>  -- 0. enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
  -- check for required version; alter the version-number if necessary
  if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

  -- 1. add the run-functions for the ui-elements

  -- 2. start a new gui
  reagirl.Gui_New()

  -- 3. add the ui-elements and set their attributes
  tabs=reagirl.Tabs_Add(nil, nil, nil, -20, &quot;Tabs&quot;, &quot;Some meters.&quot;, {&quot;Track-meters&quot;, &quot;Hardware Inputs&quot;}, 1, nil)
  track_meters={} -- the table for all track-meters in tab 1
  hardware_meters={} -- the table for all hardware-input-meters in tab 2
  reagirl.Tabs_SetUIElementsForTab(tabs, 1, track_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1
  reagirl.Tabs_SetUIElementsForTab(tabs, 2, hardware_meters) -- associate ui-elements of table &quot;tab1&quot; with tab 1

  -- UI-elements in tab 1
  -- the meter for the main track
  track_meters.main_track_label = reagirl.Label_Add(20, 50, &quot;Main track&quot;, &quot;The main track.&quot;, false)
  track_meters.main_track_meter = reagirl.Meter_Add(20, 70, 60, -50, 3, &quot;Main track&quot;, &quot;The levels of the main track.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.main_track_meter, 0)

  -- the meters for tracks 1-5
  track_meters.track_label = reagirl.Label_Add(90, 50, &quot;Track 1-5&quot;, &quot;Tracks 1-5.&quot;, false)

  track_meters.track_1_meter = reagirl.Meter_Add(90, 70,  -30, 40, 2, &quot;Track 1&quot;, &quot;The levels of the track 1.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_1_meter, 1)

  track_meters.track_2_meter = reagirl.Meter_Add(90, 120, -30, 40, 2, &quot;Track 2&quot;, &quot;The levels of the track 2.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_2_meter, 2)

  track_meters.track_3_meter = reagirl.Meter_Add(90, 170, -30, 40, 2, &quot;Track 3&quot;, &quot;The levels of the track 3.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_3_meter, 3)

  track_meters.track_4_meter = reagirl.Meter_Add(90, 220, -30, 40, 2, &quot;Track 4&quot;, &quot;The levels of the track 4.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_4_meter, 4)

  track_meters.track_5_meter = reagirl.Meter_Add(90, 270, -30, 40, 2, &quot;Track 5&quot;, &quot;The levels of the track 5.&quot;)
  reagirl.Meter_LinkToTrack(track_meters.track_5_meter, 5)

  -- UI-elements in tab 2
  -- a label
  hardware_meters.hardware_inputs = reagirl.Label_Add(20, 50, &quot;Hardware inputs 1-3&quot;, &quot;Hardware inputs 1-3.&quot;, false)

  -- the meters for hardware inputs 1-3
  hardware_meters.track_1_meter = reagirl.Meter_Add(20, 70,  -30, 40, 2, &quot;Hardware input 1&quot;, &quot;The levels of hardware input 1.&quot;)
  reagirl.Meter_LinkToHWInput(hardware_meters.track_1_meter, 1)

  hardware_meters.track_2_meter = reagirl.Meter_Add(20, 120, -30, 40, 2, &quot;Hardware input 2&quot;, &quot;The levels of hardware input 2.&quot;)
  reagirl.Meter_LinkToHWInput(hardware_meters.track_2_meter, 2)

  hardware_meters.track_3_meter = reagirl.Meter_Add(20, 170, -30, 40, 2, &quot;Hardware input 3&quot;, &quot;The levels of hardware input 3.&quot;)
  reagirl.Meter_LinkToHWInput(hardware_meters.track_3_meter, 3)

  -- 4. open the gui
  reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, 360, nil, nil, nil)

  -- 5. a main-function that runs the gui-management-function
  function main()
  reagirl.Gui_Manage()

  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end
  main()</code></pre>
<p><img src="gfx/Tutorial13_05.gif" title="The second tab showing three horizontal meters for hardware input 1 to 3. It&#39;s columns are showing input-signal of the hardware inputs." alt="The second tab showing three horizontal meters for hardware input 1 to 3. It&#39;s columns are showing input-signal of the hardware inputs." /></p>
<p>Nice, now we are done.</p>
<p>Meters can be customized using various methode. Especially the mode-parameter of reagirl.Meter_Add() gives you three different meters. Other options you can get and set with various functions. See <a href="#The_Gui_Elements_012_LevelMeters">Level Meters</a> for more details.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_014_ToolbarButtons"></a>
<a href="#Tutorial_014_ToolbarButtons"> ^</a> <u><b>Tutorial 014: doing toolbars with Toolbarbuttons</b></u><br>			<p>
<div class="ch">
<p>You are probably used to Reaper's own toolbars but they have some limitations. For instance, buttons only have two states, which can be difficult for and other limitations like limited accessibility. So what about being able to code toolbar-buttons that behave exactly like you want them to behave? Behold: ReaGirl comes to a rescue. ReaGirl's toolbar buttons can have up to 32 different states or behave like Reaper's own toolbar-buttons.</p>
<p>You add toolbarbuttons, like all other ReaGirl-ui-elements with its add-function, called reagirl.ToolbarButton_Add(). You can control various things, especially with the mode-parameter, which allows to set different variations of toolbar buttons. In this tutorial, I will show you two different toolbar-button-modes and how to customize with the mode parameter. I will also use toolbar-button-images that Reaper deploys with its installation, but you can use toolbar-button-images from anywhere.</p>
<p>Let's start with a simple gui with one single button added with reagirl.ToolbarButton_Add(). It gets it's run-function, that show a message box, when the button is clicked.</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_01.png" title="A simple window with one toolbar button." alt="A simple window with one toolbar button." /></p>
<p>This shows a simple gui with one toolbar-button. When you click it, a message box appears. The add-function works that the first two parameters are x and y position(but it's nil here, as we use autopositioning in this tutorial). The third parameter is the toolbar-image that shall be shown in the toolbar-button. A toolbar-image is an image split into several different parts, usually three. You can see it in the next image:</p>
<p><img src="gfx/Tutorial14_01_1.png" title="A toolbar-button image with three images being 90x30 pixels in total. The first 30 pixels width are for the first image, the second 30 pixels for the second image and the third 30 pixels for the third one." alt="A toolbar-button image with three images being 90x30 pixels in total. The first 30 pixels width are for the first image, the second 30 pixels for the second image and the third 30 pixels for the third one." /></p>
<p>As you can see in the image, it has multiple images. Toolbar-Buttons in ReaGirl basically have two different ways of treating them. The first one(parameter mode=1 or 2) is a toolbar-button with multiple states. In that case, each image represents an image for a state. So the first image is for when the toolbar button has state 1, the second for when the toolbar button has state 2 and the 32nd for when the toolbar button has state 32, etc. The second one is like Reaper's own toolbar-buttons(mode=5), where the first images is for when the button is not clicked/in off state, the second image for when the mouse is hovering above the button and the third image for when the button is clicked/in on state. The third one(mode=3 or 4) is text-buttons, where the toolbar-image is not used at all.</p>
<p>So the mode of the toolbar-button decide how the toolbar-image is treated. In this tutorial, we will do toolbar-buttons that act like Reaper's own toolbar-buttons(mode=5), which is probably the standard case for most of y'all. So the first image is button is off, the third image is button is on, the second image is for when the mouse is hovering above an off-button.</p>
<p>Feel free to experiment with the other modes too to get a feeling for if they do what you need.</p>
<p>Ok, we have one button, but a toolbar has more than just one button, so let's add a few additional toolbar-buttons, shall we?</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)
toolbarbutton2_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_color_item.png&quot;, 2, 1,{&quot;Uno&quot;, &quot;Dos&quot;}, 5, &quot;Second Toolbar Button&quot;, &quot;A second example toolbar button.&quot;, run_function, &quot;Toolbarbutton #2&quot;)
toolbarbutton3_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_delete.png&quot;, 2, 1,{&quot;Eins&quot;, &quot;Zwei&quot;}, 5, &quot;Third Toolbar Button&quot;, &quot;A third example toolbar button.&quot;, run_function, &quot;Toolbarbutton #3&quot;)
toolbarbutton4_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_glue.png&quot;, 2, 1,{&quot;Primo&quot;, &quot;Segundo&quot;}, 5, &quot;Fourth Toolbar Button&quot;, &quot;A fourth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #4&quot;)
toolbarbutton5_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 3, 1,{&quot;Un&quot;, &quot;Deux&quot;, &quot;Trois&quot;}, 2, &quot;Fifth Toolbar Button&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)
toolbarbutton6_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 4, 1,{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}, 3, &quot;Sixth&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_02.png" title="A simple window with six toolbar buttons. Four regular buttons, one with the state next to it having three states and one text-toolbar-button." alt="A simple window with six toolbar buttons. Four regular buttons, one with the state next to it having three states and one text-toolbar-button." /></p>
<p>Nice, this looks better. We have now six buttons, four regular Reaper-style toolbar-buttons(mode=5), one three-state-button that has its states next to it(mode=2) and a sixth button as a text-toolbar-button(mode=3). All of them are clickable and show a highlighting, when hovering above them. This is quite good but not good enough, yet. For instance, all buttons have spaces between them. This not only wastes precious screen estate, it is also hard to read. So let's group the first three and the fourth and fifth button together, so we have two groups and one single button. For this, we add 128 to the mode-parameter to every button that we want to be right after the former one. So to group the first three buttons together, we will need to add 128 to the mode parameter of the second and third toolbar button. Same for the fifth one.</p>
<p>Let's do it and see, how it looks.</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)
toolbarbutton2_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_color_item.png&quot;, 2, 1,{&quot;Uno&quot;, &quot;Dos&quot;}, 5+128, &quot;Second Toolbar Button&quot;, &quot;A second example toolbar button.&quot;, run_function, &quot;Toolbarbutton #2&quot;)
toolbarbutton3_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_delete.png&quot;, 2, 1,{&quot;Eins&quot;, &quot;Zwei&quot;}, 5+128, &quot;Third Toolbar Button&quot;, &quot;A third example toolbar button.&quot;, run_function, &quot;Toolbarbutton #3&quot;)
toolbarbutton4_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_glue.png&quot;, 2, 1,{&quot;Primo&quot;, &quot;Segundo&quot;}, 5, &quot;Fourth Toolbar Button&quot;, &quot;A fourth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #4&quot;)
toolbarbutton5_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 3, 1,{&quot;Un&quot;, &quot;Deux&quot;, &quot;Trois&quot;}, 2+128, &quot;Fifth Toolbar Button&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)
toolbarbutton6_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 4, 1,{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}, 3, &quot;Sixth&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_03.png" title="The same six buttons, but this time, the first three buttons are grouped together as well as the fourth and the fifth button. The sixth button is on its own." alt="The same six buttons, but this time, the first three buttons are grouped together as well as the fourth and the fifth button. The sixth button is on its own." /></p>
<p>Ah, this is better and easier to read, as you can see, which button belongs to which. We could be finished now but let's go one step further. You see, all buttons have rounded edges. But what if we have the rounded edges only on the sides, where a gap is between buttons and not inbweteen them. Means: we make the inner sides of a unit of toolbar-buttons square and the outer side round. For this we use reagirl.ToolbarButton_SetEdgeStyle(), which allows us to set the individual edges of a toolbar-button to round or square. That way, they look more as a unit. So let's do it.</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton_guid, false, true, false, true)
toolbarbutton2_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_color_item.png&quot;, 2, 1,{&quot;Uno&quot;, &quot;Dos&quot;}, 5+128, &quot;Second Toolbar Button&quot;, &quot;A second example toolbar button.&quot;, run_function, &quot;Toolbarbutton #2&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton2_guid, true, true, true, true)
toolbarbutton3_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_delete.png&quot;, 2, 1,{&quot;Eins&quot;, &quot;Zwei&quot;}, 5+128, &quot;Third Toolbar Button&quot;, &quot;A third example toolbar button.&quot;, run_function, &quot;Toolbarbutton #3&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton3_guid, true, false, true, false)

toolbarbutton4_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_glue.png&quot;, 2, 1,{&quot;Primo&quot;, &quot;Segundo&quot;}, 5, &quot;Fourth Toolbar Button&quot;, &quot;A fourth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #4&quot;)
toolbarbutton5_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 3, 1,{&quot;Un&quot;, &quot;Deux&quot;, &quot;Trois&quot;}, 2+128, &quot;Fifth Toolbar Button&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

toolbarbutton6_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 4, 1,{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}, 3, &quot;Sixth&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_04.png" title="The inner parts of the first button group has now square edges and the outer parts have rounded edges. This makes them look more like a unit." alt="The inner parts of the first button group has now square edges and the outer parts have rounded edges. This makes them look more like a unit." /></p>
<p>Ahh, now it looks really pleasing and is even better to read.<br />
Let's give the second button-group the same treatmen, that the inner part is squared and the outer edges are round.</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton_guid, false, true, false, true)
toolbarbutton2_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_color_item.png&quot;, 2, 1,{&quot;Uno&quot;, &quot;Dos&quot;}, 5+128, &quot;Second Toolbar Button&quot;, &quot;A second example toolbar button.&quot;, run_function, &quot;Toolbarbutton #2&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton2_guid, true, true, true, true)
toolbarbutton3_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_delete.png&quot;, 2, 1,{&quot;Eins&quot;, &quot;Zwei&quot;}, 5+128, &quot;Third Toolbar Button&quot;, &quot;A third example toolbar button.&quot;, run_function, &quot;Toolbarbutton #3&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton3_guid, true, false, true, false)

toolbarbutton4_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_glue.png&quot;, 2, 1,{&quot;Primo&quot;, &quot;Segundo&quot;}, 5, &quot;Fourth Toolbar Button&quot;, &quot;A fourth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #4&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton4_guid, false, true, false, true)
toolbarbutton5_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 3, 1,{&quot;Un&quot;, &quot;Deux&quot;, &quot;Trois&quot;}, 2+128, &quot;Fifth Toolbar Button&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton5_guid, true, false, true, false)

toolbarbutton6_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 4, 1,{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}, 3, &quot;Sixth&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_05.png" title="The inner parts of the second button group has now square edges and the outer parts have rounded edges. This makes them look more like a unit." alt="The inner parts of the second button group has now square edges and the outer parts have rounded edges. This makes them look more like a unit." /></p>
<p>Ok, this is coming along nicely. But what about the ugly titlebar? This is something, we should get rid of. This we can do with the function reagirl.Window_SetBorderless(), which makes the gui-window borderless. But if we do this, how can the user drag around the window? Well, we can make it, that clicking into an empty area of the gui-window allows dragging it around. For this, we need the function reagirl.Window_DragOnEmptyArea().</p>
<p>Let's do it and see, how it looks:</p>
<pre><code>-- 0. enable ReaGirl for the script
dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)
-- check for required version; alter the version-number if necessary
if reagirl.GetVersion()&lt;1.3 then reaper.MB(&quot;Needs ReaGirl v&quot;..(1.3)..&quot; to run&quot;, &quot;Too old version&quot;, 2) return false end

-- 1. add the run-functions for the ui-elements
function run_function(element_id, A, B, C)
  local name = reagirl.UI_Element_GetSetCaption(element_id, false, &quot;&quot;)
  reaper.MB(B, name, 0)
end

-- 2. start a new gui
reagirl.Gui_New()

toolbarbutton_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_audio_waveform.png&quot;, 2, 1,{&quot;One&quot;, &quot;Two&quot;}, 5, &quot;First Toolbar Button&quot;, &quot;A first example toolbar button.&quot;, run_function, &quot;Toolbarbutton #1&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton_guid, false, true, false, true)
toolbarbutton2_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_color_item.png&quot;, 2, 1,{&quot;Uno&quot;, &quot;Dos&quot;}, 5+128, &quot;Second Toolbar Button&quot;, &quot;A second example toolbar button.&quot;, run_function, &quot;Toolbarbutton #2&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton2_guid, true, true, true, true)
toolbarbutton3_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_delete.png&quot;, 2, 1,{&quot;Eins&quot;, &quot;Zwei&quot;}, 5+128, &quot;Third Toolbar Button&quot;, &quot;A third example toolbar button.&quot;, run_function, &quot;Toolbarbutton #3&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton3_guid, true, false, true, false)

toolbarbutton4_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_glue.png&quot;, 2, 1,{&quot;Primo&quot;, &quot;Segundo&quot;}, 5, &quot;Fourth Toolbar Button&quot;, &quot;A fourth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #4&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton4_guid, false, true, false, true)
toolbarbutton5_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 3, 1,{&quot;Un&quot;, &quot;Deux&quot;, &quot;Trois&quot;}, 2+128, &quot;Fifth Toolbar Button&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)
reagirl.ToolbarButton_SetEdgeStyle(toolbarbutton5_guid, true, false, true, false)

toolbarbutton6_guid = reagirl.ToolbarButton_Add(nil, nil, reaper.GetResourcePath()..&quot;/Data/toolbar_icons/toolbar_item_properties.png&quot;, 4, 1,{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}, 3, &quot;Sixth&quot;, &quot;A fifth example toolbar button.&quot;, run_function, &quot;Toolbarbutton #5&quot;)

-- 4. open the gui
reagirl.Gui_Open(&quot;My Dialog Name&quot;, false, &quot;Dialog Title&quot;, &quot;A short explanation of my dialog.&quot;, nil, nil, nil, nil, nil)
reagirl.Window_SetBorderless() -- make the window borderless
reagirl.Window_DragOnEmptyArea(true) -- make window draggable when clicking into an empty area

-- 5. a main-function that runs the gui-management-function
function main()
  reagirl.Gui_Manage()
  
  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
end
main()</code></pre>
<p><img src="gfx/Tutorial14_06.gif" title="The gui-window is now borderless and can be dragged around by clicking into an empty are of the gui-window." alt="The gui-window is now borderless and can be dragged around by clicking into an empty are of the gui-window." /></p>
<p>Nice, now we have a compact and good looking toolbar with our own buttons. You can do more with toolbars, so see <a href="#The_Gui_Elements_012_LevelMeters">Level Meters</a> and the various ToolbarButton_ functions for more details.</p>
<p>A final note: toolbar-images can be scaled too, so different scale-factors make the buttons look good. For this you create upscaled images for 1x(30*num_states x 30 pixels), 2x(60*num_states x 60 pixels, 3x(90*num_states x 60 pixels), etc. The filenames are either in the same folder like the unscaled image, like:</p>
<p>toolbaricon-image.png toolbaricon-image-2x.png toolbaricon-image-3x.png etc</p>
<p>Or you place them in subfolders, where the scaling is written in 100 steps(Reaper's behavior):</p>
<p>toolbar-image.png 200/toolbar-image.png 300/toolbar-image.png 400/toolbar-image.png etc</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Tutorial_015_ExternalControlOfGuis"></a>
<a href="#Tutorial_015_ExternalControlOfGuis"> ^</a> <u><b>Tutorial 015: External control of ReaGirl-guis</b></u><br>			<p>
<div class="ch">
<p>It's real cool to code your own guis, but: what if there's an already existing gui, which has numerous options that you want to set but there's no action or anything for it? Well, for ReaGirl-guis, there's a solution to control guis from the outside. And in this tutorial, I will show you, how to do it. I will show you, how to open the ReaGirl-settings, set various settings and close it again. And this with just a handful of code-lines. Let's begin.</p>
<p>To be able to control ui-elements from the outside, you need several bits of information from the gui-script in question. But if you fear, that you have to dig through its code, I can assure you, you don't need to, as ReaGirl has features to retrieve the information you need.</p>
<p>Ok, the information you need is basically two: the name of the gui and the id of the ui-element, that you want to influence. To retrieve it, go into the ReaGirl-settings in the development-tab and hit the checkbox for "Show gui-name and ui-element-name in console". If you use the tab-key or shift+tab-key, you can tab through the ui-elements, where the focused one will be enclosed in a rectangle. A window opens, the ReaScript-console-window, which displays the name of the gui and various information about the focused ui-element. This looks like this:</p>
<pre><code>  Gui-Name:&quot;ReaGirl_Settings&quot;
  Gui-Element-Name:&quot;Show screen reader messages in console&quot;
  Gui-Element_ID:&quot;Show Screen Reader Messages In Console Checkbox&quot;
  Gui-Element-Type:Checkbox</code></pre>
<p>After Gui-Name in "", it's the name of the gui, in this case the ReaGirl_Settings. After Gui-Element_ID in "", there's an id for the focused-ui-element. Now hit Tab until the ui-element is focused, that you want to influence. In this tutorial, we want to toggle the checkbox for "Show tooltips when hovering above ui-element" and the "Blink every"-slider in the "Draggable UI-Elements"-section in the General tab. So switch to the first tab and use the tab-key to focus these two ui-elements.</p>
<p>You'll notice, that the ui-element for show tooltips has the id of "Tooltip checkbox" and the blink-every-slider has the id of "Drag Blink Every Slider". With these and the name of the gui "ReaGirl_Settings", we can start to write our script.</p>
<p>Let's begin with a script, that clicks the show tooltips-checkbox. In this, we need to use the function reagirl.Ext_SendEventByID() to send the click-event to the checkbox. reagirl.Ext_SendEventByID() has as first parameter the gui-name, as second parameter the id of the show-tooltips-checkbox and as third parameter the event to send. In our case, we use 1 for left click. The other parameters we can ignore for now. The code looks like this.</p>
<pre><code>  -- enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

  -- set ui-elements
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Tooltip checkbox&quot;, 1, &quot;&quot;, 0, 0, 0)        -- toggle &quot;show tooltips&quot;-checkbox</code></pre>
<p>Now open the ReaGirl settings, select the General tab and run the script. The show-tooltip checkbox will now toggle, everytime you run the script.</p>
<p>Nice.</p>
<p>Now, let's add a second event, to influence the Blink every-slider of the Draggable UI-elemens-area. This is basically the same thing, but we adjust the id of the ui-element to use "Drag Blink Every Slider" and the event to send is 5, which selects a certain value for a slider. And to choose, which value to set it to, we adjust the fifth parameter to 5, which makes the slider go to 5. Here's the script:</p>
<pre><code>  -- enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

  -- set ui-elements
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Tooltip checkbox&quot;, 1, &quot;&quot;, 0, 0, 0)        -- toggle &quot;show tooltips&quot;-checkbox
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Drag Blink Every Slider&quot;, 5, &quot;&quot;, 5, 0, 0) -- set &quot;Blink every&quot;-slider of highlight drag destinations to 5</code></pre>
<p>You see, we just added another line. And when we run it, not only the show tooltips-checkbox toggles, but the blink-every-slider is set to 5. Now adjust the fifth parameter to 2 and rerun the script. The slider is changed to 2. Ok, but what if you want to set text into an inputbox? You can, so let's do it for the "Test input"-inputbox. We tab through the settings and find out, that its id is "Test Input Inputbox". With that, we can add another reagirl.Ext_SendEventByID()-functioncall and set the second parameter to "Test Input Inputbox", the third parameter to 8(for setting text) and then add into the fourth parameter the new text, like "New text".</p>
<pre><code>  -- enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

  -- set ui-elements
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Tooltip checkbox&quot;, 1, &quot;&quot;, 0, 0, 0)        -- toggle &quot;show tooltips&quot;-checkbox
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Drag Blink Every Slider&quot;, 5, &quot;&quot;, 5, 0, 0) -- set &quot;Blink every&quot;-slider of highlight drag destinations to 5
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Test Input Inputbox&quot;, 8, &quot;New text&quot;, 0, 0, 0) -- set &quot;Test input&quot;-inputbox to &quot;New text&quot;</code></pre>
<p>And when we run it, the checkbox is toggled, the slider is set to the desired value AND the Test input-inputbox is set to "New text".</p>
<p>Ok, this is cool. However: this script needs, that the settings are already open to have an effect. So let's automatically open the gui-script and close the gui-script. For opening we use Reaper's own functions reaper.NamedCommandLookup(). Go into the actionlist, search for the gui-script, right click and click "Copy selected action command ID", which will put the action command id of the script into the clipboard. This will be used in the following example:</p>
<pre><code>  -- enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

  -- open ReaGirl settings
  cmd=reaper.NamedCommandLookup(&quot;_RS40947c73d65bf5f2d6b7f4d52a4e6a69629495f0&quot;)                               
  reaper.Main_OnCommand(cmd, 0)

  -- set ui-elements
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Tooltip checkbox&quot;, 1, &quot;&quot;, 0, 0, 0)        -- toggle &quot;show tooltips&quot;-checkbox
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Drag Blink Every Slider&quot;, 5, &quot;&quot;, 5, 0, 0) -- set &quot;Blink every&quot;-slider of highlight drag destinations to 5
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Test Input Inputbox&quot;, 8, &quot;New text&quot;, 0, 0, 0) -- set &quot;Test input&quot;-inputbox to &quot;New text&quot;</code></pre>
<p>So close the settings and run the script. This opens the gui and sets the various values.</p>
<p>Ok, but we also want it to close automatically, so let's add this. as well. For this, we need to send a close-event to the settings. However, we shouldn't do it right after the reagirl.Ext_SendEventByID()-functioncalls, because this could close the gui and end the gui-script before all values were set to the gui. To circumvent, we add one single defer-cycle. Defer-cycles are ways to let a script run in the background. For ReaGirl-guis, each defer-run checks, whether ui-elements were clicked, then the gui is drawn again if needed and then it temporarily stops, so the next defer-script could be run and do its stuff and when it's done, it gives control to he next script, etc. In our case, we set all ui-elements, then we give control to other background-scripts, including the ReaGirl-settings to set all ui-elements the way we wanted it. Then it gives back the control to our script, which requests the close-button to be clicked. And when it gives control to the ReaGirl-settings, they will close the gui and end the gui-script.</p>
<p>This sounds more complicated than it actually is. In fact, you can use the code from the next snippet and adjust it accordingly. It is basically everything from function main() to reaper.defer(main) which you can copy n paste. Within the main-function, we add a reagirl.Ext<em>Window</em>Close()-functioncall. And here is it how it looks like:</p>
<pre><code>  -- enable ReaGirl for the script
  dofile(reaper.GetResourcePath()..&quot;/UserPlugins/reagirl.lua&quot;)

  -- open ReaGirl settings
  cmd=reaper.NamedCommandLookup(&quot;_RS40947c73d65bf5f2d6b7f4d52a4e6a69629495f0&quot;)                               
  reaper.Main_OnCommand(cmd, 0)

  -- set ui-elements
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Tooltip checkbox&quot;, 1, &quot;&quot;, 0, 0, 0)        -- toggle &quot;show tooltips&quot;-checkbox
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Drag Blink Every Slider&quot;, 5, &quot;&quot;, 5, 0, 0) -- set &quot;Blink every&quot;-slider of highlight drag destinations to 5
  reagirl.Ext_SendEventByID(&quot;ReaGirl_Settings&quot;, &quot;Test Input Inputbox&quot;, 8, &quot;New text&quot;, 0, 0, 0) -- set &quot;Test input&quot;-inputbox to &quot;New text&quot;

  -- close the gui by clicking the close-Button
  -- we do this in a second defer-cycle so we don&#39;t accidentally close the gui(and possibly ending the script) before all values were set successfully
  -- Copy and paste the following lines and adjust the reagirl.Ext_SendeEventByID()-line, if needed.
  function main()                  
    reagirl.Ext_Window_Close(&quot;ReaGirl_Settings&quot;)
  end
  reaper.defer(main)</code></pre>
<p>You see, that it basically is the same functioncall, it is just "delayed" a little, so the gui-script had a chance to apply all the changes we requested.</p>
<p>And there we are. A script that opens the ReaGirl-settings, sets the values and closes it again. This should make ReaGirl-settings controllable for you from the outside.</p>
<p>One more thing: sometimes you may notice, that the id of a ui-element hasn't been set and you see it only as "". In this case, you can't use the id, as the scripter didn't set one. But, you can use the name of the gui-element as well, for which you use the function reagirl.Ext_SendEvent() !</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_000"></a>
<a href="#The_Gui_Elements_000"> ^</a> <u><b>The Gui Elements</b></u><br>			<p>
<div class="ch">
<p>ReaGirl features a set of ui-elements that you can add to your gui and add functionality to them,<br />
as of now buttons, labels, checkboxes, inputboxes, images, sliders, dropdownmenus, tabs, color rectangles, burgermenus, toolbar buttons and level-meters.</p>
<p>You can also add to each ui-element a context-menu. You can also add a file-drop-zone, which allows you to drop files onto a certain ui-element.<br />
For both, context-menus and drop zones, you can add run-functions that will be run when a context-menu is opened or files have been dropped.</p>
<p>Some ui-elements(images and labels) can even be made draggable.</p>
<p>In addition, there's a subset of ReaGirl-functions whose name begin with reagirl.UI_Element_ that allow influencing ui-elements, like reagirl.UI_Element_GetSetPosition() which allows getting and setting the position of a ui-element.</p>
<p>In the next chapters, I will go through all of these ui-elements and additional concepts and explain how they are intended.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_001_Buttons"></a>
<a href="#The_Gui_Elements_001_Buttons"> ^</a> <u><b>Buttons</b></u><br>			<p>
<div class="ch">
<p>Buttons are calls to action. They are rectangular shaped ui-elements with round edges that feature a short text(called a caption).<br />
They can be pressed to start an action, like opening a dialog, running actions from the action list, closing a window, etc.<br />
What they do is defined by what you write into the run-function.</p>
<p>To add a button to your gui, you use reagirl.Button_Add(). It has eight parameters.</p>
<ul>
<li>The first and the second are the position of the button in pixels. You can set them to nil to auto-position it.<br />
</li>
<li>The third and fourth are margins around the caption. So if the button is too small for you, make these &gt;0 to make the button bigger.<br />
</li>
<li>The fifth parameter is the caption, which is the text of the button.<br />
</li>
<li>The sixth parameter is meaningOfUI_Element, which is a short explanation on what the button is doing and why. This is needed by blind users so they know, what the button is for.<br />
</li>
<li>The seventh parameter is a run-function. This function will be run, when the button is clicked. It gets as parameter the element_id of the button that was clicked.<br />
</li>
<li>The eighth parameter is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it.</li>
</ul>
<p>With this, you can add a button to your gui, but there's more that you can do with a button.</p>
<ul>
<li>reagirl.Button_SetDisabled() - sets a button to disability-state, so you can prevent the button from being clickable<br />
</li>
<li>reagirl.Button_GetDisabled() - gets the current disability state, if the button can be clicked or not<br />
</li>
<li>reagirl.Button_SetRadius() - allows you to make the button more round or more square<br />
</li>
<li>reagirl.Button_GetRadius() - gets the current roundness of the button's edges<br />
</li>
<li>reagirl.Button_GetEdgeStyle() - gets, if the edges of the button are round or square</li>
<li>reagirl.Button_SetEdgeStyle() - sets, if the edges of the button are round or square</li>
</ul>
<p>Check the <a href="#Tutorial_001_A_Basic_Gui">first tutorial "A basic gui"</a> to see examples of guis with buttons.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_002_Checkboxes"></a>
<a href="#The_Gui_Elements_002_Checkboxes"> ^</a> <u><b>Checkboxes</b></u><br>			<p>
<div class="ch">
<p>Checkboxes are toggle-states. They can be set to checked(on) or unchecked(off).<br />
They are square and have a small yellow square in the middle when checked with a descriptive text(caption) next to it.</p>
<p>They are usually used when the user has the option to turn something on or off.</p>
<p>To add a checkbox, you use reagirl.Checkbox_Add(). It has seven parameters.</p>
<ul>
<li>The first and second parameter are the position in pixels. Set them to nil to auto-position the checkbox.<br />
</li>
<li>The third parameter is the text of the caption.<br />
</li>
<li>The fourth parameter is meaningOfUI_Element, which is a short explanation on what the checkbox is doing and why. This is needed by blind users so they know, what the checkbox stands for.<br />
</li>
<li>The fifth parameter is the initial checkstate when the script is started. True, the checkbox is checked, false, it is unchecked.<br />
</li>
<li>The sixth parameter is the run-function which is run everytime the user toggles the checkstate of the checkbox.<br />
It gets as parameters the element_id of the toggled checkbox as first and the new checkstate as second parameter.<br />
You can set the run-function to nil if you don't want a run-function to be run.<br />
</li>
<li>The seventh parameter is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it.</li>
</ul>
<p>There's more that you can do with checkboxes:</p>
<ul>
<li>reagirl.Checkbox_SetDisabled - sets a checkbox disability-state, so you can set if the checkbox can be clicked<br />
</li>
<li>reagirl.Checkbox_GetDisabled - gets the current disability-state of a checkbox, if it can be clicked<br />
</li>
<li>reagirl.Checkbox_SetCheckState - sets the checkstate of the checkbox<br />
</li>
<li>reagirl.Checkbox_GetCheckState - gets the current checkstate of the checkbox<br />
</li>
<li>reagirl.Checkbox_SetWidth - sets width of a checkbox, which helps you with autopositioning<br />
</li>
<li>reagirl.Checkbox_LinkToConfigVar - links the checkbox to a certain config-variable-bitfield<br />
</li>
<li>reagirl.Checkbox_LinkToExtstate - links the checkbox to an extstate<br />
</li>
<li>reagirl.Checkbox_LinkToIniValue - links the checkbox to an ini-value</li>
<li>reagirl.Checkbox_LinkToToggleState - links the checkbox to the toggle-state of an action<br />
</li>
<li>reagirl.Checkbox_Unlink - removes the link between the checkbox and a certain state</li>
</ul>
<p>Check the <a href="#Tutorial_001_A_Basic_Gui">first tutorial "A basic gui"</a> to see examples of guis with checkboxes.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_003_Labels"></a>
<a href="#The_Gui_Elements_003_Labels"> ^</a> <u><b>Labels</b></u><br>			<p>
<div class="ch">
<p>Labels are a way to show text in your gui. They are meant to explain things or<br />
give your gui some structure, like explaining the basic context of some ui-elements as a header.<br />
They can be copied to the clipboard using Ctrl+C.<br />
You can also make a label clickable, so it behaves like a link on a webpage.<br />
Labels can have newlines.</p>
<p>There are also functions to set a label to draggable.</p>
<p>You add labels to your gui with reagirl.Label_Add(), which has seven parameters.</p>
<ul>
<li>The first and second parameters are the position of the label in pixels. To autoposition the label, pass nil into these parameters.<br />
</li>
<li>The third parameter is the label-text. It can include newlines.<br />
</li>
<li>The fourth parameter is meaningOfUI_Element, which gives some more explanation of this label for blind users.<br />
Means, if the label is a header for some ui-elements, you can explain in more detail, what the ui-elements are supposed to be.<br />
</li>
<li>The fifth parameter sets, if the label is clickable(true) or not(false).<br />
</li>
<li>The sixth parameter is a run-function, that is run when a clickable label is clicked and/or a label is dragged onto another ui-element.<br />
You can keep the run-function nil if you don't need a run-function to be run.<br />
</li>
<li>The seventh parameter is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it.</li>
</ul>
<p>There's more that you can do with labels:</p>
<ul>
<li>reagirl.Label_SetBackdrop - sets the backdrop of a label, which could enclose ui-elements underneath it<br />
</li>
<li>reagirl.Label_GetBackdrop - gets the backdrop of a label, which could enclose ui-elements underneath it<br />
</li>
<li>reagirl.Label_AutoBackdrop - sets a backdrop from label to underneath a specific ui-element<br />
</li>
<li>reagirl.Label_SetStyle - allows setting different styles for the label, like underlined or bold<br />
</li>
<li>reagirl.Label_GetStyle - gets the currently set styles for a label<br />
</li>
<li>reagirl.Label_SetFontSize - sets the font-size of the label<br />
</li>
<li>reagirl.Label_GetFontSize - gets the currently set font-size of the label<br />
</li>
<li>reagirl.Label_SetAlignment - sets the alignment of the label-text, like centered or right aligned<br />
</li>
<li>reagirl.Label_GetAlignment - gets the current alignment for this label<br />
</li>
<li>reagirl.Label_SetDraggable - sets the label as draggable, including possible drag-destinations<br />
</li>
<li>reagirl.Label_GetDraggable - gets the current drag-state and the current drag-destinations<br />
</li>
<li>reagirl.UI_Element_GetSetCaption - gets or sets the label text</li>
</ul>
<p>Check the <a href="#Tutorial_001_A_Basic_Gui">first tutorial "A basic gui"</a> to see examples of guis with labels.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_004_Images"></a>
<a href="#The_Gui_Elements_004_Images"> ^</a> <u><b>Images</b></u><br>			<p>
<div class="ch">
<p>Images show an image in the gui. They can be clicked and do things using the run-function.<br />
Transparency in png-images will be obeyed, so you can have images with transparent background drawn into your gui.</p>
<p>Very important: the caption and the meaningOfUI_Element-parameters must describe the content of the image, so blind users know, what the image contains, as they can't see it.</p>
<p>Images can automatically scale from 1x to 8x.<br />
To make this happen, add scaled versions of the image to the same folder as the source image and name them the following way:</p>
<p>image-filename.png - 1x-scaling<br />
image-filename-2x.png - 2x-scaling<br />
image-filename-3x.png - 3x-scaling<br />
image-filename-4x.png - 4x-scaling<br />
image-filename-5x.png - 5x-scaling<br />
image-filename-6x.png - 6x-scaling<br />
image-filename-7x.png - 7x-scaling<br />
image-filename-8x.png - 8x-scaling</p>
<p>Means: add -2x before the extension for the 2x scaled image, add -3x before the extension for the 3x scaled image and so on.</p>
<p>Give Image_Add the 1x-scaled image as filename and when the user changes the scaling, ReaGirl will load the accompanying scaled image automatically.<br />
If there's no scaled image available, ReaGirl will automatically revert to the original filename for 1x-scaling. So if there's only one image available, ReaGirl will only load that one.</p>
<p>You can have up to 1000 images per gui.</p>
<p>Images can be made draggable.</p>
<p>You can add images using Image_Add, which has nine parameters.</p>
<ul>
<li>Parameter 1 and 2 are the position of the image in pixels. Set them to nil to autoposition the image.<br />
</li>
<li>Parameter 3 and 4 are the width and height of the image in pixels.<br />
</li>
<li>Parameter 5 is the filename of the 1x-scaled image.<br />
</li>
<li>Parameter 6 is the caption of the image. This won't be shown but screen reader users will get this communicated so make it descriptive.<br />
</li>
<li>Parameter 7 is the meaningOfUI_Element, which describes to the blind users what the image is for and why.<br />
</li>
<li>Parameter 8 is the run-function of the image that is run when the user clicks the image.<br />
Set it to nil, if you don't need it.<br />
</li>
<li>Parameter 9 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>You can do more things with images:</p>
<pre><code>                        - reagirl.Image\_GetAutoUpdate - gets, if the image is automatically updated when the underlying image-file is changed/updated
                        - reagirl.Image\_SetAutoUpdate - sets, if the image is automatically updated when the underlying image-file is changed/updated</code></pre>
<ul>
<li>reagirl.Image_GetDraggable - get if the image is draggable and what the potential drag-destinations are<br />
</li>
<li>reagirl.Image_SetDraggable - set the image to draggable and set the potential drag-destination-ui-elements<br />
</li>
<li>reagirl.Image_GetDimensions - get the width and height of the image<br />
</li>
<li>reagirl.Image_SetDimensions - set the width and height of the image<br />
</li>
<li>reagirl.Image_ReloadImage_Scaled - reloads the image if the image-file has been altered and you want to update the shown image<br />
</li>
<li>reagirl.Image_KeepAspectRatio - forces the image to be shown with correct aspect ratio(otherwise it might get stretched)<br />
</li>
<li>reagirl.Image_GetImageFilename - get the current image-filename<br />
</li>
<li>reagirl.Image_Load - loads a new image-file into the image<br />
</li>
<li>reagirl.Image_ClearToColor - clears the image and sets it to a color instead<br />
</li>
<li>reagirl.Image_GetDropShadow - gets, if the image is drawn with a drop-shadow</li>
<li>reagirl.Image_SetDropShadow - sets, if the image is drawn with a drop-shadow(good for better contrast with certain background-colors)</li>
</ul>
<p>See the tutorial <a href="#Tutorial_003_A_Basic_Image_Viewer">"A basic Image Viewer"</a> and the tutorial <a href="#Tutorial_005_Draggable_Images">"Draggable Images"</a> to know how to work with images.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_005_Inputboxes"></a>
<a href="#The_Gui_Elements_005_Inputboxes"> ^</a> <u><b>Inputboxes(Edit-Fields)</b></u><br>			<p>
<div class="ch">
<p>Inputboxes are fields, into which you can type text. They consist of a caption and a square next to it, into which you enter the text.<br />
Unlike other ui-elements, inputboxes allow for two run-functions: one for when the user typed a character into the inputbox and one for when the user hits enter.</p>
<p>You can add inputboxes with InputBox_Add, which has 10 parameters.</p>
<ul>
<li>Parameter 1 and 2 are the position of the inputbox in pixels. Set them to nil to autoposition them.<br />
</li>
<li>Parameter 3 is the width of the inputbox in pixels. This includes the length of the caption so make it<br />
long enough.<br />
</li>
<li>Parameter 4 is the caption, which is the text on the left side of the inputbox.<br />
</li>
<li>Parameter 5 is the caption-width. With this you can influence, at which point the actual editfield shall start.<br />
So if you have numerous inputboxes underneath, you can set all their cap_width to the same value so they are perfectly aligned.<br />
If you don't need that, set this to nil, which starts the editfield directly after the caption.<br />
</li>
<li>Parameter 6 is meaningOfUI_Element, which is a description for the inputbox communicated to screen reader users. Explain what the inputbox is for and why.<br />
</li>
<li>Parameter 7 is the default text, which is the text shown when the gui is started.<br />
</li>
<li>Parameter 8 is the run-function for when the user hits enter into the inputfield.<br />
This run-function gets the inputbox-element_id as first and the entered text as second parameter.<br />
</li>
<li>Parameter 9 is the run-function for when the user entered a character into the inputfield.<br />
This run-function gets the inputbox-element_id as first, the entered text as second and the last entered character(or pasted text) as third parameter.<br />
</li>
<li>Parameter 10 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>You can do more with inputboxes.</p>
<ul>
<li>reagirl.Inputbox_GetPassword - gets if the inputbox shall be used for entering passwords. Means, all characters will be shown as *<br />
</li>
<li>reagirl.Inputbox_SetPassword - sets if the inputbox shall be used for entering passwords. Means, all characters will be shown as *<br />
</li>
<li>reagirl.Inputbox_GetDisabled - gets the disability state of an inputbox<br />
</li>
<li>reagirl.Inputbox_SetDisabled - sets an inputbox's disability-state, means, if the inputbox is clickable/allows entering text or not<br />
</li>
<li>reagirl.Inputbox_GetText - gets the text from the editfield of an inputbox<br />
</li>
<li>reagirl.Inputbox_SetText - sets the text in the editfield of an inputbox<br />
</li>
<li>reagirl.Inputbox_SetEmptyText - sets text that is shown when no text has been entered<br />
</li>
<li>reagirl.Inputbox_GetSelectedText - gets the currently selected text<br />
</li>
<li>reagirl.InputBox_GetCursorOffset - gets the current offset of the edit-cursor in the editfield of an inputbox<br />
</li>
<li>reagirl.Inputbox_GetTextSuggestions - gets the current text-suggestions of an inputbox</li>
<li>reagirl.Inputbox_SetTextSuggestions - sets the text-suggestions of an inputbox<br />
- reagirl.InputBox_LinkToConfigVar - links the inputbox to a certain config-variable - reagirl.InputBox_LinkToExtstate - links the inputbox to an extstate<br />
- reagirl.InputBox_LinkToIniValue - links the inputbox to an ini-value - reagirl.InputBox_Unlink - removes the link between the inputbox and a certain state</li>
</ul>
<p>Check the examples in the subfolder Additional_Examples for examples of guis with inputboxes. Run the action "ReaGirl_OpenFolder_ExampleScripts.lua" to open the example-folder.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_006_DropDownMenus_ComboBoxes"></a>
<a href="#The_Gui_Elements_006_DropDownMenus_ComboBoxes"> ^</a> <u><b>DropDownMenus(ComboBoxes)</b></u><br>			<p>
<div class="ch">
<p>Drop down menus are menus that give the user a selection of options and they can choose one of them.<br />
They are a caption and a box right next to it which can be clicked to select the option.<br />
You can cycle through the options with the arrow-keys, home/end-key and mouse-wheel.</p>
<p>You can add a drop down menu to the gui using DropDownMenu_Add, which has 10 parameters.</p>
<ul>
<li>Parameters 1 and 2 are the x and y coordinate in pixels of the drop down menu. Set them to nil to autoposition the drop down menu.<br />
</li>
<li>Parameter 3 is the width of the drop down menu in pixels. This includes the caption so make it long enough.<br />
</li>
<li>Parameter 4 is the caption of the drop down menu, which is a text shown on the left side of the drop down menu.<br />
</li>
<li>Parameter 5 is the caption-width. With this you can influence, at which point the actual clickable drop down menu shall start.<br />
So if you have numerous drop down menus underneath, you can set all their cap_width to the same value so they are perfectly aligned.<br />
If you don't need that, set this to nil, which starts the clickable drop down menu-area directly after the caption.<br />
</li>
<li>Parameter 6 is meaningOfUI_Element, which is a description for the drop down menu communicated to screen reader users. Explain what the drop down menu is for and why.<br />
</li>
<li>Parameter 7 is the menuItems, which is a table with all menu-item-names, like {"Option 1", "second Option", "Option number three"}<br />
</li>
<li>Parameter 8 is the selected menu item when the gui is started<br />
</li>
<li>Parameter 9 is the run-function that is run everytime the user changes the menu-selection<br />
The run-function gets the element_id of the selected drop down menu as first, the selected menu-entry-number as second and the selected menu-entry-name as third parameter.<br />
</li>
<li>Parameter 10 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>You can do more things with drop down menus:</p>
<ul>
<li>reagirl.DropDownMenu_SetDimensions - sets the width of the drop down menu<br />
</li>
<li>reagirl.DropDownMenu_GetDimensions - gets the width of the drop down menu<br />
</li>
<li>reagirl.DropDownMenu_SetDisabled - sets the drop down menu's disability-state, means, if it can be clicked or not<br />
</li>
<li>reagirl.DropDownMenu_GetDisabled - gets the current disability state of the drop down menu<br />
</li>
<li>reagirl.DropDownMenu_GetMenuItems - gets the menu-items of the drop down menu<br />
</li>
<li>reagirl.DropDownMenu_SetMenuItems - sets the menu-items of the drop down menu<br />
</li>
<li>reagirl.DropDownMenu_GetSelectedMenuItem - gets the selected menu-item</li>
<li>reagirl.DropDownMenu_SetSelectedMenuItem - sets the selected menu-item - reagirl.DropDownMenu_LinkToExtstate - links the drop down menu to an extstate<br />
- reagirl.DropDownMenu_LinkToIniValue - links the drop down menu to an ini-value - reagirl.DropDownMenu_Unlink - removes the link between the drop down menu and a certain state</li>
</ul>
<p>Check the <a href="#Tutorial_004_Disabled_UI_Elements">fourth tutorial "Disabled UI-Elements"</a> to see examples of guis with sliders.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_007_Sliders"></a>
<a href="#The_Gui_Elements_007_Sliders"> ^</a> <u><b>Sliders</b></u><br>			<p>
<div class="ch">
<p>Sliders are ui-elements that give the user a way to choose a number-value between a start-value and an end-value.<br />
It has a line on which you have a circle that can be moved around. Depending on where the circle is, a certain value has been selected.<br />
For instance: you can have a slider with a value-range from 1 to 10 and the user can move the circle to choose any value between 1 and 10.<br />
You can also give a stepsize. So if you want the user to just choose integers, give a step-size of 1.<br />
The slider can be altered using mousewheel, arrow keys, PgUp and PgDn as well as home/end-key</p>
<p>You can add sliders with reagirl.Slider_Add() which has 14 parameters.</p>
<ul>
<li>Parameters 1 and 2 are the x and y coordinate in pixels of the slider. Set them to nil to autoposition the slider.<br />
</li>
<li>Parameter 3 is the width of the slider in pixels. This includes the caption so make it long enough.<br />
</li>
<li>Parameter 4 is the caption of the slider, which is a text shown on the left side of the slider.<br />
</li>
<li>Parameter 5 is the caption-width. With this you can influence, at which point the actual slider shall start.<br />
So if you have numerous sliders underneath, you can set all their cap_width to the same value so they are perfectly aligned.<br />
If you don't need that, set this to nil, which starts the slider directly after the caption.<br />
</li>
<li>Parameter 6 is meaningOfUI_Element, which is a description for the slider communicated to screen reader users. Explain what the slider is for and why.<br />
</li>
<li>Parameter 7 is the unit. This is a string that is shown at the right side of the slider. This can be something like "%", "percentage" or "cpus" or whatever the unit of your slider is. Set it to nil or "" if you don't need one.<br />
</li>
<li>Parameter 8 and 9 are the start and end-values of the slider. Means, when you move the circle to the far left or to the far right, it will be at start-value or end-value respectively.<br />
</li>
<li>Parameter 10 is the stepsize. This will make the slider go in steps. For instance a step of 10 will move the circle of the slider only in steps of 10.<br />
So for instance, if you have startvalue=10 and end-value=50 and steps=10, the possible steps in the slider are 10, 20, 30, 40 and 50. No other values can be chosen by the user.<br />
</li>
<li>Parameter 11 is the init-value. That's where the circle is when you start the gui.<br />
</li>
<li>Parameter 12 is the default value. So if you have a default-value, set this to this value.<br />
The slider will draw a small line at where the default-value is.<br />
Doubleclicking will set the slider back to this default-value.<br />
</li>
<li>Parameter 13 is the run-function, which is run everytime the user moves the circle of the slider.<br />
You can set this to nil, if you don't need one.<br />
The run-function gets the element_id of the moved slider as first and the current value of the slider as second parameter.<br />
</li>
<li>Parameter 14 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>You can do more things with sliders:</p>
<ul>
<li>reagirl.Slider_GetStartValue - gets the start-value of the slider<br />
</li>
<li>reagirl.Slider_SetStartValue - sets the start-value of the slider<br />
</li>
<li>reagirl.Slider_GetEndValue - gets the end-value of the slider<br />
</li>
<li>reagirl.Slider_SetEndValue - sets the end-value of the slider<br />
</li>
<li>reagirl.Slider_GetDefaultValue - gets the current default-value of the slider<br />
</li>
<li>reagirl.Slider_SetDefaultValue - sets the current default-value of the slider<br />
</li>
<li>reagirl.Slider_ResetToDefaultValue - resets the slider to the default-value<br />
</li>
<li>reagirl.Slider_GetValue - gets the currently set value of the slider<br />
</li>
<li>reagirl.Slider_SetValue - sets the current value of the slider<br />
</li>
<li>reagirl.Slider_GetDimensions - gets the current width of the slider<br />
</li>
<li>reagirl.Slider_SetDimensions - sets the width of the slider<br />
</li>
<li>reagirl.Slider_GetDisabled - gets the disability-state of the slider<br />
</li>
<li>reagirl.Slider_SetDisabled - sets the disability-state of the slider, means, if it can be influenced by mouse or keyboard or not<br />
</li>
<li>reagirl.Slider_LinkToIntConfigVar - links the slider to a certain integer config-variable - reagirl.Slider_LinkToDoubleConfigVar - links the slider to a certain double config-variable - reagirl.Slider_LinkToExtstate - links the slider to an extstate<br />
- reagirl.Slider_LinkToIniValue - links the slider to an ini-value - reagirl.Slider_Unlink - removes the link between the checkbox and a certain state<br />
Check the <a href="#Tutorial_004_Disabled_UI_Elements">fourth tutorial "Disabled UI-Elements"</a> to see examples of guis with sliders.</li>
</ul>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_008_Tabs"></a>
<a href="#The_Gui_Elements_008_Tabs"> ^</a> <u><b>Tabs</b></u><br>			<p>
<div class="ch">
<p>Tabs allow you to structure ui-elements into categories. For instance, you can have all settings for setting one in one category(tab) and the ones for setting two in another category(tab).<br />
And when you switch between the tabs, only the ui-elements associated with a specific tab are shown while the others are hidden.</p>
<p>With them, you can organize your guis better so people are not overwhelmed by one page with all ui-elements at once.<br />
You can also put ui-elements outside of tabs so they are shown all the time.</p>
<p>Only one tab-ui-element per gui is allowed!</p>
<p>You add tabs to your gui using reagirl.Tabs_Add(), which has ten parameters.</p>
<ul>
<li>Parameters 1 and 2 are x and y-position of the tabs in pixels. You can set these to nil to autoposition the tabs.<br />
</li>
<li>Parameters 3 and 4 are the width and height of the grey background of the tabs, that gives a backdrop to ui-elements.<br />
It's intended to show which ui-elements are parts of a specific tab. Set them to 0 for no background or nil to let the<br />
background be automatically around the added ui-elements.<br />
</li>
<li>Parameter 5 is a caption for the tabs, which is communicated to screen readers as a general overview of what the tabs are for.<br />
</li>
<li>Parameter 6 is meaningOfUI_Element, which is a description for the tabs, communicated to screen reader users. Explain what the tabs are for and why.<br />
</li>
<li>Parameter 7 is a table with all tab-names, like {"Tab Number 1", "The second tab", "The third one"}<br />
</li>
<li>Parameter 8 is the tab that is selected when the gui is opened.<br />
</li>
<li>Parameter 9 is a run-function that is called everytime the user switched tabs<br />
You can set this to nil, if you don't want to use a run-function when tabs are switched.<br />
The run-function will get the element_id of the tab as first, the selected tab as second and the selected tabname as third parameter.<br />
</li>
<li>Parameter 10 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>There are more things you can do with tabs:</p>
<ul>
<li>reagirl.Tabs_SetUIElementsForTab - associates ui-elements with a specific tab. Means, the associated ui-elements<br />
will only be shown when this tab is selected<br />
</li>
<li>reagirl.Tabs_SetSelected - sets a specific tab as selected<br />
</li>
<li>reagirl.Tabs_GetSelected - gets the currently selected tab</li>
</ul>
<p>Check the <a href="#Tutorial_002_Adding_Tabs_to_a_Gui">second tutorial "Adding Tabs to a Gui"</a> as well as the <a href="#Tutorial_008_Autopositioning_With_Tabs">eight tutorial "Autopositioning with tabs"</a> to see, how to code tabs.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_009_ColorRectangle"></a>
<a href="#The_Gui_Elements_009_ColorRectangle"> ^</a> <u><b>Color Rectangle</b></u><br>			<p>
<div class="ch">
<p>A color rectangle is a rectangle that is of a specific color of your choosing. It can be clicked by the user. It is optionally possible to open a color-selector-dialog when clicking the color rectangle and the chosen color will be used right away in the rectangle. It has a border around it. You can also choose to make the edges round or square shaped individually.</p>
<p>Screen reader users will get notified the color value by its name and by its color-values. These are also communicated via the tooltip for colorblind users. To make it easier for blind users to get a picture of the used color, use one that has a name for it. You can use reagirl.Color_EnumerateNames(), reagirl.Color_GetName() and reagirl.Color_GetColorValuesByName() for this. All standard HTML-color-names are supported.</p>
<p>You add Color-Rectangles to your gui using reagirl.ColorRectangle_Add(), which has 12 parameters.</p>
<ul>
<li>Parameters 1 and 2 are x and y-position of the color rectangle in pixels. You can set these to nil to autoposition the color rectangle.<br />
</li>
<li>Parameters 3 and 4 are the width and height of the color rectangle.</li>
<li>Parameter 5 through 7 are the r,g,b-values of the color of the rectangle(values ranging from 1-255)</li>
<li>Parameter 8 is the caption of the color-rectangle, which is communicated to screen readers. - Parameter 9 is meaningOfUI_Element, which is a description for the color-rectangle, communicated to screen reader users. Explain what the rectangle is for and why.<br />
</li>
<li>Parameter 10 signals, if clicking the color-rectangle opens up a color-selector-dialog(true) or not(false) - Parameter 11 is the run-function, that is run everytime the user clicks the color-rectangle. If a color-selector-dialog is opened, the run-function will be run after the user closed the color-selector.</li>
<li>Parameter 12 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>If you need a color-rectangle, that is not treated as a clickable ui-element, use reagirl.DecorRectangle_Add().</p>
<p>There are more things you can do with color-rectangles:</p>
<ul>
<li>reagirl.ColorRectangle_GetEdgeStyle - gets if the individual edges of the color-rectangle are square or rounded<br />
</li>
<li>reagirl.ColorRectangle_SetEdgeStyle - sets the individual edges of the color-rectangle to square or rounded<br />
</li>
<li>reagirl.ColorRectangle_GetRadius - gets the current radius of the color-rectangle edges</li>
<li>reagirl.ColorRectangle_SetRadius - sets the radius of the color-rectangle edges</li>
<li>reagirl.ColorRectangle_GetColor - gets the current color of the color-rectangle</li>
<li>reagirl.ColorRectangle_SetColor - sets the color of the color-rectangle</li>
</ul>
<p>Check the <a href="#Tutorial_002_Adding_Tabs_to_a_Gui">second tutorial "Adding Tabs to a Gui"</a> as well as the <a href="#Tutorial_008_Autopositioning_With_Tabs">eight tutorial "Autopositioning with tabs"</a> to see, how to code tabs.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_010_BurgerMenu"></a>
<a href="#The_Gui_Elements_010_BurgerMenu"> ^</a> <u><b>Burger Menu</b></u><br>			<p>
<div class="ch">
<p>A burger-menu is a ui-element very common on websites, being a button with three horizontal lines on it. It opens a menu when clicking on it, so the user can select additional options.</p>
<pre><code>                    You add Burger-menus to your gui using reagirl.Burgermenu\_Add(), which has 8 parameters.  </code></pre>
<ul>
<li>Parameters 1 and 2 are x and y-position of the burger-menu in pixels. You can set these to nil to autoposition the burger-menus.<br />
</li>
<li>Parameter 3 is a caption read to accessibility-users</li>
<li>Parameter 4 is mode, which let's you choose between different options for the burger menu, like 15x15 size or 30x30 size</li>
<li>Parameter 5 is a description of the burger-menu, communicated to accessibility-users by screen reader as well as a tooltip</li>
<li>Parameter 6 is the menu shown, when the user clicks the burger-menu. It is formatted the way as gfx.showmenu() accepts it. - Parameter 7 is the run-function, that is run everytime the user selects a menu-entry</li>
<li>Parameter 8 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>There are more things you can do with burgermenus:<br />
- reagirl.Burgermenu_GetMenu - gets the currently set menu of the burger-menu - reagirl.Burgermenu_SetMenu - sets a new menu to the burger-menu</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_011_ToolbarButtons"></a>
<a href="#The_Gui_Elements_011_ToolbarButtons"> ^</a> <u><b>Toolbarbuttons</b></u><br>			<p>
<div class="ch">
<p>A toolbar button is a button, that can be clicked to. It shows either a text(as text icons) or an image. They can show different states(up to 32). It's possible to show them with a button-image or as a text-toolbar-button. Toolbarbuttons are basically the same as what you expect from the buttons in Reaper's toolbars, but with more options.</p>
<p>For toolbar-button-images, you create a toolbar-image, which is 30 pixels in height and 30*number of states. So if you have 5 states, you create an image with 30+150 pixels. In the images, you put the number of states as individual images. So for our 5-state image, the first 30 pixels are for the image of state 1, the second 30 pixels are for the image of state 2, the third 30 pixels for the image of state 3, etc. Important: if you set mode=5, the image will behave as Reaper's own toolbar-buttons. With that, the image is 30*90 pixels with the first 30 pixels being the image for button is turned off, the second 30 pixels for the mouse is hovering above the button and the third 30 pixels for when the button is turned on.</p>
<p>For scaling, you create upscaled images for 1x(30*num_states x 30 pixels), 2x(60*num_states x 60 pixels, 3x(90*num_states x 60 pixels), etc. The filenames are either in the same folder like the unscaled image, like:</p>
<p>toolbaricon-image.png toolbaricon-image-2x.png toolbaricon-image-3x.png etc</p>
<p>Or you place them in subfolders, where the scaling is written in 100 steps(Reaper's behavior):</p>
<p>toolbar-image.png 200/toolbar-image.png 300/toolbar-image.png 400/toolbar-image.png etc</p>
<pre><code>                    You add toolbar-buttons to your gui using reagirl.ToolbarButton\_Add(), which has 11 parameters.  </code></pre>
<ul>
<li>Parameters 1 and 2 are x and y-position of the toolbar-butotn in pixels. You can set these to nil to autoposition the tabs.<br />
</li>
<li>Parameter 3 is the toolbar-icon-filename with path. Set it to "" when doing text-icons.</li>
<li>Parameter 4 is the number of states the button allows. You can have up to 32 states.</li>
<li>Parameter 5 is the default state. Pick a number and it will show the state in the button.</li>
<li>Parameter 6 is a table with all state-names. Each state-name will be shown in the tooltip, when the user clicks the button. So if the button is clicked and turns into state 2, the second state-name will be shown. Pass it over like: {"state 1", "the second state", "and a third state too"}</li>
<li>Parameter 7 is the drawing-mode. You can choose between different states, like 1, toolbar-icon only 2, toolbar-icon+caption right 3, text-toolbar-icon 4, text-toolbar-icon double width 5, Reaper's toolbar behavior, means, the toolbar-image will be seen as: left side, state 0; right side, state 1 and the middle part is used for when the mouse hovers above the toolbar button There are also flags like &amp;128, which places the button directly after the previous ui-element(good for grouped buttons that belong together) and &amp;256, which draws the button borderless, where only the button-image will be shown, not the borders around it(good for when you want to create your own button-edges in the image) Just add the flag-value to the mode-parameter, like 3+256 for a text-icon without borders or 1+128 for a toolbar-icon-button, that is placed directly after the previous ui-element.<br />
</li>
<li>Parameter 8 is a caption read to accessibility-users</li>
<li>Parameter 9 is a description of the toolbar-button, communicated to accessibility-users by screen reader as well as a tooltip</li>
<li>Parameter 10 is the run-function, that is run everytime the user clicks the button</li>
<li>Parameter 11 is unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>There are more things you can do with burgermenus:</p>
<pre><code>                    - reagirl.ToolbarButton\_GetColor() - gets the color of the toolbar-button</code></pre>
<ul>
<li>reagirl.ToolbarButton_SetColor() - sets the color of the toolbar-button<br />
</li>
<li>reagirl.ToolbarButton_GetState() - gets the state of the toolbar-button</li>
<li>reagirl.ToolbarButton_SetState() - gets the state of the toolbar-button</li>
<li>reagirl.ToolbarButton_GetDropShadow() - gets, if the toolbar-icon is drawn with a drop-shadow</li>
<li>reagirl.ToolbarButton_SetDropShadow() - sets the toolbar-icon to be drawn with a drop-shadow(good for borderless toolbars, where the image would drown otherwise)</li>
<li>reagirl.ToolbarButton_GetEdgeStyle() - get, if the individual edges of the toolbar-button are square or rounded</li>
<li>reagirl.ToolbarButton_SetEdgeStyle() - set, if the individual edges of the toolbar-button are square or rounded</li>
<li>reagirl.ToolbarButton_GetRadius() - get the roundness of the edges of the toolbar-button</li>
<li>reagirl.ToolbarButton_SetRadius() - set the roundness of the edges of the toolbar-button</li>
<li>reagirl.ToolbarButton_LinkToExtstate() - link the toolbar-button to an extstate, so everytime the extstate is updated, the toolbar is as well, vice versa</li>
<li>reagirl.ToolbarButton_LinkToIniValue() - link the toolbar-button to an ini-value, so everytime the ini-value is updated, the toolbar is as well, vice versa</li>
<li>reagirl.ToolbarButton_LinkToIntConfigVar() - link the toolbar-button to a configuration variable, so everytime the config-var is updated, the toolbar is as well, vice versa</li>
<li>reagirl.ToolbarButton_LinkToIntConfigVarBit() - link the toolbar-button to a configuration-variable's bit-value, so everytime the bit-value is updated, the toolbar is as well, vice versa</li>
<li>reagirl.ToolbarButton_LinkToToggleState() - link the toolbar-button to an action's togglestate, so everytime the toggle-state is updated, the toolbar is as well, vice versa</li>
<li>reagirl.ToolbarButton_Unlink() - unlink the toolbar-button from any states</li>
</ul>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_012_LevelMeters"></a>
<a href="#The_Gui_Elements_012_LevelMeters"> ^</a> <u><b>Level Meters</b></u><br>			<p>
<div class="ch">
<p>Level-meters are meters, that show you the level of a track or a hardware input. They show the level with green(everything is fine), yellow(headroom) or red(clipping) as well as a level-value. You can click into them to reset the the level-value, for instance, when clippings have occured.</p>
<pre><code>                    You add Meters to your gui using reagirl.Meter\_Add(), which has 9 parameters.  </code></pre>
<ul>
<li>Parameters 1 and 2 are x and y-position of the meter in pixels. You can set these to nil to autoposition the meters.<br />
</li>
<li>Parameters 3 and 4 are width and height of the meters; can be negative to anchor them to the bottom or right edge of the window</li>
<li>Parameter 5 is the mode, which is either 1, the meter is a rectangle showing the level using the color of the rectangle, 2, a horizontal meter, 3, a vertical meter</li>
<li>Parameter 6 is the name of the meter, that will be communicated to screen reader users</li>
<li>Parameter 7 is a description of the meter, communicated to accessibility-users by screen reader as well as a tooltip<br />
- Parameter 8 is the run-function, which is currently unused(suggest me, in which case you want the run-function to be triggered)</li>
<li>Parameter 9 is a unique identifier, used to adress this specific ui-element. With that, it's possible to control the ui-element from the outside of a script, like clicking it</li>
</ul>
<p>There are more things you can do with meters:<br />
- reagirl.Meter_GetMode() - gets the current drawing-mode of a meter - reagirl.Meter_SetMode() - sets the drawing mode of a meter - reagirl.Meter_GetPeak() - gets the currently measured peaks of a meter - reagirl.Meter_SetPeak() - sets new peak-values for a meter - reagirl.Meter_GetLink() - gets, to which the meter is currently linked to - reagirl.Meter_LinkToHWInput() - links a meter to a hardware input - reagirl.Meter_LinkToTrack() - links a meter to a track, including the options for the main track - reagirl.Meter_Unlink() - unlinks the meter - reagirl.Meter_GetOptions() - gets the various options for a meter - reagirl.Meter_SetOptions() - sets various options of a meter - reagirl.Meter_GetScreenreaderOptions() - gets various screen reader options for a meter - reagirl.Meter_SetScreenreaderOptions() - sets various screen reader options for a meter</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_Concepts001_Context_Menus"></a>
<a href="#The_Gui_Elements_Concepts001_Context_Menus"> ^</a> <u><b>Context Menus</b></u><br>			<p>
<div class="ch">
<p>Context menus are menus that are opened, when the user right-clicks a ui-element.<br />
Any ui-element can have its own context-menu.<br />
To add one to a ui-element, you need the element_id of the ui-element that shall get the menu as well as a run-function.<br />
Then use the function reagirl.UI_Element_GetSet_ContextMenu()</p>
<p>It has four parameters.</p>
<ul>
<li>The first one is the element_id of the ui-element, that shall get a context-menu.<br />
</li>
<li>The second one is a boolean with which you tell ReaGirl, if you want to add a context-menu(true) or get the current menu(false).<br />
</li>
<li>The third parameter is the menu itself. It follows the scheme of gfx.showmenu():</li>
</ul>
<blockquote>
<p>It is a list of fields separated by | characters. Each field represents a menu item.<br />
Fields can start with special characters:</p>
</blockquote>
<blockquote>
<p># : grayed out<br />
! : checked<br />
&gt; : this menu item shows a submenu<br />
&lt; : last item in the current submenu</p>
</blockquote>
<blockquote>
<p>Example:<br />
"first item, followed by separator||!second item, checked|&gt;third item which spawns a submenu|#first item in submenu, grayed out|&lt;second and last item in submenu|fourth item in top menu")</p>
</blockquote>
<p>Experiment with it to get a grip on how it works.</p>
<ul>
<li>The last parameter is a run-function that will be run when the user selects a menu-item in the context-menu.<br />
It will get two parameters. First, the element_id of the ui-element, whose context-menu has been used and second the chosen menu-entry.</li>
</ul>
<p>And that's it. Add a run-function for the context-menu, add a ui-element, use its element_id as parameter for reagirl.UI_Element_GetSet_ContextMenu() and fill out the other parameters.<br />
Run the script and the ui-element has a context menu when right clicking it.<br />
Check the <a href="#Tutorial_003_A_Basic_Image_Viewer">third tutorial "A Basic Image Viewer with a file-drop-zone and a context menu"</a> to see, how it looks in practice.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_Concepts002_FileDropZones"></a>
<a href="#The_Gui_Elements_Concepts002_FileDropZones"> ^</a> <u><b>File Drop Zones</b></u><br>			<p>
<div class="ch">
<p>File Drop Zones are zones, where you can drag and drop files onto.<br />
You can give a ui-element a file drop zone and when you did, you can drop files onto the corresponding ui-element.<br />
For instance, you can show an image and define a drop zone for this image. And then you can drop files onto the image itself.<br />
Accessibility users can use ctrl+shift+f to select a file to drop.</p>
<p>Every ui-element can have a file drop zone. You just need the element_id and a run-function for it.<br />
Then use the function reagirl.UI_Element_GetSet_DropZoneFunction() to add a file drop zone to a ui-element.</p>
<ul>
<li>The first parameter is the element_id of the ui-element, that shall get a file drop zone.<br />
</li>
<li>The second parameter sets, if you want to set a file drop zone to the ui-element(true) or get its current run-function.<br />
</li>
<li>The third parameter is a run-function that gets run, when the user drops files onto the ui-element.</li>
</ul>
<p>The run-function will get two parameters passed:<br />
First, the element_id of the ui-element, onto which the files were dropped.<br />
Second, a table with all filenames that were dropped.<br />
It also supports dropping of fx from inside Reaper to it. In that case, the filename starts with @fx:</p>
<p>Check the <a href="#Tutorial_003_A_Basic_Image_Viewer">third tutorial "A Basic Image Viewer with a file-drop-zone and a context menu"</a> to see, how it looks in practice.</p>
<p>And that's all you need to add file drop zones to ui-elements.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="The_Gui_Elements_100_General"></a>
<a href="#The_Gui_Elements_100_General"> ^</a> <u><b>Functions for getting/setting ui-elements in general</b></u><br>			<p>
<div class="ch">
<p>ReaGirl includes a variety of basic functions to influence various attributes of UI-elements, Guis and the gui-window.<br />
Here's a list of all of them. You've seen some of them already in the tutorials.</p>
<ul>
<li>reagirl.GetVersion - returns the version-number of the installed ReaGirl-version</li>
</ul>
<p>Functions for UI-elements:</p>
<ul>
<li>reagirl.UI_Element_GetFocusRect - gets the current coordinates of the focus rectangle<br />
</li>
<li>reagirl.UI_Element_GetFocused - gets the currently focused ui-element<br />
</li>
<li>reagirl.UI_Element_GetHovered - gets the currently hovered ui-element<br />
</li>
<li>reagirl.UI_Element_GetSetCaption - gets/sets the caption of a ui-element<br />
</li>
<li>reagirl.UI_Element_GetSetMeaningOfUIElement - gets/sets the meaning of ui-element, like tooltip/screen reader helpmessage<br />
</li>
<li>reagirl.UI_Element_GetSetPosition - gets/sets the position of a ui-element<br />
</li>
<li>reagirl.UI_Element_GetSetRunFunction - gets/sets the current run-functions<br />
- reagirl.UI_Element_GetSetSticky - gets/sets if a ui-element is set to sticky</li>
<li>reagirl.UI_Element_GetSetVisibility - gets/sets visibility of a ui-element<br />
</li>
<li>reagirl.UI_Element_GetType - gets the type of a ui-element, like Edit for inputboxes, label, checkbox, etc<br />
</li>
<li>reagirl.UI_Element_IsElementAtMousePosition - checks, if a ui-element is at mouse-position<br />
</li>
<li>reagirl.UI_Element_Last_Element_Current_Position - gets the position of the last ui-element added to the gui<br />
</li>
<li>reagirl.UI_Element_Remove - removes a ui-element<br />
</li>
<li>reagirl.UI_Element_SetFocused - sets a specific ui-element focused<br />
</li>
<li>reagirl.UI_Element_SetHiddenFromTable - sets all ui-elements hidden/visible that are passed over as a table<br />
</li>
<li>reagirl.UI_Element_SetFocusRect - sets the focus rectangle to certain coordinates</li>
</ul>
<p>Functions for the Gui:</p>
<ul>
<li>reagirl.Gui_AtExit - sets a run-function that is run when the gui-window gets closed<br />
</li>
<li>reagirl.Gui_AtEnter - sets a run-function when the user hits the enter key into the gui(for closing at enter-key)<br />
</li>
<li>reagirl.Gui_Close - closes the gui-window<br />
</li>
<li>reagirl.Gui_ForceRefresh - forces a refresh of the gui, if something has changed, usually not needed<br />
</li>
<li>reagirl.Gui_GetBoundaries - gets the current boundaries of the ui-elements<br />
- reagirl.Gui_GetCurrentScriptInstance - gets the identifier of the current script-instance<br />
</li>
<li>reagirl.Gui_IsOpen - returns, if the gui-window is currently opened or not<br />
</li>
<li>reagirl.Gui_Manage - manages the gui-functionality, needs to be called periodically<br />
</li>
<li>reagirl.Gui_New - starts a new gui and throws away the current one<br />
</li>
<li>reagirl.Gui_Open - opens up the gui-window<br />
- reagirl.Gui_GetSetStickyOffset - sets an offset to the top/bottom to prevent ui-elements scrolling/tabbing behind sticky ui-elements</li>
<li>reagirl.Gui_PreventCloseViaEscForOneCycle - prevents the closing of the gui via esc-key for one defer-cycle<br />
</li>
<li>reagirl.Gui_PreventEnterForOneCycle - prevents the "global" enter-key from working for one defer-cycle<br />
</li>
<li>reagirl.Gui_PreventScrollingForOneCycle - prevents scrolling of the gui for one defer-cycle</li>
</ul>
<p>Functions for the color-theme:</p>
<ul>
<li>reagirl.Color_GetSet() - gets/sets the colors of ui-elements</li>
<li>reagirl.Color_GetColorValuesByName - get the r,g,b-color-values by the name of a color(all html-color-names are supported)</li>
<li>reagirl.Color_GetName - gets the name of a color by its r,g,b-values(all html-color-names are supported)</li>
<li>reagirl.Color_EnumerateNames - enumerates the supported html-names</li>
</ul>
<p>Functions for the gui-window:</p>
<ul>
<li>reagirl.Window_ForceSize_Minimum - forces that the window can't be resizes under a specific minimum<br />
</li>
<li>reagirl.Window_ForceSize_Maximum - forces that the window can't be resizes above a specific maximum<br />
</li>
<li>reagirl.Window_GetCurrentScale - gets the currently used scaling-factor for the gui<br />
- reagirl.Window_GetScrollOffset - gets the current scroll-offset of the gui<br />
- reagirl.Window_GetHWND - gets the window-handler of the current ReaGirl-window<br />
- reagirl.Window_ResizedFunc - sets a run-function that gets called everytime the ReaGirl-window gets resized<br />
</li>
<li>reagirl.Window_SetCurrentScale - sets a scaling factor for the gui between 1 and 8<br />
</li>
<li>reagirl.Window_SetFocus - sets window-focus back to the gui-window<br />
</li>
<li>reagirl.Window_DragOnEmptyArea - sets, if clicking into an empty area(an area without ui-elements) allows dragging the window</li>
<li>reagirl.Window_SetBorderless - sets, the window to be borderless</li>
</ul>
<p>Function to access a ReaGirl-gui-window from other scripts:</p>
<ul>
<li><p>reagirl.Ext_SendEvent - send an event to a ui-element in a ReaGirl-gui; set "Show gui-name and ui-element-name in console" in the settings to get the attributes</p></li>
<li><p>reagirl.Ext_SendEventByID - send an event to a ui-element in a ReaGirl-gui; set "Show gui-name and ui-element-name in console" in the settings to get the attributes</p></li>
<li><p>reagirl.Ext_Tab_SetSelected - sets a tab of specific ReaGirl-gui-window focused<br />
- reagirl.Ext_UI_Element_GetHovered - gets the currently hovered ui-element from a ReaGirl-gui-window<br />
- reagirl.Ext_Window_GetInstances - gets the ReaGirl-window-instances currently opened<br />
</p></li>
<li><p>reagirl.Ext_Window_Focus - sets window-focus to an opened ReaGirl-gui-window<br />
- reagirl.Ext_IsAnyReaGirlGuiHovered - gets, if the mouse is currently hovering above any ReaGirl-window<br />
</p></li>
<li><p>reagirl.Ext_Window_IsOpen - gets, if a specific ReaGirl-gui-window is currently opened<br />
</p></li>
<li><p>reagirl.Ext_Window_Close - close a ReaGirl-gui-window from the outside</p></li>
<li><p>reagirl.Ext_Window_GetState - gets the current dimensions and dock-state of an opened/previously opened ReaGirl-window<br />
</p></li>
<li><p>reagirl.Ext_Window_SetState - sets the current dimensions and dock-state of an opened/previously opened ReaGirl-window<br />
</p></li>
<li><p>reagirl.Ext_Window_ResetToDefault - resets a ReaGirl-Gui-Window to its default dimensions and dockstate</p>
<pre><code>              Tools:  

              - reagirl.Base64\_Decoder - decodes a base-64-encoded string  
              - reagirl.Base64\_Encoder - encodes a string into base64  </code></pre></li>
</ul>
<p>Most of them are probably not needed by you but some you may need them from time to time.</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Best_Practices_On_Accessibility"></a>
<a href="#Best_Practices_On_Accessibility"> ^</a> <u><b>Best Practices On Accessibility</b></u><br>			<p>
<div class="ch">
<p>ReaGirl is designed to make accessibility as easy as possible. For instance, screen reader messages are sent automatically. So blind users always know, what is happening on your gui.<br />
Screen readers are usually a speech synthesis engine, that reads out, which ui-element is currently selected, which setting, etc.<br />
This helps blind users to know, where in a gui they are, since the screen reader is reading it to them.<br />
ReaGirl takes care of this as good as possible.</p>
<p>ReaGirl also takes care of keyboard-navigation, since blind users usually use the keyboard to use your gui.</p>
<p>However, there are some areas, where ReaGirl can't do the work for you and that need to be taken into consideration by you.<br />
But don't worry, it's easier than you think. Once you digested the rules, most of your guis will be easy to use by blind users.</p>
<ol>
<li><p>Blind users use guis generally using the keyboard. They select the ui-element using tab or shift+tab.<br />
They "click" ui-elements using the space-bar or the enter-key.<br />
And they choose the current selection of a drop down menu or a slider using cursor-keys, PgUp, PgDn, Home and End.<br />
This has some implications on how to place ui-elements. For instance:</p></li>
<li><p>Put ui-elements of a certain context next to each other.<br />
This is important! In your script, it means that the _Add-functions that belong to each other should follow each other.<br />
Imagine an inputbox that shows a filename and a button that opens up a file-selection-dialog.<br />
The inputbox and the button are probably placed next to each other in your gui. And they need to be placed<br />
next to each other in your script, means: reagirl.InputBox_Add() first, then reagirl.Button_Add() as the next ui-element.<br />
And when you use your gui and choose the ui-element using the tab-key, your inputbox will be selected first and the button as the next ui-element.<br />
Make this logical. Blind users can't see, where an important ui-element is placed, so they usually expect, that the next logical ui-element they tab to follows the current one.<br />
Or in our example: the inputbox first and when hitting the tab key again, the file-selection-button is selected next.<br />
This might be a challenge at first, especially when you are not used to gui-coding yet. But you are going to get used to it quickly.<br />
Oh, before I forget: when you rearrange ui-elements in your gui, don't only change the coordinates, but also think, if the order of the ui-elements visually is still the same as the order when going through them using the tab key.<br />
So after the change, go through them using the tab key to see, if the order is still logical.<br />
Rule of thumb is: when tabbing through the ui-elements, you go from left to right and from up to down, just like text in an editor.<br />
If tabbing through the ui-elements doesn't follow this scheme, change the order of the _Add-functions in your script until they are correct.<br />
This way, you make the gui easier to use by blind people.</p></li>
<li><p>Put the most important ui-elements first, then the less important ones, then the least important ones.<br />
As I said, blind people usually use the tab-key and shift+tab to select the ui-elements in your gui.<br />
When the gui-window is opened, the first ui-element is selected.<br />
And here's why it's important to place the most important first:<br />
When you need to enter your gui time and again to change settings, you want to access the most important ui-elements as quickly as possible.<br />
If you need to hit tab thousands of times to get to the important ui-elements, it costs time and is very annoying.<br />
So make a wise order of ui-elements so going through them using tab is as fast as possible.<br />
If you have two sets of ui-elements that should be reached as quickly as possible, put the one set at the beginning and the other at the end of your gui.<br />
That way you quickly reach the first ones using tab and the last ones using shift+tab.</p></li>
<li><p>Add text to meaningOfUI_Element-parameters, which is a short explanation and some context on what the ui-element is supposed to do.<br />
This is very important! Setting meaningOfUI_Element-parameters fills up the tooltips. But it is also the text sent to users of screen readers.<br />
You can imagine this the following:<br />
If a blind user uses tab to select a checkbox, they get read out checkbox-caption, current checkstate and meaningOfUI_Element.<br />
That way they know, how the checkbox is named(caption), if it's currently checked or not(checkstate) and what the checkbox is supposed to do and what happens if they change the checkstate(meaningOfUI_Element).<br />
Make it as long as needed and as short as possible. Don't be afraid to rework it a few times to get it more precisely.<br />
Rule of thumb: answer the questions What does the ui-element, how does it and why does it, as well as what happens when the ui-element is used. With these questions answered, you usually write a good meaningOfUI_Element.<br />
If you need inspiration, open up the preferences of Reaper and hover above the ui-elements.<br />
At the bottom of the window, there's a short explanation on what the ui-element is supposed to do(which is also sent to screen reader users).<br />
This gives you an idea on how to write them.</p></li>
<li><p>If you need to write #Hashtags, write them camel case. Like #ThisIsBrilliant or #TheMightyBoosh. Screen readers will read out each word individually<br />
that way, as they see each uppercase letter as start of a new word. If you write them all lowercase or uppercase, screen readers will try to read the hashtag as one word which could be a mumbling mess.<br />
If you need to write acronyms, write them UPPERCASE. That way, screen readers will read each letter individually.</p></li>
<li><p>Sometimes, you do things in your script that you might want to communicate to blind users. For instance, if you store a setting everytime a checkbox is toggled, you should communicate this as blind users don't neccessarily know, what you did. In that case, use reagirl.ScreenReader_SendMessage() to send a message to screen reader users. So in our case, reagirl.ScreenReader_SendMessage("Setting stored") or something similar would be suitable to communicate this to blind users clearly. Don't use reaper.osara_outputMessage() since ReaGirl might interfere with this function and interrupt your sent message. Always use reagirl.ScreenReader_SendMessage() if you want to send screen reader messages, as ReaGirl will send them always this way. One thing to mention too: don't send messages permanently, only when needed. If you sent a message while the former one is still being read to blind users, the old message will be interrupted with the new one. So blind people might not get all information that you tried to convey.</p></li>
<li><p>Check, if your gui is working in black'n'white/grayscale, means, make a screenshot, put it into a graphics-editor and set saturation to 0. Check, if all ui-elements are still easy to differentiate from each other. This is important for colorblind users. for instance: If you have two images, next to each other, one is red and the other one is green, you can easily differentiate them from each other. But: many colorblind people only see everything in grayscale and two colors, that look very different from each other, may have the exact same grey color for colorblind people. So, when you want to have two images next to each other that are differentiable from each other, make one brighter than the other. And to know, if you did it right, check the gui in black'n'white/grayscale and see, if one image looks brighter from the other. If yes, then it's easier to read for colorblind people.</p></li>
<li><p>Ask for feedback, especially by blind users. They know best if your explanations are understandable or hard to get.<br />
There's a mailing list called Reaper without Peepers, which is primarily a mailinglist by blind people for blind people.<br />
Ask there for people who could test your script and give you feedback.<br />
They have the most experience in what a good description is and what is a bad one, so pay attention and listen.</p></li>
</ol>
<p>With these rules, most of your guis should be easy to use by blind people. The rest I intend to do automagically with ReaGirl.</p>
<p>One thing to note: in the ReaGirl-settings, there's an option under accessibility called "Show screen reader messages in console(debug)".<br />
When you turn this option on, ReaGirl will put all screen reader-messages of ReaGirl-guis into the ReaScript-console-window.<br />
That way you can peek, how other ReaGirl-guis write screen reader-messages or how things are communicated to blind people.<br />
Looking at this for some time helps getting an idea on how blind users perceive guis.</p>
<p>You can also install the Osara-extension and NVDA(or JAWS) to get the full experience.<br />
Osara sends screen reader messages to the operating system with the help of NVDA(or JAWS).<br />
You install Osara and either NVDA(or JAWS). Then you start NVDA(or JAWS).You computer will read now every ui-element you are hovering above with the mouse and each ui-element that you are selecting using tab or shift+tab.<br />
This can be overwhelming at first, so you can make it silent in the preferences and show a speech viewer instead, which gives you all screen reader messages as well, not just the ones from ReaGirl-guis.<br />
Read about how to use NVDA(or JAWS), speech viewer and it's preferences and how to use it.<br />
It's usually not needed to install Osara and NVDA(or JAWS) for ReaGirl scripts, but if you intend to make non-ReaGirl-scripts accessible, you'll need both to get these things right.<br />
Especially, since Osara includes a function called reaper.osara_outputMessage(), that outputs messages to the screen reader. A function that I use in ReaGirl extensively(but use reagirl.ScreenReader_SendMessage() instead in your ReaGirl-guis!).</p>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Best_Practices_On_Writing_Guis_As_Blind_Scripter"></a>
<a href="#Best_Practices_On_Writing_Guis_As_Blind_Scripter"> ^</a> <u><b>Best Practices on Writing guis as Blind Scripter</b></u><br>			<p>
<div class="ch">
<p>ReaGirl has some features, that you can use as a blind scripter to code your own guis.<br />
The most important thing is auto-positioning, which allows you to position ui-elements automatically.<br />
It's comparable with writing text: you can place each ui-element after each other or you place it in the next line.<br />
To place ui-elements automatically, set the x and y-position-parameters of the _Add-functions to nil.<br />
This will place the ui-element to the right side of the previous ui-element.<br />
If you want to place the next ui-element into the next line, use reagirl.NextLine(), which is like the Enter-key in an editor, that starts a new line. So the next ui-element is positioned on the left side underneath the last one(like in a newly started line).</p>
<p>Read the <a href="#Tutorial_007_Autopositioning_Of_UI_Elements">tutorial about autopositioning</a> and <a href="#Tutorial_008_Autopositioning_With_Tabs">tutorial about autopositioning with tabs</a> to learn how it works.</p>
<p>There are some things you should consider to also make the gui easy to use for sighted users:<br />
1. Don't put too many ui-elements after each other, as this means you need to scroll horizontally to reach the ui-elements.<br />
This is usually not a problem for you, as you are navigating with the tab-key, which automatically scrolls the tabbed ui-element into view.<br />
However, sighted users usually work with mouse and they can become easily annoyed when having to scroll horizontally to see the last ui-element in a line.<br />
So don't add more than five buttons, three checkboxes, one inputbox, one slider or one drop down menu after each other, to keep the gui conveniently usable.<br />
When in doubt, better start a new line where you put the next ui-element. Scrolling up and down to get the next ui-element into view is usually more accepted than scrolling left and right.</p>
<ol>
<li><p>When using labels, don't write a wall of text. From my experience, blind users use paragraphs in text much less often than sighted people, which can become difficult to read, especially for neurodivergent people.<br />
So when you need to write a lot of text into a label, think about, when one point ends and when the next point starts.<br />
Add two newlines between them. That way sighted people can digest your text much easier.<br />
The reason for it is that sighted people tend to "scan" the text loosely for the most important things, like striving through the text for important words that their eyes will be hooked at, which determines if a text is important right now or not.<br />
And they usually see each paragraph as one piece of knowledge to digest.<br />
So adding newlines between each point you are making makes it faster for sighted people to scan your text for the most important information.</p></li>
<li><p>This point is basically the same advice I gave you about text in labels, but this time it's for ui-elements:<br />
Put all ui-elements that are belonging to each other close to each other.<br />
And when all ui-elements of one context are added, use two reagirl.NextLine()-functioncalls. This will add a, for lack of a better term, newline between ui-elements.<br />
So you have one pack of ui-elements of one context, then some gap by a new line, then the next pack of ui-elements of the next context, etc.<br />
That way you prevent crowded guis that can be hard to read.<br />
Just as sighted people scan text, they also scan guis for the most important elements, so by adding newlines using two reagirl.NextLine()-functioncalls,<br />
you make the gui easier to read, as it's faster to skip the unimportant parts in this moment.</p></li>
<li><p>Use label-backdrops to structure your gui. With them you can avoid even more walls of ui-elements.<br />
Label-backdrops are rectangles that originate in a label and who enclose ui-elements. So sighted users easily see, which ui-element belongs to a certain context(like a label describing the context) and which one doesn't.<br />
I wrote a tutorial on how to <a href="#Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning">structure guis with label-backdrops</a>.<br />
This is probably a little difficult in the beginning, since it's hard to know, if you did it right, even though the functions used try to minimize potential errors as much as possible.<br />
So when getting into label-backdrops, get feedback by sighted users to improve on potential issues.</p></li>
<li><p>When doing a gui that shall also be used by sighted people, don't hesitate to ask for feedback. That way you can avoid crowded walls of texts or walls of ui-elements.<br />
Autopositioning should give you everything you need to make them work and label-backdrops to improve readability but there are still cases, where some feedback is still very valuable to get a gui right.</p></li>
</ol>
</div><br>
</div>
<div class="ch">
<hr>
<a class="anch" id="Final_words"></a>
<a href="#Final_words"> ^</a> <u><b>Final Words</b></u><br>			<p>
<div class="ch">
<p>When you read every chapter of this documentation, you have a good idea of what ReaGirl can do for you and how.</p>
<p>But there's even more possible. So read about them in the functions-reference, where I explain in great detail every available function, their parameters and return values.</p>
<p>Great thanks to the development-team of Osara(especially James) without their extension the ReaGirl-project wouldn't be possible at all.<br />
Also thanks to Scott and Chris, who helped me iron out accessibility-issues in the beta-phase.</p>
<p>Big thanks also to the various gui-lib-developers over the years like Lokasenna(Lokasennas Gui-Lib v2 and Scythe), Chris Fillion(ReaImGui) and Tack(Gui Toolkit),<br />
whose gui-libraries were a huge inspiration for various concepts available in ReaGirl. Their influence made ReaGirl as easy to use as it is.</p>
<p>And also a big shoutout to the dozens of scripters in the Reaper-Community, whose help over the years made me a better scripter and therefore able to do this huge project.<br />
I'm standing on the shoulders of giants.</p>
<p>And that's it for now. Enjoy coding guis with ReaGirl and give feedback and bugreports if you have any(see introduction for the Reaper-forum's thread.</p>
<p>Cheers and see you in the next version of ReaGirl</p>
<p>Meo-Ada Mespotine, 6th of May 2024</p>
</div><br>
</div>
      <div class="ch">
        <hr>
                     
          <table><td class="td2"> &#160;</td><td>&#160;</td><td class="td3">Automatically generated by Ultraschall-API 5.3  - 39 elements available <br></td></table>
        <hr>
      </div>
      <br>
      </body>
  </html>
  