    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">    
        <slug>Introduction_001_Introduction</slug>    
        <title>Introduction</title>    
        <description markup_type="markdown" markup_version="1.0.1" indent="default">    
            Welcome to ReaGirl, an accessible Gui-library for Reaper.  
              
            Up until now, there are numerous gui-libraries available for Reaper who do a great job at allowing you to code your own guis.  
            The problem is: none of them allow making guis for blind people for various (mostly technical) reasons, so only people who can see without a problem can use them.  
            ReaGirl's intention is to solve this with a gui-library that makes it easy for you to code your own guis that are also useable by blind users.  
              
            And it does not only feature accessibility for blind users, but it has some additional benefits:  
              
            * It's easy to use.    
            I tried to make it as easy to use as possible so you can quickly throw together a gui for your needs without having to practice using ReaGirl 40 hours a day.  
            * It has 8 ui-elements available for your needs.    
            Labels, Checkboxes, Buttons, Drop Down Menus, Sliders, InputBoxes, Tabs and Images  
            * Fully useable via keyboard.    
            You can navigate through it with keyboard, as you are used with every other gui out there.  
            * It has scrolling features.    
            So if your gui is bigger than the window, users can simpy scroll around to reach every gui-element.  
            * Context-Menus for UI-Elements.    
            Each ui-element can get it's own context menu. And you don't need to worry about positioning and click management. Just associate a context-menu with a ui-element and ReaGirl does the rest for you.  
            * File Drop Zones    
            Each ui-element can have a file-drop zone so you can easily drag n drop files onto them. And just like context-menus, you don't need to place or manage anything. Just add it to a ui-element and ReaGirl does the rest.  
            * AutoScaling    
            ReaGirl scales the gui automatically. So if you change the scaling-factor in Reaper's preferences or use a gui on HiDPI/Retina-displays, ReaGirl scales properly for you.  
			* Linking of UI-Elements to states  
			Many of the ui-elements can be linked to toggle-states, extstates, ini-file-entries and config-variables  
            * Screen Reader Support    
            Blind people can navigate through your gui via keyboard and get feedback to their screen readers, which reads to them the currently selected ui-element and the chosen setting. ReaGirl does it all for you.  
              
            So if you want to make easy guis that are also useable by blind users of your scripts, ReaGirl is there for you and tries to manage everthing you need.  
              
            There's also an official support thread for ReaGirl in the Reaper-forum at:  
            [https://forum.cockos.com/showthread.php?t=291220](https://forum.cockos.com/showthread.php?t=291220)  
                
            So if you find bugs or need help in general, head over there and ask your questions.  
             
            But there's one question left now:    
            "How do I start?" you may ask?     
              
            Well, let's dive into ReaGirl in the next chapters.    
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Introduction
        </chapter_context>
        <next_chapter>Introduction_002_Installation</next_chapter>  
        <tags>introduction</tags>  
    </US_DocBloc>  
  
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">    
        <slug>Introduction_002_Installation</slug>    
        <title>Installation</title>    
        <description markup_type="markdown" markup_version="1.0.1" indent="default">    
            Since ReaGirl is part of Ultraschall-API, the installation-instructions from Ultraschall-API are applicable here as well.  
              
            First make sure, you use the right versions of Reaper, SWS and JS-extension:  
               [Reaper 7.03 and higher](https://www.reaper.fm), [SWS 2.10.0.1 and higher](https://www.sws-extension.org) and [Julian Sader's plugin 1.215 and higher.](https://github.com/juliansader/ReaExtensions/tree/master/js_ReaScriptAPI/)  
            You can download them at [reaper.fm](http://www.reaper.fm) and [sws-extension.org](http://www.sws-extension.org) respectively.  
            Julian Sader's plugin can be installed using ReaPack or gotten from [his own github-site](https://github.com/juliansader/ReaExtensions/tree/master/js_ReaScriptAPI/)  
              
            The screen reader compatbility needs at least Windows 10 or Mac OS.  
              
            To install the Ultraschall-API with ReaGirl, just follow the following steps:  
              
            **Installation via ReaPack**:  
              
            The easiest way is to install the Ultraschall-API and ReaGirl using ReaPack. ReaPack is a package-manager for extensions and helper-stuff for Reaper, which allows you to easily install and update content done by the Reaper community.  
            Many Scripts, Themes, JSFX-FX, etc are available through that.  
              
            1. Install ReaPack. Get it from [https://reapack.com/](https://reapack.com/). There's also a real good [User guide](https://reapack.com/user-guide) for it available, that explains, how to do it.    
               Copy the downloaded dll(Windows), dylib(Mac) or so(Linux)-file into the UserPlugins-folder in the Resources-folder of Reaper.   
               You can find the correct Resources-path in the Reaper-menu "Options -> Show REAPER resource path in explorer/finder...".      
            2. (Re-)Start Reaper    
            3. Go into the Menu Extensions -> ReaPack -> Manage Repositories    
            4. Click on Import/export...-button and choose Import repositories    
            5. Paste into the dialog the following link    
                      
                    https://github.com/Ultraschall/ultraschall-lua-api-for-reaper/raw/master/ultraschall_api_index.xml  
                 
               and hit OK.    
            6. Doubleclick on the Ultraschall-API-entry. A dialog will pop up with a description of the Ultraschall-API and ReaGirl    
            7. Hit the Install/update Ultraschall-API-button and select Install all packages in this repository    
            8. ReaPack will ask you, if you want to install new packages/updates the next time you synchronize ReaPack.    
               Hit Yes.    
            9. ReaPack installs the Ultraschall-API with ReaGirl. If no error appears, it will tell you to restart Reaper, as a new extension has been installed    
            10. Restart Reaper.    
              
            To update the Ultraschall-API with ReaGirl in the future, choose in the menu Extensions -> ReaPack -> Synchronize packages. If an update is available, it will install it automatically.    
            For more information on ReaPack and it's usage, refer [User guide](https://reapack.com/user-guide).  
              
            **Manual Installation**:  
              
            If you can't or don't want to install ReaPack, you can also install it manually.  
              
            1. Just download the zip-file of the current version from [ultraschall_api5.zip](https://github.com/Ultraschall/ultraschall-lua-api-for-reaper/raw/master/ultraschall_api5.zip).    
            2. Extract it to the UserPlugins-folder in the Resources-folder of Reaper. You can find the correct Resources-path in the Reaper-menu "Options -> Show REAPER resource path in explorer/finder...".      
               The folder UserPlugins should contain the folder ultraschall\_api and the files ultraschall\_api\_readme.txt, ultraschall\_api.lua and reagirl.lua after this step.    
            3. Restart Reaper.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Introduction
        </chapter_context>
        <previous_chapter>Introduction_001_Introduction</previous_chapter>  
        <next_chapter>Introduction_003_Included_Actions</next_chapter>  
        <tags>introduction</tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">    
        <slug>Introduction_003_Included_Actions</slug>    
        <title>Included Actions</title>    
        <description markup_type="markdown" markup_version="1.0.1" indent="default">    
            ReaGirl provides a variety of actions that go along with it. Some are meant for development, some for the general users, some both.  
  
            __Development:__    
  
            * __ReaGirl\_Help\_Introduction\_Concepts\_Tutorials\_Documentation.lua__ - opens this documentation  
            * __ReaGirl\_Help\_Functions\_Documentation.lua__ - opens a documentation of all available ReaGirl-functions  
            * __ReaGirl\_OpenFolder\_ExampleScripts.lua__ - opens the example-scripts-folder  
  
            __Settings:__    
  
            * __ReaGirl\_Gui\_Settings.lua__ - a settings-dialog, with which you can set various things in ReaGirl's behavior. Includes also some settings relevant for development. Some of these settings are also settable via actions.  
  
            __Scaling:__    
  
            * __ReaGirl\_Gui\_Settings\_Set\_Scaling\_To\_AutoScaling.lua__ - sets scaling to auto, to use Reaper's/HiDPI/Retina scaling automatically  
            * __ReaGirl\_Gui\_Settings\_Set\_Scaling\_To\_1.lua__ - sets scaling to 1x  
            * ...  
            * __ReaGirl\_Gui\_Settings\_Set\_Scaling\_To\_8.lua__ - sets scaling to 2x  
  
            __General user settings:__    
  
            * __ReaGirl\_Gui\_Settings\_Hovered\_UI\_Element\_Enable\_Report.lua__ - enables, hovering above a ui-element will get read the name of it to screen readers  
            * __ReaGirl\_Gui\_Settings\_Hovered\_UI\_Element\_Disable\_Report.lua__ - disables, that hovered ui-elements get read to screen readers  
            * __ReaGirl\_Gui\_Settings\_Move\_Mouse\_When\_Tabbing\_Enable.lua__ - enables that mouse moves to tabbed ui-element for screen reader users(helpful for when clicking using context-menus)  
            * __ReaGirl\_Gui\_Settings\_Move\_Mouse\_When\_Tabbing\_Disable.lua__ - disables mouse-move when tabbing to ui-elements for screen reader users(makes right-clicking for context-menus difficult)  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Helpmessage\_Enable.lua__ - enables that screen reader-users get an additional help-message on how to use ui-elements  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Helpmessage\_Disable.lua__ - disables help-message on how to use ui-elements  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Messages\_Enable.lua__ - enable screen reader-support in ReaGirl  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Messages\_Disable.lua__ - disable screen reader-support in ReaGirl  
            * __ReaGirl\_Gui\_Settings\_Tooltips\_Enable.lua__ - shows tooltips when hovering above ui-elements  
            * __ReaGirl\_Gui\_Settings\_Tooltips\_Disable.lua__- don't show tooltips  
            * __ReaGirl\_Gui\_Settings\_Scroll\_Via\_Keyboard\_Enable.lua - enables scrolling of ReaGirl-guis via keyboard
            * __ReaGirl\_Gui\_Settings\_Scroll\_Via\_Keyboard\_Disable.lua - disables scrolling of ReaGirl-guis via keyboard
            * __ReaGirl\_Gui\_Settings\_Reset\_Settings\_Window\_Pos\_And\_Size.lua - resets settings window's position and size
  
            __Developer settings:__    
  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Messages\_Show\_In\_Console.lua__ - show screen reader-messages in ReaScript console-window. Helps you debugging meaninOfUI\_Element for blind people.  
            * __ReaGirl\_Gui\_Settings\_Screen\_Reader\_Messages\_Hide\_From\_Console.lua__ - don't show screen reader-messages in the console  
  
            __Experimental Edit Mode:__    
  
            * __ReaGirl\_Gui\_Settings\_EditMode\_Enable.lua__ - will enable experimental edit-mode. This will allow you to drag around ui-elements in a ReaGirl-gui, show a grid by typing g, double-click to edit caption, etc  
            * __ReaGirl\_Gui\_Settings\_EditMode\_Disable.lua__ - disable experimental edit-mode  
  
            You'll probably not need many of them, especially when developing new guis with ReaGirl and if you are not a screen reader-user, but it's probably good to know that these exists, if you need to provide support for users of your ReaGirl-gui-script.  
  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Introduction
        </chapter_context>
        <previous_chapter>Introduction_002_Installation</previous_chapter>  
        <next_chapter>Introduction_001_First_Steps</next_chapter>  
        <tags>introduction</tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Introduction_001_First_Steps</slug>  
        <title>First steps in ReaGirl</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            When making a gui in ReaGirl, you basically have to work through 5 steps.  
  
            0) Initialize ReaGirl    
            1) Add some run-functions    
            2) Start a new gui using reagirl.Gui\_New()    
            3) Add some ui-elements using the various \_Add-functions    
            4) Open a gui using reagirl.Gui\_Open()    
            5) Write and run a defer-function, in which you call reagirl.Gui\_Manage()    
  
            Let's get into these steps in more details.  
  
            #### Step 0: Initialize ReaGirl  
            First add the line  
  
            ```  
            dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
            ```  
              
            to your script. It will load all functions and features of ReaGirl. After that, you can start writing your guis with it.  
            It would also be a good idea to check here, if the installed ReaGirl-version is the one your script is requiring.  
            For this you can use reagirl.GetVersion() and warn the user, if the installed version is too old.  
  
            #### Step 1: Add some run-functions  
            Run-Functions are functions that are run, when the user interacts with a user-interface-element(ui-element). For instance, clicking a checkbox or a button.  
            Or typing/hitting enter into an inputbox. Or if the user moves the slider or selects a menu in a drop-down-menu.    
            Or if the user selects a context-menu-entry or drag n drops files onto a ui-element.    
            So in a run function you tell Reaper what to do, after the user interacted with a ui element.  
  
            A rule of thumb is: every ui-element and interaction-style gets it's own run-function.  
            So one for when the user hits the button. One for when the user toggles a checkbox. One for when the user types text into an inputbox and one for when the user hits enter into the inputbox, etc, etc.  
            These run-functions will get parameters passed from the gui, like the identifier of a ui-element(more on this later) or additional information like a selected menu-entry.  
            So run-functions are powerful and will make the magic happen, once the user interacted with a ui-element.  
  
            When writing a new gui, you can just write some "empty" functions that do nothing. We'll fill them in later.  
            More on run-functions in our tutorials.  
  
            #### Step 2: Start a new gui using reagirl.Gui\_New()  
            This will tell ReaGirl, that you want to start a new gui. And it's simple, just add reagirl.Gui\_New() to your script and you're done.  
            You can also use this later in more complex scripts to throw away an already existing gui and start a new one, but in most cases, you'll only do this once at the beginning of your gui-script.  
  
            #### Step 3: Add some ui-elements using the various \_Add-functions  
            Now the magic starts, we add our first ui-elements. You do it using the various \_Add-functions like Button\_Add, InputBox\_Add, DropDownMenu\_Add, Slider\_Add, Checkbox\_Add, Label\_Add, Image\_Add, etc.  
            All these add-functions will ask you for the position of the ui-element, a caption(which is usually shown next to it), an accessibility-hint which is shown as tooltip and also helps blind users to navigate and understand your gui, and a run-function.  
            Some may ask you for more things like width and height(Images) or initial values(Checkboxes, Sliders, DropDownMenu) or even additional run-functions(InputBox uses one run-function when the user types text and one for when the user hits enter in the inputbox).  
  
            All \_Add-functions return a string called element\_id. This element\_id is like a unique name for your ui-element.    
            You can use this to do additional things with the ui-element. For instance, you can make the edges of a button more round or more edgier using the reagirl-Button\_SetRadius()-function.    
            The function needs this element\_id to know, of which button you want to edit the edges and alter it accordingly.    
            If you remember what I told you about run-functions, then you'll know already that element\_ids are also passed to a run-function by ReaGirl.    
            So you can use one run-function for all buttons. You just check, whether the element\_id passed to the run-function is the same as the element\_id of button1, button2 or button3.    
            So keep these element\_ids in variables or tables, as you can do really nice things with it(we'll dive deeper into element\_ids in the tutorials).    
  
            You can add up to several thousand ui-elements in your gui(though usually, you will do much less).  
  
            #### Step 4: Open a gui using reagirl.Gui\_Open()  
            This will open the gui. You can pass to it the position, the dimensions, the window-title, an accessibility-hint which tells the blind user what to expect from your gui and so on.  
            It's pretty straightforward, so just follow the documentation for what the parameters shall be.  
  
            #### Step 5: Write and run a defer-function, in which you call reagirl.Gui\_Manage()  
            This one's also very easy. Add the following lines at the end of your script:    
              
                  function main()  
                    -- let ReaGirl manage the gui  
                    reagirl.Gui_Manage()  
                      
                    -- check, if the gui-window is still open and if not, stop the script  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            This will run the Gui\_Manage-function, which basically does all the management of the gui, like drawing, click-management, runnning the run-functions when the user interacts with a ui-element, scrolling and other cool stuff, so you don't have to do it yourself.  
            And that's it, 5 steps to make your own gui.  
  
            Some general things to know about ReaGirl:  
            Don't bother with scrolling your ui-elements. This is done by ReaGirl. So if a ui-element is outside of the window, scrollbars appear and you can scroll around with them or by swiping or by keyboard(basically like you do in web-browsers).  
  
            Also don't bother about scaling like Retina/HiDPI or something. This is also done by ReaGirl automatically. So if the user chooses to run your script on Retina/HiDPI-displays or even with an altered scaling set in the preferences, your gui will change automatically.  
  
            Since one of the key-features in ReaGirl is accessibility for blind people, most of the stuff needed for screen reader-management is done by ReaGirl itself. You just need to set the parameters meaningOfUI\_Element properly by giving a short and precise explanation, what the ui-element is doing and why. This will be shown as tooltip and also communicated to blind users via screen reader. This happens automatically, so you don't need to do much more.  
            There's a chapter dedicated on best practices for accessible guis later, if you want to improve on things further.  
  
            In the next chapters, I will take you through some basic tutorials on how making a gui is done in practice.  
            And we'll start with a basic one.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Introduction  
        </chapter_context>
        <previous_chapter>Introduction_001_Introduction</previous_chapter>  
        <next_chapter>Tutorial_000_Introduction</next_chapter>  
        <tags>introduction, first steps</tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_000_Introduction</slug>  
        <title>Tutorial Introduction</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
          In the next few chapters, I will show you a lot of the available concepts and features of ReaGirl through various tutorials.  
            
          I added ready to use code-snippets and I tried to add screenshots wherever possible.  
            
          If for some reason or another you might not be able to copy the code-snippets from the documentation, you can also   
          find them as lua-script-examples. Just run the action "ReaGirl\_OpenFolder\_ExampleScripts.lua" which will open the   
          examples folder of ReaGirl. In the folders named tutorial, you find the codes used in the tutorials as ready to use lua-files.  
          The last lua-file in each tutorial-folder is the finished tutorial-example, if you want to jump ahead.  
            
          The documentation is available with the actions "ReaGirl\_Help\_Introduction\_Concepts\_Tutorials\_Documentation.lua" for the explanation chapters and "ReaGirl\_Help\_Functions\_Documentation.lua" for the function's reference.  
          
          At the end of this document, you'll also find two chapters on best practices for accessible guis with ReaGirl.  
          I recomment you to read these to improve accessibility on your guis with a handful of rules of thumb.  
          [Best Practices on Accessibility](#Best_Practices_On_Accessibility) and [Best Practices on ReaGirl-Guis for blind scripters](#Best_Practices_On_Writing_Guis_As_Blind_Scripter).  
          I will update them from time to time so check them out occasionally for more practices from feedback by users of ReaGirl.  
            
          And now, without much further ado, let's head over to the tutorials.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Introduction
        </chapter_context>
        <previous_chapter>Introduction_001_Introduction</previous_chapter>  
        <next_chapter>Tutorial_001_A_Basic_Gui</next_chapter>  
        <tags>introduction, first steps</tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_001_A_Basic_Gui</slug>  
        <title>Tutorial 001: A Basic Gui</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In this tutorial, I will show you how to make a basic gui with some buttons, inputboxes and checkboxes. I will also explain to you the basic concepts in practice that you need to know to make guis with ReaGirl.    
            Stick with me, it's easier than you think.    
  
            Let's start with a basic gui, which will show one single button.    
              
            ![Screenshot of the gui-window with one ok-button.](gfx/Tutorial1_1.png "Screenshot of the gui-window with one ok-button.")              
  
                  -- Step 0: initialize ReaGirl  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  -- Step 1: write the run-functions  
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    reaper.MB("Button has been pressed", "Pressed", 0)  
                  end  
  
                  -- Step 2: create new gui  
                  reagirl.Gui_New()  
                    
                  -- Step 3: add the ui-elements to the gui  
                  -- add an ok-button to the gui at x-position 30 and y-position 200 with the run-function Button_RunFunction  
                  -- The meaningOfUI_Element-parameter "Apply changes and close dialog" will be shown as tooltip   
                  -- and sent to a screen reader for blind people.  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                    
                  -- Step 4: open the new gui with size 640x250 pixels, titled "The dialog".   
                  -- In addition to the title, blind people will also get "This is a demo dialog with settings for tool xyz."   
                  -- sent to their screen readers.  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  -- Step 5: Write and run a defer-function, in which you call reagirl.Gui_Manage()  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You see the 5 steps I mentioned in the first steps-chapter detailed out in this script.    
              
            This script adds a button and the run-function Button\_RunFunction which is run when the user hits the button.    
            Also note the parameter meaningOfUI\_Element, which is set to "Apply changes and close dialog". This parameter will be shown as a tooltip. It will also tell blind users, what the ui-element is supposed to do and why via screen reader. So if you add your own ui-elements, add a short and descriptive explanation into this parameter which says more than just "ok". Blind users will thank you for that.      
              
            And that's it, a simple gui with one button. Try it and experiment with it. Write a different text into the button. Alter the numbers in the parameters of reagirl.Button\_Add to see what happens.      
            Don't worry about making mistakes. When you pass wrong parameters to ReaGirl-functions, they will tell you with an error message, what went wrong and where.    
  
            One thing you'll note in the code is that reagirl.Button_Add() returns the element\_id as a returnvalue that I put into the variable button\_ok\_id. We will use this later on.    
  
            As a sidenote: ReaGirl stores in the background the position, size and dockstate of the window, so you can reopen it the next time with the old position, size and dockstate.    
            This will be done by the first two parameters of reagirl.Gui\_New(). The first parameter is a name for your window that should be a unique one like "Mespotine_My gui Window", which will be used by ReaGirl as a settings name to store position, size and dockstate in the background.      
            The second parameter sets, if the window shall be reopened with the old position, size and dockstate. Set it to false to open always with the position you give in reagirl.Gui\_Open() or set it to true to reopen it with the old position, size and dockstate.     
            Try it. Set the second parameter in reagirl.Gui\_Open() to true and run the script. Move it, resize it and then close it. When you run the script again, the window reopens at the position where you closed it.    
            In the tutorials, we will set the second parameter to false so the examples always behave the same. But in your scripts, you can do what works best for you.  
    
            Ok, now that you fiddled around with the example, how about adding a second button?    
            For this, we add a second Button\_Add-function for a Cancel-button. We'll also give it the same run-function like the first button. The returned element\_id of the cancel-button we put into the variable button\_cancel\_id.    
            It's looks like the following.    
  
            ![Screenshot of the gui-window with one ok-button and one cancel-button.](gfx/Tutorial1_2.png "Screenshot of the gui-window with one ok-button and one cancel-button.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You'll also notice, that I altered the run-function Button\_RunFunction. I mentioned in the first steps chapter, that the run-function gets passed over several parameters, with the first one being the element\_id of the button that got pressed.     
            In our example, the function Button\_RunFunction has a parameter pressed\_button\_id into which ReaGirl will tell you, which button that uses this run-function got pressed.    
              
            You remember, that both added buttons share the same run-function.    
              
            And that's the reason, why the variables button\_ok\_id and button\_cancel\_id come in handy, because you can use them now to check, if pressed\_button\_id==button\_ok\_id(the ok-button got pressed) or elseif pressed\_button\_id==button\_cancel\_id(the cancel button got pressed).    
            In this code, we will show a message-box that tells you, which one has been pressed.    
            This way, all buttons can share the same run-function, as you can compare the element\_ids of each button with the parameter pressed\_button\_id.    
  
            As a little excercise, add another button called "Help". Put its return-value into the variable button\_help\_id and add to the run-function a help-message shown, when the help button is pressed.    
            It'll help you internalising how the mechanics work and will help you further down the road with more complex guis.    
  
            Now that we have two buttons, we could add another ui-element. This time it's checkboxes.    
            You know the drill: Checkbox\_Add adds checkboxes into the next script. The Checkbox\_Add-functions return the element\_ids which will be put into the variables checkbox\_remember and checkbox\_mysetting.    
            We also add a run-function for it called Checkbox\_RunFunction, which will pop up a dialog when one of the checkboxes is checked. It'll tell you which one it will be with the help of the element\_ids, just like we did with the buttons.    
  
            ![Screenshot of the gui-window with two buttons and two checkboxes as examples.](gfx/Tutorial1_3.png "Screenshot of the gui-window with two buttons and two checkboxes as examples.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            One thing that's different from before is, that the run-function for the checkboxes Checkbox\_RunFunction gets now two parameters, whereas the one for the buttons only got one.    
            The parameters are:    
              
            1. the element\_id of the clicked checkbox(like it was in the button's run-function) AND    
            2. a parameter for the current checkstate after clicking the checkbox.    
              
            So a run-function for checkboxes gets the element\_id and the state of the checkbox after it was clicked. That way you know, how the checkbox-state currently is.    
            You can then use it for things like storing settings in the background: when the checkbox is checked you store "true" and when the checkbox is unchecked you store "false".    
            And since you can check against the individual element\_ids of the checkboxes, you know, which one got clicked and therefore must be stored.    
  
            The different parameters of the run-functions is also the reason, why you cannot use the same run-function for all types of ui-elements, as different ui-elements pass over different parameters to the run-function.    
            This could confuse your code. It's possible to code around this but I highly recommend to only use one run-function for all buttons and one for all checkboxes and one for all sliders, etc.    
  
            Although you can do one run-function for each ui-element, which is perfectly fine.    
  
            Back to our example.    
  
            We have now two checkboxes and two buttons. Let's add another type of ui-elements: InputBoxes.    
            InputBoxes allow to type in text into your gui. They are added basically like all other ui-elements: InputBox\_Add and two run-functions.    
  
            Two run-functions?    
  
            Yes, InputBoxes allow to have two run-functions. One is called everytime the user enters a character into the inputbox while the other one is called when the user hits enter into the inputbox.    
            Let's add two inputboxes with the two run-functions(InputBox\_RunFunction\_Type for when the user types text, InputBox\_RunFunction\_Enter when the user hits enter into the inputbox).    
  
            ![Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes as examples.](gfx/Tutorial1_4.png "Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes as examples.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"My Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                    
            If you run this script, you can click into the inputbox and enter text. The entered text will be shown in the debugging-window "ReaScript Console" of Reaper.    
            This outputting is done by the run-function InputBox\_RunFunction\_Type. When you hit enter, a message-box appears which shows you the entered text. This is done by the run-function InputBox\_RunFunction\_Enter.    
            Both run-functions get as parameters the element\_id(inputbox\_id) as well as the entered text(entered\_text).    
  
            Ok, now we have two buttons, two checkboxes and two inputboxes, all doing stuff when clicking/typing.    
  
            I would like to introduce you to another ui-element, the label element. This allows you to show some text.    
            It's working the same: Label\_Add adds a label. This could potentially be made clickable which would mean, we need a run-function as well, but right now we just make it a regular label that just shows text.    
            Therefore the last parameter for the run-function is nil(which means, no run-function available for this ui-element).    
            I would also like to show you something else that you can do with the element\_id: setting additional attributes for a ui-element.    
            In this case, we want to make the font-size of the label bigger and set it's style to underlined.    
            For this, we use the functions Label\_SetFontSize and Label\_SetStyle.    
  
            ![Screenshot of the gui-window with two buttons, two checkboxes, two inputboxes and a label text.](gfx/Tutorial1_5.png "Screenshot of the gui-window with two buttons, two checkboxes, two inputboxes and a label text.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)    
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            Running this code will add the text "This is a settings dialog" to the gui in font-size 40 and underlined.    
            You'll notice that Label\_SetFontSize and Label\_SetStyle are using the element\_id stored in the variable label\_header to adress, which label shall be altered.    
            Another use-case for element\_ids.      
            This is how you can actually change other ui-elements too. For buttons for instance, just look up all functionnames starting with reagirl.Button\_ in the [functions list](ReaGirl_Functions.html#Button) to find lots of functions to alter buttons. They'll expect the element\_id of the button that you want to alter.    
            The same goes for reagirl.InputBox\_, reagirl.Slider\_, reagirl.DropDownMenu_\, reagirl.Label\_, reagirl.Checkbox\_, reagirl.Tabs\_, etc.    
  
            Speaking of altering buttons: let's make the OK-button more round and the Cancel-button more edgier.    
            For this, we use the function reagirl.Button\_SetRadius in the following code, which allows us to set the radius of the edges.    
  
            ![Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text.](gfx/Tutorial1_6.png "Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
                  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
                  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                    
            You see, it's working the same: you give the reagirl.Button\_SetRadius-function the element\_id of the button that you want to alter.    
  
            What's now bothering me, is the black background, which looks a little bleak in my eyes, so let's change it using reagirl.Background\_GetSetColor.    
            This function accepts four parameters, with the first one setting if you want to set the background or get its colors and the other three the red, green and blue-color values from 0-255.    
            I'll choose to set it(true) to a grey tone(55).    
  
            ![Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text. The window has a grey background now.](gfx/Tutorial1_8.png "Screenshot of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes and a label text. The window has a grey background, now.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
                  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
                  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            Ahh, that's better. Of course, you can choose a different color. Just experiment with it.      
                
            And while we are at making things prettier, let's add one last ui-element, an image.    
            Reaper deploys several images for track-icons so let's choose one of them to display here, one of a bass-guitar.    
            This time, though, I would like to anchor the image to the right and bottom side of the window. ReaGirl supports anchoring ui-elements to the right-side/bottom of the window.    
            To achieve this, just make the x/y-coordinate negative. In the case of our image, I choose to make the image 150 pixels from the right side of the window(-150) and 120 pixels from the bottom(-120).    
  
            ![Gif of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes, a label text and an image of a bass guitar, linked to the bottom and right edge of the window.](gfx/Tutorial1_8.gif "Gif of the gui-window with two buttons(one of them round), two checkboxes, two inputboxes, a label text and an image of a bass guitar, linked to the bottom and right edge of the window.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
  
                  -- create new gui  
                  reagirl.Gui_New()    
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
                  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
                  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  
  
                  -- add an image of a bass guitar  
                  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "A Bass guitar", "An image of a bass guitar.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            Hmmm, nice bass guitar, Davie. And when you resize the window, you'll notice, that it'll stay linked to the right and bottom side of the window.    
            You can also link other ui-elements that way or even just link width and height of a ui-element to it(if a ui-element has width and height). Works the same: make the coordinate negative.    
            Let's link the width of the first inputbox to the right-side of the window(-50) to see how that looks.    
             
            ![Gif showing, that one of the inputboxe's length is linked to right window-edge.](gfx/Tutorial1_9.gif "Gif showing, that one of the inputboxe's length is linked to right window-edge.")  
             
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()    
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, -50, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
                  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
                  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  
  
                  -- add an image of a bass guitar  
                  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "A Bass guitar", "An image of a bass guitar.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                    
            Looking good. This way, the user can choose, how long the visible inputbox shall be.    
            Images support this as well, so you can experiment by making x and y linked to the left/top of the window(positive value) and link width and height to the right/bottom of the window(negative value).    
            That way, the size of the image changes the way the window is resized. You can also use reagirl.Image\_KeepAspectRatio() to keep the image from looking stretched(more on this in tutorial #3: "a basic image viewer with a drag'n'drop-zone and a context menu").    
  
            When resizing the window to make it smaller, you probably noticed already, that the image is moving behind the inputboxes at some point. It would be nice to have a way to prevent that.    
            There's a way. The functions reagirl.Window\_ForceSize\_Minimum() and reagirl.Window\_ForceSize\_Maximum() set a minimum and maximum window-size. So the user cannot resize it bigger or smaller than that.    
            Let's add them into our gui and set some reasonable boundaries.  
  
            ![Gif of the gui-window that shows, that resizing the window can't be done below or beyond a certain size.](gfx/Tutorial1_10.gif "Gif of the gui-window that shows, that resizing the window can't be done below or beyond a certain size.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a textlabel to the top of the gui  
                  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish.", false, nil)  
                  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40  
                  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, -50, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
                  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button rounder  
                  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square  
  
                  -- add an image of a bass guitar  
                  reagirl.Image_Add(-150, -120, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "A Bass guitar", "An image of a bass guitar.", nil)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 250) -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(800, 400) -- set the maximum size of the window  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you try to resize the window now, it will remain within the chosen constraints, not bigger and not smaller, only inbetweens.    
            And so we're done. Our first basic gui with a lot of ui-elements and features applied.    
            Toy around with it to get a deeper grip on how the basic concepts work.    
  
            And when you are ready, you can move on to tutorial #2, which shows you, how to add tabs to this gui.    
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Introduction_001_First_Steps</previous_chapter>  
        <next_chapter>Tutorial_002_Adding_Tabs_to_a_Gui</next_chapter>  
        <tags>tutorial, basic gui, button, label, background, window size</tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_002_Adding_Tabs_to_a_Gui</slug>  
        <title>Tutorial 002: Adding Tabs to a Gui</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In the first tutorial, we made a basic gui with some ui-elements. In this tutorial we want to add tabs and put the ui-elements into the individual tabs.    
            The first tab gets all inputboxes, the second tab all checkboxes and the third tab all buttons.    
            I removed the label and the image from the gui in this tutorial to make it a little simpler.    
            Our initial gui looks this way, now:    
  
            ![Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes.](gfx/Tutorial2_1.png "Screenshot of the gui-window with two buttons, two checkboxes and two inputboxes.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add inputboxes to type in text  
                  inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
  
            The first thing we will do is to create three tables, in which we will store the element\_ids of the gui-elements.    
            Each table represents a tab, means: tab1 contains all element\_ids of the ui-elements of tab 1, tab2 all element\_ids of the ui-elements of tab 2 and tab3 all of tab 3.      
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add tables that will contain the element-ids of the ui-element  
                  tab1={} -- for the ui-elements in tab 1  
                  tab2={} -- for the ui-elements in tab 2  
                  tab3={} -- for the ui-elements in tab 3  
                    
                  -- add inputboxes to type in text  
                  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
  
            You'll notice that we added three tables, tab1, tab2 and tab3. You'll also notice, that we put the element\_ids returned by the \_Add-functions into these tabs, for instance :    
                
              ```  
              inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
              ```    
                
            became     
                
              ```  
              tab1.inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
              ```    
                
            means, we added __tab1.__ in front of the variable-name, so it's now associated with the table that stores the gui-elements of the first tab.    
                
            All Inputbox\_Add add to tab1, all Checkbox\_Add add to tab2 and all Button\_Add add to tab3. That way we have one table for each tab with all ui-elements that shall be in that tab.    
            Now, let's add the tabs-ui-element to the gui using the function reagirl.Tabs\_Add(). We also add a run-function for tabs called Tab\_RunFunction.    
  
            ![Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which triggers a dialog that says the name of the tab.](gfx/Tutorial2_3.gif "Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which triggers a dialog that says the name of the tab.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
                    
                    
                  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
                    -- this function is run, when tabs are switched  
                    reaper.MB("Tab #"..tab_selected.." with name "..tab_name_selected.." is selected.", "Tabs", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add tables that will contain the element-ids of the ui-element  
                  tab1={} -- for the ui-elements in tab 1  
                  tab2={} -- for the ui-elements in tab 2  
                  tab3={} -- for the ui-elements in tab 3  
                    
                  -- let's add tabs  
                  reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Inputboxes", "Checkboxes", "Buttons"}, 1, Tab_RunFunction)  
                    
                  -- add inputboxes to type in text  
                  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
  
                  -- add two checkboxes to the gui  
                  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            If you run this example, you'll have tabs. Click on them and the run-function will show a dialog with the selected tab number and its name.    
            Tabs can have a background drawn, which I set here to 620x187 pixels. You can alter them or make them linked to the right/bottom of the window by making them negative.    
            You can also pass nil instead of numbers. This will make the background enclose all ui-elements automatically. If you don't want a background, pass 0 as background-width and height.    
            Toy around with it to get an idea.  
  
            This dialog still shows all ui-elements in all tabs, so let's alter the tabs-run-function to show only all ui-elements associated with a certain tab.    
            To achieve this, we use the function reagirl.Tabs\_SetUIElementsForTab(), which allows us to link element\_ids stored in a table with a certain tab.    
            Now, tab1, tab2 and tab3 come in handy. We associated the ui-elements of tab1 with the first table(1), the one of tab2 with the second(2) and the one from tab3 with the third(3).    
            Here's how it looks like with reagirl.Tabs\_SetUIElementsForTab()  
              
            ![Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which shows now only the ui-elements associated with a certain tab.](gfx/Tutorial2_4.gif "Gif of the gui-window with two buttons, two checkboxes and two inputboxes and tabs. The gifs shows changing tabs which shows now only the ui-elements associated with a certain tab.")  
              
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
                    
                    
                  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
                    -- this function is run, when tabs are switched  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add tables that will contain the element-ids of the ui-element  
                  tab1={} -- for the ui-elements in tab 1  
                  tab2={} -- for the ui-elements in tab 2  
                  tab3={} -- for the ui-elements in tab 3  
                    
                  -- let's add tabs  
                  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Inputboxes", "Checkboxes", "Buttons"}, 1, Tab_RunFunction)  
                    
                  -- add inputboxes to type in text  
                  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                    
                  -- add two checkboxes to the gui  
                  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
                    
                  -- set ui-elements to the tabs.   
                  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
                  -- and give tab 3 the ones stored in tab3.  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                
            Now we're talking! If we switch the tabs, now, it will show all correct ui-elements: tab 1 all inputboxes, tab 2 all checkboxes and tab 3 all buttons.    
            We're almost done.    
            You remember from the first tutorial, that interacting with the user elements was showing dialogs. For instance, clicking the OK-button shows a dialog saying "OK button is pressed".    
            But when you click it now, it does nothing.    
            This is because our run-functions still use the old variables that used to store the element\_ids but they are stored in the tables tab1, tab2 and tab3, now.    
            So let's alter the run-functions to check not for i.e. pressed\_button\_id==button\_ok\_id but pressed\_button\_id==tab3.button\_ok\_id and so on.    
            Here's how the run-functions look like, when they check against the table-entries of the ui-elements:    
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==tab3.button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==tab3.button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==tab2.checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==tab2.checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==tab1.inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==tab1.inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==tab1.inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==tab1.inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
                    
                    
                  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
                    -- this function is run, when tabs are switched  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add tables that will contain the element-ids of the ui-element  
                  tab1={} -- for the ui-elements in tab 1  
                  tab2={} -- for the ui-elements in tab 2  
                  tab3={} -- for the ui-elements in tab 3  
                    
                  -- let's add tabs  
                  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Inputboxes", "Checkboxes", "Buttons"}, 1, Tab_RunFunction)  
                    
                  -- add inputboxes to type in text  
                  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                    
                  -- add two checkboxes to the gui  
                  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
                    
                  -- set ui-elements to the tabs.   
                  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
                  -- and give tab 3 the ones stored in tab3.  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                
            Now the code works exactly as intended. Tab 1 shows all ui-elements of tab1, tab 2 shows all ui-elements of tab2, tab 3 shows all ui-elements of tab3.    
            Plus: interacting with all ui-elements works properly now.    
  
            There's one final thing: what if I want to have buttons shown all the time, like apply and close-buttons or additional checkboxes?    
            It's simple: add them BUT don't add their ids to tab1, tab2 or tab3:    
              
            ![Gif of the gui-window with tabs which consists of two inputboxes. Under the tabs-area are now two buttons and a checkbox, that are always visible when changing tabs.](gfx/Tutorial2_6.gif "Gif of the gui-window with tabs which consists of two inputboxes. Under the tabs-area are now two buttons and a checkbox, that are always visible when changing tabs.")    
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction(pressed_button_id)  
                    -- this function is run, when a button is pressed  
                    if pressed_button_id==tab3.button_ok_id then  
                      reaper.MB("OK Button is pressed", "OK Button", 0)  
                    elseif pressed_button_id==tab3.button_cancel_id then  
                      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)  
                    elseif pressed_button_id==apply_button then  
                      reaper.MB("Apply Button is pressed", "Apply Button", 0)  
                    elseif pressed_button_id==close_button then  
                      reaper.MB("Close Button is pressed", "Close Button", 0)  
                    end  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==tab2.checkbox_remember then  
                      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==tab2.checkbox_mysetting then  
                      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    elseif checked_checkbox_id==global_checkbox then  
                      reaper.MB("Checkbox \"Apply only to project\" is "..tostring(checkstate), "Checkbox-State changed", 0)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Type(inputbox_id, entered_text)  
                    -- this function is run, when the user types in text into an inputbox  
                    reaper.ClearConsole()  
                    if inputbox_id==tab1.inputbox_name_of_setting then  
                      reaper.ShowConsoleMsg("NAME: "..entered_text)  
                    elseif inputbox_id==tab1.inputbox_description_of_setting then  
                      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)  
                    end  
                  end  
  
                  function InputBox_RunFunction_Enter(inputbox_id, entered_text)  
                    -- this function is run, when the user hits enter into an inputbox  
                    if inputbox_id==tab1.inputbox_name_of_setting then  
                      reaper.MB(entered_text, "The typed text into NAME was", 0)  
                    elseif inputbox_id==tab1.inputbox_description_of_setting then  
                      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)  
                    end  
                  end  
                    
                    
                  function Tab_RunFunction(tab_id, tab_selected, tab_name_selected)  
                    -- this function is run, when tabs are switched  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add tables that will contain the element-ids of the ui-element  
                  tab1={} -- for the ui-elements in tab 1  
                  tab2={} -- for the ui-elements in tab 2  
                  tab3={} -- for the ui-elements in tab 3  
                    
                  -- let's add tabs  
                  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Inputboxes", "Checkboxes", "Buttons"}, 1, Tab_RunFunction)  
                    
                  -- add inputboxes to type in text  
                  tab1.inputbox_name_of_setting = reagirl.Inputbox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting.", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                  tab1.inputbox_description_of_setting = reagirl.Inputbox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting.", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)  
                    
                  -- add two checkboxes to the gui  
                  tab2.checkbox_mysetting = reagirl.Checkbox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)  
                  tab2.checkbox_remember = reagirl.Checkbox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)  
  
                  -- add an ok-button and a cancel button to the gui  
                  tab3.button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog.", Button_RunFunction)  
                  tab3.button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog.", Button_RunFunction)  
  
                  -- add a "global" checkbox, as well as an apply-button and close-button to the gui  
                  global_checkbox = reagirl.Checkbox_Add(10, 225, "Apply only to project", "Shall these settings be applied only to a project?", true, Checkbox_RunFunction)  
                  apply_button = reagirl.Button_Add(532, 225, 0, 0, "Apply", "Apply changes.", Button_RunFunction)  
                  close_button = reagirl.Button_Add(582, 225, 0, 0, "Close", "Close dialog.", Button_RunFunction)  
  
                  -- let's force window-sizes  
                  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window  
                  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window  
                    
                  -- set ui-elements to the tabs.   
                  -- Give tab 1 the ui-elements stored in tab1, give tab 2 the ui-elements stored in tab2   
                  -- and give tab 3 the ones stored in tab3.  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with some options.", 640, 250)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run this script, a checkbox and two buttons are added to the bottom of the window. And you can switch tabs, they will always be visible.  
            And all we did was adding a checkbox and two more buttons, whose ids are stored into apply\_button, close\_button and global\_checkbox and not in tab1 or tab2 or tab3.  
            We also altered the run-functions Button\_RunFunction and Checkbox\_RunFunction so clicking these ui-elements will also show a dialog.    
              
            If you want, you can place the ui-elements properly into the upper part of the each tab as an excercise.  
  
            Now you know everything you need to make guis with tabs in ReaGirl.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_001_A_Basic_Gui</previous_chapter>  
        <next_chapter>Tutorial_003_A_Basic_Image_Viewer</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_003_A_Basic_Image_Viewer</slug>  
        <title>Tutorial 003: A Basic Image Viewer with a file-drop-zone and a context menu</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In this tutorial, I will show you a basic image viewer. I will also show you, how to add a drag'n'drop-zone to this image as well as a context menu.  
            And as a cherry on the top, we will make clicking the image setting the loaded image as track icon for the first track in the current project.  
            So let's get it on.  
  
            Let's start with basic code, which will show one of Reaper's images, a bass guitar, in a window.  
  
            ![Screenshot of the gui-window with an image of a bass guitar.](gfx/Tutorial3_1.png "Screenshot of the gui-window with an image of a bass guitar.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run it, it will show the image of a bass guitar.  
            Now, we will try to adapt the code, so you can drag n drop an image onto it to change it. To achieve this, we need a drag n drop area for this image.  
            In ReaGirl, you can add to each ui-element a dropzone. This will have the dimensions and position of the ui-element.  
            This dropzone gets it's own run-function that is run every time a file is dropped onto the dropzone.  
            So, let's add a dropzone for our image, using the function reagirl.UI\_Element\_GetSet\_DropZoneFunction(). We also add a run-function for this drop-zone, Image\_DropZone\_RunFunction.  
  
            ![Gif of the gui-window with an image of a bass guitar. When dropping files onto it, a dialog appears that shows the dropped filename.](gfx/Tutorial3_2.gif "Gif of the gui-window with an image of a bass guitar. When dropping files onto it, a dialog appears that shows the dropped filename.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                    reaper.MB(dropped_filenames_table[1], "First dropped file", 0)  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You'll notice, it's only one functioncall to add the dropzone plus a run-function. That's all you need.  
            Now you can drop files onto the image. A dialog will pop up that tells you the filename of the first file dropped. It's only the first one in this code, but you could drop multiple files at the same time into it.  
            What we would like to do next, is to change the shown image. For this, we alter the function Image\_DropZone\_RunFunction accordingly.  
  
            ![Gif of the gui-window with an image of a bass guitar. It shows how dropping of image-files changes the shown image.](gfx/Tutorial3_3.gif "Gif of the gui-window with an image of a bass guitar. It shows how dropping of image-files changes the shown image.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                      
                    -- load the first file dropped as new image and show it  
                    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You see, it's simply one functioncall of reagirl.Image\_Load() to load the dropped file, the first file dropped in this case (dropped\_filenames\_table[1]).    
            Now that we have an image-viewer that accepts dropping of image-files, we might want to have a context-menu that allows us to load a file-requester and to clear the image.    
            Contextmenus work the same as dropzones. You can add a context-menu to a specific ui-element and you add a run-function.     
            When the user right-clicks the ui-element, the context-menu is opened. When the user selects a menu-entry, the run-function for this context-menu is run, which gives you the chance to react to the user's choice.    
            Let's add a context-menu using reagirl.UI\_Element\_GetSet\_ContextMenu() including its run-function.  
  
            ![Gif of the gui-window with an image of a bass guitar. It shows how right-clicking opens a context-menu. Selecting a menu-item shows a dialog that signals which menu-item was selected.](gfx/Tutorial3_4.gif "Gif of the gui-window with an image of a bass guitar. It shows how right-clicking opens a context-menu. Selecting a menu-item shows a dialog that signals which menu-item was selected.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                      
                    -- load the first file dropped as new image and show it  
                    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
                  end  
                    
                  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
                    -- this function will be called when the user opens up   
                    -- the context-menu of the image and makes a choice  
                    reaper.MB("The user chose menuentry "..menu_entry_selection, "Menu chosen", 0)  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                  -- add a context-menu to this image  
                  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, "Clear Image|Select a file", Image_ContextMenu_RunFunction)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
                
            Now you can right-click on the image and a menu will appear. You can select either of the entries and the run-function Image\_ContextMenu\_RunFunction() will show a dialog with the selected menu-entry-number.  
            The parameter menu of the function reagirl.UI\_Element\_GetSet\_ContextMenu works like gfx.showmenu from Reaper's own gfx-functions.  
            So check out the docs for it for more details or read the chapter about context-menus, where I'll explain it in more detail.  
              
            Ok, now that we have a menu, let's alter the run-function Image\_ContextMenu\_RunFunction() to react to the individual menu-entries.  
            The first menu-entry will clear the image to be fully black, while the other one loads a filerequester that allows you to choose an image.  
              
            ![Gif of the gui-window with an image of a bass guitar. It shows a context-menu which allows clearing the image and using a file-requester to select an image-file.](gfx/Tutorial3_5.gif "Gif of the gui-window with an image of a bass guitar. It shows a context-menu which allows clearing the image and using a file-requester to select an image-file.")  
              
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                      
                    -- load the first file dropped as new image and show it  
                    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
                  end  
                    
                  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
                    -- this function will be called when the user opens up   
                    -- the context-menu of the image and makes a choice  
                      
                    if menu_entry_selection==1 then  
                      -- if user chose the first menu-entry, clear the image to black  
                      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
                    elseif menu_entry_selection==2 then  
                      -- if user chose the second menu-entry, allow to load an image using a file requester  
                      local retval, filename =   
                              reaper.GetUserFileNameForRead(reaper.GetResourcePath().."/Data/track_icons/",   
                                                            "Choose an image to load",   
                                                            "*.png;*.jpg")  
                      if retval==true then  
                        reagirl.Image_Load(element_id, filename)    
                      end  
                    end  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                  -- add a context-menu to this image  
                  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, "Clear Image|Select a file", Image_ContextMenu_RunFunction)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            Nice, it does the job. But there's still one thing, that might bother you: images that are not square will be shown stretched. So, why not keeping the aspect ratio of the image properly?  
            We can achieve this with the function reagirl.Image\_KeepAspectRatio()  
  
            ![Two gui-windows who are square each who show the same high image. On the left, the image looks stretched, on the right the same image is shown with correct aspect ratio.](gfx/Tutorial3_6.png "Two gui-windows who are square each who show the same hight image. On the left, the image looks stretched, on the right the same image is shown with correct aspect ratio.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                      
                    -- load the first file dropped as new image and show it  
                    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
                  end  
                    
                  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
                    -- this function will be called when the user opens up   
                    -- the context-menu of the image and makes a choice  
                    if menu_entry_selection==1 then  
                      -- if user chose the first menu-entry, clear the image to black  
                      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
                    elseif menu_entry_selection==2 then  
                      -- if user chose the second menu-entry, allow to load an image using a file requester  
                      local retval, filename =   
                              reaper.GetUserFileNameForRead(reaper.GetResourcePath().."/Data/track_icons/",   
                                                            "Choose an image to load",   
                                                            "*.png;*.jpg")  
                      if retval==true then  
                        reagirl.Image_Load(element_id, filename)    
                      end  
                    end  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                  -- add a context-menu to this image  
                  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, "Clear Image|Select a file", Image_ContextMenu_RunFunction)  
                  -- keep the aspect ratio of the image properly  
                  reagirl.Image_KeepAspectRatio(image_id, true)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            This is starting to look good.  
            Since we're good in programming flow, let's put the currently loaded image as track-icon of the first track in the project everytime the user clicks on the image.  
            For this, we need to adapt the run-function for the image(it's finally used!).  
            First, we get the filename of the currently used image-file for the image using reagirl.Image\_GetImageFilename() and pass it over to reaper.GetSetMediaTrackInfo\_String().  
  
            ![A gif showing how images are dropped onto the gui window and clicking the image in the gui sets the image-file as track-icon.](gfx/Tutorial3_7.gif "A gif showing how images are dropped onto the gui window and clicking the image in the gui sets the image-file as track-icon.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Image_RunFunction(clicked_image_id)  
                    -- this function is run, when the image is clicked  
                      
                    -- get the filename of the currently loaded image-file  
                    filename = reagirl.Image_GetImageFilename(clicked_image_id)  
                      
                    -- set it as track-icon of the first track  
                    reaper.GetSetMediaTrackInfo_String(reaper.GetTrack(0,0), "P_ICON", filename, true)  
                  end  
                    
                  function Image_DropZone_RunFunction(element_id, dropped_filenames_table)  
                    -- this function will be called everytime a file is dropped onto the image  
                      
                    -- load the first file dropped as new image and show it  
                    reagirl.Image_Load(element_id, dropped_filenames_table[1])  
                  end  
                    
                  function Image_ContextMenu_RunFunction(element_id, menu_entry_selection)  
                    -- this function will be called when the user opens up   
                    -- the context-menu of the image and makes a choice  
                    if menu_entry_selection==1 then  
                      -- if user chose the first menu-entry, clear the image to black  
                      reagirl.Image_ClearToColor(element_id, 0, 0, 0)  
                    elseif menu_entry_selection==2 then  
                      -- if user chose the second menu-entry, allow to load an image using a file requester  
                      local retval, filename =   
                              reaper.GetUserFileNameForRead(reaper.GetResourcePath().."/Data/track_icons/",   
                                                            "Choose an image to load",   
                                                            "*.png;*.jpg")  
                      if retval==true then  
                        reagirl.Image_Load(element_id, filename)    
                      end  
                    end  
                  end  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- add the image of a bass guitar to this gui  
                  image_id = reagirl.Image_Add(10, 10, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "An image", "A user selectable image.", Image_RunFunction)  
                  -- add a dropzone for dropped files for this image  
                  reagirl.UI_Element_GetSet_DropZoneFunction(image_id, true, Image_DropZone_RunFunction)  
                  -- add a context-menu to this image  
                  reagirl.UI_Element_GetSet_ContextMenu(image_id, true, "Clear Image|Select a file", Image_ContextMenu_RunFunction)  
                  -- keep the aspect ratio of the image properly  
                  reagirl.Image_KeepAspectRatio(image_id, true)  
                    
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "Image Viewer", "This is a demo image viewer.", 120, 120)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When running this script, left-clicking the image will set the loaded image to be the track-icon of track 1 in the project.  
  
            And then we're done.  
            A gui-script which shows an image on which you can drag n drop image-files. You can also use a context-menu with it to clear it/load a new image.  
            And when clicking on it, the loaded imagefile will be set as track-icon.  
            In 64 lines of code(including comments ;) ).  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_002_Adding_Tabs_to_a_Gui</previous_chapter>  
        <next_chapter>Tutorial_004_Disabled_UI_Elements</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_004_Disabled_UI_Elements</slug>  
        <title>Tutorial 004: Disabled UI Elements</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            You may have seen it in certain guis, that sometimes gui-elements are disabled. You can do this too in ReaGirl.  
            In this tutorial, I will show you, how.  
  
            First things first: not all ui-elements can be set to disabled, but those who can have a \_SetDisabled-function.  
            Like reagirl.Button\_SetDisabled() or reagirl.Checkbox\_SetDisabled, etc.  
            So let's dive into it.  
  
            In this tutorial I want to introduce you to two new gui-elements not yet covered in the other ones: Sliders and Drop Down Menus.  
            Our final gui will have one slider and one drop down menu plus checkboxes who disable/enable them.  
  
            First, let's create our basic gui without any gui-element in it as a base, that just opens a window.  
              
            ![A gui-window with no ui-elements, yet.](gfx/Tutorial4_1.png "A gui-window with no ui-elements, yet.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            Now, let's add first ui-elements: a checkbox and a slider. I will also add two run-functions, one for the checkboxes and one for the slider.  
  
            ![A gui-window with one checkbox and one slider.](gfx/Tutorial4_2.png "A gui-window with one checkbox and one slider.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Slider_RunFunction(used_slider_id, current_value)  
                    -- this function is run, when the slider is moved  
                    reaper.ClearConsole()  
                    reaper.ShowConsoleMsg("The current value is: "..current_value)  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                    if checked_checkbox_id==checkbox_disableSlider_id then  
                      reaper.ClearConsole()  
                      reaper.ShowConsoleMsg("Checkbox is "..tostring(checkstate), "", 0)  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a checkbox and a slider to the gui  
                  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, "Activated", "Check to activate slider.", true, Checkbox_RunFunction)  
                  slider_id = reagirl.Slider_Add(200, 50, -20, "I am a slider", nil, "A slider to set a value.", "%", 20, 200, 1, 25, 100, Slider_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run this code, you see a checkbox and a slider. When you click on the checkbox or move the slider, you will see the current value in the ReaScript console window.  
            Now, let's make the checkbox disable the slider. For this, we use the function reagirl.Slider\_SetDisabled() in the run-function Checkbox_RunFunction.  
            We will use the element\_id of the slider called slider\_id to adress it in reagirl.Slider\_SetDisabled().  
  
            ![A gif of gui-window with one checkbox and one slider. The gif shows, how the checkbox disables the slider so it can not be dragged.](gfx/Tutorial4_3.gif "A gif of gui-window with one checkbox and one slider. The gif shows, how the checkbox disables the slider so it can not be dragged.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Slider_RunFunction(used_slider_id, current_value)  
                    -- this function is run, when the slider is moved  
                    reaper.ClearConsole()  
                    reaper.ShowConsoleMsg("The current value is: "..current_value)  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                      
                    if checked_checkbox_id==checkbox_disableSlider_id then  
                      -- if the first checkbox's checkstate is changed to true  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
                      else -- otherwise  
                        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
                      end  
                    end  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a checkbox and a slider to the gui  
                  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, "Activated", "Check to activate slider.", true, Checkbox_RunFunction)  
                  slider_id = reagirl.Slider_Add(200, 50, -20, "I am a slider", nil, "A slider to set a value.", "%", 20, 200, 1, 25, 100, Slider_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When running this script, clicking the checkbox will change the slider to disabled/enabled, depending on the checkbox-state.  
            Now, let's do this for another ui-element. But this time with a drop down menu. And we want it to set disabled at script startup.  
  
            To do this, we add another checkbox and a drop down menu(using reagirl.DropDownMenu\_Add()).   
            And as usual: we add a run-function called DropDownMenu\_RunFunction() for the drop down menu.  
            For the second checkbox, we use again the Checkbox\_RunFunction(), but we'll modify it in a later step.  
  
            Let's see, how the gui looks now.  
              
            ![A gui window with two checkboxes, one slider and one drop down menu.](gfx/Tutorial4_4.png "A gui window with two checkboxes, one slider and one drop down menu.")              
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Slider_RunFunction(used_slider_id, current_value)  
                    -- this function is run, when the slider is moved  
                    reaper.ClearConsole()  
                    reaper.ShowConsoleMsg("The current value is: "..current_value)  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                      
                    if checked_checkbox_id==checkbox_disableSlider_id then  
                      -- if the first checkbox's checkstate is changed to true  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
                      else -- otherwise  
                        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
                      end  
                    end  
                  end  
  
                  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
                    -- this function is run, when the user selects a menu-entry  
                    reaper.MB("Dropdownmenu entry #"..selected_menuitem.." - "..selected_name, "", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a checkbox and a slider to the gui  
                  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, "Activated", "Check to activate slider.", true, Checkbox_RunFunction)  
                  slider_id = reagirl.Slider_Add(200, 50, -20, "I am a slider", nil, "A slider to set a value.", "%", 20, 200, 1, 25, 100, Slider_RunFunction)  
  
                  -- add a checkbox and a drop-down-menu to the gui  
                  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, "Activated", "Check to activate drop-down-menu.", false, Checkbox_RunFunction)  
                  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, "I am a dropdownmenu", nil, "A Drop Down Menu to choose from.", {"Entry 1 - The first entry", "Entry 2 - The second entry", "Entry 3 - The third entry"}, 2, DropDownMenu_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            This code shows now additionally a checkbox and a drop down menu. You can select menu-entries by clicking into it and when you do, the run-function of the drop down menu will show a messagebox with the selected menu-entry.  
            The checkbox isn't doing anything yet, so clicking has no effect. Let's change this, by altering the run-function Checkbox\_RunFunction().  
            It's basically done the same way, as we did for the slider. However, we use now reagirl.DropDownMenu\_SetDisabled() to disable the drop down menu.  
  
            ![A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu.](gfx/Tutorial4_5.gif "A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Slider_RunFunction(used_slider_id, current_value)  
                    -- this function is run, when the slider is moved  
                    reaper.ClearConsole()  
                    reaper.ShowConsoleMsg("The current value is: "..current_value)  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                      
                    if checked_checkbox_id==checkbox_disableSlider_id then  
                      -- if the first checkbox's checkstate is changed to true  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
                      else -- otherwise  
                        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
                      end  
                      -- if the second checkbox's checkstate is changed to true  
                    elseif checked_checkbox_id==checkbox_disableDropDownMenu_id then  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, false) -- set the drop down menu to enabled  
                      else -- otherwise  
                        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true)  -- set the drop down menu to disabled  
                      end  
                    end  
                  end  
  
                  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
                    -- this function is run, when the user selects a menu-entry  
                    reaper.MB("Dropdownmenu entry #"..selected_menuitem.." - "..selected_name, "", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a checkbox and a slider to the gui  
                  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, "Activated", "Check to activate slider.", true, Checkbox_RunFunction)  
                  slider_id = reagirl.Slider_Add(200, 50, -20, "I am a slider", nil, "A slider to set a value.", "%", 20, 200, 1, 25, 100, Slider_RunFunction)  
  
                  -- add a checkbox and a drop-down-menu to the gui  
                  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, "Activated", "Check to activate drop-down-menu.", false, Checkbox_RunFunction)  
                  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, "I am a dropdownmenu", nil, "A Drop Down Menu to choose from.", {"Entry 1 - The first entry", "Entry 2 - The second entry", "Entry 3 - The third entry"}, 2, DropDownMenu_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            This will set the drop down menu to disabled, when you set the checkbox to unchecked and enabled when you set it to checked.  
            However, you have probably noticed when starting up the script, the checkbox is unchecked but the drop down menu is still enabled. Only checking the checkbox on and off will make it disabled.  
            To solve this, we add one last reagirl.DropDownMenu\_SetDisabled(), this time right after the reagirl.DropDownMenu\_Add-functioncall, using the element\_id of the drop down list.  
            And we set it to disable the drop down menu(true).  
  
            Here's how the code looks like now.  
              
            ![A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu. The drop down menu is now disabled at startup of the script.](gfx/Tutorial4_6.gif "A gif of a gui-window with two checkboxes, one slider and one drop down menu. The gif shows, how the second checkbox toggles disability-state of the drop down menu. The drop down menu is now disabled at startup of the script.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Slider_RunFunction(used_slider_id, current_value)  
                    -- this function is run, when the slider is moved  
                    reaper.ClearConsole()  
                    reaper.ShowConsoleMsg("The current value is: "..current_value)  
                  end  
  
                  function Checkbox_RunFunction(checked_checkbox_id, checkstate)  
                    -- this function is run, when the checkstate of a checkbox is changed  
                      
                    if checked_checkbox_id==checkbox_disableSlider_id then  
                      -- if the first checkbox's checkstate is changed to true  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.Slider_SetDisabled(slider_id, false) -- set the slider enabled  
                      else -- otherwise  
                        reagirl.Slider_SetDisabled(slider_id, true)  -- set the slider disabled  
                      end  
                      -- if the second checkbox's checkstate is changed to true  
                    elseif checked_checkbox_id==checkbox_disableDropDownMenu_id then  
                      if reagirl.Checkbox_GetCheckState(checked_checkbox_id)==true then  
                        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, false) -- set the drop down menu to enabled  
                      else -- otherwise  
                        reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true)  -- set the drop down menu to disabled  
                      end  
                    end  
                  end  
  
                  function DropDownMenu_RunFunction(used_dropdownmenu_id, selected_menuitem, selected_name)  
                    -- this function is run, when the user selects a menu-entry  
                    reaper.MB("Dropdownmenu entry #"..selected_menuitem.." - "..selected_name, "", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- add a checkbox and a slider to the gui  
                  checkbox_disableSlider_id = reagirl.Checkbox_Add(30, 50, "Activated", "Check to activate slider.", true, Checkbox_RunFunction)  
                  slider_id = reagirl.Slider_Add(200, 50, -20, "I am a slider", nil, "A slider to set a value.", "%", 20, 200, 1, 25, 100, Slider_RunFunction)  
  
                  -- add a checkbox and a drop-down-menu to the gui  
                  checkbox_disableDropDownMenu_id = reagirl.Checkbox_Add(30, 72, "Activated", "Check to activate drop-down-menu.", false, Checkbox_RunFunction)  
                  dropdownmenu_id = reagirl.DropDownMenu_Add(200, 72, -20, "I am a dropdownmenu", nil, "A Drop Down Menu to choose from.", {"Entry 1 - The first entry", "Entry 2 - The second entry", "Entry 3 - The third entry"}, 2, DropDownMenu_RunFunction)  
                  reagirl.DropDownMenu_SetDisabled(dropdownmenu_id, true) -- set drop-down-menu to disabled  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 640, 120)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            And there we are: the finished gui that enables/disables the slider and the drop down menu according to the states of the checkboxes.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_003_A_Basic_Image_Viewer</previous_chapter>  
        <next_chapter>Tutorial_005_Draggable_Images</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_005_Draggable_Images</slug>  
        <title>Tutorial 005: Draggable Images</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In this tutorial, I will show you, how to make a gui, where an image is draggable to multiple destinations.  
            It will have one image, that can be dragged and two other images and a label, which act as destinations for the dragged source-image.  
            Dragging the source-image to the destination-images will change the destination-image to the one of the source image, while dragging to the label will show the filename+path of the source-image.  
  
            Note: blind users can drag the image using Ctrl+Shift+PageUp or Ctrl+Shift+PageDown to select, to which ui-element the images shall be dragged to and Ctrl+Shift+Enter to drop it.  
  
            Let's start first with a basic-gui, that will show the source-image and have an empty run-function for the image.  
  
            ![A gui-window with one image of a bass guitar.](gfx/Tutorial5_1.png "A gui-window with one image of a bass guitar.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                    -- this function will be run when the image is clicked or dragged to a destination  
                  end  
  
                  -- start a new gui  
                  reagirl.Gui_New()  
  
                  -- add the source-image, which we will draggable  
                  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
  
                  -- open gui  
                  reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                  -- manage gui  
                  function main()  
                    reagirl.Gui_Manage()  
                      
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            This will show our image of a bass guitar. Note, how the meaningOfUI_Element-parameter explains, that the image shows a bass-guitar. This is important for blind users, since they can't see the image and need to know, what the image looks like by you giving a short description.  
            Clicking the image does nothing yet, as well as trying to drag.  
            Now, let's add our dragging-destinations, which will be a label and two images.  
    
            ![A gui-window with one image of a bass guitar on the left and in the center a label that says "Nothing has been dragged to this label yet", underneath it an image of an ampflifier and underneath it an image of congas.](gfx/Tutorial5_2.png "A gui-window with one image of a bass guitar on the left and in the center a label that says "Nothing has been dragged to this label yet", underneath it an image of an ampflifier and underneath it an image of congas.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                    -- this function will be run when the image is clicked or dragged to a destination  
                  end  
  
                  -- start a new gui  
                  reagirl.Gui_New()  
  
                  -- add the source-image, which we will draggable  
                  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
                  -- add some additional images and a label, that are the destinations for the dragging  
                  label_id = reagirl.Label_Add(240, 10, "Nothing has been dragged to this label, yet", "A destination for the source-image to drag to.", false, nil)  
                  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath().."/Data/track_icons/amp.png", "Amplifier", "An image of an amplifier.", nil)  
                  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath().."/Data/track_icons/congas.png", "Congas", "An image of congas.", nil)  
  
                  -- open gui  
                  reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                  -- manage gui  
                  function main()  
                    reagirl.Gui_Manage()  
                      
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
                    
                  main()  
  
            This shows now the source and destination-images as well as a label. The parameter meaningOfUI_Element describes now, what the images are showing(amp, congas).  
  
            In the next step, we will make the source-image draggable. For this, we use the function reagirl.Image\_SetDraggable(), in which we can set, which ui-element shall be destination of the source-image-dragging.  
            It will look like this.  
              
            ![A gif that shows how the image of a bass guitar is dragged over to the other three ui-elements. When the bass is dropped onto them, a dialog pops up that says, onto what the bass guitar was dropped.](gfx/Tutorial5_3.gif "A gif that shows how the image of a bass guitar is dragged over to the other three ui-elements. When the bass is dropped onto them, a dialog pops up that says, onto what the bass guitar was dropped.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                    -- this function will be run when the image is clicked or dragged to a destination  
                    reaper.MB("Dragged to: "..reagirl.UI_Element_GetSetCaption(drag_destination, false, ""), "", 0)  
                  end  
  
                  -- start a new gui  
                  reagirl.Gui_New()  
  
                  -- add the source-image, which we will draggable  
                  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
                  -- add some additional images and a label, that are the destinations for the dragging  
                  label_id = reagirl.Label_Add(240, 10, "Nothing has been dragged to this label, yet", "A destination for the source-image to drag to.", false, nil)  
                  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath().."/Data/track_icons/amp.png", "Amplifier", "An image of an amplifier.", nil)  
                  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath().."/Data/track_icons/congas.png", "Congas", "An image of congas.", nil)  
  
                  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
                  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  
  
                  -- open gui  
                  reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                  -- manage gui  
                  function main()  
                    reagirl.Gui_Manage()  
                      
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
                    
                  main()  
  
            You can see, that we pass to it the element\_ids of the destinations, like label\_id, image\_dest1\_id and image\_dest2\_id.  
            When you run this, you can drag the source-image of a bass-guitar around. You will see a smaller version of the image is shown at the mouse-cursor during dragging.  
            When dropping the source-image to a destination, the run-function of the source-image Image\_Runfunction() will be run and shows a messagebox that tells you, onto which ui-element you dragged the source-image.  
            It will use the function reagirl.UI\_Element\_GetSetCaption() to get the caption of the dragged ui-element.  
            The run-function uses the third parameter, drag\_destination. This parameter is sent to run-functions once the image it is associated with is set to draggable, like image\_source\_id in our case.  
  
            Now, we want to make the label show the filename of the source-image when dropping the source-image onto it.  
              
            ![A gif that shows, how the bass guitar is dragged to the label and dropped there. The label changes to show the filename of the bass-guitar-image after dropping.](gfx/Tutorial5_4.gif "A gif that shows, how the bass guitar is dragged to the label and dropped there. The label changes to show the filename of the bass-guitar-image after dropping.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                    -- this function will be run when the image is clicked or dragged to a destination  
                      if drag_destination==label_id then  
                      -- if source-image is dragged to the label, set labeltext to filename of the source-image  
                        
                      -- get the filename of the source-image  
                      image_filename = reagirl.Image_GetImageFilename(element_id)   
                      -- set label-text to filename of source-image  
                      reagirl.Label_SetLabelText(label_id, "Filename of source-image is: "..image_filename)   
                    end  
                  end  
  
                  -- start a new gui  
                  reagirl.Gui_New()  
  
                  -- add the source-image, which we will draggable  
                  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
                  -- add some additional images and a label, that are the destinations for the dragging  
                  label_id = reagirl.Label_Add(240, 10, "Nothing has been dragged to this label, yet", "A destination for the source-image to drag to.", false, nil)  
                  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath().."/Data/track_icons/amp.png", "Amplifier", "An image of an amplifier.", nil)  
                  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath().."/Data/track_icons/congas.png", "Congas", "An image of congas.", nil)  
  
                  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
                  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  
  
                  -- open gui  
                  reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                  -- manage gui  
                  function main()  
                    reagirl.Gui_Manage()  
                      
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
                    
                  main()  
  
            When we drag the source-image now to the label, the run-function Image\_Runfunction() is run, in which we check the parameter drag\_destination against the element\_id label\_id.  
            If the source-image has been dropped at the label(drag\_destination==label\_id) then we get the filename of the source-image and set the caption of the label to it.  
  
            Nice.  
            Now, let's alter the run-function even further. We will now make it, that dragging the source-image onto the destination-images will change the destination-images once the image was dropped on them.  
  
            ![A gif that shows, how the bass-guitar-image is dropped on the label, after that on the image of the amplifier and after that on the image of the congas. The label changes to show the filename of the bass guitar while the amplifier and the congas get exchanged with the image of the bass guitar.](gfx/Tutorial5_5.gif "A gif that shows, how the bass-guitar-image is dropped on the label, after that on the image of the amplifier and after that on the image of the congas. The label changes to show the filename of the bass guitar while the amplifier and the congas get exchanged with the image of the bass guitar.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                  function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                    -- this function will be run when the image is clicked or dragged to a destination  
                    if drag_destination==label_id then  
                      -- if source-image is dragged to the label, set labeltext to   
                      -- filename of the source-image  
                        
                      -- get the filename of the source-image  
                      image_filename = reagirl.Image_GetImageFilename(element_id)   
                      -- set label-text to filename of source-image  
                      reagirl.Label_SetLabelText(label_id, "Filename of source-image is: "..image_filename)   
                    elseif drag_destination==image_dest1_id then  
                      -- if source_image is dragged to image2, change it's image to the  
                      -- one of the source-image  
                        
                      -- get the filename of the source-image  
                      image_filename = reagirl.Image_GetImageFilename(element_id)  
                      -- load the filename of the source-image in the destination-image  
                      reagirl.Image_Load(image_dest1_id, image_filename)  
  
                    elseif drag_destination==image_dest2_id then  
                      -- if source_image is dragged to image2, change it's image to the  
                      -- one of the source-image  
                        
                      -- get the filename of the source-image  
                      image_filename = reagirl.Image_GetImageFilename(element_id)  
                      -- load the filename of the source-image in the destination-image  
                      reagirl.Image_Load(image_dest2_id, image_filename)  
                    end  
                  end  
  
                  -- start a new gui  
                  reagirl.Gui_New()  
  
                  -- add the source-image, which we will draggable  
                  image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
                  -- add some additional images and a label, that are the destinations for the dragging  
                  label_id = reagirl.Label_Add(240, 10, "Nothing has been dragged to this label, yet", "A destination for the source-image to drag to.", false, nil)  
                  image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath().."/Data/track_icons/amp.png", "Amplifier", "An image of an amplifier.", nil)  
                  image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath().."/Data/track_icons/congas.png", "Congas", "An image of congas.", nil)  
  
                  -- add the element_ids of image2-4_id as drag-destinations of image1_id  
                  reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  
  
                  -- open gui  
                  reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                  -- manage gui  
                  function main()  
                    reagirl.Gui_Manage()  
                      
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When we run this code, dropping the source-image onto one of the destination-images will now change the shown image.  
            To achieve this, we checked in the run-function Image\_Runfunction() if the destination-ui-element(drag\_destination-parameter) was either the first destination image(image\_dest1\_id) or the second(image\_dest2\_id).  
            If so, we get the filename of the source using reagirl.Image\_GetImageFilename() and load it using reagirl.Image\_Load() into the destination-image.  
  
            Awesome, it's already looking good. But: there's one thing we missed:  
            Remember that the description of the destination images was amp and conga? It still is, even though it's now showing a bass-guitar. That means, blind users didn't get, that the images was changed.  
            Let's change that.  
            For this, we need to alter the run-function Image\_Runfunction and add the two functions, reagirl.UI\_Element\_GetSetMeaningOfUIElement() and reagirl.UI\_Element\_GetSetCaption().  
            The function reagirl.UI\_Element\_GetSetCaption() will change the caption, which is sent to blind users when hovering above a ui-element.  
            The function reagirl.UI\_Element\_GetSetMeaningOfUIElement() will change the screen reader-message, which is sent to blind users when they are tabbing through the ui-elements.  
            For the label we don't need to change the caption, since label-text and caption is the same.  
            We need to alter the run-function for the images as well as the label.  
  
            Note: in the ReaGirl-Settings you find an option called "Show screen reader messages in console", which will show the messages sent to blind users in the ReaScript-console window.  
            With that, you can check, whether the meaningOfUI_Element was correctly altered or is even reflecting the correct message.  
  
            Ok, now that we altered the script, it looks like this now.  
  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                function Image_Runfunction(element_id, imagepath_plus_filename, drag_destination)  
                  -- this function will be run when the image is clicked or dragged to a destination  
                  if drag_destination==label_id then  
                    -- if source-image is dragged to the label, set labeltext to   
                    -- filename of the source-image  
                      
                    -- get the filename of the source-image  
                    image_filename = reagirl.Image_GetImageFilename(element_id)   
                    -- set label-text to filename of source-image  
                    reagirl.Label_SetLabelText(label_id, "Filename of source-image is: "..image_filename)   
                    -- change meaningOfUI_Element to reflect, what the label shows now for blind users  
                    reagirl.UI_Element_GetSetMeaningOfUIElement(label_id, true, "An image of a bass-guitar")  
                    
                  elseif drag_destination==image_dest1_id then  
                    -- if source_image is dragged to image2, change it's image to the  
                    -- one of the source-image  
                      
                    -- get the filename of the source-image  
                    image_filename = reagirl.Image_GetImageFilename(element_id)  
                    -- load the filename of the source-image in the destination-image  
                    reagirl.Image_Load(image_dest1_id, image_filename)  
                    -- change meaningOfUI_Element to reflect, what the image shows now for blind users  
                    reagirl.UI_Element_GetSetMeaningOfUIElement(image_dest1_id, true, "An image of a bass-guitar")  
                    reagirl.UI_Element_GetSetCaption(image_dest1_id, true, "Image of a bass guitar")  
                    
                  elseif drag_destination==image_dest2_id then  
                    -- if source_image is dragged to image2, change it's image to the  
                    -- one of the source-image  
                      
                    -- get the filename of the source-image  
                    image_filename = reagirl.Image_GetImageFilename(element_id)  
                    -- load the filename of the source-image in the destination-image  
                    reagirl.Image_Load(image_dest2_id, image_filename)  
                    -- change meaningOfUI_Element to reflect, what the image shows now for blind users  
                    reagirl.UI_Element_GetSetMeaningOfUIElement(image_dest2_id, true, "An image of a bass-guitar.")  
                    reagirl.UI_Element_GetSetCaption(image_dest2_id, true, "Image of a bass guitar")  
                  end  
                end  
  
                -- start a new gui  
                reagirl.Gui_New()  
  
                -- add the source-image, which we will draggable  
                image_source_id = reagirl.Image_Add(20, 100, 100, 100, reaper.GetResourcePath().."/Data/track_icons/bass.png", "Bass-guitar", "An image of a bass guitar.", Image_Runfunction)  
  
                -- add some additional images and a label, that are the destinations for the dragging  
                label_id = reagirl.Label_Add(240, 10, "Nothing has been dragged to this label, yet", "A destination for the source-image to drag to.", false, nil)  
                image_dest1_id = reagirl.Image_Add(220, 50, 100, 100, reaper.GetResourcePath().."/Data/track_icons/amp.png", "Amplifier", "An image of an amplifier.", nil)  
                image_dest2_id = reagirl.Image_Add(220, 160, 100, 100, reaper.GetResourcePath().."/Data/track_icons/congas.png", "Congas", "An image of congas.", nil)  
  
                -- add the element_ids of image2-4_id as drag-destinations of image1_id  
                reagirl.Image_SetDraggable(image_source_id, true, {label_id, image_dest1_id, image_dest2_id})  
  
                -- open gui  
                reagirl.Gui_Open("My Dialog Name", false, "ReaGirl Tutorial", "Tutorial for draggable images.", 665, 310, nil, nil, nil)  
  
                -- manage gui  
                function main()  
                  reagirl.Gui_Manage()  
                    
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
                main()  
                  
            You'll notice, how we alter the screen reader-message using reagirl.UI\_Element\_GetSetMeaningOfUIElement() as well as the caption using reagirl.UI\_Element\_GetSetCaption().  
            And when you run the script, tabbing through the ui-elements will now tell to blind users, which image has been used by image\_dest1\_id and image\_dest2\_id and label\_id.  
  
            Great. Now we have a script that allows dragging a source-image to various destinations. It alters the images and labels when the source-image has been dropped.  
            We also altered the screen reader-messages accordingly to reflect the changes, so blind users know, what has happened with dragging as well.  
  
            In this tutorial, we made images draggable, but you can also make labels draggable. The only difference is, that for labels, the run-function is getting the destination-element\_id as second parameter instead of the third.  
            The rest is the same.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_004_Disabled_UI_Elements</previous_chapter>  
        <next_chapter>Tutorial_006_Enter_ESC_AtExit</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_006_Enter_ESC_AtExit</slug>  
        <title>Tutorial 006: Enter, Esc-Key and AtExit</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In ReaGirl, you can set a run-function for when the gui-window is closed using esc and closing via the close-button.  
            You can also set a run-function to the enter-key, so you can have a "Apply settings and close window via Enter-key"-feature.  
            In this tutorial, we'l look at how to do them.  
  
            Let's start with a basic gui.  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction()  
                    -- this function will be run when the button is pressed  
                      
                    -- It stores the setting and keeps the dialog open  
                    reaper.SetExtState("My_Setting", "My_Key", reagirl.Slider_GetValue(slider_percentage), true)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- Add a slider and a button to the gui.  
                  -- First: get old stored value of the slider  
                  old_slider_value=reaper.GetExtState("My_Setting", "My_Key")   
                  -- Second: if there isn't a slider-value stored yet, use a default of 0  
                  if old_slider_value=="" then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
                  -- add the slider with the slider-value stored in old_slider_value  
                  slider_percentage = reagirl.Slider_Add(4, 4, 250, "Percentage", 140, "Set the percentage.", nil, 0, 8, 1, old_slider_value, 0, nil)  
                  -- add a store button  
                  button = reagirl.Button_Add(260, 4, 0, 0, "Store", "Store percentage setting.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 325, 40)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run the script, you get a script with one slider and a button to store the value of the slider in an extstate.  
            You can close it via the close-button of the window and the esc-key.  
            In the next step, we want to show a dialog that tells the user that the slider-value wasn't stored when closing via esc-key or the close-button.  
            For this we add a new run-function AtExit\_RunFunction and also add the function reagirl.Gui\_AtExit() to tell ReaGirl, which run-function to use when the gui is closed.  
            This is how it looks like, now.  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction()  
                    -- this function will be run when the button is pressed  
                      
                    -- It stores the setting and keeps the dialog open  
                    reaper.SetExtState("My_Setting", "My_Key", reagirl.Slider_GetValue(slider_percentage), true)  
                  end  
                    
                  function AtExit_RunFunction()  
                    -- this function is run when the window is closed by either esc-key or the x-button of the window  
                      
                    -- it will show an aborted dialog  
                    reaper.MB("Aborted setting the percentage.\n\nPercentage is not stored.", "Abort", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- Add a slider and a button to the gui.  
                  -- First: get old stored value of the slider  
                  old_slider_value=reaper.GetExtState("My_Setting", "My_Key")   
                  -- Second: if there isn't a slider-value stored yet, use a default of 0  
                  if old_slider_value=="" then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
                  -- add the slider with the slider-value stored in old_slider_value  
                  slider_percentage = reagirl.Slider_Add(4, 4, 250, "Percentage", 140, "Set the percentage.", nil, 0, 8, 1, old_slider_value, 0, nil)  
                  -- add a store button  
                  button = reagirl.Button_Add(260, 4, 0, 0, "Store", "Store percentage setting.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 325, 40)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run this script, you can close the window via esc-key and the close-button and if you do, a dialog opens up that tells the user that storing the setting was aborted.  
            We made this possible with the function AtExit\_RunFunction(), which opens a dialog using reaper.MB(). And we used reagirl.Gui\_AtExit(AtExit\_RunFunction) to tell Reaper to run the run-function AtExit\_RunFunction everytime the window is closes using the close-button or the esc-key.  
            Great.  
            In the next step, we add that hitting enter stores the slider-value and closes the window. For this, we add another run-function AtEnter\_RunFunction() and the function reagirl.Gui\_AtEnter(AtEnter_RunFunction) to tell ReaGirl to run the run-function everytime the user hits enter in the dialog.  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  function Button_RunFunction()  
                    -- this function will be run when the button is pressed  
                      
                    -- It stores the setting and keeps the dialog open  
                    reaper.SetExtState("My_Setting", "My_Key", reagirl.Slider_GetValue(slider_percentage), true)  
                  end  
                    
                  function AtEnter_RunFunction()  
                    -- this function is run, when the enter-key is hit  
                      
                    -- it stores the setting, shows a success-message and closes the gui  
                    reaper.SetExtState("My_Setting", "My_Key", reagirl.Slider_GetValue(slider_percentage), true)  
                    reaper.MB("Entered new percentage", "Success", 0)  
                    reagirl.Gui_Close()  
                  end  
                    
                  function AtExit_RunFunction()  
                    -- this function is run when the window is closed by either esc-key or the x-button of the window  
                      
                    -- it will show an aborted dialog  
                    reaper.MB("Aborted setting the percentage.\n\nPercentage is not stored.", "Abort", 0)  
                  end  
  
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- Add a slider and a button to the gui.  
                  -- First: get old stored value of the slider  
                  old_slider_value=reaper.GetExtState("My_Setting", "My_Key")   
                  -- Second: if there isn't a slider-value stored yet, use a default of 0  
                  if old_slider_value=="" then old_slider_value=0 else old_slider_value=tonumber(old_slider_value) end   
                  -- add the slider with the slider-value stored in old_slider_value  
                  slider_percentage = reagirl.Slider_Add(4, 4, 250, "Percentage", 140, "Set the percentage.", nil, 0, 8, 1, old_slider_value, 0, nil)  
                  -- add a store button  
                  button = reagirl.Button_Add(260, 4, 0, 0, "Store", "Store percentage setting.", Button_RunFunction)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 325, 40)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You'll notice, that the run-function AtEnter\_RunFunction() stores the slider-value into an extstate. It also closes the gui using Gui\_Close() and shows a dialog using reaper.MB() that tells the user that the slider-value is stored.  
            And when you run this script, you can change the slider, hit enter and when you rerun the script, the stored slider-value is restored.  
  
            With that, you have a dialog that reacts to closing via close-button, the esc-key and the enter key.  
  
            One thing to notice: the run-function for enter isn't run when the an inputbox is currently selected, which uses a run-function for the enter-key! It's also not run when the inputbox is currently selected and the user is a screen reader-user.   
            So you might need to add a run-function for inputboxes that does the same as the enter-run-function used by reagirl.Gui\_AtEnter()  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_005_Draggable_Images</previous_chapter>  
        <next_chapter>Tutorial_007_Autopositioning_Of_UI_Elements</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_007_Autopositioning_Of_UI_Elements</slug>  
        <title>Tutorial 007: Autopositioning of UI-Elements</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            When doing guis in ReaGirl, you can use its autopositioning-feature. This is very practical, as you don't really need to place them by hand.  
            Especially when you are blind and want to create a gui, you need a way to position the gui-elements without having to use your eyes to finetune things.  
            In this and the next tutorials, I will show you, how to use it.   
            And believe me: it's easy.  
  
            First we start with a basic gui with no ui-element in it.  
      
            ![An empty dialog-window.](gfx/Tutorial7_1.png "An empty dialog-window.")  
              
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            And then we add some ui-elements in it, let's say, three checkboxes. These shall be one after another in one line.  
            To do that with the autopositioning-feature, you simply set the x and y-parameters to nil.  
            Here's how it looks like.  
              
            ![A dialog-window with three checkboxes automatically positioned.](gfx/Tutorial7_2.png "An dialog-window with three checkboxes automatically positioned.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- first line of checkboxes  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            There you are. Three checkboxes, positioned after each other in one line.  
            Now, let's add another line into it, but how to do that?  
            Simple. Before we start another line, we add reagirl.NextLine() to it. Then we add another line of checkboxes with x and y set to nil.  
  
            ![A dialog-window with five checkboxes(two new ones) automatically positioned.](gfx/Tutorial7_3.png "An dialog-window with five checkboxes(two new ones) automatically positioned.")  
              
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- first line of checkboxes  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
                    
                  -- second line of checkboxes  
                  reagirl.NextLine() -- start a new line of ui-elements  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 4", "This is the fourth checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When you run it, you see two lines of checkboxes, one with three and one with two checkboxes.   
            Let's add another line of ui-elements, this time a checkbox and a button, anchored to the right side of the window. And we position it a few pixels more than the space between the first two lines were.  
            To do that, we use reagirl.NextLine() but this time we add 10 pixels as parameter to it.  
            And then we add a checkbox and a button. For the checkbox we add as x-parameter 200 pixels from the right side of the window(-200) and y-parameter we leave at nil for autopositioning.  
            The button, we set x=nil and y=nil.  
  
            ![A dialog-window with six checkboxes(one new one) and a button automatically positioned.](gfx/Tutorial7_4.png "A dialog-window with six checkboxes(one new one) and a button automatically positioned.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- first line of checkboxes  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
                    
                  -- second line of checkboxes  
                  reagirl.NextLine() -- start a new line of ui-elements  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 4", "This is the fourth checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                    
                  -- third line with one checkbox and one button anchored to right side of the window  
                  -- this line is placed 10 pixels lower to gain some distance between the lines  
                  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
                  reagirl.Checkbox_Add(-200, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                  button = reagirl.Button_Add(nil, nil, 0, 0, "Store", "Store 1.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            When we run this script, the newly added checkbox and button are anchored to the right side of the window. So when you resize it, they more accordingly.  
            You also notice, that the button is positioned relative to the checkbox that we put at x=-200. So ui-elements coming after a ui-element that was positioned "manually" will be placed relative to the manually placed one.  
            Let's add another line with a checkbox and a button, this time anchored again to the left side of the window.  
            But how do we do that?  
            Simple:  
            We set the x-position(40) and this time the y-position as well(100) of the checkbox. After that, we autoposition another button with x=nil and y=nil.  
  
            ![A dialog-window with seven checkboxes(one new one) and two buttons(one new one) automatically positioned.](gfx/Tutorial7_5.png "A dialog-window with seven checkboxes(one new one) and two buttons(one new one) automatically positioned.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  -- first line of checkboxes  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
                    
                  -- second line of checkboxes  
                  reagirl.NextLine() -- start a new line of ui-elements  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 4", "This is the fourth checkbox.", true, nil)  
                  reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                    
                  -- third line with one checkbox and one button anchored to right side of the window  
                  -- this line is placed 10 pixels lower to gain some distance between the lines  
                  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
                  reagirl.Checkbox_Add(-200, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                  button = reagirl.Button_Add(nil, nil, 0, 0, "Store", "Store 1.", nil)  
                    
                  -- fourth line with one checkbox and one button anchored to the left side of the window  
                  reagirl.Checkbox_Add(40, 100, "Checkbox 6", "This is the fifth checkbox.", true, nil)  
                  button = reagirl.Button_Add(nil, nil, 0, 0, "Store 2", "Store 2.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.", 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            And there you are. The new line added is anchored to the left side of the window again and the button has been placed relative to this checkbox.  
  
            So rule of thumb is:  
            1. to autoposition, set x and/or y-position to nil to place ui-elements after each other.  
            2. add reagirl.NextLine() to start another line of ui-elements  
            3. when you place a ui-element to specific coordinates, all following ui-elements will be autopositioned relative to the previous one when x=nil and/or y=nil  
  
            Toy around with it to get a grip on it.  
  
            More on using autopositioning as blind scripter in a later chapter.  
  
            In the next tutorial, I will explain to you, how to use auto-positioning with tabs.  
  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_006_Enter_ESC_AtExit</previous_chapter>  
        <next_chapter>Tutorial_008_Autopositioning_With_Tabs</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_008_Autopositioning_With_Tabs</slug>  
        <title>Tutorial 008: Autopositioning with Tabs</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            In the last tutorial, I showed you how to use autopositioning in ReaGirl. In this one, we will enhance it by adding tabs, which differs slightly.  
            You probably remember from the last tutorial, that when using auto-positioning, the next ui-element is positioned relative to the previous ui-element.  
            Means: next to the right of the previous ui-element or underneath it(when using reagirl.NextLine()).  
            We could use the same thing using tabs, what would look like the following, which includes all the ui-elements from the  
            previous tutorial but sorted into tabs, using autopositioning:  
  
            ![A gif showing the autopositioned checkboxes and buttons from the previous tutorial placed over four tabs. The tabs get switched which reveal, that the ui-elements start one line lower with each tab. So they kind of walk from the top to the bottom with each tab.](gfx/Tutorial8_1.gif "A gif showing the autopositioned checkboxes and buttons from the previous tutorial placed over four tabs. The tabs get switched which reveal, that the ui-elements start one line lower with each tab. So they kind of walk from the top to the bottom with each tab.")  
  
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  tab1={}  
                  tab2={}  
                  tab3={}  
                  tab4={}  
                    
                  -- let's add tabs  
                  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Tab1", "Tab2", "Tab3", "Tab4"}, 1, Tab_RunFunction)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 4, tab4)  
                  --]]  
                    
                  -- first line of checkboxes  
                  tab1.checkbox1 = reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  tab1.checkbox2 = reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  tab1.checkbox3 = reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
                    
                  -- second line of checkboxes  
                  reagirl.NextLine() -- start a new line of ui-elements  
                  tab2.checkbox1 = reagirl.Checkbox_Add(nil, nil, "Checkbox 4", "This is the fourth checkbox.", true, nil)  
                  tab2.checkbox2 = reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                    
                  -- third line with one checkbox and one button anchored to right side of the window  
                  -- this line is placed 10 pixels lower to gain some distance between the lines  
                  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
                  tab3.checkbox = reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                  tab3.button = reagirl.Button_Add(nil, nil, 0, 0, "Store", "Store 1.", nil)  
                    
                  -- fourth line with one checkbox and one button anchored to the left side of the window  
                  reagirl.NextLine()  
                  tab4.checkbox = reagirl.Checkbox_Add(nil, nil, "Checkbox 6", "This is the fifth checkbox.", true, nil)  
                  tab4.button = reagirl.Button_Add(nil, nil, 0, 0, "Store 2", "Store 2.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")--, 425, 240)  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            However, when you run it, you quickly realize, there's a problem. When clicking through the tabs, the ui-elements are positioned  
            under the ui-elements from the previous tabs. So when you click through tab1 to tab4, the ui-elements wander downwards.  
            This is due the fact, that they are positioned according to the last ui-element in the code and not by the tabs.  
            And it would be much better, if the ui-elements would start at the top of each tab.  
            For this, we add another new function, called reagirl.AutoPosition\_SetNextYToUIElement(). With this function,  
            you can set, which ui-element shall be seen as the previous one, so autoposition uses this "newly set" ui-element as basis to position the next ui-element.  
  
            In our element, we want to set the first checkbox of each tab right after the tab. So all we do is include   
  
            ```  
            reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
            ```  
  
            into our script right before each checkbox, that shall be put at the beginning of the tab. You'll notice, that we  
            put the element\_id of the tabs, "tabs\_id", as parameter. This tells autoposition "The next ui-element shall be put after tabs.  
            Here's how it looks like:  
  
            ![A gif that switches through all the tabs of the gui-window. The ui-elements are now placed on top of each tab.](gfx/Tutorial8_2.gif "A gif that switches through all the tabs of the gui-window. The ui-elements are now placed on top of each tab.")  
              
                  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
                    
                  -- create new gui  
                  reagirl.Gui_New()  
                    
                  tab1={}  
                  tab2={}  
                  tab3={}  
                  tab4={}  
                    
                  -- let's add tabs  
                  tabs_id = reagirl.Tabs_Add(10, 10, 620, 187, "Tabs", "Different options in this dialog.", {"Tab1", "Tab2", "Tab3", "Tab4"}, 1, Tab_RunFunction)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 1, tab1)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 2, tab2)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 3, tab3)  
                  reagirl.Tabs_SetUIElementsForTab(tabs_id, 4, tab4)  
                    
                  -- first line of checkboxes  
                  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
                  tab1.checkbox1 = reagirl.Checkbox_Add(nil, nil, "Checkbox 1", "This is the first checkbox.", true, nil)  
                  tab1.checkbox2 = reagirl.Checkbox_Add(nil, nil, "Checkbox 2", "This is the second checkbox.", true, nil)  
                  tab1.checkbox3 = reagirl.Checkbox_Add(nil, nil, "Checkbox 3", "This is the third checkbox.", true, nil)  
                    
                  -- second line of checkboxes  
                  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
                  reagirl.NextLine() -- start a new line of ui-elements  
                  tab2.checkbox1 = reagirl.Checkbox_Add(nil, nil, "Checkbox 4", "This is the fourth checkbox.", true, nil)  
                  tab2.checkbox2 = reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                    
                  -- third line with one checkbox and one button anchored to right side of the window  
                  -- this line is placed 10 pixels lower to gain some distance between the lines  
                  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
                  reagirl.NextLine(10) -- start a new line of ui-elements, ten pixels lower than  
                  tab3.checkbox = reagirl.Checkbox_Add(nil, nil, "Checkbox 5", "This is the fifth checkbox.", true, nil)  
                  tab3.button = reagirl.Button_Add(nil, nil, 0, 0, "Store", "Store 1.", nil)  
                    
                  -- fourth line with one checkbox and one button anchored to the left side of the window  
                  reagirl.AutoPosition_SetNextUIElementRelativeTo(tabs_id)  
                  reagirl.NextLine()  
                  tab4.checkbox = reagirl.Checkbox_Add(nil, nil, "Checkbox 6", "This is the fifth checkbox.", true, nil)  
                  tab4.button = reagirl.Button_Add(nil, nil, 0, 0, "Store 2", "Store 2.", nil)  
  
                  -- open the new gui  
                  reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                  -- make the background grey  
                  reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
                  reagirl.Gui_AtExit(AtExit_RunFunction)  
                  reagirl.Gui_AtEnter(AtEnter_RunFunction)  
  
                  function main()  
                    -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                    reagirl.Gui_Manage()  
                      
                    -- if the gui-window hasn't been closed, keep the script alive.  
                    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                  end  
  
                  main()  
  
            You'll notice, that reagirl.AutoPosition\_SetNextYToUIElement() is put right before the reagirl.Checkbox\_Add()-functioncalls to tell ReaGirl to autoposition the next checkbox right after the next tab.  
            And when you run it and click through the tabs, the ui-elements are now positioned at the right position: right after the tabs.  
  
            One thing to notice: you could theoretically put the element\_id of any ui-element into reagirl.AutoPosition\_SetNextYToUIElement(), not just tabs.  
            That way, you can autoposition in relation to any ui-element.  
            Keep in mind: when using tabs, autoposition will assume that the next ui-element shall be put into the next line, so you don't need to use reagirl.NextLine() when using reagirl.AutoPosition\_SetNextYToUIElement() with tabs.  
            With other ui-elements, like buttons, checkboxes, sliders, etc, the next ui-element will be placed next to the right of it. So you might need to add reagirl.NextLine() when needed.  
            You'll see it when it happens and if you want to put the next ui-element underneath the one you put in reagirl.AutoPosition\_SetNextYToUIElement(), simply use reagirl.NextLine() and you're fine.  
  
            And there you are. If you followed all tutorials up til this one, you know most of the concepts and possibilities in ReaGirl.  
            This should give you plenty of possibilities to code guis as you need and wish.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_007_Autopositioning_Of_UI_Elements</previous_chapter>  
        <next_chapter>Tutorial_009_Structuring_Guis_With_Labels</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_009_Structuring_Guis_With_Labels</slug>  
        <title>Tutorial 009: Structuring Guis with Labels</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
          In this tutorial, we will structure Guis using labels. For this, we will add backdrops around ui-elements to create sections in your gui. We will also have spaces between these sections, so each section is easy to separate from the other ones for the user.    
          Backdrops are additional elements for labels. They are a rectangle that starts at half the height of the label and goes around until it ends again on the other side of the label.    
          You can imagine this as a rectangle, that has a gap on the top at which the label-text is placed. The bottom ends under the last ui-elements of a section of ui-elements.    
          Backdrops enclose ui-elements to make it easier to see, which ui-elements belong to each other.    
            
          If you do only simple guis, you will usually not having problems with guis that are hard to read.    
          However, when you have a lot of ui-elements in your gui, you may quickly end up with a wall of ui-elements.    
          Consider the following example-gui.    
            
          ![Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read.](gfx/Tutorial9_1.png "Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read.")  
            
              -- load ReaGirl into this script  
              dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
              -- create new gui  
              reagirl.Gui_New()  
  
              -- now let's add all ui-elements of the first tab to table tab1  
               
              -- Labels  
              label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
               
              reagirl.NextLine()  
              label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
              label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                
              label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
              reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
              reagirl.NextLine()  
              label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                
              label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                
              label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
              label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
              reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
              reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                      -- let it end underneath label_large - the largest label  
              -- Inputboxes  
              reagirl.NextLine()  
              label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                
              reagirl.NextLine()  
              inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
              reagirl.NextLine()  
              button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button                                                                             
                
              -- Checkboxes  
              reagirl.NextLine()  
              label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
              reagirl.NextLine() -- first line of checkboxes  
              checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
              checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                
              reagirl.NextLine() -- second line of checkboxes  
              checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
              checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                
              -- Images  
              reagirl.NextLine()   
              label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                
              -- local some images from Reaper  
              reagirl.NextLine()  
              image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
              image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
              image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
              image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
              image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
              -- Buttons  
              reagirl.NextLine(10)  
              button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
              button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
              -- open the new gui  
              reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
              -- make the background grey  
              reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
              function main()  
                -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                reagirl.Gui_Manage()  
                  
                -- if the gui-window hasn't been closed, keep the script alive.  
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
              end  
  
              main()  
                
          When you run this gui, you see gazillions of ui-elements placed onto this gui. And you also notice that it's hard to read.    
          You don't know, where one context starts and where another context ends. It's using labels to somewhat structure the gui but the labels simply drown in this multiverse of ui-elements.    
          It would be awesome to have a way to separate each context from each other: "Labels", "Inputboxes", "And some checkboxes" and "Or Images".    
            
          Behold, there's a way to do it, an attribute-function for labels, the function reagirl.Label\_SetBackdrop().    
          With this function, you can create a backdrop for ui-elements. This backdrop is a boundary box that you surround around your ui-elements, beginning at a certain label.    
          The function accepts as first parameter the element\_id of the label, where the backdrop shall start, then the width and height of it.    
          Let's add this function to draw a backdrop from the label "Labels" underneath the huge label "size".    
  
          ![Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The labels on the top are now enclosed with a label-backdrop going from the label "Labels" to underneath the label "size".](gfx/Tutorial9_2.png "Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The labels on the top are now enclosed with a label-backdrop going from the label 'Labels' to underneath the label 'size'.")  
            
              -- load ReaGirl into this script  
              dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
              -- create new gui  
              reagirl.Gui_New()  
  
              -- now let's add all ui-elements of the first tab to table tab1  
               
              -- Labels  
              label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
               
              reagirl.NextLine()  
              label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
              label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                
              label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
              reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
              reagirl.NextLine()  
              label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                
              label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                
              label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
              label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
              reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
              reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                      -- let it end underneath label_large - the largest label  
                                                                        
              reagirl.Label_SetBackdrop(label_header, 290, 80)  
                
              -- Inputboxes  
              reagirl.NextLine()  
              label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                
              reagirl.NextLine()  
              inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
              reagirl.NextLine()  
              button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                
              -- Checkboxes  
              reagirl.NextLine()  
              label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
              reagirl.NextLine() -- first line of checkboxes  
              checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
              checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                
              reagirl.NextLine() -- second line of checkboxes  
              checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
              checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                
              -- Images  
              reagirl.NextLine()   
              label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                
              -- local some images from Reaper  
              reagirl.NextLine()  
              image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
              image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
              image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
              image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
              image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
              -- Buttons  
              reagirl.NextLine(10)  
              button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
              button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
              -- open the new gui  
              reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
              -- make the background grey  
              reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
              function main()  
                -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                reagirl.Gui_Manage()  
                  
                -- if the gui-window hasn't been closed, keep the script alive.  
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
              end  
  
              main()  
            
          That looks much better, the upper part for labels is much easier to distinguish from the other parts.    
          In the code, we added reagirl.Label\_SetBackdrop(label\_header, 290, 80) which started the label from the label with the element_\id label\_header and a backdrop-size of 290 by 80 pixels.    
          Let's add it for the other parts as well to see, if things get more easier to read with that.    
            
          ![Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the 'Choose File'-button.](gfx/Tutorial9_3.png "Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the 'Choose File'-button.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_SetBackdrop(label_header, 290, 80)  
                  
                -- Inputboxes  
                reagirl.NextLine()  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                reagirl.Label_SetBackdrop(label_header2, 290, 53)  
                  
                -- Checkboxes  
                reagirl.NextLine()  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                reagirl.Label_SetBackdrop(label_header3, 290, 55)  
                  
                -- Images  
                reagirl.NextLine()   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                reagirl.Label_SetBackdrop(label_header4, 290, 65)  
  
                -- Buttons  
                reagirl.NextLine(10)  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
                  
          This is even better. Each part is now separated from the other one. However, some are a little crammed to each other, so let's add some space by setting a margin into the function reagirl.NextLine() right above the labels with a backdrop "And some checkboxes" and "Or Images".    
          That way, the gui "can breathe" a little bit better and give the user even more clear indication, where one section starts and where one section ends.    
            
          ![Screenshot of the gui-window with dozens of ui-elements. The label-backdrops which make up all the sections have now more space inbetween them so the gui can breathe a little better.](gfx/Tutorial9_4.png "Screenshot of the gui-window with dozens of ui-elements. The label-backdrops which make up all the sections have now more space inbetween them so the gui can breathe a little better.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_SetBackdrop(label_header, 290, 80)  
                  
                -- Inputboxes  
                reagirl.NextLine()  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                reagirl.Label_SetBackdrop(label_header2, 290, 53)  
                  
                -- Checkboxes  
                reagirl.NextLine(8)  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                reagirl.Label_SetBackdrop(label_header3, 290, 55)  
                  
                -- Images  
                reagirl.NextLine(9)   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                reagirl.Label_SetBackdrop(label_header4, 290, 65)  
  
                -- Buttons  
                reagirl.NextLine(10)  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
                  
                  
          Ah, now each part is separated from the other one properly and has some margin, so the gui "can breathe" a little.    
          So if you compare the first example in this tutorial with the final one, you see a huge improvement in readability.    
          In this tutorial, I used autopositioning for the most ui-elements, but if you position the ui-elements "manually" by giving exact positions, the same things are valid.    
          Use reagirl.Label\_SetBackdrop() to create backdrops around ui-elements that you want to be seen together, usually the ones from the same context.    
          And give some space between each of these backdrops, so each section is obviously separated from each other. This will make it easier for users to quickly see each section, glancing at the label of each section to get, if the section is important right now and ignore everything that is unimportant.    
            
          Also keep in mind: don't add other ui-elements at the same y-position as the label that shall start a backdrop. Otherwise your ui-element will have a line right through it from the backdrop.    
            
          In the next tutorial, I will show you, how to do the same with autopositioning. So if you can't place the backdrops by eye, you still have an option to structure your gui better.    
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_008_Autopositioning_With_Tabs</previous_chapter>  
        <next_chapter>Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning</slug>  
        <title>Tutorial 010: Structuring Guis with Labels when autopositioning</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
          In this tutorial, I will show you, how to structure guis with autopositioning.     
          We will do the same as in the tutorial before: add backdrops around ui-elements to create sections in your gui and add spaces between these sections to make it easier to separate each section from each other by the user.    
            
          As a reminder: Backdrops are additional elements for labels. They are a rectangle that starts at half the height of the label and goes around until it ends again on the other side of the label.    
          You can imagine this as a rectangle, that has a gap on the top at which the label-text is placed. The bottom ends under the last ui-elements of a section of ui-elements.    
          Backdrops enclose ui-elements to make it easier to see, which ui-elements belong to each other.    
            
          Let's start with the same crowded gui from the previous tutorial.    
            
          ![Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read.](gfx/Tutorial10_1.png "Screenshot of the gui-window with dozens of ui-elements, like labels, inputboxes, images, checkboxes and buttons. The whole gui-window looks crowded and therefore is hard to read.")  
            
              -- load ReaGirl into this script  
              dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
              -- create new gui  
              reagirl.Gui_New()  
  
              -- now let's add all ui-elements of the first tab to table tab1  
               
              -- Labels  
              label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
               
              reagirl.NextLine()  
              label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
              label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                
              label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
              reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
              reagirl.NextLine()  
              label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                
              label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                
              label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
              reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
              label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
              reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
              reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                      -- let it end underneath label_large - the largest label  
              -- Inputboxes  
              reagirl.NextLine()  
              label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                
              reagirl.NextLine()  
              inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
              reagirl.NextLine()  
              button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                
              -- Checkboxes  
              reagirl.NextLine()  
              label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
              reagirl.NextLine() -- first line of checkboxes  
              checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
              checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                
              reagirl.NextLine() -- second line of checkboxes  
              checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
              checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                
              -- Images  
              reagirl.NextLine()   
              label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                
              -- local some images from Reaper  
              reagirl.NextLine()  
              image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
              image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
              image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
              image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
              image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
              -- Buttons  
              reagirl.NextLine()  
              button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
              button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
              -- open the new gui  
              reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
              -- make the background grey  
              reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
              function main()  
                -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                reagirl.Gui_Manage()  
                  
                -- if the gui-window hasn't been closed, keep the script alive.  
                if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
              end  
  
              main()  
              
          Ooof, this is really hard to read. Let's create some backdrops to make it better, shall we?    
          Let us start with the backdrop for the first section that starts with the label "Labels" with the element\_id "label\_header".    
          In the previous tutorial, we defined specific coordinates for the backdrop. In this tutorial, we will specify a backdrop from a label to underneath a specific ui-element.   
          For this, we use the function reagirl.Label\_AutoBackdrop(). This accepts as first parameter the label at which the backdrop starts and the element\_id of a second ui-element, under which the backdrop shall end.    
          Let's do this for the first section called "Labels". We add reagirl.Label\_AutoBackdrop() and let it start with the label "Labels" with the element\_id label\_header and end it underneath the label "and style" with the element\_id label\_medium\_and\_style.    
  
          ![Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. However, the biggest label 'size' is only half within the label-backdrop.](gfx/Tutorial10_2.png "Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. However, the biggest label 'size' is only half within the label-backdrop.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_AutoBackdrop(label_header, label_medium_and_style)  
                  
                -- Inputboxes  
                reagirl.NextLine()  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                -- Checkboxes  
                reagirl.NextLine()  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                -- Images  
                reagirl.NextLine()   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                -- Buttons  
                reagirl.NextLine()  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
          
          Hmm, this is close to what we want but not perfect. Most of the labels are within the backdrop but the label "size" is only halfway in it.    
          This is due to the fact, that the we set the backdrop to a label that isn't the highest ui-element in that line "and style". However, we gave the label "size" a much bigger height than "and style" so we need to choose "size" as the ui-element, underneath it the backdrop ends.    
          Let's do this by altering reagirl.Label_AutoBackdrop() to use "label\_large"(the element\_id of label "size") instead.    
            
          ![Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. The biggest label 'size' is now within the label-backdrop.](gfx/Tutorial10_3.png "Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop. The biggest label 'size' is now within the label-backdrop.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_AutoBackdrop(label_header, label_large)  
                  
                -- Inputboxes  
                reagirl.NextLine()  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                -- Checkboxes  
                reagirl.NextLine()  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                -- Images  
                reagirl.NextLine()   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                -- Buttons  
                reagirl.NextLine()  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
            
          Ah, that looks much better. Now all labels are within the backdrop, since we end it underneath the biggest ui-element "size".    
          This will usually not be a problem happening in your practice, since only labels and images can be higher than other ui-elements. But keep in mind that you need to keep track, if between two reagirl.NextLine()-functioncalls you have higher ui-elements than usual.    
          If you do and you want to end a backdrop underneath them, use the highest ui-element as ending-point for the bottom border, which isn't neccessarily the last ui-element in the line!    
            
          Ok, let's add backdrops for the other sections too, shall we?    
            
          ![Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the 'Choose File'-button.](gfx/Tutorial10_4.png "Screenshot of the gui-window with dozens of ui-elements. The labels are now enclosed in a label-backdrop as well as all checkboxes, all images and the inputbox with the 'Choose File'-button.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_AutoBackdrop(label_header, label_large)  
                  
                -- Inputboxes  
                reagirl.NextLine()  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                reagirl.Label_AutoBackdrop(label_header2, button_choose_file_id)  
                  
                -- Checkboxes  
                reagirl.NextLine()  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                reagirl.Label_AutoBackdrop(label_header3, checkbox_remember)  
                  
                -- Images  
                reagirl.NextLine()   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                reagirl.Label_AutoBackdrop(label_header4, image5)  
  
                -- Buttons  
                reagirl.NextLine()  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
            
          Ahh, much easier on the eyes. And all we added was four times a reagirl.Label\_AutoBackdrop()-functioncall to the gui.    
          Now let's do one last step and add some space between each section, so the gui "can breathe" a little better.    
          For this we add some margin of 10 into the reagirl.NextLine()-functioncalls above the labels "Inputboxes", "And some checkboxes" and "And Images".    
          The first label "Labels" we don't move, since it's already at the top of the window.    
            
          ![Screenshot of the gui-window with dozens of ui-elements. The label-backdrops that make up the sections are now spaced better so the gui can 'breathe a little'.](gfx/Tutorial10_5.png "Screenshot of the gui-window with dozens of ui-elements. The label-backdrops that make up the sections are now spaced better so the gui can 'breathe a little'.")  
            
                -- load ReaGirl into this script  
                dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")  
  
                -- create new gui  
                reagirl.Gui_New()  
  
                -- now let's add all ui-elements of the first tab to table tab1  
                 
                -- Labels  
                label_header=reagirl.Label_Add(nil, nil, "Labels", "Possible labels with ReaGirl.", false, nil)  
                 
                reagirl.NextLine()  
                label_regular=reagirl.Label_Add(nil, nil, "Example label", "A regular label.", false, nil)  
                label_clickable=reagirl.Label_Add(nil, nil, "Clickable label", "A clickable label.", true, nil)  
                  
                label_styled=reagirl.Label_Add(nil, nil, "Styled label", "A styled label.", false, nil)  
                reagirl.Label_SetStyle(label_styled, 7, 2, 0) -- set to inverted and italic  
  
                reagirl.NextLine()  
                label_small=reagirl.Label_Add(nil, nil, "different", "Label with small font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_small, 10) -- set to small font-size  
                  
                label_medium=reagirl.Label_Add(nil, nil, "font", "Label with medium font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_medium, 30) -- set to medium font-size  
                  
                label_large=reagirl.Label_Add(nil, nil, "size", "Label with large font-size.", false, nil)  
                reagirl.Label_SetFontSize(label_large, 50) -- set to large font-size  
  
                label_medium_and_style=reagirl.Label_Add(nil, nil, "and style", "Label with medium font-size and some styles.", false, nil)  
                reagirl.Label_SetFontSize(label_medium_and_style, 30)   -- set to medium font-size  
                reagirl.Label_SetStyle(label_medium_and_style, 2, 0, 0) -- set to italic  
                                                                        -- let it end underneath label_large - the largest label  
                                                                          
                reagirl.Label_AutoBackdrop(label_header, label_large)  
                  
                -- Inputboxes  
                reagirl.NextLine(10)  
                label_header2=reagirl.Label_Add(nil, nil, "Inputboxes", "Some demo-inputboxes.", false, nil)  
                  
                reagirl.NextLine()  
                inputbox_name_of_setting = reagirl.Inputbox_Add(nil, nil, 280, "Name:", 90, "Type in here the name of the setting.", "No title", nil, nil)  
  
                reagirl.NextLine()  
                button_choose_file_id = reagirl.Button_Add(223, nil, 0, 0, "Choose file", "Choose a file.", nil) -- a button  
                  
                reagirl.Label_AutoBackdrop(label_header2, button_choose_file_id)  
                  
                -- Checkboxes  
                reagirl.NextLine(10)  
                label_header3=reagirl.Label_Add(nil, nil, "And some checkboxes", "Some checkboxes in ReaGirl.", false, nil)  
  
                reagirl.NextLine() -- first line of checkboxes  
                checkbox_mysetting = reagirl.Checkbox_Add(nil, nil, "My setting", "The first checkbox.", true, nil)  
                checkbox_another_setting = reagirl.Checkbox_Add(nil, nil, "Another setting", "The second checkbox.", true, nil)  
                  
                reagirl.NextLine() -- second line of checkboxes  
                checkbox_extra_setting = reagirl.Checkbox_Add(nil, nil, "Extra", "A third checkbox?", true, nil)  
                checkbox_remember = reagirl.Checkbox_Add(108, nil, "Remember chosen setting", "Shall this setting be used as future default?", true, nil)  
                  
                reagirl.Label_AutoBackdrop(label_header3, checkbox_remember)  
                  
                -- Images  
                reagirl.NextLine(10)   
                label_header4=reagirl.Label_Add(nil, nil, "Or Images", "Set the settings, as you wish.", false, nil)  
                  
                -- local some images from Reaper  
                reagirl.NextLine()  
                image1 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/idea.png", "An idea-cloud", "An image of an idea-thought-cloud.", nil)  
                image2 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/envelope.png", "An envelope", "An image of an envelope.", nil)  
                image3 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/ff.png", "ff notation symbol", "An image of a ff-notation-symbol.", nil)  
                image4 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/folder_up.png", "A folder up", "An image of a folder with an arrow pointing up.", nil)  
                image5 = reagirl.Image_Add(nil, nil, 50, 50, reaper.GetResourcePath().."/Data/track_icons/bass_clef.png", "A bass clef", "An image of a bass clef.", nil)  
  
                reagirl.Label_AutoBackdrop(label_header4, image5)  
  
                -- Buttons  
                reagirl.NextLine(10)  
                button_ok_id = reagirl.Button_Add(205, nil, 0, 0, "OK", "Apply changes and close dialog.", nil)  
                button_cancel_id = reagirl.Button_Add(nil, nil, 0, 0, "Cancel", "Discard changes and close dialog.", nil)  
  
                -- open the new gui  
                reagirl.Gui_Open("My Dialog Name", false, "The dialog", "This is a demo dialog with settings for tool xyz.")  
  
                -- make the background grey  
                reagirl.Background_GetSetColor(true, 55, 55, 55)  
  
  
                function main()  
                  -- a function that runs the gui-manage function in the background, so the gui is updated correctly  
                  reagirl.Gui_Manage()  
                    
                  -- if the gui-window hasn't been closed, keep the script alive.  
                  if reagirl.Gui_IsOpen()==true then reaper.defer(main) end  
                end  
  
                main()  
            
          And that's it. We added backdrops for each section of ui-elements, so it's easier to separate them from each other, using autopositioning and reagirl.Label\_AutoBackdrop() and added space between each section with reagirl.NextLine(10).    
            
          For blind scripters: this can be confusing in the beginning, so get some feedback from sighted users for your scripts that use label-backdrops.    
          That way you can improve on potential wrongfully positioned backdrops. Once you got a grip on how to achieve this, you'll be able to do it without feedback too.    
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_009_Structuring_Guis_With_Labels</previous_chapter>  
        <next_chapter>Tutorial_011_Linking_UI_Elements_To_States</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
	
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Tutorial_011_Linking_UI_Elements_To_States</slug>  
        <title>Tutorial 011: Linking UI-elements to states</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
			In ReaGirl, you can link many of the ui-elements to states like toggle-command-states, extstates, ini-file-entries or config-variables.
			That means: if the state is updated by something, the ui-element is updated immediately and clicking/altering the ui-element updates the state is is linked to immediately as well.
			With that, you can easily create guis that alter configuration-settings without having to think about it a lot.
			Let me show you an example by linking a checkbox to the toggle-state of the loop-button-action.
			
			We start with the basic gui containing one checkbox:
			
					-- 0. enable ReaGirl for the script
					dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")

					-- 1. add the run-functions for the ui-elements
					function checkbox_run_function()
					end

					-- 2. start a new gui
					reagirl.Gui_New()

					-- 3. add the checkbox, that shall display the toggle-state of the loop-action
					checkbox_id = reagirl.Checkbox_Add(10, 10, "Loop-State", "Shows the state of the loop-button.\nGets immediately updated when the loop-button is clicked/the loop-action is run.", true, checkbox_run_function)

					-- 4. open the gui
					reagirl.Gui_Open("My Dialog Name", false, "Dialog Title", "A short explanation of my dialog.", nil, nil, nil, nil, nil)

					-- 5. start the gui with the manage-function, whose parameter is set to true
					reagirl.Gui_Manage(true)

			![A window with one checkbox that reads "Loop-State" in the caption.](gfx/Tutorial11_1.png "A window with one checkbox that reads "Loop-State" in the caption")  

			This shows a nice little window with one checkbox, but clicking it does nothing to the loop-button.   
			So let's add one new line, a functioncall to reagirl.Checkbox\_LinkToToggleState() directly after the Checkbox\_Add-function.
			We link it to the action "Transport: Toggle repeat" with command-id 1068 in the main-section(0) and we set the last parameter to true that signals, that toggling the checkbox shall run the 
			linked action to change the toggle-state(some actions require this, more about this later).  
			Ok, let's see, how the code looks now with the new line:
			
					-- 0. enable ReaGirl for the script
					dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")

					-- 1. add the run-functions for the ui-elements
					function checkbox_run_function()
					end

					-- 2. start a new gui
					reagirl.Gui_New()

					-- 3. add the checkbox, that shall display the toggle-state of the loop-action
					checkbox_id = reagirl.Checkbox_Add(10, 10, "Loop-State", "Shows the state of the loop-button.\nGets immediately updated when the loop-button is clicked/the loop-action is run.", true, checkbox_run_function)
					reagirl.Checkbox_LinkToToggleState(checkbox_id, 0, 1068, true)

					-- 4. open the gui
					reagirl.Gui_Open("My Dialog Name", false, "Dialog Title", "A short explanation of my dialog.", nil, nil, nil, nil, nil)

					-- 5. start the gui with the manage-function, whose parameter is set to true
					reagirl.Gui_Manage(true)

			Looking good, so let's run it and check, what happens, when we toggle the checkbox and the loop-button.
			
			![A window with one checkbox that reads "Loop-State" in the caption. Toggling the checkbox toggles the loop-button-state as well. Toggling the loop-button toggles the checkbox-state as well.](gfx/Tutorial11_2.gif "A window with one checkbox that reads "Loop-State" in the caption. Toggling the checkbox toggles the loop-button-state as well. Toggling the loop-button toggles the checkbox-state as well.")  
			
			Nice. With just one additional line, we made the checkbox behaving according to the loop-button. And it even works, when you run the loop-action from the actionlist or from a shortcut: the checkbox is toggled accordingly.

			Note: as I said, some actions need to be run for the toggle-state to change. In that case, set the last parameter of reagirl.Checkbox\_LinkToToggleState() to true.
			If you need to set the last parameter to true or false depends on how the action actually works. Best is to check first with false and see, if the behavior is as you expected. If not, set it to true and test it again. This should work most of the times.
			
			As mentioned, you can link ui-elements to toggle-states(checkboxes), ext-states(checkbox, dropdownmenu, slider, inputbox), ini-file-entries(checkbox, dropdownmenu, slider, inputbox), integer-bitfield-config-variables(checkbox), integer/double config-variables(slider), string config-variables(inputbox).
			And everytime the linked-state is updated, the ui-element gets updated and when the ui-element gets updated, the state gets updated immediately too.
			
			And to unlink a ui-element from a ui-element, use the \_UnLink() functions, like reagirl.Checkbox\_UnLink() for checkboxes.
			
			This should make things real easy for you, when making guis with certain settings available in one spot.	
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Tutorials
        </chapter_context>
        <previous_chapter>Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning</previous_chapter>  
        <next_chapter>The_Gui_Elements_000</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
          
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_000</slug>  
        <title>The Gui Elements</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            ReaGirl features a set of ui-elements that you can add to your gui and add functionality to them,  
            as of now buttons, labels, checkboxes, inputboxes, images, sliders, dropdownmenus and tabs.  
              
            You can also add to each ui-element a context-menu. You can also add a file-drop-zone, which allows you to drop files onto a certain ui-element.  
            For both, context-menus and drop zones, you can add run-functions that will be run when a context-menu is opened or files have been dropped.  
              
            Some ui-elements(images and labels) can even be made draggable.  
              
            In addition, there's a subset of ReaGirl-functions whose name begin with reagirl.UI\_Element\_ that allow influencing ui-elements, like reagirl.UI\_Element\_GetSetPosition() which allows getting and setting the position of a ui-element.  
              
            In the next chapters, I will go through all of these ui-elements and additional concepts and explain how they are intended.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning</previous_chapter>  
        <next_chapter>The_Gui_Elements_001_Buttons</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_001_Buttons</slug>  
        <title>Buttons</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Buttons are calls to action. They are rectangular shaped ui-elements with round edges that feature a short text(called a caption).  
            They can be pressed to start an action, like opening a dialog, running actions from the action list, closing a window, etc.  
            What they do is defined by what you write into the run-function.  
              
            To add a button to your gui, you use reagirl.Button\_Add(). It has seven parameters.  
              
            - The first and the second are the position of the button in pixels. You can set them to nil to auto-position it.  
            - The third and fourth are margins around the caption. So if the button is too small for you, make these >0 to make the button bigger.  
            - The fifth parameter is the caption, which is the text of the button.  
            - The sixth parameter is meaningOfUI\_Element, which is a short explanation on what the button is doing and why. This is needed by blind users so they know, what the button is for.  
            - The seventh parameter is a run-function. This function will be run, when the button is clicked. It gets as parameter the element\_id of the button that was clicked.  
              
            With this, you can add a button to your gui, but there's more that you can do with a button.  
              
            - reagirl.Button\_SetDisabled() - sets a button to disability-state, so you can prevent the button from being clickable  
            - reagirl.Button\_GetDisabled() - gets the current disability state, if the button can be clicked or not  
            - reagirl.Button\_SetRadius - allows you to make the button more round or more square  
            - reagirl.Button\_GetRadius - gets the current roundness of the button's edges  
              
            Check the [first tutorial "A basic gui"](#Tutorial_001_A_Basic_Gui) to see examples of guis with a buttons.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_000</previous_chapter>  
        <next_chapter>The_Gui_Elements_002_Checkboxes</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_002_Checkboxes</slug>  
        <title>Checkboxes</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Checkboxes are toggle-states. They can be set to checked(on) or unchecked(off).  
            They are square and have a small yellow square in the middle when checked with a descriptive text(caption) next to it.  
              
            They are usually used when the user has the option to turn something on or off.  
              
            To add a checkbox, you use reagirl.Checkbox\_Add(). It has six parameters.  
              
            - The first and second parameter are the position in pixels. Set them to nil to auto-position the checkbox.  
            - The third parameter is the text of the caption.  
            - The fourth parameter is meaningOfUI\_Element, which is a short explanation on what the checkbox is doing and why. This is needed by blind users so they know, what the checkbox stands for.  
            - The fifth parameter is the initial checkstate when the script is started. True, the checkbox is checked, false, it is unchecked.  
            - The sixth parameter is the run-function which is run everytime the user toggles the checkstate of the checkbox.   
              It gets as parameters the element\_id of the toggled checkbox as first and the new checkstate as second parameter.  
              You can set the run-function to nil if you don't want a run-function to be run.  
                
            There's more that you can do with checkboxes:  
              
            - reagirl.Checkbox\_SetDisabled - sets a checkbox disability-state, so you can set if the checkbox can be clicked  
            - reagirl.Checkbox\_GetDisabled - gets the current disability-state of a checkbox, if it can be clicked  
            - reagirl.Checkbox\_SetCheckState - sets the checkstate of the checkbox  
            - reagirl.Checkbox\_GetCheckState - gets the current checkstate of the checkbox  
            - reagirl.Checkbox\_SetWidth - sets width of a checkbox, which helps you with autopositioning  
			
			- reagirl.Checkbox\_LinkToConfigVar - links the checkbox to a certain config-variable-bitfield  
			- reagirl.Checkbox\_LinkToExtstate - links the checkbox to an extstate  
			- reagirl.Checkbox\_LinkToIniValue - links the checkbox to an ini-value
			- reagirl.Checkbox\_LinkToToggleState - links the checkbox to the toggle-state of an action  
			- reagirl.Checkbox\_Unlink - removes the link between the checkbox and a certain state  
			
            Check the [first tutorial "A basic gui"](#Tutorial_001_A_Basic_Gui) to see examples of guis with checkboxes.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_001_Buttons</previous_chapter>  
        <next_chapter>The_Gui_Elements_003_Labels</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_003_Labels</slug>  
        <title>Labels</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Labels are a way to show text in your gui. They are meant to explain things or   
            give your gui some structure, like explaining the basic context of some ui-elements as a header.  
            They can be copied to the clipboard using Ctrl+C.  
            You can also make a label clickable, so it behaves like a link on a webpage.  
            Labels can have newlines.  
              
            There are also functions to set a label draggable.  
              
            You add labels to your gui with reagirl.Label\_Add(), which has six parameters.  
              
            - The first and second parameters are the position of the label in pixels. To autoposition the label, pass nil into these parameters.  
            - The third parameter is the label-text. It can include newlines.  
            - The fourth parameter is meaningOfUI\_Element, which gives some more explanation of this label for blind users.  
              Means, if the label is a header for some ui-elements, you can explain in more detail, what the ui-elements are supposed to be.  
            - The fifth parameter sets, if the label is clickable(true) or not(false).  
            - The sixth parameter is a run-function, that is run when a clickable label is clicked and/or a label is dragged onto another ui-element.  
              You can keep the run-function nil if you don't need a run-function to be run.  
              
            There's more that you can do with labels:  
              
            - reagirl.Label\_SetBackdrop - sets the backdrop of a label, which could enclose ui-elements underneath it  
            - reagirl.Label\_GetBackdrop - gets the backdrop of a label, which could enclose ui-elements underneath it  
            - reagirl.Label\_AutoBackdrop - sets a backdrop from label to underneath a specific ui-element  
            - reagirl.Label\_SetStyle - allows setting different styles for the label, like underlined or bold  
            - reagirl.Label\_GetStyle - gets the currently set styles for a label  
            - reagirl.Label\_SetFontSize - sets the font-size of the label  
            - reagirl.Label\_GetFontSize - gets the currently set font-size of the label  
            - reagirl.Label\_SetAlignment - sets the alignment of the label-text, like centered or right aligned  
            - reagirl.Label\_GetAlignment - gets the current alignment for this label  
            - reagirl.Label\_SetDraggable - sets the label as draggable, including possible drag-destinations  
            - reagirl.Label\_GetDraggable - gets the current drag-state and the current drag-destinations  
              
            - reagirl.UI_Element\_GetSetCaption - gets or sets the label text  
              
            Check the [first tutorial "A basic gui"](#Tutorial_001_A_Basic_Gui) to see examples of guis with labels.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_002_Checkboxes</previous_chapter>  
        <next_chapter>The_Gui_Elements_004_Images</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_004_Images</slug>  
        <title>Images</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Images show an image in the gui. They can be clicked and do things using the run-function.  
            Transparency in png-images will be obeyed, so you can have images with transparent background drawn into your gui.  
              
            Very important: the caption and the meaningOfUI\_Element-parameters must describe the content of the image, so blind users know, what the image contains, as they can't see it.  
              
            Images can automatically scale from 1x to 8x.  
            To make this happen, add scaled versions of the image to the same folder as the source image and name them the following way:  
              
            image-filename.png - 1x-scaling    
            image-filename-2x.png - 2x-scaling    
            image-filename-3x.png - 3x-scaling    
            image-filename-4x.png - 4x-scaling    
            image-filename-5x.png - 5x-scaling    
            image-filename-6x.png - 6x-scaling    
            image-filename-7x.png - 7x-scaling    
            image-filename-8x.png - 8x-scaling    
              
            Means: add -2x before the extension for the 2x scaled image, add -3x before the extension for the 3x scaled image and so on.  
                          
            Give Image\_Add the 1x-scaled image as filename and when the user changes the scaling, ReaGirl will load the accompanying scaled image automatically.  
            If there's no scaled image available, ReaGirl will automatically revert to the original filename for 1x-scaling. So if there's only one image available, ReaGirl will only load that one.  
              
            You can have up to 1000 images per gui.  
              
            Images can be made draggable.    
              
            You can add images using Image\_Add, which has eight parameters.    
              
              - Parameter 1 and 2 are the position of the image in pixels. Set them to nil to autoposition the image.  
              - Parameter 3 and 4 are the width and height of the image in pixels.  
              - Parameter 5 is the filename of the 1x-scaled image.  
              - Parameter 6 is the caption of the image. This won't be shown but screen reader users will get this communicated so make it descriptive.  
              - Parameter 7 is the meaningOfUI\_Element, which describes to the blind users what the image is for and why.  
              - Parameter 8 is the run-function of the image that is run when the user clicks the image.  
                Set it to nil, if you don't need it.  
                  
            You can do more things with images:  
              
              - reagirl.Image\_GetDraggable - get if the image is draggable and what the potential drag-destinations are  
              - reagirl.Image\_SetDraggable - set the image to draggable and set the potential drag-destination-ui-elements  
              - reagirl.Image\_GetDimensions - get the width and height of the image  
              - reagirl.Image\_SetDimensions - set the width and height of the image  
              - reagirl.Image\_ReloadImage_Scaled - reloads the image if the image-file has been altered and you want to update the shown image  
              - reagirl.Image\_KeepAspectRatio - forces the image to be shown with correct aspect ratio(otherwise it might get stretched)  
              - reagirl.Image\_GetImageFilename - get the current image-filename  
              - reagirl.Image\_Load - loads a new image-file into the image  
              - reagirl.Image\_ClearToColor - clears the image and sets it to a color instead  
                              
            See the tutorial ["A basic Image Viewer"](#Tutorial_003_A_Basic_Image_Viewer) and the tutorial ["Draggable Images"](#Tutorial_005_Draggable_Images) to know how to work with images.              
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_003_Labels</previous_chapter>  
        <next_chapter>The_Gui_Elements_005_Inputboxes</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_005_Inputboxes</slug>  
        <title>Inputboxes(Edit-Fields)</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Inputboxes are fields, into which you can type text. They consist of a caption and a square next to it, into which you enter the text.  
            Unlike other ui-elements, inputboxes allow for two run-functions: one for when the user typed a character into the inputbox and one for when the user hits enter.  
              
            You can add inputboxes with InputBox\_Add, which has 9 parameters.  
              
            - Parameter 1 and 2 are the position of the inputbox in pixels. Set them to nil to autoposition them.  
            - Parameter 3 is the width of the inputbox in pixels. This includes the length of the caption so make it  
              long enough.  
            - Parameter 4 is the caption, which is the text on the left side of the inputbox.  
            - Parameter 5 is the caption-width. With this you can influence, at which point the actual editfield shall start.  
              So if you have numerous inputboxes underneath, you can set all their cap_width to the same value so they are perfectly aligned.  
              If you don't need that, set this to nil, which starts the editfield directly after the caption.  
            - Parameter 6 is meaningOfUI\_Element, which is a description for the inputbox communicated to screen reader users. Explain what the inputbox is for and why.  
            - Parameter 7 is the default text, which is the text shown when the gui is started.  
            - Parameter 8 is the run-function for when the user hits enter into the inputfield.  
              This run-function gets the inputbox-element\_id as first and the entered text as second parameter.  
            - Parameter 9 is the run-function for when the user entered a character into the inputfield.  
              This run-function gets the inputbox-element\_id as first, the entered text as second and the last entered character(or pasted text) as third parameter.  
                
            You can do more with inputboxes.  
              
            - reagirl.Inputbox\_GetPassword - gets if the inputbox shall be used for entering passwords. Means, all characters will be shown as *  
            - reagirl.Inputbox\_SetPassword - sets if the inputbox shall be used for entering passwords. Means, all characters will be shown as *  
            - reagirl.Inputbox\_GetDisabled - gets the disability state of an inputbox  
            - reagirl.Inputbox\_SetDisabled - sets an inputbox's disability-state, means, if the inputbox is clickable/allows entering text or not  
            - reagirl.Inputbox\_GetText - gets the text from the editfield of an inputbox  
            - reagirl.Inputbox\_SetText - sets the text in the editfield of an inputbox  
            - reagirl.Inputbox\_SetEmptyText - sets text that is shown when no text has been entered  
            - reagirl.Inputbox\_GetSelectedText - gets the currently selected text  
            - reagirl.InputBox\_GetCursorOffset - gets the current offset of the edit-cursor in the editfield of an inputbox              
			
			- reagirl.InputBox\_LinkToConfigVar - links the inputbox to a certain config-variable
			- reagirl.InputBox\_LinkToExtstate - links the inputbox to an extstate  
			- reagirl.InputBox\_LinkToIniValue - links the inputbox to an ini-value
			- reagirl.InputBox\_Unlink - removes the link between the inputbox and a certain state  
            Check the examples in the subfolder Additional\_Examples for examples of guis with inputboxes. Run the action "ReaGirl\_OpenFolder\_ExampleScripts.lua" to open the example-folder.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_004_Images</previous_chapter>  
        <next_chapter>The_Gui_Elements_006_DropDownMenus_ComboBoxes</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_006_DropDownMenus_ComboBoxes</slug>  
        <title>DropDownMenus(ComboBoxes)</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Drop down menus are menus that give the user a selection of options and they can choose one of them.  
            They are a caption and a box right next to it which can be clicked to select the option.  
            You can cycle through the options with the arrow-keys, home/end-key and mouse-wheel.
              
            You can add a drop down menu to the gui using DropDownMenu\_Add, which has 9 parameters.  
              
            - Parameters 1 and 2 are the x and y coordinate in pixels of the drop down menu. Set them to nil to autoposition the drop down menu.  
            - Parameter 3 is the width of the drop down menu in pixels. This includes the caption so make it long enough.  
            - Parameter 4 is the caption of the drop down menu, which is a text shown on the left side of the drop down menu.  
            - Parameter 5 is the caption-width. With this you can influence, at which point the actual clickable drop down menu shall start.  
              So if you have numerous drop down menus underneath, you can set all their cap_width to the same value so they are perfectly aligned.  
              If you don't need that, set this to nil, which starts the clickable drop down menu-area directly after the caption.  
            - Parameter 6 is meaningOfUI\_Element, which is a description for the drop down menu communicated to screen reader users. Explain what the drop down menu is for and why.  
            - Parameter 7 is the menuItems, which is a table with all menu-item-names, like {"Option 1", "second Option", "Option number three"}  
            - Parameter 8 is the selected menu item when the gui is started  
            - Parameter 9 is the run-function that is run everytime the user changes the menu-selection  
              The run-function gets the element\_id of the selected drop down menu as first, the selected menu-entry-number as second and the selected menu-entry-name as third parameter.  
                
            You can do more things with drop down menus:  
              
            - reagirl.DropDownMenu\_SetDimensions - sets the width of the drop down menu  
            - reagirl.DropDownMenu\_GetDimensions - gets the width of the drop down menu  
            - reagirl.DropDownMenu\_SetDisabled - sets the drop down menu's disability-state, means, if it can be clicked or not  
            - reagirl.DropDownMenu\_GetDisabled - gets the current disability state of the drop down menu  
            - reagirl.DropDownMenu\_GetMenuItems - gets the menu-items of the drop down menu  
            - reagirl.DropDownMenu\_SetMenuItems - sets the menu-items of the drop down menu  
			
			- reagirl.DropDownMenu\_LinkToExtstate - links the drop down menu to an extstate  
			- reagirl.DropDownMenu\_LinkToIniValue - links the drop down menu to an ini-value
			- reagirl.DropDownMenu\_Unlink - removes the link between the drop down menu and a certain state  
			
            Check the [fourth tutorial "Disabled UI-Elements"](#Tutorial_004_Disabled_UI_Elements) to see examples of guis with sliders.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_005_Inputboxes</previous_chapter>  
        <next_chapter>The_Gui_Elements_007_Sliders</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_007_Sliders</slug>  
        <title>Sliders</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Sliders are ui-elements that give the user a way to choose a number-value between a start-value and an end-value.  
            It has a line on which you have a circle that can be moved around. Depending on where the circle is, a certain value has been selected.  
            For instance: you can have a slider with a value-range from 1 to 10 and the user can move the circle to choose any value between 1 and 10.  
            You can also give a stepsize. So if you want the user to just choose integers, give a step-size of 1.  
            The slider can be altered using mousewheel, arrow keys, PgUp and PgDn as well as home/end-key
              
            You can add sliders with reagirl.Slider\_Add() which has 13 parameters.  
              
            - Parameters 1 and 2 are the x and y coordinate in pixels of the slider. Set them to nil to autoposition the slider.  
            - Parameter 3 is the width of the slider in pixels. This includes the caption so make it long enough.  
            - Parameter 4 is the caption of the slider, which is a text shown on the left side of the slider.  
            - Parameter 5 is the caption-width. With this you can influence, at which point the actual slider shall start.  
              So if you have numerous sliders underneath, you can set all their cap_width to the same value so they are perfectly aligned.  
              If you don't need that, set this to nil, which starts the slider directly after the caption.  
            - Parameter 6 is meaningOfUI\_Element, which is a description for the slider communicated to screen reader users. Explain what the slider is for and why.  
            - Parameter 7 is the unit. This is a string that is shown at the right side of the slider. This can be something like "%", "percentage" or "cpus" or whatever the unit of your slider is. Set it to nil or "" if you don't need one.  
            - Parameter 8 and 9 are the start and end-values of the slider. Means, when you move the circle to the far left or to the far right, it will be at start-value or end-value respectively.  
            - Parameter 10 is the stepsize. This will make the slider go in steps. For instance a step of 10 will move the circle of the slider only in steps of 10.  
              So for instance, if you have startvalue=10 and end-value=50 and steps=10, the possible steps in the slider are 10, 20, 30, 40 and 50. No other values can be chosen by the user.  
            - Parameter 11 is the init-value. That's where the circle is when you start the gui.  
            - Parameter 12 is the default value. So if you have a default-value, set this to this value.  
              The slider will draw a small line at where the default-value is.  
              Doubleclicking will set the slider back to this default-value.  
            - Parameter 13 is the run-function, which is run everytime the user moves the circle of the slider.  
              You can set this to nil, if you don't need one.  
              The run-function gets the element\_id of the moved slider as first and the current value of the slider as second parameter.  
                
            You can do more things with sliders:  
              
            - reagirl.Slider\_GetStartValue - gets the start-value of the slider  
            - reagirl.Slider\_SetStartValue - sets the start-value of the slider  
            - reagirl.Slider\_GetEndValue - gets the end-value of the slider  
            - reagirl.Slider\_SetEndValue - sets the end-value of the slider  
            - reagirl.Slider\_GetDefaultValue - gets the current default-value of the slider  
            - reagirl.Slider\_SetDefaultValue - sets the current default-value of the slider  
            - reagirl.Slider\_ResetToDefaultValue - resets the slider to the default-value  
            - reagirl.Slider\_GetValue - gets the currently set value of the slider  
            - reagirl.Slider\_SetValue - sets the current value of the slider  
            - reagirl.Slider\_GetDimensions - gets the current width of the slider  
            - reagirl.Slider\_SetDimensions - sets the width of the slider  
            - reagirl.Slider\_GetDisabled - gets the disability-state of the slider  
            - reagirl.Slider\_SetDisabled - sets the disability-state of the slider, means, if it can be influenced by mouse or keyboard or not  
			
            - reagirl.Slider\_LinkToIntConfigVar - links the slider to a certain integer config-variable
			- reagirl.Slider\_LinkToDoubleConfigVar - links the slider to a certain double config-variable
			- reagirl.Slider\_LinkToExtstate - links the slider to an extstate  
			- reagirl.Slider\_LinkToIniValue - links the slider to an ini-value
			- reagirl.Slider\_Unlink - removes the link between the checkbox and a certain state  
            Check the [fourth tutorial "Disabled UI-Elements"](#Tutorial_004_Disabled_UI_Elements) to see examples of guis with sliders.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter></previous_chapter>  
        <next_chapter>The_Gui_Elements_008_Tabs</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_008_Tabs</slug>  
        <title>Tabs</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Tabs allow you to structure ui-elements into categories. For instance, you can have all settings for setting one in one category(tab) and the ones for setting two in another category(tab).  
            And when you switch between the tabs, only the ui-elements associated with a specific tab are shown while the others are hidden.  
              
            With them, you can organize your guis better so people are not overwhelmed by one page with all ui-elements at once.  
            You can also put ui-elements outside of tabs so they are shown all the time.  
              
            Only one tab-ui-element per gui is allowed!  
              
            You add tabs to your gui using reagirl.Tabs\_Add(), which has nine parameters.  
              
            - Parameters 1 and 2 are x and y-position of the tabs in pixels. You can set these to nil to autoposition the tabs.  
            - Parameters 3 and 4 are the width and height of the grey background of the tabs, that gives a backdrop to ui-elements.  
              It's intended to show which ui-elements are parts of a specific tab. Set them to 0 for no background or nil to let the  
              background be automatically around the added ui-elements.  
            - Parameter 5 is a caption for the tabs, which is communicated to screen readers as a general overview of what the tabs are for.  
            - Parameter 6 is meaningOfUI\_Element, which is a description for the tabs, communicated to screen reader users. Explain what the tabs are for and why.  
            - Parameter 7 is a table with all tab-names, like {"Tab Number 1", "The second tab", "The third one"}  
            - Parameter 8 is the tab that is selected when the gui is opened.  
            - Parameter 9 is a run-function that is called everytime the user switched tabs  
              You can set this to nil, if you don't want to use a run-function when tabs are switched.  
              The run-function will get the element\_id of the tab as first, the selected tab as second and the selected tabname as third parameter.  
              
            There are more things you can do with tabs:  
              
            - reagirl.Tabs\_SetUIElementsForTab - associates ui-elements with a specific tab. Means, the associated ui-elements   
                                                will only be shown when this tab is selected  
            - reagirl.Tabs\_SetSelected - sets a specific tab as selected  
            - reagirl.Tabs\_GetSelected - gets the currently selected tab  
              
            Check the [second tutorial "Adding Tabs to a Gui"](#Tutorial_002_Adding_Tabs_to_a_Gui) as well as the [eight tutorial "Autopositioning with tabs"](#Tutorial_008_Autopositioning_With_Tabs) to see, how to code tabs.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_007_Sliders</previous_chapter>  
        <next_chapter>The_Gui_Elements_Concepts001_Context_Menus</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
  
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_Concepts001_Context_Menus</slug>  
        <title>Context Menus</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            Context menus are menus that are opened, when the user right-clicks a ui-element.  
            Any ui-element can have its own context-menu.  
            To add one to a ui-element, you need the element\_id of the ui-element that shall get the menu as well as a run-function.  
            Then use the function reagirl.UI\_Element\_GetSet\_ContextMenu()  
              
            It has four parameters.   
              
            - The first one is the element\_id of the ui-element, that shall get a context-menu.  
            - The second one is a boolean with which you tell ReaGirl, if you want to add a context-menu(true) or get the current menu(false).  
            - The third parameter is the menu itself. It follows the scheme of gfx.showmenu():  
              
            >It is a list of fields separated by | characters. Each field represents a menu item.  
            >Fields can start with special characters:  
  
            >\# : grayed out    
            >! : checked    
            >\> : this menu item shows a submenu    
            >< : last item in the current submenu    
              
            >Example:    
            >"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu")    
              
            Experiment with it to get a grip on how it works.  
              
            - The last parameter is a run-function that will be run when the user selects a menu-item in the context-menu.  
            It will get two parameters. First, the element\_id of the ui-element, whose context-menu has been used and second the chosen menu-entry.  
              
            And that's it. Add a run-function for the context-menu, add a ui-element, use its element\_id as parameter for reagirl.UI\_Element\_GetSet\_ContextMenu() and fill out the other parameters.  
            Run the script and the ui-element has a context menu when right clicking it.  
            Check the [third tutorial "A Basic Image Viewer with a file-drop-zone and a context menu"](#Tutorial_003_A_Basic_Image_Viewer) to see, how it looks in practice.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_008_Tabs</previous_chapter>  
        <next_chapter>The_Gui_Elements_Concepts002_FileDropZones</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_Concepts002_FileDropZones</slug>  
        <title>File Drop Zones</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            File Drop Zones are zones, where you can drag and drop files onto.  
            You can give a ui-element a file drop zone and when you did, you can drop files onto the corresponding ui-element.  
            For instance, you can show an image and define a drop zone for this image. And then you can drop files onto the image itself.  
            Accessibility users can use ctrl+shift+f to select a file to drop.
              
            Every ui-element can have a file drop zone. You just need the element\_id and a run-function for it.  
            Then use the function reagirl.UI\_Element\_GetSet\_DropZoneFunction() to add a file drop zone to a ui-element.  
              
            - The first parameter is the element\_id of the ui-element, that shall get a file drop zone.  
            - The second parameter sets, if you want to set a file drop zone to the ui-element(true) or get its current run-function.  
            - The third parameter is a run-function that gets run, when the user drops files onto the ui-element.  
              
            The run-function will get two parameters passed:  
            First, the element\_id of the ui-element, onto which the files were dropped.  
            Second, a table with all filenames that were dropped.  
            It also supports dropping of fx from inside Reaper to it. In that case, the filename starts with @fx:  
              
            Check the [third tutorial "A Basic Image Viewer with a file-drop-zone and a context menu"](#Tutorial_003_A_Basic_Image_Viewer) to see, how it looks in practice.  
              
            And that's all you need to add file drop zones to ui-elements.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_Concepts001_Context_Menus</previous_chapter>  
        <next_chapter>The_Gui_Elements_100_General</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>The_Gui_Elements_100_General</slug>  
        <title>Functions for getting/setting ui-elements in general</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
          ReaGirl includes a variety of basic functions to influence various attributes of UI-elements, Guis and the gui-window.  
          Here's a list of all of them. You've seen some of them already in the tutorials.  
            
          - reagirl.GetVersion - returns the version-number of the installed ReaGirl-version  
            
          Functions for UI-elements:  
            
          - reagirl.UI\_Element\_GetFocusRect - gets the current coordinates of the focus rectangle  
          - reagirl.UI\_Element\_GetFocused - gets the currently focused ui-element  
          - reagirl.UI\_Element\_GetHovered - gets the currently hovered ui-element  
          - reagirl.UI\_Element\_GetSetCaption - gets/sets the caption of a ui-element  
          - reagirl.UI\_Element\_GetSetMeaningOfUIElement - gets/sets the meaning of ui-element, like tooltip/screen reader helpmessage  
          - reagirl.UI\_Element\_GetSetPosition - gets/sets the position of a ui-element  
          - reagirl.UI\_Element\_GetSetRunFunction - gets/sets the current run-functions  
          - reagirl.UI\_Element\_GetSetVisibility - gets/sets visibility of a ui-element  
          - reagirl.UI\_Element\_GetType - gets the type of a ui-element, like Edit for inputboxes, label, checkbox, etc  
          - reagirl.UI\_Element\_IsElementAtMousePosition - checks, if a ui-element is at mouse-position  
          - reagirl.UI\_Element\_Last\_Element\_Current\_Position - gets the position of the last ui-element added to the gui  
          - reagirl.UI\_Element\_Remove - removes a ui-element  
          - reagirl.UI\_Element\_SetFocused - sets a specific ui-element focused  
          - reagirl.UI\_Element\_SetHiddenFromTable - sets all ui-elements hidden/visible that are passed over as a table  
          - reagirl.UI\_Element\_SetFocusRect - sets the focus rectangle to certain coordinates  
            
          Functions for the Gui:  
  
          - reagirl.Gui\_AtExit - sets a run-function that is run when the gui-window gets closed  
          - reagirl.Gui\_AtEnter - sets a run-function when the user hits the enter key into the gui(for closing at enter-key)  
          - reagirl.Gui\_Close - closes the gui-window  
          - reagirl.Gui\_ForceRefresh - forces a refresh of the gui, if something has changed, usually not needed  
          - reagirl.Gui\_GetBoundaries - gets the current boundaries of the ui-elements  
          - reagirl.Gui\_IsOpen - returns, if the gui-window is currently opened or not  
          - reagirl.Gui\_Manage - manages the gui-functionality, needs to be called periodically  
          - reagirl.Gui\_New - starts a new gui and throws away the current one  
          - reagirl.Gui\_Open - opens up the gui-window  
          - reagirl.Gui\_PreventCloseViaEscForOneCycle - prevents the closing of the gui via esc-key for one defer-cycle  
          - reagirl.Gui\_PreventEnterForOneCycle - prevents the "global" enter-key from working for one defer-cycle  
          - reagirl.Gui\_PreventScrollingForOneCycle - prevents scrolling of the gui for one defer-cycle  
  
          Functions for the gui-window:  
            
          - reagirl.Window\_ForceSize\_Minimum - forces that the window can't be resizes under a specific minimum  
          - reagirl.Window\_GetCurrentScale - gets the currently used scaling-factor for the gui  
          - reagirl.Window\_SetCurrentScale - sets a scaling factor for the gui between 1 and 8  
          - reagirl.Window\_SetFocus - sets window-focus back to the gui-window  
          - reagirl.Window\_ForceSize\_Maximum - forces that the window can't be resizes above a specific maximum  
            
          Function to access a ReaGirl-gui-window from other scripts:  
  
          - reagirl.Ext\_Tab\_SetSelected - sets a tab of specific ReaGirl-gui-window focused  
          - reagirl.Ext\_Window\_Focus - sets window-focus to an opened ReaGirl-gui-window  
          - reagirl.Ext\_Window\_IsOpen - gets, if a specific ReaGirl-gui-window is currently opened  
          - reagirl.Ext\_Window\_GetState - gets the current dimensions and dock-state of an opened/previously opened ReaGirl-window  
          - reagirl.Ext\_Window\_SetState - gets the current dimensions and dock-state of an opened/previously opened ReaGirl-window  
          - reagirl.Ext\_Window\_ResetToDefault - resets a ReaGirl-Gui-Window to its default dimensions and dockstate  
  
          Most of them are probably not needed by you but some you may need them from time to time.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          The Gui Elements
        </chapter_context>
        <previous_chapter>The_Gui_Elements_Concepts002_FileDropZones</previous_chapter>  
        <next_chapter>Best_Practices_On_Accessibility</next_chapter>  
        <tags></tags>  
    </US_DocBloc>      
  
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Best_Practices_On_Accessibility</slug>  
        <title>Best Practices On Accessibility</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            ReaGirl is designed to make accessibility as easy as possible. For instance, screen reader messages are sent automatically. So blind users always know, what is happening on your gui.  
            Screen readers are usually a speech synthesis engine, that reads out, which ui-element is currently selected, which setting, etc.  
            This helps blind users to know, where in a gui they are, since the screen reader is reading it to them.  
            ReaGirl takes care of this as good as possible.  
              
            ReaGirl also takes care of keyboard-navigation, since blind users usually use the keyboard to use your gui.  
              
            However, there are some areas, where ReaGirl can't do the work for you and that need to be taken into consideration by you.  
            But don't worry, it's easier than you think. Once you digested the rules, most of your guis will be easy to use by blind users.  
              
            1. Blind users use guis generally using the keyboard. They select the ui-element using tab or shift+tab.  
               They "click" ui-elements using the space-bar or the enter-key.  
               And they choose the current selection of a drop down menu or a slider using cursor-keys, PgUp, PgDn, Home and End.  
               This has some implications on how to place ui-elements. For instance:  
              
            2. Put ui-elements of a certain context next to each other.  
               This is important! In your script, it means that the \_Add-functions that belong to each other should follow each other.  
               Imagine an inputbox that shows a filename and a button that opens up a file-selection-dialog.  
               The inputbox and the button are probably placed next to each other in your gui. And they need to be placed  
               next to each other in your script, means: reagirl.InputBox\_Add() first, then reagirl.Button\_Add() as the next ui-element.  
               And when you use your gui and choose the ui-element using the tab-key, your inputbox will be selected first and the button as the next ui-element.  
               Make this logical. Blind users can't see, where an important ui-element is placed, so they usually expect, that the next logical ui-element they tab to follows the current one.  
               Or in our example: the inputbox first and when hitting the tab key again, the file-selection-button is selected next.  
               This might be a challenge at first, especially when you are not used to gui-coding yet. But you are going to get used to it quickly.  
               Oh, before I forget: when you rearrange ui-elements in your gui, don't only change the coordinates, but also think, if the order of the ui-elements visually is still the same as the order when going through them using the tab key.   
               So after the change, go through them using the tab key to see, if the order is still logical.  
               Rule of thumb is: when tabbing through the ui-elements, you go from left to right and from up to down, just like text in an editor.  
               If tabbing through the ui-elements doesn't follow this scheme, change the order of the \_Add-functions in your script until they are correct.  
               This way, you make the gui easier to use by blind people.  
                 
            3. Put the most important ui-elements first, then the less important ones, then the least important ones.  
               As I said, blind people usually use the tab-key and shift+tab to select the ui-elements in your gui.  
               When the gui-window is opened, the first ui-element is selected.  
               And here's why it's important to place the most important first:  
               When you need to enter your gui time and again to change settings, you want to access the most important ui-elements as quickly as possible.  
               If you need to hit tab thousands of times to get to the important ui-elements, it costs time and is very annoying.  
               So make a wise order of ui-elements so going through them using tab is as fast as possible.  
               If you have two sets of ui-elements that should be reached as quickly as possible, put the one set at the beginning and the other at the end of your gui.  
               That way you quickly reach the first ones using tab and the last ones using shift+tab.  
                 
            4. Add text to meaningOfUI\_Element-parameters, which is a short explanation and some context on what the ui-element is supposed to do.  
               This is very important! Setting meaningOfUI\_Element-parameters fills up the tooltips. But it is also the text sent to users of screen readers.  
               You can imagine this the following:  
               If a blind user uses tab to select a checkbox, they get read out checkbox-caption, current checkstate and meaningOfUI\_Element.  
               That way they know, how the checkbox is named(caption), if it's currently checked or not(checkstate) and what the checkbox is supposed to do and what happens if they change the checkstate(meaningOfUI\_Element).  
               Make it as long as needed and as short as possible. Don't be afraid to rework it a few times to get it more precisely.  
               Rule of thumb: answer the questions What does the ui-element, how does it and why does it, as well as what happens when the ui-element is used. With these questions answered, you usually write a good meaningOfUI\_Element.  
               If you need inspiration, open up the preferences of Reaper and hover above the ui-elements.  
               At the bottom of the window, there's a short explanation on what the ui-element is supposed to do(which is also sent to screen reader users).  
               This gives you an idea on how to write them.  
                 
            5. If you need to write #Hashtags, write them camel case. Like #ThisIsBrilliant or #TheMightyBoosh. Screen readers will read out each word individually   
               that way, as they see each uppercase letter as start of a new word. If you write them all lowercase or uppercase, screen readers will try to read the hashtag as one word which could be a mumbling mess.  
               If you need to write acronyms, write them UPPERCASE. That way, screen readers will read each letter individually.
               
            6. Sometimes, you do things in your script that you might want to communicate to blind users. For instance, if you store a setting everytime a checkbox is toggled, you should communicate this as blind users don't neccessarily know, what you did.
               In that case, use reagirl.ScreenReader\_SendMessage() to send a message to screen reader users.
               So in our case, reagirl.ScreenReader\_SendMessage("Setting stored") or something similar would be suitable to communicate this to blind users clearly.
               Don't use reaper.osara_outputMessage() since ReaGirl might interfere with this function and interrupt your sent message.
               Always use reagirl.ScreenReader\_SendMessage() if you want to send screen reader messages, as ReaGirl will send them always this way.
               One thing to mention too: don't send messages permanently, only when needed. If you sent a message while the former one is still being read to blind users,
               the old message will be interrupted with the new one. So blind people might not get all information that you tried to convey.               
            
            7. Check, if your gui is working in black'n'white/grayscale, means, make a screenshot, put it into a graphics-editor and set saturation to 0. 
               Check, if all ui-elements are still easy to differentiate from each other. This is important for colorblind users.
               for instance: If you have two images, next to each other, one is red and the other one is green, you can easily differentiate them from each other.
               But: many colorblind people only see everything in grayscale and two color, that look very different from each other, may have the exact same grey color for colorblind people.
               So, when you want to have two images next to each other that are differentiable from each other, make one brighter than the other.
               And to know, if you did it right, check the gui in black'n'white/grayscale and see, if one image looks brighter from the other.
               If yes, then it's easier to read for colorblind people.
            
            8. Ask for feedback, especially by blind users. They know best, if your explanations are understandable or hard to get.  
               There's a mailing list called Reaper without Peepers, which is primarily a mailinglist by blind people for blind people.  
               Ask there for people who could test your script and give you feedback.  
               They have the most experience in what a good description is and what is a bad one, so pay attention and listen.  
                 
            With these rules, most of your guis should be easy to use by blind people. The rest I intend to do automagically with ReaGirl.  
              
            One thing to note: in the ReaGirl-settings, there's an option under accessibility called "Show screen reader messages in console(debug)".  
            When you turn this option on, ReaGirl will put all screen reader-messages of ReaGirl-guis into the ReaScript-console-window.  
            That way you can peek, how other ReaGirl-guis write screen reader-messages or how things are communicated to blind people.  
            Looking at this for some time helps getting an idea on how blind users perceive guis.  
              
            You can also install the Osara-extension and NVDA(or JAWS) to get the full experience.  
            Osara sends screen reader messages to the operating system with the help of NVDA(or JAWS).  
            You install Osara and either NVDA(or JAWS). Then you start NVDA(or JAWS).You computer will read now every ui-element you are hovering above with the mouse and each ui-element that you are selecting using tab or shift+tab.  
            This can be overwhelming at first, so you can make it silent in the preferences and show a speech viewer instead, which gives you all screen reader messages as well, not just the ones from ReaGirl-guis.  
            Read about how to use NVDA(or JAWS), speech viewer and it's preferences and how to use it.  
            It's usually not needed to install Osara and NVDA(or JAWS) for ReaGirl scripts, but if you intend to make non-ReaGirl-scripts accessible, you'll need both to get these things right.  
            Especially, since Osara includes a function called reaper.osara_outputMessage(), that outputs messages to the screen reader. A function that I use in ReaGirl extensively(but use reagirl.ScreenReader\_SendMessage() instead in your ReaGirl-guis!).  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Best Practices
        </chapter_context>
        <previous_chapter>The_Gui_Elements_100_General</previous_chapter>  
        <next_chapter>Best_Practices_On_Writing_Guis_As_Blind_Scripter</next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
  
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Best_Practices_On_Writing_Guis_As_Blind_Scripter</slug>  
        <title>Best Practices on Writing guis as Blind Scripter</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            ReaGirl has some features, that you can use as a blind scripter to code your own guis.  
            The most important thing is auto-positioning, which allows you to position ui-elements automatically.   
            It's comparable with writing text: you can place each ui-element after each other or you place it in the next line.  
            To place ui-elements automatically, set the x and y-position-parameters of the \_Add-functions to nil.  
            This will place the ui-element to the right side of the previous ui-element.  
            If you want to place the next ui-element into the next line, use reagirl.NextLine(), which is like the Enter-key in an editor, that starts a new line. So the next ui-element is positioned on the left side underneath the last one(like in a newly started line).
              
            Read the [tutorial about autopositioning](#Tutorial_007_Autopositioning_Of_UI_Elements) and [tutorial about autopositioning with tabs](#Tutorial_008_Autopositioning_With_Tabs) to learn how it works.  
              
            There are some things you should consider to also make the gui easy to use for sighted users:  
            1. Don't put too many ui-elements after each other, as this means you need to scroll horizontally to reach the ui-elements.    
               This is usually not a problem for you, as you are navigating with the tab-key, which automatically scrolls the tabbed ui-element into view.    
               However, sighted users usually work with mouse and they can become easily annoyed when having to scroll horizontally to see the last ui-element in a line.    
               So don't add more than five buttons, three checkboxes, one inputbox, one slider or one drop down menu after each other, to keep the gui conveniently usable.    
               When in doubt, better start a new line where you put the next ui-element. Scrolling up and down to get the next ui-element into view is usually more accepted than scrolling left and right.    
                 
            2. When using labels, don't write a wall of text. From my experience, blind users use paragraphs in text much less often than sighted people, which can become difficult to read, especially for neurodivergent people.    
               So when you need to write a lot of text into a label, think about, when one point ends and when the next point starts.    
               Add two newlines between them. That way sighted people can digest your text much easier.    
               The reason for it is that sighted people tend to "scan" the text loosely for the most important things, like striving through the text for important words that their eyes will be hooked at, which determines if a text is important right now or not.    
               And they usually see each paragraph as one piece of knowledge to digest.    
               So adding newlines between each point you are making makes it faster for sighted people to scan your text for the most important information.    
              
            3. This point is basically the same advice I gave you about text in labels, but this time it's for ui-elements:    
               Put all ui-elements that are belonging to each other close to each other.    
               And when all ui-elements of one context are added, use two reagirl.NextLine()-functioncalls. This will add a, for lack of a better term, newline between ui-elements.  
               So you have one pack of ui-elements of one context, then some gap by a new line, then the next pack of ui-elements of the next context, etc.    
               That way you prevent crowded guis that can be hard to read.    
               Just as sighted people scan text, they also scan guis for the most important elements, so by adding newlines using two reagirl.NextLine()-functioncalls,  
               you make the gui easier to read, as it's faster to skip the unimportant parts in this moment.    
              
            4. Use label-backdrops to structure your gui. With them you can avoid even more walls of ui-elements.  
               Label-backdrops are rectangles that originate in a label and who enclose ui-elements. So sighted users easily see, which ui-element belongs to a certain context(like a label describing the context) and which one doesn't.  
               I wrote a tutorial on how to [structure guis with label-backdrops](#Tutorial_010_Structuring_Guis_With_Labels_When_Autopositioning).  
               This is probably a little difficult in the beginning, since it's hard to know, if you did it right, even though the functions used try to minimize potential errors as much as possible.  
               So when getting into label-backdrops, get feedback by sighted users to improve on potential issues.                 
              
            5. When doing a gui that shall also be used by sighted people, don't hesitate to ask for feedback. That way you can avoid crowded walls of texts or walls of ui-elements.  
               Autopositioning should give you everything you need to make them work and label-backdrops to improve readability but there are still cases, where some feedback is still very valuable to get a gui right.  
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Best Practices
        </chapter_context>
        <previous_chapter>Best_Practices_On_Accessibility</previous_chapter>  
        <next_chapter></next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
      
    <US_DocBloc version="1.0" spok_lang="en" prog_lang="*">  
        <slug>Final_words</slug>  
        <title>Final Words</title>  
        <description markup_type="markdown" markup_version="1.0.1" indent="default">  
            When you read every chapter of this documentation, you have a good idea of what ReaGirl can do for you and how.  
              
            But there's even more possible. So read about them in the functions-reference, where I explain in great detail every available function, their parameters and return values.  
  
            Great thanks to the development-team of Osara(especially James) without their extension the ReaGirl-project wouldn't be possible at all.  
            Also thanks to Scott and Chris, who helped me iron out accessibility-issues in the beta-phase.  
              
            Big thanks also to the various gui-lib-developers over the years like Lokasenna(Lokasennas Gui-Lib v2 and Scythe), Chris Fillion(ReaImGui) and Tack(Gui Toolkit),  
            whose gui-libraries were a huge inspiration for various concepts available in ReaGirl. Their influence made ReaGirl as easy to use as it is.  
              
            And also a big shoutout to the dozens of scripters in the Reaper-Community, whose help over the years made me a better scripter and therefore able to do this huge project.              
            I'm standing on the shoulders of giants.  
              
            And that's it for now. Enjoy coding guis with ReaGirl and give feedback and bugreports if you have any(see introduction for the Reaper-forum's thread.  
              
            Cheers and see you in the next version of ReaGirl  
              
            Meo-Ada Mespotine, 6th of May 2024              
        </description>  
        <target_document>ReaGirl_Introduction_and_Concepts.html</target_document>  
        <source_document>ReaGirl_Introduction_and_Concepts.USDocML</source_document>  
        <chapter_context>
          Final Words
        </chapter_context>
        <previous_chapter>Best_Practices_On_Accessibility</previous_chapter>  
        <next_chapter></next_chapter>  
        <tags></tags>  
    </US_DocBloc>  
  
  